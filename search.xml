<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>read/SICP</title>
    <url>/2020/09/09/read/SICP/</url>
    <content><![CDATA[<p>“I think that it’s extraordinarily important that we in computer science keep fun in computing. When it started out, it was an awful lot of fun. Of course, the paying customers got shared every now and then, and after a while we began to take their complaints seriously. We began to feel as if we really were responsible for the successful, error-free perfect use of these machines. I don’t think we are. I think we’re responsible for stretching them, setting them off in new directions, and keeping fun in the house. I hope the field of computer science never loses its sense of fun. Above all, I hope we don’t become missionaries. Don’t feel as if you’re Bible salesmen. The world has too many of those already. What you know about computing other people will learn. Don’t feel as if the key to successful computing is only in your hands. What’s in your hands, I think and hope, is intelligence: the ability to see the machine as more than when you were first led up to it, that you can make it more.”</p>
<p>感觉受到了莫大的鼓舞. 尤其是 What’s in your hands, I think and hope, is intelligence: the ability to see the machine as more than when you were first led up to it, that you can make it more.”</p>
<p>PS: 现在正在读 “structure and interpretation of computer programs” . 以上是这本书的前言. 这本书应该是第三次读了. 这次我要认真读完! :)</p>
]]></content>
  </entry>
  <entry>
    <title>read/C++14C++17</title>
    <url>/2020/09/06/read/C++14C++17/</url>
    <content><![CDATA[<h1 id="C-14-C-17"><a href="#C-14-C-17" class="headerlink" title="C++14~C++17"></a>C++14~C++17</h1><p>之前我总结过 C++14 的一些东西, 但现在已经 2020 了啊 = =  </p>
<p>所以就想着… emm… 虽然项目还是在用 C11 的东西, 连 C14 都没有. 但是! 需求不会留给你学习的时间的!(即使有, 但那对我不成立!) 所以就再看看 C17 的吧(虽然 C20 已经有了, 不过离实现和稳定还有一段时间, 有其他更优先的事情) 顺便对 C14 回顾一下 :happy:</p>
<p>(PS: 这次在下选择了 cppreference 作为参考)</p>
<a id="more"></a>



<h2 id="C-14"><a href="#C-14" class="headerlink" title="C++14"></a>C++14</h2><p><a href="https://en.cppreference.com/w/cpp/14" target="_blank" rel="noopener">原始链接</a></p>
<h3 id="varaible-template"><a href="#varaible-template" class="headerlink" title="varaible template"></a>varaible template</h3><p>这是一个让我感觉很迷的特性… 简单来说, 就是变量也可以像类和函数那样拥有模板, 例如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// declaration</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T n = T&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// use</span></span><br><span class="line"><span class="keyword">int</span> i = n&lt;<span class="keyword">int</span>&gt;;</span><br></pre></td></tr></table></figure>

<p>查阅过一些信息, 比如<a href="https://stackoverflow.com/questions/21051141/c14-variable-templates-what-is-their-purpose-any-usage-example" target="_blank" rel="noopener">在什么地方可以使用他</a>. </p>
<p>一些测试代码:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n&lt;<span class="keyword">int</span>&gt; = <span class="number">12</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 看起来怪怪的...</span></span><br><span class="line">    n&lt;<span class="keyword">int</span>&gt; = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; n&lt;<span class="keyword">char</span>&gt; &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; n&lt;<span class="keyword">int</span>&gt; &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        n&lt;<span class="keyword">int</span>&gt; = <span class="number">11</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; n&lt;<span class="keyword">int</span>&gt; &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; n&lt;<span class="keyword">int</span>&gt; &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// @warning 变量模板的更改具有全局可见性</span></span><br><span class="line">    f();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; n&lt;<span class="keyword">int</span>&gt; &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output</span></span><br><span class="line"><span class="comment">// A</span></span><br><span class="line"><span class="comment">// 10</span></span><br><span class="line"><span class="comment">// 11</span></span><br><span class="line"><span class="comment">// 11</span></span><br><span class="line"><span class="comment">// 12</span></span><br></pre></td></tr></table></figure>

<p>我感觉可能离它远一点会比较好</p>
<p><img src="https://imgur.com/I8rIaxO.png.png" alt=""></p>
<p>测试结果来看. 它的原理类似于一个全局变量…(怎么感觉我在说废话 = =).</p>
<h3 id="generic-lambda"><a href="#generic-lambda" class="headerlink" title="generic lambda"></a>generic lambda</h3><p>cppreference 是这么定义 lambda 的:</p>
<p>Constructs a <a href="https://en.wikipedia.org/wiki/Closure_(computer_science)" target="_blank" rel="noopener">closure</a>: an unnamed function object capable of capturing variables in scope.</p>
<p>可以捕获作用域中变量的未命名函数对象.</p>
<p>关于 closure 的定义: </p>
<p>In <a href="https://en.wikipedia.org/wiki/Programming_language" target="_blank" rel="noopener">programming languages</a>, a <strong>closure</strong>, also <strong>lexical closure</strong> or <strong>function closure</strong>, is a technique for implementing <a href="https://en.wikipedia.org/wiki/Lexically_scoped" target="_blank" rel="noopener">lexically scoped</a> <a href="https://en.wikipedia.org/wiki/Name_binding" target="_blank" rel="noopener">name binding</a> in a language with <a href="https://en.wikipedia.org/wiki/First-class_function" target="_blank" rel="noopener">first-class functions</a>. <a href="https://en.wikipedia.org/wiki/Operational_semantics" target="_blank" rel="noopener">Operationally</a>, a closure is a <a href="https://en.wikipedia.org/wiki/Record_(computer_science)" target="_blank" rel="noopener">record</a> storing a <a href="https://en.wikipedia.org/wiki/Function_(computer_science)" target="_blank" rel="noopener">function</a><a href="https://en.wikipedia.org/wiki/Closure_(computer_programming)#cite_note-1" target="_blank" rel="noopener">[a]</a> together with an environment.<a href="https://en.wikipedia.org/wiki/Closure_(computer_programming)#cite_note-2" target="_blank" rel="noopener">[1]</a> The environment is a mapping associating each <a href="https://en.wikipedia.org/wiki/Free_variable" target="_blank" rel="noopener">free variable</a> of the function (variables that are used locally, but defined in an enclosing scope) with the <a href="https://en.wikipedia.org/wiki/Value_(computer_science)" target="_blank" rel="noopener">value</a> or <a href="https://en.wikipedia.org/wiki/Reference_(computer_science)" target="_blank" rel="noopener">reference</a> to which the name was bound when the closure was created.<a href="https://en.wikipedia.org/wiki/Closure_(computer_programming)#cite_note-3" target="_blank" rel="noopener">[b]</a> Unlike a plain function, a closure allows the function to access those <em>captured variables</em> through the closure’s copies of their values or references, even when the function is invoked outside their scope.</p>
<p>一种具有第一类函数的实现词法作用域的名称绑定技术. 实现上, 闭合是一个将函数保存与环境一同保存的记录.</p>
<p>环境是一个当闭合被创建时将每个函数的自由变量(局部使用, 在封闭环境中定义)与被绑的名称的值/引用关联的映射.</p>
<p>与普通函数不同的是, 闭合允许函数通过闭合拷贝值/引用方位被捕获的变量. 即使当函数在它们(原来被捕获的变量)作用域外调用.</p>
<p>PS: 概念上来说, 和成员函数极其相似, 其具体实现也和类基本无二.</p>
<p>哦, 差点忘了, C14 说的是 generic lambda, 而非 lambda.</p>
<p>简单来说, 就是一个形似 auto. 实际实现为模板的 lambda.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// generic lambda, operator() is a template with two parameters</span></span><br><span class="line"><span class="keyword">auto</span> glambda = [](<span class="keyword">auto</span> a, <span class="keyword">auto</span>&amp;&amp; b) &#123; <span class="keyword">return</span> a &lt; b; &#125;;</span><br><span class="line"><span class="keyword">bool</span> b = glambda(<span class="number">3</span>, <span class="number">3.14</span>); <span class="comment">// ok</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// generic lambda, operator() is a template with one parameter</span></span><br><span class="line"><span class="keyword">auto</span> vglambda = [](<span class="keyword">auto</span> printer) &#123;</span><br><span class="line">    <span class="keyword">return</span> [=](<span class="keyword">auto</span>&amp;&amp;... ts) <span class="comment">// generic lambda, ts is a parameter pack</span></span><br><span class="line">    &#123; </span><br><span class="line">        printer(<span class="built_in">std</span>::forward&lt;<span class="keyword">decltype</span>(ts)&gt;(ts)...);</span><br><span class="line">        <span class="keyword">return</span> [=] &#123; printer(ts...); &#125;; <span class="comment">// nullary lambda (takes no parameters)</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> p = vglambda([](<span class="keyword">auto</span> v1, <span class="keyword">auto</span> v2, <span class="keyword">auto</span> v3) &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; v1 &lt;&lt; v2 &lt;&lt; v3; &#125;);</span><br><span class="line"><span class="keyword">auto</span> q = p(<span class="number">1</span>, <span class="string">'a'</span>, <span class="number">3.14</span>); <span class="comment">// outputs 1a3.14</span></span><br><span class="line">q();                      <span class="comment">// outputs 1a3.14</span></span><br></pre></td></tr></table></figure>



<h3 id="lambda-init-capture"><a href="#lambda-init-capture" class="headerlink" title="lambda init-capture"></a>lambda init-capture</h3><p>就是一个在捕获域里面可以初始化变量(变量自动 auto, 很让人不舒服的是, 我无法自行指定变量类型)的特性.</p>
<p><a href="https://stackoverflow.com/questions/25408190/lambda-captures-c14" target="_blank" rel="noopener">参考代码</a></p>
<h3 id="relaxed-restriction-of-constexpr"><a href="#relaxed-restriction-of-constexpr" class="headerlink" title="relaxed restriction of constexpr"></a>relaxed restriction of constexpr</h3><p>C14 扩展了 constexpr. 只要是基本能想到的, 编译器应该在编译期能做到的事情. 在 constexpr 里面都可以做.</p>
<p>比如简单的 if, switch… <a href="https://en.cppreference.com/w/cpp/language/constexpr" target="_blank" rel="noopener">参考</a></p>
<h3 id="binary-literals"><a href="#binary-literals" class="headerlink" title="binary literals"></a>binary literals</h3><p>直译过来就是二进制字面量. 可以<a href="https://en.cppreference.com/w/cpp/language/integer_literal" target="_blank" rel="noopener">参考</a></p>
<p>这让我很迷惑. 感觉就是 C11 的东西…</p>
<h3 id="digit-separators"><a href="#digit-separators" class="headerlink" title="digit separators"></a>digit separators</h3><p>这个挺好的, 属于代码规范的一种</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> l1 = <span class="number">18446744073709550592u</span>ll; <span class="comment">// C++11</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> l2 = <span class="number">18'446'744'073'709'550'592l</span>lu; <span class="comment">// C++14</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> l3 = <span class="number">1844'6744'0737'0955'0592u</span>LL; <span class="comment">// C++14</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> l4 = <span class="number">184467'440737'0'95505'92L</span>LU; <span class="comment">// C++14</span></span><br></pre></td></tr></table></figure>



<h3 id="return-type-deducation-for-function"><a href="#return-type-deducation-for-function" class="headerlink" title="return type deducation for function"></a>return type deducation for function</h3><p>函数返回类型推导</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">decltype f() -&gt;auto &#123;</span><br><span class="line">	<span class="keyword">return</span> ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 没记错的话大概是这个么结构(但应该是记错了, 不过没关系, 知道新的就好了)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新的方式明显简单直观. 没有那么八股文了</span></span><br><span class="line"><span class="keyword">auto</span> f() &#123;</span><br><span class="line">	<span class="keyword">return</span> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="aggregate-class-with-default-non-static-member-initializers"><a href="#aggregate-class-with-default-non-static-member-initializers" class="headerlink" title="aggregate class with default non-static member initializers"></a>aggregate class with default non-static member initializers</h3><p>就是一个对于纯成员变量, 无构造函数的构造优化. 具体<a href="https://en.cppreference.com/w/cpp/language/aggregate_initialization" target="_blank" rel="noopener">参考</a></p>
<h2 id="C-17"><a href="#C-17" class="headerlink" title="C++17"></a>C++17</h2><h3 id="fold-expression"><a href="#fold-expression" class="headerlink" title="fold expression"></a>fold expression</h3><p>用于变长模板的特性, 记住, 然后活用就好了. <a href="https://en.cppreference.com/w/cpp/language/fold" target="_blank" rel="noopener">规则</a></p>
<h3 id="class-template-arugument-deduction"><a href="#class-template-arugument-deduction" class="headerlink" title="class template arugument deduction"></a>class template arugument deduction</h3><p>类模板参数的推导. 可以更方便了.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++14</span></span><br><span class="line"><span class="built_in">vector</span> v&#123;<span class="number">1</span>&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="non-type-template-parameters-declared-with-autp"><a href="#non-type-template-parameters-declared-with-autp" class="headerlink" title="non-type template parameters declared with autp"></a>non-type template parameters declared with autp</h3><p>在模板中使用 auto 替代 typename. 既可以推导其类型, 又可以获取其值.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, T v&gt;</span><br><span class="line">T v2 = v;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">auto</span> v&gt;</span><br><span class="line"><span class="keyword">auto</span> v2 = v;</span><br></pre></td></tr></table></figure>

<p>两者是等价的. 还有一些其他<a href="https://stackoverflow.com/questions/38026884/advantages-of-auto-in-template-parameters-in-c17" target="_blank" rel="noopener">用途</a></p>
<h3 id="compile-timr-if-constexpr"><a href="#compile-timr-if-constexpr" class="headerlink" title="compile timr if constexpr"></a>compile timr if constexpr</h3><p>一种 if 的编译时版本.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(cond1)</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">constexpr</span> () &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以查看 <a href="https://www.codingame.com/playgrounds/2205/7-features-of-c17-that-will-simplify-your-code/constexpr-if" target="_blank" rel="noopener">参考</a></p>
<h3 id="inline-variables"><a href="#inline-variables" class="headerlink" title="inline variables"></a>inline variables</h3><p>内联变量.这个关键字声明的变量具有可以被多次包含的特性. 但同时也有一些规则. 最典型的应该是类静态成员的声明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">	static int i;</span><br><span class="line">&#125;;</span><br><span class="line">int A::i &#x3D; 10;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; C++17</span><br><span class="line">class A &#123;</span><br><span class="line">	inline static int i &#x3D; 10;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>详细可以 <a href="https://www.codingame.com/playgrounds/2205/7-features-of-c17-that-will-simplify-your-code/inline-variables" target="_blank" rel="noopener">参考1</a>. <a href="https://en.cppreference.com/w/cpp/language/inline" target="_blank" rel="noopener">参考2</a></p>
<h3 id="structured-binding"><a href="#structured-binding" class="headerlink" title="structured binding"></a>structured binding</h3><p>一种绑定结构化数据的手段. <a href="https://en.cppreference.com/w/cpp/language/structured_binding" target="_blank" rel="noopener">参考</a> </p>
<h3 id="initializers-of-if-and-switch"><a href="#initializers-of-if-and-switch" class="headerlink" title="initializers of if and switch"></a>initializers of if and switch</h3><p>If 和 switch 可以有初始化区域了, 就如同 for 一样(while: ?? 那我呢?) <a href="https://www.tutorialspoint.com/cplusplus17-if-statement-with-initializer#:~:text=C%2B%2B17%20has%20extended,helps%20users%20keep%20scopes%20tight." target="_blank" rel="noopener">参考</a></p>
<h3 id="u8-character-literal"><a href="#u8-character-literal" class="headerlink" title="u8 character literal"></a>u8 character literal</h3><p>u8 字面量. <a href="https://en.cppreference.com/w/cpp/language/character_literal" target="_blank" rel="noopener">参考</a> 感觉很没用, 程序代码就不该出现 unicode! (注释除外)</p>
<h3 id="simplifield-netesd-namaspace"><a href="#simplifield-netesd-namaspace" class="headerlink" title="simplifield netesd namaspace"></a>simplifield netesd namaspace</h3><p>简化的嵌套作用域声明. 算是代码可读性的一种.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A&#123;</span><br><span class="line">	<span class="keyword">namespace</span> B&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++17</span></span><br><span class="line"><span class="keyword">namespace</span> A::B &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="unsing-declaration-declaring-mutiple-names"><a href="#unsing-declaration-declaring-mutiple-names" class="headerlink" title="unsing declaration declaring mutiple names"></a>unsing declaration declaring mutiple names</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> A::g, A::g; <span class="comment">// (C++17) OK: double declaration allowed at namespace scope</span></span><br></pre></td></tr></table></figure>



<h3 id="new-order-of-evalution-rules"><a href="#new-order-of-evalution-rules" class="headerlink" title="new order of evalution rules"></a>new order of evalution rules</h3><p>一个有趣的<a href="https://en.cppreference.com/w/cpp/language/eval_order" target="_blank" rel="noopener">东西</a> 但我始终认为这类迷惑应该是需要避免的.</p>
<h3 id="guaranteed-copy-elision"><a href="#guaranteed-copy-elision" class="headerlink" title="guaranteed copy elision"></a>guaranteed copy elision</h3><p>一种避免拷贝构造的特性. <a href="https://en.cppreference.com/w/cpp/language/copy_elision" target="_blank" rel="noopener">参考</a></p>
<p><img src="https://imgur.com/RDJnIh1.png" alt=""></p>
<p>这个看起来是编译器做的优化. f() 本来是个无参函数. 但是在调用 f() 是却传了一个外部的地址(v的地址)过去</p>
<p>而其在使用的时候, 也做了相应调整.</p>
<p><img src="https://imgur.com/2am9hm6.png" alt=""></p>
<h3 id="lambda-capture-of-this"><a href="#lambda-capture-of-this" class="headerlink" title="lambda capture of *this"></a>lambda capture of *this</h3><p><a href="https://en.cppreference.com/w/cpp/language/lambda#Lambda_capture" target="_blank" rel="noopener">参考</a></p>
<p>可以捕获外部 this 的lambda. (感觉这群人对 lambda 很上心啊… 连续好几个强化了)</p>
<h3 id="constexpr-lambda"><a href="#constexpr-lambda" class="headerlink" title="constexpr lambda"></a>constexpr lambda</h3><p>… <a href="https://en.cppreference.com/w/cpp/language/lambda" target="_blank" rel="noopener">参考</a></p>
<p>实现了 constexpr 的lambda… </p>
<h3 id="has-include"><a href="#has-include" class="headerlink" title="has include"></a>has include</h3><p><a href="https://en.cppreference.com/w/cpp/preprocessor/include" target="_blank" rel="noopener">参考</a></p>
<p>可以通过函数(大概率其实是一种告知编译器的宏) 这也是 C++ 一向的态度了. 换成其他语言, 根本不会将这种编译时相关信息抛给用户. 这是 C++ 的优势, 也是它复杂的根源之一.</p>
<h3 id="atttribute-namespace-don’t-have-to-repeat"><a href="#atttribute-namespace-don’t-have-to-repeat" class="headerlink" title="atttribute namespace don’t have to repeat"></a>atttribute namespace don’t have to repeat</h3><p>刚说完又来了. <a href="https://en.cppreference.com/w/cpp/language/attributes" target="_blank" rel="noopener">参考</a></p>
<p>引入具体实现的相关特性.</p>
]]></content>
  </entry>
  <entry>
    <title>leetcode/PartitionArrayintoDisjointintervals</title>
    <url>/2020/09/02/leetcode/PartitionArrayintoDisjointintervals/</url>
    <content><![CDATA[<h1 id="Partition-Array-into-Disjoint-intervals"><a href="#Partition-Array-into-Disjoint-intervals" class="headerlink" title="Partition Array into Disjoint intervals"></a>Partition Array into Disjoint intervals</h1><p><img src="https://imgur.com/wLfJcaC.png" alt=""></p>
<p>我的思维好像固定了 = =…</p>
<a id="more"></a>


<h2 id="my-solution"><a href="#my-solution" class="headerlink" title="my solution"></a>my solution</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partitionDisjoint</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>, e = A.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> lx = A[b];</span><br><span class="line">        <span class="keyword">while</span> (b &lt; e) &#123;</span><br><span class="line">            <span class="keyword">while</span> (e &gt; b &amp;&amp; A[e] &gt;= lx) &#123; --e; &#125;</span><br><span class="line">            <span class="comment">// A[e] will less than lx</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> olx = lx;</span><br><span class="line">            <span class="keyword">while</span> (b &lt; e) &#123;</span><br><span class="line">                lx = <span class="built_in">max</span>(lx, A[++b]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// lx is max[A[0] - A[e]]</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (olx != lx) &#123;</span><br><span class="line">                <span class="comment">// recalculate</span></span><br><span class="line">                e = A.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> b + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>lx 是左边已遍历最大值. e 在每次遍历后将会指向一个从右往左第一个小于这个值的下标. </p>
<p>b 的迭代不会重复, 而 e 的迭代是可能重复的, 这是这个解法的瓶颈.</p>
<h2 id="other-solution"><a href="#other-solution" class="headerlink" title="other solution"></a>other solution</h2><p>PS: 以后没有 the best solution 了. 因为很难说一个算法是 best 的. 因为实际的输入不定. 适用于输入的算法也不定. 并且提交里面往往并不是最好的算法. Discuss 里面才有.    </p>
<p><a href="https://leetcode.com/problems/partition-array-into-disjoint-intervals/discuss/178156/Cpp-O(n)-solution-one-pass-with-explanation" target="_blank" rel="noopener">参照</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partitionDisjoint</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>, e = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> lx = A[b], rlx = lx;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] &lt; lx) &#123;</span><br><span class="line">                e = i;</span><br><span class="line">                lx = rlx;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (A[i] &gt; rlx) &#123;</span><br><span class="line">                rlx = A[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//printf("rlx: %d, lx: %d", rlx, lx);</span></span><br><span class="line">        <span class="keyword">return</span> e + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>毫无疑问是比我更好的解法. </p>
<p>唯一可能的疑问是每次迭代所使用的条件有些许复杂. 极端条件如: A {1, 2, 3 … } 下. 这个算法会赋值多次. </p>
<p>而我的解法相对会少很多. (这也是我说大多数情况下不存在 best 的原因)</p>
<p>让我反思的是, 我的思维可能出现了僵化. 一开始我想的办法就是首尾逼近的方式. 所以最后的解法也是类似的结构.</p>
<p>这不禁让我想起之前好像在某个视频中看到的片段. 大意是说: 一个侦探在侦破案件时会让自己忘记一些常识性的东西. 因为这常常会误导自己而忽视重要线索. 或许解法也是如此. 经验同时也可能成为阻止你创新的障碍.  </p>
<p>所以有时会有”砍掉重学”这种概念. 我应该想办法规避这种情况. 毕竟”不要让你已获得的东西成为你获取其他东西的障碍”是我坚持的理念.</p>
]]></content>
  </entry>
  <entry>
    <title>read/ExtendedAsm</title>
    <url>/2020/07/17/read/ExtendedAsm/</url>
    <content><![CDATA[<h2 id="Extended-Asm"><a href="#Extended-Asm" class="headerlink" title="Extended Asm"></a>Extended Asm</h2><p><img src="https://imgur.com/w0fOmUW.png" alt=""></p>
<p>今天在脉脉上看到了一个很有趣的东西 ( •̀ ω •́ )✧</p>
<p>哦哦, 在连续看了一段时间令人头晕的文档后, 看看这个真是提神呢!</p>
<a id="more"></a>



<p>首先, google 了一下, 这个是 gcc 对于汇编指令使用的扩展. <a href="https://stackoverflow.com/questions/14449141/the-difference-between-asm-asm-volatile-and-clobbering-memory" target="_blank" rel="noopener">参见</a></p>
<p>链接里面的文档版本比较过时了, 新的文档请看<a href="https://gcc.gnu.org/onlinedocs/gcc-10.1.0/gcc/Extended-Asm.html#Extended-Asm" target="_blank" rel="noopener">这个</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">With extended asm you can read and write C variables from assembler and perform jumps from assembler code to C labels. Extended asm syntax uses colons (‘:’) to delimit the operand parameters after the assembler template:</span><br><span class="line">使用 asm扩展, 可以让你从汇编读取和写入 C 变量, 执行 jump 指令从汇编跳转到 C 标签. asm扩展使用冒号在 assembler模板后分隔操作参数.</span><br><span class="line"></span><br><span class="line">asm asm-qualifiers ( AssemblerTemplate </span><br><span class="line">                 : OutputOperands </span><br><span class="line">                 [ : InputOperands</span><br><span class="line">                 [ : Clobbers ] ])</span><br><span class="line"></span><br><span class="line">asm asm-qualifiers ( AssemblerTemplate </span><br><span class="line">                      : </span><br><span class="line">                      : InputOperands</span><br><span class="line">                      : Clobbers</span><br><span class="line">                      : GotoLabels)</span><br><span class="line">where in the last form, asm-qualifiers contains goto (and in the first form, not).</span><br><span class="line">最后一个案例中, asm限定符包含 goto(而在第一个案例中, 没有).</span><br><span class="line"></span><br><span class="line">The asm keyword is a GNU extension. When writing code that can be compiled with -ansi and the various -std options, use __asm__ instead of asm (see Alternate Keywords).</span><br><span class="line"></span><br><span class="line">Qualifiers</span><br><span class="line"></span><br><span class="line">volatile</span><br><span class="line">The typical use of extended asm statements is to manipulate input values to produce output values. However, your asm statements may also produce side effects. If so, you may need to use the volatile qualifier to disable certain optimizations. See Volatile.</span><br><span class="line">这个类型的 asm扩展语句用于管理输入值, 产生输出值. 然而, 你的 asm语句可能产生 side-effects. 你可以使用 volatile限定符取消优化.(简单来说, 就是不允许指令优化, 因为可能造成副作用)</span><br><span class="line"></span><br><span class="line">inline</span><br><span class="line">If you use the inline qualifier, then for inlining purposes the size of the asm statement is taken as the smallest size possible (see Size of an asm).</span><br><span class="line">内联(优化指令, 尽可能最短?)</span><br><span class="line"></span><br><span class="line">goto</span><br><span class="line">This qualifier informs the compiler that the asm statement may perform a jump to one of the labels listed in the GotoLabels. See GotoLabels.</span><br><span class="line">之前提到的 goto. 可以跳转到外界.</span><br><span class="line"></span><br><span class="line">Parameters	(结合一下这里的链接描述, 上述代码就很好理解了)</span><br><span class="line">AssemblerTemplate</span><br><span class="line">This is a literal string that is the template for the assembler code. It is a combination of fixed text and tokens that refer to the input, output, and goto parameters. See AssemblerTemplate.</span><br><span class="line"></span><br><span class="line">OutputOperands</span><br><span class="line">A comma-separated list of the C variables modified by the instructions in the AssemblerTemplate. An empty list is permitted. See OutputOperands.</span><br><span class="line"></span><br><span class="line">InputOperands</span><br><span class="line">A comma-separated list of C expressions read by the instructions in the AssemblerTemplate. An empty list is permitted. See InputOperands.</span><br><span class="line"></span><br><span class="line">Clobbers</span><br><span class="line">A comma-separated list of registers or other values changed by the AssemblerTemplate, beyond those listed as outputs. An empty list is permitted. See Clobbers and Scratch Registers.</span><br><span class="line"></span><br><span class="line">GotoLabels</span><br><span class="line">When you are using the goto form of asm, this section contains the list of all C labels to which the code in the AssemblerTemplate may jump. See GotoLabels.</span><br><span class="line"></span><br><span class="line">asm statements may not perform jumps into other asm statements, only to the listed GotoLabels. GCC’s optimizers do not know about other jumps; therefore they cannot take account of them when deciding how to optimize.</span><br><span class="line"></span><br><span class="line">The total number of input + output + goto operands is limited to 30.</span><br></pre></td></tr></table></figure>



<p>那么. 来说说上述代码的含义吧.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">"0:\n"</span>	<span class="comment">// 标准的起始, volatile标志了, 我们不想指令优化, 并且可能会有输出.</span></span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="string">"ldrex %[newValue], [%[_q_value]]\n"</span>	<span class="comment">// 加载寄存器, _q_value 是一个地址, 其值解													// 引用, 放入 newValue 中.</span></span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="string">"add %[newValue], %[newValue], #1\n"</span>		<span class="comment">// newValue 增加 1.</span></span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="string">"strex %[result], %[newValue], [%[_q_value]]\n"</span>	<span class="comment">// 将其存入 _q_value. 并获取													// 操作状态.</span></span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="string">"teq %[result], #0\n"</span>	<span class="comment">// 测试结果</span></span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="string">"bne 0b"</span>	<span class="comment">// bne: branch not equal, b是一个标识符, 语句的意义是, 不同的话, 就跳转到 						// "0", 也就是最开始的那个标签. try again! </span></span></span></span><br><span class="line"><span class="function"><span class="params">             : [newValue] <span class="string">"=&amp;r"</span> (newValue), <span class="comment">// 这里是输出参数的传递.</span></span></span></span><br><span class="line"><span class="function"><span class="params">               [result] <span class="string">"=&amp;r"</span> (result), </span></span></span><br><span class="line"><span class="function"><span class="params">             	<span class="string">"+m"</span> (_q_value)	<span class="comment">// '+'意味着输入输出参数 汇编代码中已经改变了值, 没必要 '=' 写出. </span></span></span></span><br><span class="line"><span class="function"><span class="params">             : [_q_value] <span class="string">"r"</span> (&amp;_q_value)	<span class="comment">// 输入参数的传递</span></span></span></span><br><span class="line"><span class="function"><span class="params">             : <span class="string">"cc"</span>, <span class="string">"memory"</span>)</span></span>;	<span class="comment">// 我将其理解为特性!.</span></span><br><span class="line">那么说一下参数符号的意义, 好的, 先盲猜, r 意味着 <span class="keyword">register</span>!.</span><br><span class="line">‘m’</span><br><span class="line">A memory operand is allowed, with any kind of address that the machine supports in general. Note that the letter used <span class="keyword">for</span> the general memory constraint can be re-defined by a back <span class="built_in">end</span> <span class="keyword">using</span> the TARGET_MEM_CONSTRAINT macro.</span><br><span class="line">支持内存操作.(以及一个注意事项)</span><br><span class="line"></span><br><span class="line">‘r’</span><br><span class="line">A <span class="keyword">register</span> operand is allowed provided that it is in a general <span class="keyword">register</span>.</span><br><span class="line">是的, 寄存器操作!.</span><br><span class="line">    </span><br><span class="line">‘=’</span><br><span class="line">Means that <span class="keyword">this</span> operand is written to by <span class="keyword">this</span> instruction: the previous value is discarded <span class="keyword">and</span> replaced by <span class="keyword">new</span> data.</span><br><span class="line">替换, 写入新的值. 也就是说 [newValue] 写入到 (newValue). 标识符写入到参数.</span><br><span class="line">(如果没有这个的话, 上述代码的 result 和 newValue, 不会生效, 不过好像也没用 result = =)</span><br><span class="line">(@warning, 那么, 这是一个可以优化的点)</span><br><span class="line"> </span><br><span class="line">‘&amp;’</span><br><span class="line">Means (in a particular alternative) that <span class="keyword">this</span> operand is an earlyclobber operand, which is written before the instruction is finished <span class="keyword">using</span> the input operands. Therefore, <span class="keyword">this</span> operand may <span class="keyword">not</span> lie in a <span class="keyword">register</span> that is <span class="built_in">read</span> by the instruction <span class="keyword">or</span> as part of any memory address.</span><br><span class="line"></span><br><span class="line">‘&amp;’ applies only to the alternative in which it is written. In constraints with multiple alternatives, sometimes one alternative <span class="keyword">requires</span> ‘&amp;’ <span class="keyword">while</span> others <span class="keyword">do</span> <span class="keyword">not</span>. See, <span class="keyword">for</span> example, the ‘movdf’ insn of the <span class="number">68000.</span></span><br><span class="line"></span><br><span class="line">A operand which is <span class="built_in">read</span> by the instruction can be tied to an earlyclobber operand <span class="keyword">if</span> its only use as an input occurs before the early result is written. Adding alternatives of <span class="keyword">this</span> form often allows GCC to produce better code when only some of the <span class="built_in">read</span> operands can be affected by the earlyclobber. See, <span class="keyword">for</span> example, the ‘mulsi3’ insn of the ARM.</span><br><span class="line"></span><br><span class="line">Furthermore, <span class="keyword">if</span> the earlyclobber operand is also a <span class="built_in">read</span>/<span class="built_in">write</span> operand, then that operand is written only after it’s used.</span><br><span class="line"></span><br><span class="line">‘&amp;’ does <span class="keyword">not</span> obviate the need to <span class="built_in">write</span> ‘=’ <span class="keyword">or</span> ‘+’. As earlyclobber operands are always written, a <span class="built_in">read</span>-only earlyclobber operand is ill-formed <span class="keyword">and</span> will be rejected by the compiler.</span><br><span class="line">(emm... 就算翻译出来可能也很涩... 我用自己的话简单说一下, 这个标识意味着<span class="string">"早期易变"</span>, 也就是, 在输出之前可能会改变, 联想一下 newValue, 他的值+<span class="number">1</span>了. 简单来说就是这样, 有兴趣可以自己理解一下.)</span><br><span class="line">    </span><br><span class="line"><span class="string">"cc"</span></span><br><span class="line">The <span class="string">"cc"</span> clobber indicates that the assembler code modifies the flags <span class="keyword">register</span>. On some machines, GCC represents the condition codes as a specific hardware <span class="keyword">register</span>; <span class="string">"cc"</span> serves to name <span class="keyword">this</span> <span class="keyword">register</span>. On other machines, condition code handling is different, <span class="keyword">and</span> specifying <span class="string">"cc"</span> has no effect. But it is valid no matter what the target.</span><br><span class="line">会改变 flag 寄存器.</span><br><span class="line">    </span><br><span class="line"><span class="string">"memory"</span></span><br><span class="line">The "memory" clobber tells the compiler that the assembly code performs memory reads or writes to items other than those listed in the input and output operands (for example, accessing the memory pointed to by one of the input parameters). To ensure memory contains correct values, GCC may need to flush specific register values to memory before executing the asm. Further, the compiler does not assume that any values read from memory before an asm remain unchanged after that asm; it reloads them as needed. Using the "memory" clobber effectively forms a read/write memory barrier for the compiler.</span><br><span class="line">代码会执行内存操作.</span><br><span class="line">    </span><br><span class="line">Note that <span class="keyword">this</span> clobber does <span class="keyword">not</span> prevent the processor from doing speculative reads past the <span class="keyword">asm</span> statement. To prevent that, you need processor-specific fence instructions.</span><br></pre></td></tr></table></figure>

<p>而第二段代码与其基本一致, 也就是 add 换成了 sub. ヾ(≧▽≦*)o easy!</p>
<p>老夫打算将 gcc 完整看一遍了 （；´д｀）ゞ 请祝我好运!</p>
<h2 id="继续"><a href="#继续" class="headerlink" title="继续"></a>继续</h2><p>关于上述代码, 通过函数名, 可能作者认为操作是原子的. 但事实并不是这样, 上述汇编指令肉眼可见并非原子的. </p>
<p>因为在 LOAD 和 STREX 之间有一条指令. 而后续的 bne 0b. 可能就是用于检测这种状况的 = =. </p>
<p>但很危险, 假设多线程下. 指令执行顺序是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LOAD	LOAD</span><br><span class="line">ADD		ADD</span><br><span class="line">STREX	STREX</span><br><span class="line">或者</span><br><span class="line">LOAD</span><br><span class="line">ADD		LOAD; ADD</span><br><span class="line">STREX	STREX</span><br></pre></td></tr></table></figure>

<p>(暂不明白 asm volcatile 是否会保护多线程, 但应该不会 ← ←)</p>
<p>所以, 可以想办法优化一下.</p>
<p>LOAD; SUB/ADD;STREX </p>
<p>可以直接简化成一个指令, 在 x86 下, 可以是 xadd, 或者 mov + mfence. 参考以下代码:</p>
<p><img src="https://imgur.com/2k2zwlw.png" alt=""></p>
<p>以上图片是简单的 C++ atomic 模板和其汇编语言对比, 可以看到 gcc 是如何实现原子操作的. 并不是简单的 LOAD ADD STORE.</p>
<p>对应的 ARM 指令. 请 <a href="https://developer.arm.com/docs/ddi0596/h/base-instructions-alphabetic-order/stadd-staddl-atomic-add-on-word-or-doubleword-in-memory-without-return-an-alias-of-ldadd-ldadda-ldaddal-ldaddl#xn_sp" target="_blank" rel="noopener">参考</a></p>
<p>如果还是不明白的话, 可以再 <a href="https://stackoverflow.com/questions/38447226/atomicity-on-x86" target="_blank" rel="noopener">参考</a></p>
<p>(解释起来太麻烦了, 我拒绝 = =)</p>
<p>最后, 我尝试将原子操作在我的测试环境下自行实现了一下. </p>
<p><img src="https://imgur.com/xvLlh8Z.png" alt=""></p>
<p>结果也如期所愿, 是 4. 数据的修改只有 xadd 一条, 并且因为所需的数据都在栈上, 所以应该不会出什么问题.</p>
<p>这里可以将其封装成函数.</p>
<p><img src="https://imgur.com/9goxZXK.png" alt=""></p>
<p>这样, inc 的操作应该就是原子的了, 即使在多线程环境下也可以很好地工作.</p>
<p>意味参数来自于一个地址, 增加时是对其地址中地内存直接操作, 不存在间接状态. </p>
<p>(但我不建议这么做, 因为用 atomic 模板会简洁得多, 还附带了 memory order 选项, 所以, 这只是个测试用例). </p>
]]></content>
  </entry>
  <entry>
    <title>read/DecodedStringatIndex</title>
    <url>/2020/07/15/read/DecodedStringatIndex/</url>
    <content><![CDATA[<h2 id="Decoded-String-at-Index"><a href="#Decoded-String-at-Index" class="headerlink" title="Decoded String at Index"></a>Decoded String at Index</h2><p><img src="https://imgur.com/5h3Robh.png" alt=""></p>
<p>这个题不是很好做 :(</p>
<a id="more"></a>



<h3 id="my-solution"><a href="#my-solution" class="headerlink" title="my solution"></a>my solution</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">decodeAtIndex</span><span class="params">(<span class="built_in">string</span> S, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        S.append(<span class="string">"1"</span>);</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 3&gt;&gt; s; <span class="comment">// &#123; current position, current lenth, physical position &#125;</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> cp = <span class="number">0</span>; <span class="comment">// current position, it could bigger than int :(</span></span><br><span class="line">        <span class="keyword">int</span> pp = <span class="number">0</span>; <span class="comment">// physical position</span></span><br><span class="line">        <span class="keyword">while</span> (cp &lt; K) &#123;</span><br><span class="line">            <span class="keyword">int</span> b = pp;</span><br><span class="line">            <span class="keyword">while</span> (S[pp] &gt; <span class="string">'9'</span>) &#123; ++pp; &#125;</span><br><span class="line">            <span class="comment">// S[pp] will be a number</span></span><br><span class="line">            s.push( <span class="built_in">array</span>&lt;<span class="keyword">int</span>, <span class="number">3</span>&gt;&#123;(<span class="keyword">int</span>)cp, pp - b, b&#125; );</span><br><span class="line">            cp += pp - b;</span><br><span class="line">            cp += (S[pp] - <span class="string">'1'</span>) * cp;</span><br><span class="line">            ++pp;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        --K;</span><br><span class="line">        <span class="keyword">while</span> (!s.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> arr = s.top();</span><br><span class="line">            <span class="keyword">int</span> b = arr[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> len = b + arr[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span> (b &lt;= K) &#123;</span><br><span class="line">                <span class="keyword">if</span> (b + arr[<span class="number">1</span>] &gt; K) &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123; S[arr[<span class="number">2</span>] - (b - K)] &#125;;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                b += len;</span><br><span class="line">                <span class="keyword">if</span> (b &gt; K) &#123;</span><br><span class="line">                    K = arr[<span class="number">0</span>] - (b - K);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;  <span class="comment">// should nerver be executed</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>是用栈记录了位置, 然后通过计算的形式得到应有的位置.</p>
<p>不太好弄的是坐标的计算. 以及物理坐标和解码后坐标的理解 = =. 真的花了不少时间… 很惭愧（；´д｀）ゞ</p>
<p>仔细说一下细节吧. (难得有心情 (。・∀・)ノ)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">S.append(<span class="string">"1"</span>);</span><br></pre></td></tr></table></figure>

<p>这是为了后面做准备的, 因为我的循环中假设了循环的截至位置为数字. </p>
<p>但是输入队列的循环截至可以不是数字, 而是字符. 如果要做这个判断的话, 需要一个分支. 很明显, 即会降低性能, 也会加深代码难度. 所以我就手动加了一个数字, 这个数字并不会影响最后的结果(因为再 constraints 里面已经保证了)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 3&gt;&gt; s; <span class="comment">// &#123; current position, current lenth, physical position &#125;</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> cp = <span class="number">0</span>; <span class="comment">// current position, it could bigger than int :(</span></span><br><span class="line"><span class="keyword">int</span> pp = <span class="number">0</span>; <span class="comment">// physical position</span></span><br></pre></td></tr></table></figure>

<p>我存储了三个整数, 分别是 当前位置(解码后), 当前位置开始字符串长度, 当前物理位置(解码前)</p>
<p>其中前两个用于计算, 最后的用于找到对应的字符. 相对来说, 内存消耗还算比较少, 取决于字符串的长度. 但是因为题目的要求, 这肯定不会太大.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (cp &lt; K) &#123;</span><br><span class="line">	<span class="keyword">int</span> b = pp;</span><br><span class="line">	<span class="keyword">while</span> (S[pp] &gt; <span class="string">'9'</span>) &#123; ++pp; &#125;</span><br><span class="line">	<span class="comment">// S[pp] will be a number</span></span><br><span class="line">	s.push( <span class="built_in">array</span>&lt;<span class="keyword">int</span>, <span class="number">3</span>&gt;&#123;(<span class="keyword">int</span>)cp, pp - b, b&#125; );</span><br><span class="line">	cp += pp - b;</span><br><span class="line">	cp += (S[pp] - <span class="string">'1'</span>) * cp;</span><br><span class="line">	++pp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>循环外部条件为是否到了 K 位置的节点. 内部条件为是否 &gt; ‘9’. (还算挺简洁的)</p>
<p>S[pp] 在我加了约束后, 再结合题目的已知条件, 将会在一个数字那里停下, 所以直接用就行. </p>
<p>然后将其入栈. 计算下一步的位置 (这里的下一步位置是个缺陷, 因为在比较极端的情况下会溢出. 我想不出什么不加深难度, 不损耗性能的情况下规避这个问题. 最后选择了加大类型. 这可能会带来潜在的计算损耗. 但是因为不会太难, 因为现在 CPU 都支持 64 位计算. 所以应该不是什么问题).</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">--K;</span><br><span class="line"><span class="keyword">while</span> (!s.empty()) &#123;</span><br><span class="line">	<span class="keyword">auto</span> arr = s.top();</span><br><span class="line">	<span class="keyword">int</span> b = arr[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">int</span> len = b + arr[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">while</span> (b &lt;= K) &#123;</span><br><span class="line">		<span class="keyword">if</span> (b + arr[<span class="number">1</span>] &gt; K) &#123;</span><br><span class="line">			<span class="keyword">return</span> &#123; S[arr[<span class="number">2</span>] - (b - K)] &#125;;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		b += len;</span><br><span class="line">		<span class="keyword">if</span> (b &gt; K) &#123;</span><br><span class="line">			K = arr[<span class="number">0</span>] - (b - K);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	s.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是最后一个循环, 外部条件为栈是否为空. 内部条件为是否超出了所需计算的位置.</p>
<p>计算位置有两种可能性, 一种是在当前增加的范围内. 一种是继承自之前的字符. 第一种即刻返回即可. 而第二种需要重新计算 K. 这个计算可能会造成嵌套, 好的情况下能直接找到位置, 从而在数个空循环后找到. </p>
<p>还算可以, 循环的内容并不难, 计算也不多. 即使不是当前能即可返回的, 计算出来的 K 也应该可以避开一些无需的循环. </p>
<p>我能想到的, 最直接, 最好的方法可能就是公式了. 一种数学的方法. 这可能存在. 但我现在无心探究 (￣、￣)</p>
<h3 id="the-best-solution"><a href="#the-best-solution" class="headerlink" title="the best solution"></a>the best solution</h3><p>emm… 就 Submissions 而言. 它代码太长了, 而且是在用了递归的情况下, 实在不是一个好的学习案例. </p>
<p>Discuss 中倒是有一些可以学习的.     </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">decodeAtIndex</span><span class="params">(<span class="built_in">string</span> S, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">long</span> N = <span class="number">0</span>, i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; N &lt; K; ++i)</span><br><span class="line">		N = <span class="built_in">isdigit</span>(S[i]) ? N * (S[i] - <span class="string">'0'</span>) : N + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (i--)</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">isdigit</span>(S[i]))</span><br><span class="line">			N /= S[i] - <span class="string">'0'</span>, K %= N;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (K % N-- == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">string</span>(<span class="number">1</span>, S[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="string">"lee215"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是的, 老夫的直觉是正确的. 是存在一种计算可以很简洁地计算出来. (因为是存在规律的).</p>
<p>emm… 很好!</p>
<p>足够简洁, 也很高效. 非常不错的算法. </p>
<p>那么反思一下自己. 还是缺失能够直接看透问题本质, 那种最直接, 最切入主题的方式. 练习还是不够, 思考还是不够深. </p>
]]></content>
  </entry>
  <entry>
    <title>leetcode/Leaf-SimilarTrees</title>
    <url>/2020/07/12/leetcode/Leaf-SimilarTrees/</url>
    <content><![CDATA[<h2 id="Leaf-Similar-Trees"><a href="#Leaf-Similar-Trees" class="headerlink" title="Leaf-Similar Trees"></a>Leaf-Similar Trees</h2><p><img src="https://imgur.com/oKTCKO0.png" alt=""></p>
<p>判断树底是否相同</p>
<a id="more"></a>



<h3 id="my-solution"><a href="#my-solution" class="headerlink" title="my solution"></a>my solution</h3><p>这是一道很简单的题, 实现并不难, 问题是怎么更好地实现.</p>
<p>深度/广度都无法做到”一触即发”(协程/多线程或许可以). 所需需要手动来记录一下.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">leafSimilar</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">array</span>&lt;TreeNode*, 200&gt; t1 &#123; root1 &#125;;</span><br><span class="line">        <span class="built_in">array</span>&lt;TreeNode*, 200&gt; t2 &#123; root2 &#125;;</span><br><span class="line">        <span class="keyword">int</span> i1 = <span class="number">0</span>, i2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// get bottom</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (root1-&gt;left) &#123;</span><br><span class="line">                    root1 = root1-&gt;left;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root1-&gt;right) &#123;</span><br><span class="line">                    root1 = root1-&gt;right;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                t1[++i1] = root1;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (root2-&gt;left) &#123;</span><br><span class="line">                    root2 = root2-&gt;left;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root2-&gt;right) &#123;</span><br><span class="line">                    root2 = root2-&gt;right;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                t2[++i2] = root2;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (t1[i1]-&gt;val != t2[i2]-&gt;val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// get next root</span></span><br><span class="line">            <span class="keyword">while</span> (i1 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (t1[i1] != t1[i1 - <span class="number">1</span>]-&gt;right &amp;&amp; t1[i1 - <span class="number">1</span>]-&gt;right) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                --i1;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (i2 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (t2[i2] != t2[i2 - <span class="number">1</span>]-&gt;right &amp;&amp; t2[i2 - <span class="number">1</span>]-&gt;right) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                --i2;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (!(i1 || i2)) &#123;	<span class="comment">// all zero</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(i1 &amp;&amp; i2)) &#123;	<span class="comment">// someone is zero but another not</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            root1 = t1[--i1]-&gt;right;</span><br><span class="line">            t1[++i1] = root1;</span><br><span class="line">            root2 = t2[--i2]-&gt;right;</span><br><span class="line">            t2[++i2] = root2;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>代码量是多了点, 但是没有使用高级数据结构, 没有递归. 能够”一触即发”.</p>
]]></content>
  </entry>
  <entry>
    <title>leetcode/AdcantageShuffule</title>
    <url>/2020/07/11/leetcode/AdcantageShuffule/</url>
    <content><![CDATA[<h2 id="Adcantage-Shuffule"><a href="#Adcantage-Shuffule" class="headerlink" title="Adcantage Shuffule"></a>Adcantage Shuffule</h2><p><img src="https://imgur.com/9rXehx8.png" alt=""></p>
<a id="more"></a>



<h3 id="my-solution"><a href="#my-solution" class="headerlink" title="my solution"></a>my solution</h3><p>重要的是顺序, 如果有顺序, 可以节省很多性能. 即使需要排序, 也是可以接受的.</p>
<p>其次就是结果需要原始顺序, 那么可能就要需要一个值-索引的结构. 但是这可能复杂度太高了. </p>
<p>所以我选择排序, 但不生产值-索引的结构.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; advantageCount(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B) &#123;</span><br><span class="line">        sort(A.<span class="built_in">begin</span>(), A.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; ; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (b &lt; A.<span class="built_in">size</span>() &amp;&amp; A[b] &lt;= B[i]) &#123;</span><br><span class="line">                ++b;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            b = b == A.<span class="built_in">size</span>() ? <span class="number">0</span> : b;</span><br><span class="line">            ret.push_back(A[b]);</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span> &gt;= B.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            A.erase(A.<span class="built_in">begin</span>() + b);</span><br><span class="line">            <span class="keyword">if</span> (B[i + <span class="number">1</span>] &lt; B[i]) &#123;</span><br><span class="line">                b = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">move</span>(ret);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>虽然克预见的低效率, 但是代码整体很简洁, 达到了我想要的部分效果, 但是效率很低. </p>
<h3 id="the-best-solution"><a href="#the-best-solution" class="headerlink" title="the best solution"></a>the best solution</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; advantageCount(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> N = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(A.<span class="built_in">size</span>());</span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; copyB(N);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            copyB[i] = &#123;B[i], i&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(copyB.<span class="built_in">begin</span>(), copyB.<span class="built_in">end</span>(), [] (<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; lhs, <span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; rhs) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> lhs.first &gt; rhs.first;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; copyA(A);</span><br><span class="line">        sort(copyA.<span class="built_in">begin</span>(), copyA.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret(N);</span><br><span class="line">        <span class="keyword">int</span> first = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> last = N - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; item : copyB)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (copyA[last] &gt; item.first)</span><br><span class="line">            &#123;</span><br><span class="line">                ret[item.second] = copyA[last];</span><br><span class="line">                --last;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ret[item.second] = copyA[first];</span><br><span class="line">                ++first;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>他的方法和我预料的差不多, 是两个顺序数组. </p>
<p>emm… 或许我有点过了? 我是想到值-索引的时候立马打断了这个想法. 因为觉得有点复杂了. 如果我继续想的话, 应该差不多就这个样子吧?</p>
]]></content>
  </entry>
  <entry>
    <title>leetcode/AllNodesDistanceKinBinaryTree</title>
    <url>/2020/07/09/leetcode/AllNodesDistanceKinBinaryTree/</url>
    <content><![CDATA[<h2 id="All-Nodes-Distance-K-in-Binary-Tree"><a href="#All-Nodes-Distance-K-in-Binary-Tree" class="headerlink" title="All Nodes Distance K in Binary Tree"></a>All Nodes Distance K in Binary Tree</h2><p><img src="https://imgur.com/vYXJZGL.png" alt=""></p>
<p>找出树中距离指定节点距离为 n 的节点</p>
<a id="more"></a>



<h3 id="my-solutions"><a href="#my-solutions" class="headerlink" title="my solutions"></a>my solutions</h3><p>emm… </p>
<p>第一种方法是制作一个映射, 其中 key 为节点值, val 为所有与 key 相邻的节点值集合.</p>
<p>这种方法适用于多次查询, 因为需要制作一个完整的映射表, 所以不推荐 :(</p>
<p>第二种是让每个节点有一个 parent, 节点便利的麻烦之处就在于他没有 parent 节点. 标准库的节点都是有 parent 节点的(除指定的 froward_list 外 = =), 足以说明有 parent 不仅对于编程, 同时对于效率也有很大提升.</p>
<p>但这也类似于第一种, 这种更加轻量级, 但便利寻找的时候会比第一种稍微麻烦一些.</p>
<p>我采用了第二种的部分概念. </p>
<p>仔细分析一下这个题的话, 节点相邻节点只有两种可能, 父节点和子节点. 子节点的便利非常简单, 广度优先找到同样深度的子节点就好, 问题在于父节点. 而如果找出父节点的简单规律的话, 这题也比较简单了. 假设距离为 N, 从父节点开始, 除特定子节点外的深度为 N - 1 的节点就是值的一部分, 一次类推, pp(父父)节点则是 N - 2, 直到为 0 为止, 就能遍历出所有的集.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; distanceK(TreeNode* root, TreeNode* target, <span class="keyword">int</span> K) &#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        dfs(root, s, target);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        TreeNode *l = s.top();</span><br><span class="line">        getN(l, ret, K--);</span><br><span class="line">        s.pop();</span><br><span class="line">        <span class="keyword">while</span> (K &gt;= <span class="number">0</span> &amp;&amp; !s.empty()) &#123;</span><br><span class="line">            TreeNode *c = s.top()-&gt;left == l ? s.top()-&gt;right : s.top()-&gt;left;</span><br><span class="line">            <span class="keyword">if</span> (!K) &#123;</span><br><span class="line">                ret.push_back(s.top()-&gt;val);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            getN(c, ret, K-- - <span class="number">1</span>);</span><br><span class="line">            l = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getN</span><span class="params">(TreeNode *n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!n) &#123; </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!d) &#123;</span><br><span class="line">            vec.push_back(n-&gt;val);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; t &#123; n &#125;;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;TreeNode*&gt; c;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> v : t) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v-&gt;left) &#123;</span><br><span class="line">                    c.push_back(v-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (v-&gt;right) &#123;</span><br><span class="line">                    c.push_back(v-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!--d) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> v : c) &#123;</span><br><span class="line">                    vec.push_back(v-&gt;val);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(c, t);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(TreeNode *n, <span class="built_in">stack</span>&lt;TreeNode*&gt;&amp; s, TreeNode *t)</span> </span>&#123;</span><br><span class="line">        s.push(n);</span><br><span class="line">        <span class="keyword">if</span> (!n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n == t) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dfs(n-&gt;left, s, t)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        s.pop();</span><br><span class="line">        <span class="keyword">if</span> (dfs(n-&gt;right, s, t)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        s.pop();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://imgur.com/4j9XLua.png" alt=""></p>
<p>代码丑是丑了点 = =, 不过我其他算法也没好到哪里去… (这是必要的损失么?)</p>
<h3 id="the-best-solution"><a href="#the-best-solution" class="headerlink" title="the best solution"></a>the best solution</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode2</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode2 *left;</span><br><span class="line">        TreeNode2 *right;</span><br><span class="line">        TreeNode2 *ahead;</span><br><span class="line">        <span class="keyword">bool</span> checked;</span><br><span class="line">        TreeNode2(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) ,ahead(<span class="literal">NULL</span>),checked(<span class="literal">false</span>)&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    TreeNode2* target2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">findahead</span><span class="params">(TreeNode* node,TreeNode2* newnode,TreeNode* target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        TreeNode2 *leftnode;</span><br><span class="line">        TreeNode2 *rightnode;</span><br><span class="line">        <span class="keyword">if</span> (newnode-&gt;val ==  target-&gt;val) <span class="keyword">this</span>-&gt;target2 = newnode;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            leftnode = <span class="keyword">new</span> TreeNode2(node-&gt;left-&gt;val);</span><br><span class="line">            newnode-&gt;left = leftnode;</span><br><span class="line">            newnode-&gt;left-&gt;ahead = newnode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            rightnode = <span class="keyword">new</span> TreeNode2(node-&gt;right-&gt;val);</span><br><span class="line">            newnode-&gt;right = rightnode;</span><br><span class="line">            newnode-&gt;right-&gt;ahead = newnode;</span><br><span class="line">        &#125;</span><br><span class="line">        findahead(node-&gt;left,leftnode,target);</span><br><span class="line">        findahead(node-&gt;right,rightnode,target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode2* node,<span class="keyword">int</span> <span class="built_in">step</span>,<span class="keyword">int</span>&amp; k,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;checked == <span class="literal">true</span>) <span class="keyword">return</span>;</span><br><span class="line">        node-&gt;checked = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="built_in">step</span>) res.push_back(node-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">step</span> &gt; k) <span class="keyword">return</span>;</span><br><span class="line">        dfs(node-&gt;left,<span class="built_in">step</span> + <span class="number">1</span>,k,res);</span><br><span class="line">        dfs(node-&gt;right,<span class="built_in">step</span> + <span class="number">1</span>,k,res);</span><br><span class="line">        dfs(node-&gt;ahead,<span class="built_in">step</span> + <span class="number">1</span>,k,res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; distanceK(TreeNode* root, TreeNode* target, <span class="keyword">int</span> K) &#123;</span><br><span class="line">        <span class="comment">//constuct ahead</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        TreeNode2* newroot = <span class="keyword">new</span> TreeNode2(root-&gt;val);</span><br><span class="line">        findahead(root,newroot,target);</span><br><span class="line">        dfs(<span class="keyword">this</span>-&gt;target2,<span class="number">0</span>,K,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>它新建了一个节点, 其中包含 left, right, ahead 指针 :(</p>
<p>这会让查找变得简单, 但我并不认可这种方式 = =.</p>
]]></content>
  </entry>
  <entry>
    <title>leetcode/onMy...</title>
    <url>/2020/06/25/leetcode/onMy.../</url>
    <content><![CDATA[<h2 id="on-my-…"><a href="#on-my-…" class="headerlink" title="on my …"></a>on my …</h2><p><img src="https://imgur.com/XKsKdeU.png" alt=""></p>
<h3 id="my-solution"><a href="#my-solution" class="headerlink" title="my solution"></a>my solution</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">isNStraightHand</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; hand, <span class="keyword">int</span> W)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">div_t</span> di = div(hand.<span class="built_in">size</span>(), W);</span><br><span class="line">      <span class="keyword">if</span> (di.rem) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hds;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> v : hand) &#123;</span><br><span class="line">          ++hds[v];</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (!hds.empty()) &#123;</span><br><span class="line">          <span class="keyword">auto</span> it = *hds.<span class="built_in">begin</span>();</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> l = it.second, b = it.first, e = it.first + W; </span><br><span class="line">               b &lt; e; ++b) &#123;</span><br><span class="line">              hds[b] -= l;</span><br><span class="line">              <span class="keyword">if</span> (hds[b] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hds[b] == <span class="number">0</span>) &#123;</span><br><span class="line">                  hds.erase(b);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>什么也不想说 :(</p>
<h3 id="the-best-solution"><a href="#the-best-solution" class="headerlink" title="the best solution"></a>the best solution</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isNStraightHand</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; hand, <span class="keyword">int</span> W)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v(W);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (W == <span class="number">3</span> &amp;&amp; hand[<span class="number">0</span>] == <span class="number">2</span> &amp;&amp; hand[<span class="number">1</span>] == <span class="number">4</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> h: hand) &#123;</span><br><span class="line">        v[h%W]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cnt = v[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;W; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(v[i] != cnt) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://imgur.com/LyEoIRH.png" alt=""></p>
<p>虽然这个算法偷鸡(最开始那个 if 判断明显具有针对性, 在输入是 [2,4,3] 的情况下会不正确)  </p>
<p>但是依旧对我造成了很大打击… </p>
<p>最开始我的算法是想了一段时间的, 怎么简单, 怎么高效.  </p>
<p>啊… 我为何总是欠缺这种看透问题本质的能力呢…</p>
<p>我的算法不止返回 bool 还可以得到最后的集, 我只能如此安慰自己</p>
]]></content>
  </entry>
  <entry>
    <title>leetcode/MostProfitAssigningWork</title>
    <url>/2020/06/11/leetcode/MostProfitAssigningWork/</url>
    <content><![CDATA[<h2 id="Most-Profit-Assigning-Work"><a href="#Most-Profit-Assigning-Work" class="headerlink" title="Most Profit Assigning Work"></a>Most Profit Assigning Work</h2><p>摸了两个月鱼的胡汉三我又回来了! ( •̀ ω •́ )✧ (其实也不算摸鱼, 只是懒得写笔记了而已)</p>
<a id="more"></a>


<p><img src="https://imgur.com/cm6DHwt.png" alt=""></p>
<p>任务难度, 任务报酬, 工作能力, 求出最大工作利益.</p>
<h3 id="my-solutions"><a href="#my-solutions" class="headerlink" title="my solutions"></a>my solutions</h3><p>worker 可以排个序, 可以节省效率. 问题是 dif(difficulty) 和 pro(profit) 如何处理. 他们是想对于的东西, 直接排序会出错. 而不处理的话效率无法提高. :( </p>
<p>一种直接的方法是 map. 很适用于这种关联型数据结构. 于是乎, 简单实现了一种 map 的解法.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfitAssignment</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; difficulty, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; profit, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; worker)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; prof;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; profit.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            prof[difficulty[i]] = <span class="built_in">max</span>(</span><br><span class="line">                prof[difficulty[i]], profit[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sort(difficulty.<span class="built_in">begin</span>(), difficulty.<span class="built_in">end</span>());</span><br><span class="line">        sort(worker.<span class="built_in">begin</span>(), worker.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>, e = <span class="number">0</span>, lbp = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> abi : worker) &#123;</span><br><span class="line">            <span class="keyword">while</span> (e &lt; difficulty.<span class="built_in">size</span>() &amp;&amp; abi &gt;= difficulty[e]) &#123;</span><br><span class="line">                ++e;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = b; i &lt; e; ++i) &#123;</span><br><span class="line">                lbp = <span class="built_in">max</span>(prof[difficulty[i]], lbp);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// printf("%d ", lbp);</span></span><br><span class="line">            sum += lbp;</span><br><span class="line">            b = e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://imgur.com/rleXObP.png" alt=""></p>
<p>老夫已经不是以前的老夫了. map 其实也并不高效. 即使是红黑树, 元素的搜索也是有很大消耗的 :( </p>
<p>(那么有没有那么一种优美的数据结构, 其有媲美 vector 的线性迭代, 又去除了 vector 的巨大消耗呢? 有的! 理论上完美的 hash ! 但是要达到完美, 其要解决的首要问题就是碰撞 （；´д｀）ゞ 但这真的不是一个可以完美解决的问题)</p>
<p>所以, 老夫悟到了一个道理! 复杂的数据结构可以解决复杂的问题, 但其效率远比不上简单的数据结构. 如果一个问题可以用简单的数据结构来解决, 那么这个解法必然很优越. 数据结构的本质是用一种特性去模拟你所需要的特性. 而这种特性实现上的不同带来了数据结构的复杂程度的不同. 比如现在我所需要的 pro 和 dif 的关联性. 所以我用到了 map. (当然你也可以用一个 pair 的 vector 来实现, 其重心又转向了 pair)</p>
<p>那么, 如何用简单的数据结构解决复杂的问题呢? 好问题! 在下也并不是很清楚 (っ °Д °;)っ !. 不过有一些心得. 如果硬要说的话, 是逻辑! 就拿递归和迭代来距离, 递归的实现往往会比迭代简单很多, 而迭代为了追踪元素的改变, 会用到一些较为复杂的数据结构. (但是问题是, 迭代往往比递归更高效, 因为迭代本身的函数调用和元素传递就是一种巨大的消耗 〒▽〒) 所以, 对于这个问题, 在下还在摸索中! </p>
<p>好了, 说回来, 最后在下想到的能够不使用额外的复杂数据结构的方法是: 修改 pro 和 fit (颇有点解决不了问题, 解决提问题的人的意思… 或者说好听点, 从源头解决问题?) </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfitAssignment</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; difficulty, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; profit, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; worker)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pro &#123; profit[<span class="number">0</span>] &#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dif &#123; difficulty[<span class="number">0</span>] &#125;;</span><br><span class="line">        <span class="keyword">size_t</span> <span class="built_in">size</span> = profit.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, s = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> d = difficulty[i];</span><br><span class="line">            <span class="keyword">int</span> p = profit[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (s &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p &gt; pro[s]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (d &lt; dif[s]) &#123;</span><br><span class="line">                        pro.erase(pro.<span class="built_in">begin</span>() + s);</span><br><span class="line">                        dif.erase(dif.<span class="built_in">begin</span>() + s);</span><br><span class="line">                        --s;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        pro.insert(pro.<span class="built_in">begin</span>() + s + <span class="number">1</span>, p);</span><br><span class="line">                        dif.insert(dif.<span class="built_in">begin</span>() + s + <span class="number">1</span>, d);</span><br><span class="line">                        s = dif.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (d &lt; dif[s]) &#123;</span><br><span class="line">                        --s;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        s = dif.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (s == <span class="number">-1</span>) &#123;</span><br><span class="line">                pro.insert(pro.<span class="built_in">begin</span>(), p);</span><br><span class="line">                dif.insert(dif.<span class="built_in">begin</span>(), d);</span><br><span class="line">                s = dif.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sort(worker.<span class="built_in">begin</span>(), worker.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>, e = <span class="number">0</span>, lbp = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> abi : worker) &#123;</span><br><span class="line">            <span class="keyword">while</span> (e &lt; dif.<span class="built_in">size</span>() &amp;&amp; abi &gt;= dif[e]) &#123;</span><br><span class="line">                ++e;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = b; i &lt; e; ++i) &#123;</span><br><span class="line">                lbp = <span class="built_in">max</span>(pro[i], lbp);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            sum += lbp;</span><br><span class="line">            b = e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://imgur.com/kfJgo5e.png" alt=""></p>
<p>在下虽然对这种量级的代码并不满意, 但是好像暂时想不到什么不用到复杂数据结构, 又能比较高效解决问题的办法了… （；´д｀）ゞ 在下还是太菜了… </p>
<p>第二个循环几乎没变, 核心是第一个循环对于数据的处理, 大概是这么一个逻辑:</p>
<ol>
<li><p>当前 profit 大于对比元素的 profit</p>
<ol>
<li><p>当前 difficulty 小于对比元素的 difficulty</p>
<p>这种情况的话, 对比元素就没有存在的意义了. 删除</p>
</li>
<li><p>当前 difficulty 大于等于对比元素的 difficulty</p>
<p>插入!</p>
</li>
</ol>
</li>
<li><p>当前 profit 小于等于对比元素的 profit </p>
<ol>
<li><p>当前 difficulty 小于对比元素的 difficulty</p>
<p>对比元素有存在的价值, 继续便利其他的对比元素</p>
</li>
<li><p>当前 difficulty 大于等于对比元素的 difficulty</p>
<p>当前元素无存在价值, 跳过.</p>
</li>
</ol>
</li>
</ol>
<p>经过这些修改之后, 元素的量会大大减少(其中一个案例好像直接少了一倍以上) </p>
<p>但是, … 这个循环的消耗还是比较大的, 整体的代码量太多了. 这个循环的理解难度也比较大. 所以并不是一个满意的解法…</p>
<h3 id="the-best-solutions"><a href="#the-best-solutions" class="headerlink" title="the best solutions"></a>the best solutions</h3><p>不贴了, 他是用 pair + sort 解决的. 毫无新意! (虽然的确比较好…)</p>
]]></content>
  </entry>
  <entry>
    <title>other/vector</title>
    <url>/2020/04/21/other/vector/</url>
    <content><![CDATA[<p>emm…  </p>
<p>网络看过了, 多线程看过了, 操作系统看过了, mysql看过了, linux看过了, 数据结构和算法也看过了…  </p>
<p>大多需要的东西我都有看过 (虽然还需大量训练💪), 想了想, 是时候看源码了.</p>
<a id="more"></a>



<p>第一次看源码应该是在一年前, 当时结合&lt;STL源码剖析&gt;, 没看几页就歇气了, 不知道那里去找源码. 也不知道怎么入手. 随着自己不断进步, 这些问题也变得可以解决了. </p>
<h1 id="prepare"><a href="#prepare" class="headerlink" title="prepare"></a>prepare</h1><p>首先, 源码选用哪套呢? 想了想还是 boost 好了. </p>
<p>然后, 书籍的话, 就不读之前那本书了, 网上搜了相关书籍, 很少, 看了看感觉并不适合. 所以选用了 boost 的官方文档. </p>
<p>一开始就遇到了之前的问题: 不知道从哪里开始. 想去看看 vector 的实现. 但是一搜文档, 有很多出都有 vector 关键字. </p>
<p><img src="https://imgur.com/hiPhoqN.png" alt=""></p>
<p>脑壳疼… </p>
<p>好在这个问题可以通过官方文档上来解决:</p>
<p><img src="https://imgur.com/RzQNqTM.png" alt=""></p>
<p>找到相关的位置就好了, 所以, 就先从 vector 开始吧 :)</p>
<h1 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h1><p><img src="https://imgur.com/plUq8uw.png" alt=""></p>
<p>按照文档记载, vector 的默认容器类型是 unbounded_array.  这点 boost 做得不太友好. 因为这个默认类型在 fwd.hpp 文件中才能看到. (在文件中有这么一行 “fwd.hpp is essentially used to forward declare the main types” 应该在很多地方都会有)</p>
<p><img src="https://imgur.com/1fq6OUm.png" alt=""></p>
<p>vector 所继承的父类经查看, 并无太大的实质改变.</p>
<p><img src="https://imgur.com/ZfvVlB6.png" alt=""></p>
<p>它的名字或许有歧义, 因为容器是由 A 决定的, 其父类提供的是一些功能性函数, 并无实际数据成员.</p>
<p>一开始是一些类型的定义:</p>
<p><img src="https://imgur.com/ELEQXYC.png" alt=""></p>
<p>其中比较令人在意的是:</p>
<ul>
<li><p>difference_type</p>
   <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">BOOST_UBLAS_INLINE</span><br><span class="line">     reference <span class="keyword">operator</span> [] (difference_type n) <span class="keyword">const</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> *(it_ + n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   这个类型实际是元素距离类型? 那不应该叫 distance_type 么? 好奇怪的命名…</p>
</li>
<li><p>type_traits</p>
<p>   应该是一些类型特性相关的东西.</p>
</li>
<li><p>vector_reference, closure_type, const_closure_type</p>
<p>   <img src="https://imgur.com/7zJA0Nk.png" alt=""></p>
<p>   这貌似是一个封装了自身内部容器类型的类.</p>
</li>
<li><p>storage_category</p>
<p>   <img src="https://imgur.com/HN2Wujx.png" alt=""></p>
<p>   这好像是一个以类类型为识别的标识, emm… 用 enum 会不会好点? </p>
</li>
</ul>
<p>接下来就是一些普通的成员函数, 其中几个比较在意的: </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">AE</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">BOOST_UBLAS_INLINE</span></span></span><br><span class="line"><span class="class"><span class="title">vector</span> (<span class="title">const</span> <span class="title">vector_expression</span>&lt;AE&gt; &amp;<span class="title">ae</span>):</span></span><br><span class="line">	vector_container&lt;self_type&gt; (),</span><br><span class="line">	data_ (ae ().<span class="built_in">size</span> ()) &#123;</span><br><span class="line">    vector_assign&lt;scalar_assign&gt; (*<span class="keyword">this</span>, ae);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// vector_expression 就是 vector 表达式, 其包含 + - * / 四则运算等等</span></span><br><span class="line"><span class="comment">// 可以参考 vector_expression.hpp 文件.</span></span><br><span class="line"><span class="comment">// 我也不是十分清楚这是啥玩意 = = , 看起来是封装了一些列运算的类.</span></span><br></pre></td></tr></table></figure>
<p>还有一个比较奇怪的 resize</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">BOOST_UBLAS_INLINE</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span> <span class="params">(size_type <span class="built_in">size</span>, <span class="keyword">bool</span> preserve = <span class="literal">true</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (preserve)</span><br><span class="line">		data ().resize (<span class="built_in">size</span>, <span class="keyword">typename</span> A::value_type ());</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		data ().resize (<span class="built_in">size</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// preserve 决定了数据是否保留, 不保留的话会截断. </span></span><br><span class="line"><span class="comment">// 很多函数都只有2, 3行, vector 可以理解为一个包装, 底层数据的控制在其 container 内.</span></span><br></pre></td></tr></table></figure>
<p><img src="https://imgur.com/lil0XBq.png" alt=""></p>
<p>比较好奇 data 哪里来的, vector 只有 data_ 这一个成员. 结果看到 = =</p>
<p>data 是 public 的, 这里加 data() 感觉有点多余. 或者说, 存在它说的 “very specific case” ?</p>
<p>在其他地方也有看到调用的是 data(), 而并非 data_ . 或许是为了功能性? </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">BOOST_UBLAS_INLINE</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">fill</span> (data ().<span class="built_in">begin</span> (), data ().<span class="built_in">end</span> (), value_type<span class="comment">/*zero*/</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 它调用的是 std 的 fill 函数, 其自身也实现了一个 std 的 fill, 不过是一个比较普通的 fill</span></span><br><span class="line"><span class="comment">// memset 是否会更好?</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">C</span>&gt;          // <span class="title">Container</span> <span class="title">assignment</span> <span class="title">without</span> <span class="title">temporary</span></span></span><br><span class="line"><span class="class"><span class="title">BOOST_UBLAS_INLINE</span></span></span><br><span class="line"><span class="class"><span class="title">vector</span> &amp;<span class="title">operator</span> = (<span class="title">const</span> <span class="title">vector_container</span>&lt;C&gt; &amp;<span class="title">v</span>) &#123;</span></span><br><span class="line">    resize (v ().<span class="built_in">size</span> (), <span class="literal">false</span>);</span><br><span class="line">    assign (v);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">AE</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">BOOST_UBLAS_INLINE</span></span></span><br><span class="line"><span class="class"><span class="title">vector</span> &amp;<span class="title">operator</span> = (<span class="title">const</span> <span class="title">vector_expression</span>&lt;AE&gt; &amp;<span class="title">ae</span>) &#123;</span></span><br><span class="line">    <span class="function">self_type <span class="title">temporary</span> <span class="params">(ae)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> assign_temporary (temporary);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是个赋值操作符重载, 但是, 问题是</span></span><br><span class="line"><span class="comment">// 是否可以规避部分 resize 操作? 比如 v 长度为 10, 那么至多 10 个元素不需要 resize</span></span><br><span class="line"><span class="comment">// 交给后续的 assign 就好了</span></span><br><span class="line"><span class="comment">// 还要注意的是, expression 的赋值有临时值, 但 container 没有, 虽然这很正常.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">AE</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">BOOST_UBLAS_INLINE</span></span></span><br><span class="line"><span class="class"><span class="title">vector</span> &amp;<span class="title">assign</span> (<span class="title">const</span> <span class="title">vector_expression</span>&lt;AE&gt; &amp;<span class="title">ae</span>) &#123;</span></span><br><span class="line">	vector_assign&lt;scalar_assign&gt; (*<span class="keyword">this</span>, ae);</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 啊啊啊 绕来绕去, 要吐了 = =</span></span><br><span class="line"><span class="comment">// 不过这里有一个收获就是, 之前为什么用类类型当 tag, 明明只是一个空数据结构</span></span><br></pre></td></tr></table></figure>
<p><img src="https://imgur.com/QLzGeyR.png" alt=""></p>
<p>请看这里! 它使用了这个类类型来重载模板. </p>
<p>不过… 我记得有用值来指定的方式 = =. </p>
<p>我突然发现一个很严肃的问题, 上述的部分函数中, 返回值直接是 vector, 而并非 vector&lt;T, A&gt; … </p>
<p>而我试了一下, 发现是可以编译通过的 = =, 而 google 上几乎示例都告诉我要加 <T>, 我是不是该再看一下模板?</p>
<h2 id="iterator"><a href="#iterator" class="headerlink" title="iterator"></a>iterator</h2><p>boost 将 vector 的 iterator 实现为内部类的形式.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Use the storage array iterator</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> A::const_iterator const_subiterator_type;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> A::iterator subiterator_type;</span><br></pre></td></tr></table></figure>
<p>它使用的是底层容器的 iterator, 它和 vector 类似, 也是一个包装类. 看来一切的核心在底层容器中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Serialize a vector into and archive as defined in Boost</span></span><br><span class="line"><span class="comment">/// \param ar Archive object. Can be a flat file, an XML file or any other stream</span></span><br><span class="line"><span class="comment">/// \param file_version Optional file version (not yet used)</span></span><br><span class="line">     <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Archive</span>&gt;</span></span><br><span class="line"><span class="class">     <span class="title">void</span> <span class="title">serialize</span>(<span class="title">Archive</span> &amp; <span class="title">ar</span>, <span class="title">const</span> <span class="title">unsigned</span> <span class="title">int</span> /* <span class="title">file_version</span> */)&#123;</span></span><br><span class="line">         ar &amp; serialization::make_nvp(<span class="string">"data"</span>,data_);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p>哦哦哦, 不愧是 boost, 很方便嘛.</p>
<h2 id="unbounded-array"><a href="#unbounded-array" class="headerlink" title="unbounded_array"></a>unbounded_array</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Storage types</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">ALLOC</span> = <span class="title">std</span>:</span>:allocator&lt;T&gt; &gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">unbounded_array</span>;</span></span><br></pre></td></tr></table></figure>
<p>(ノ｀Д)ノ 你… </p>
<p>(顺便, 在这段期间我折腾了一下 IDE, Clion, xcode, visual studio. 最后还是 vs 好. 对于这种源码级别的符号解析, 其他 IDE 好像都不怎么聪明. 但是很可惜 vs mac 的支持并不好. 而且没有 vs 插件)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">const</span> T *const_pointer;</span><br><span class="line"><span class="keyword">typedef</span> T *pointer;</span><br><span class="line"><span class="keyword">typedef</span> const_pointer const_iterator;</span><br><span class="line"><span class="keyword">typedef</span> pointer iterator</span><br></pre></td></tr></table></figure>
<p>所以迭代器只是一种概念, 一种机制, 其内部还是指针.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ALLOC alloc_;</span><br><span class="line">size_type size_;</span><br><span class="line">pointer data_</span><br></pre></td></tr></table></figure>
<p>data_ 应该就是数据存储所在.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">BOOST_UBLAS_INLINE</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span> <span class="params">(unbounded_array &amp;a)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span> != &amp;a) &#123;</span><br><span class="line">	<span class="built_in">std</span>::swap (size_, a.size_);</span><br><span class="line">	<span class="built_in">std</span>::swap (data_, a.data_);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以, swap 是轻量级的, 只有内部元素交换.</p>
<p>老夫突然发现一件很要命的事情…</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">BOOST_UBLAS_INLINE</span><br><span class="line"><span class="function">reference <span class="title">insert_element</span> <span class="params">(size_type i, const_reference t)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (data () [i] = t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOST_UBLAS_INLINE</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">erase_element</span> <span class="params">(size_type i)</span> </span>&#123;</span><br><span class="line">	data () [i] = value_type<span class="comment">/*zero*/</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reference <span class="keyword">operator</span> [] (size_type i) &#123;</span><br><span class="line">    BOOST_UBLAS_CHECK (i &lt; size_, bad_index ());</span><br><span class="line">    <span class="keyword">return</span> data_ [i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是 vector 的插入和删除元素, 以及插入元素内部 [] 的重载… 这… </p>
<p>boost 的 vector 就是数组… 还是不会自动变长的那种… </p>
<p>是的, 再三对比文档和源码, 插入只有 insert_element 一处. 而插入时会先进行界限判定, 如果越界, 则直接报错… </p>
<p>想不到你是这样的 boost. 我看错你了! </p>
<p>啊, 不知不觉这个文档已经要初次结尾了呢 :) 虽然后续应该有很多补充内容, 比如标准的 vector 是如何做的. 底层其他容器的特性… </p>
<p>现在还剩的是: 内存是怎么分配的. 其实, 比意料之中的还要简单</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">_NODISCARD _DECLSPEC_ALLOCATOR _<span class="function">Ty* <span class="title">allocate</span><span class="params">(_CRT_GUARDOVERFLOW <span class="keyword">const</span> <span class="keyword">size_t</span> _Count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;_Ty*&gt;(_Allocate&lt;_New_alignof&lt;_Ty&gt;&gt;(_Get_size_of_n&lt;<span class="keyword">sizeof</span>(_Ty)&gt;(_Count)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用了 _Allocate </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">size_t</span> _Align, <span class="class"><span class="keyword">class</span> _<span class="title">Traits</span> = _<span class="title">Default_allocate_traits</span>,</span></span><br><span class="line"><span class="class">    <span class="title">enable_if_t</span>&lt;(!_HAS_ALIGNED_NEW || _Align &lt;= __STDCPP_DEFAULT_NEW_ALIGNMENT__), int&gt; = 0&gt;</span></span><br><span class="line"><span class="class">_<span class="title">DECLSPEC_ALLOCATOR</span> <span class="title">void</span>* _<span class="title">Allocate</span>(<span class="title">const</span> <span class="title">size_t</span> _<span class="title">Bytes</span>) &#123;</span></span><br><span class="line">    <span class="comment">// allocate _Bytes when !_HAS_ALIGNED_NEW || _Align &lt;= __STDCPP_DEFAULT_NEW_ALIGNMENT__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(_M_IX86) || defined(_M_X64)</span></span><br><span class="line">    <span class="keyword">if</span> (_Bytes &gt;= _Big_allocation_threshold) &#123; <span class="comment">// boost the alignment of big allocations to help autovectorization</span></span><br><span class="line">        <span class="keyword">return</span> _Allocate_manually_vector_aligned&lt;_Traits&gt;(_Bytes);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// defined(_M_IX86) || defined(_M_X64)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_Bytes != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> _Traits::_Allocate(_Bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 要么执行优化版本的分配, 要么直接分配, 我们看看直接分配的就好</span></span><br><span class="line"><span class="comment">// 在 _Default_allocate_traits 下: </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">Default_allocate_traits</span> &#123;</span></span><br><span class="line">    _DECLSPEC_ALLOCATOR <span class="keyword">static</span> <span class="keyword">void</span>* _Allocate(<span class="keyword">const</span> <span class="keyword">size_t</span> _Bytes) &#123;</span><br><span class="line">        <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="keyword">new</span>(_Bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cpp_aligned_new</span></span><br><span class="line">    _DECLSPEC_ALLOCATOR <span class="keyword">static</span> <span class="keyword">void</span>* _Allocate_aligned(<span class="keyword">const</span> <span class="keyword">size_t</span> _Bytes, <span class="keyword">const</span> <span class="keyword">size_t</span> _Align) &#123;</span><br><span class="line">        <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="keyword">new</span> (_Bytes, <span class="keyword">align_val_t</span>&#123;_Align&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// __cpp_aligned_new</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(_M_IX86) || defined(_M_X64)</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">size_t</span> _Big_allocation_threshold = <span class="number">4096</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">size_t</span> _Big_allocation_alignment = <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 意料之外的简单(当然, 再看 new 底部就不那么简单了)</span></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>other/TopLevelDirectoriesMeansInLinux</title>
    <url>/2020/03/31/other/TopLevelDirectoriesMeansInLinux/</url>
    <content><![CDATA[<h1 id="Top-Level-Directories-Means-In-Linux"><a href="#Top-Level-Directories-Means-In-Linux" class="headerlink" title="Top Level Directories Means In Linux"></a>Top Level Directories Means In Linux</h1><p>It looks like I haven’t written some notes about Linux top-level directories. so do it now!</p>
<p>我好像还没写过关于 Linux 顶层文件含义的笔记, 那就现在写吧!</p>
<a id="more"></a>



<p><a href="https://www.granneman.com/tech/linux/thelinuxenvironment/topleveldirectories" target="_blank" rel="noopener">FROM</a></p>
<p><code>/</code>: The top level directory in your system. It’s called the root directory, because it’s the root of the system: all the rest of the directory structure emanates from it like branches from the root of a tree. Don’t get confused by the /root directory, by the way; that’s a different ‘root’.</p>
<p>根节点, 叫 root 目录的时候, 有两种根据上下文不同而含义不同的选项: 根目录(/), root 用户根目录(/root)</p>
<p><code>/bin</code>: Contains binaries for your system. The /bin directory is, by default, in your PATH, meaning that any executable file in this directory can be executed just by entering the file name at the command line.</p>
<p>二进制可执行文件目录. 通常会在 PATH 环境变量中, 执行的时候只需提供可执行文件名.</p>
<p>(PS: 所以有种直接执行当前目录而不带 ./ 前缀的方法是在 PATH 中加 . )</p>
<p>(我猜的, 实测可行!  <code>export PATH=$PATH:.</code>)</p>
<p><code>/boot</code>: Contains files necessary to boot your system, including the kernel.</p>
<p>包含启动系统必须的文件, 包括内核.</p>
<p><code>/dev</code>: An abstracted directory which contains all your system devices: hard drives, CD-ROMs, sound cards, and much, much more. When devices are mounted, it occurs here.</p>
<p>虚拟文件目录, 所有可挂载设备都在这里.</p>
<p><code>/etc</code>: Contains most of the system and application configuration files your Linux machine uses. Back this directory up regularly.</p>
<p>应用和系统的配置文件. 很重要, 所以请周期性保存它.</p>
<p>(PS: 为什么叫 etc 呢? etc 是等等的意思. 我记得之前查过, 最后得到的答案是, 历史原因…  (╯▔皿▔)╯ )</p>
<p><code>/etc/skel</code>: “skeleton” files used to create user accounts.</p>
<p>创建用户所需的文件?</p>
<p>( PS: 看了看, 包括三个文件 <code>.profile</code> <code>.bashrc</code> <code>.bash_logout</code> )</p>
<p><code>/home</code>: Contains the home directory for each system user.</p>
<p>包含系统用户的 home 目录. </p>
<p>(PS: 不包含 root)</p>
<p><code>/lib</code>: System modules, software libraries, &amp; information databases, shared by various applications &amp; the system itself.</p>
<p>系统模块, 软件/信息库. </p>
<p><code>/opt</code>: Optional software that you installed.</p>
<p>可选软件安装目录.</p>
<p><code>/proc</code>: Another abstracted directory which is created when the system boots. Contains information about the processes on your system.</p>
<p>系统运行创建的虚拟目录. 包含进程信息.</p>
<p><code>/root</code>: The home directory of the root user.</p>
<p>root 的 home.</p>
<p><code>/sbin</code>: Contains additional system binaries that are only available to root. Mostly admin tools.</p>
<p>admin 工具. 只对 root 开放.</p>
<p><code>/tmp</code>: The temporary directory. Any user can place stuff in here, but be forewarned: your system periodically cleans out this directory, and anything you leave in here will be deleted.</p>
<p>临时文件目录</p>
<p><code>/usr</code>: Contains subdirectories that will be used system-wide by all users, including binaries, libraries, man files, and other things.</p>
<p>包含所有用户使用的子目录, 包括二进制, 库, man 文件, 以及其他.</p>
<p><code>/usr/doc</code>: Program documentation.</p>
<p>程序文档</p>
<p><code>/usr/info</code>: Program documentation.</p>
<p>程序文档</p>
<p><code>/usr/lib</code>: Program libraries (shareable system program modules).</p>
<p>程序库</p>
<p><code>/usr/man</code>: Manual pages.</p>
<p>man 手册</p>
<p><code>/var</code>: Contains variable data that changes in size as the system runs. For instance, log files, mail directories, databases, and printing spools.</p>
<p>随系统运行而改变的各种数据. 包括, 日志文件, 邮件目录, 数据库.</p>
<p>2020年3月31日</p>
<p>好像还有些遗漏, 不完全的, 补一下</p>
<p><a href="https://www.howtogeek.com/117435/htg-explains-the-linux-directory-structure-explained/" target="_blank" rel="noopener">FROM</a></p>
<p><code>/lost+found</code> – Recovered Files</p>
<p>Each Linux file system has a lost+found directory. If the file system crashes, a file system check will be performed at next boot. Any corrupted files found will be placed in the lost+found directory, so you can attempt to recover as much data as possible.</p>
<p>每个文件系统都包含一个 lost+found 目录. 如果文件系统崩溃, 下次重启时会检查这个文件. 任何被发现的损坏文件都会放在这个目录下.</p>
<p>(PS: 部分不会, 比如 tmpfs 和 udev)</p>
<p><code>/mnt</code> – Temporary Mount Points</p>
<p>Historically speaking, the /mnt directory is where system administrators mounted temporary file systems while using them. For example, if you’re mounting a Windows partition to perform some file recovery operations, you might mount it at /mnt/windows. However, you can mount other file systems anywhere on the system.</p>
<p>历史上来说, /mnt 目录包含系统管理员使用时挂载的临时文件系统. 比如, 如果你挂载一个 windows 分区执行一些文件恢复操作, 你应该挂载在 /mnt/windows 上. 然而, 你可以在系统任何地方挂载文件.</p>
<p><code>/opt</code> – Optional Packages</p>
<p>The /opt directory contains subdirectories for optional software packages. It’s commonly used by proprietary software that doesn’t obey the standard file system hierarchy – for example, a proprietary program might dump its files in /opt/application when you install it.</p>
<p>包含可选软件包. 这通常用于不遵循标准文件系统层次的专有软件. 比如, 将会在安装时下载其文件到 /opt/application 的专有程序. </p>
<p><code>/run</code> – Application State Files</p>
<p>The /run directory is fairly new, and gives applications a standard place to store transient files they require like sockets and process IDs. These files can’t be stored in /tmp because files in /tmp may be deleted.</p>
<p>一个程序存储其临时文件的地方, 这些文件不能存储到 /tmp, 因为里面的文件会被删除.</p>
<p><code>/srv</code> – Service Data</p>
<p>The /srv directory contains “data for services provided by the system.” If you were using the Apache HTTP server to serve a website, you’d likely store your website’s files in a directory inside the /srv directory.</p>
<p>系统服务文件数据目录. 如果使用了 Apache HTTP 服务, 那么你应该把文件存储在这里.</p>
<p>(PS: Apache 默认目录是 ‘/var/www/html’ , 怎么更改? 还记得 /etc 的用处么?)</p>
<p><code>/usr</code> – User Binaries &amp; Read-Only Data</p>
<p>The /usr directory contains applications and files used by users, as opposed to applications and files used by the system. For example, non-essential applications are located inside the /usr/bin directory instead of the /bin directory and non-essential system administration binaries are located in the /usr/sbin directory instead of the /sbin directory. Libraries for each are located inside the /usr/lib directory. The /usr directory also contains other directories – for example, architecture-independent files like graphics are located in /usr/share.</p>
<p>包含用户使用的应用和文件, 而不是系统所使用的应用和文件. </p>
<p>The /usr/local directory is where locally compiled applications install to by default – this prevents them from mucking up the rest of the system.</p>
<p><code>/var</code> – Variable Data Files</p>
<p>The /var directory is the writable counterpart to the /usr directory, which must be read-only in normal operation. Log files and everything else that would normally be written to /usr during normal operation are written to the /var directory. For example, you’ll find log files in /var/log.</p>
<p>与 /usr 相比, 是一个可写入的目录. 日志及其他通常会写入 /usr 的数据都会写入到 /var 目录. </p>
]]></content>
  </entry>
  <entry>
    <title>other/funnyThings</title>
    <url>/2020/03/31/other/funnyThings/</url>
    <content><![CDATA[<p>聊一下大概半年前的一次误操作导致的整个服务器数据丢失的问题. 单纯分享一下, 就当看戏.<br>(之所以现在才说, 是怕被逮个现行… 那就尴尬了…)  </p>
<a id="more"></a>

<p>开始正题:<br>那是一个阳光明媚的下午, 忙完手上的东西, 刚享受着清闲时光的 LZ 突然接到了一个合作方运营发来的需求.   </p>
<pre><code>亲😙 这边看服务器 xxx 流水已经比较少了呢, 为了节约成本, 将于 xxx 对服务器进行降配. 希望配合一下 🤝</code></pre><p>哦哦, 原来是扣13甲方又想节约成本 <img src="https://imgur.com/JGzIDMA.png" alt=""></p>
<p>彳亍口巴, 把这台服务器的服都关了, 刷一下外网服务器状态, 等待他们操作.  </p>
<pre><code>好的, 服务器已经关闭了, 麻烦降配之后告知一下 🤝</code></pre><p>.</p>
<pre><code>服务器怎么进不去呢? @我</code></pre><p>然后问题来了, 合作方操作重启之后服务器进不去… <img src="https://imgur.com/taxmpv7.png" alt="">  </p>
<pre><code>我看看</code></pre><p>小事小事, 待老夫登录看看 <img src="https://imgur.com/u4nEsKg.png" alt="">    </p>
<p>然后我 ssh 登录发现, 分区没了…!!!  Σ(っ°Д °;)っ <img src="https://imgur.com/iFBtw0B.png" alt="">    </p>
<p>仔细看看, 没错, 老夫的 ‘/dev/vdb1’ , 挂载在 ‘/data’ (所有数据的主目录) 的分区没了!!! <img src="https://imgur.com/lg1l2Vz.png" alt="">  </p>
<p>emm… 慌个p, 反正不关我事, 反手就把问题丢给了对面 <img src="https://imgur.com/d6j3QXi.png" alt="">   </p>
<p>本来事情可能到此为止, 与我已无关, 找不找回来锅都不是我的. 但是事情出现了转机… <img src="https://imgur.com/cqQAFFW.png" alt=""></p>
<p>因为已经处理了一段时间了, 我亲切地问候了一下合作方的运维小哥: </p>
<pre><code>您好, 请问问题进展怎么样了? 😊</code></pre><p>可能因为事情的确比较大, 刚好刺激到他了, 他回复:</p>
<pre><code>急什么? 这不正在看么? </code></pre><p>中途又说了几句诸如 “我这边没问题, 你确定你那边没做什么操作?” 之类想甩锅的话. 总之我也被刺激到了</p>
<p>行! 老夫就找证据!!! <img src="https://imgur.com/KS9TZk2.png" alt=""> </p>
<p>(然而事实证明就不该多事…) <img src="https://imgur.com/NEwh4DL.png" alt=""> </p>
<p>从 history 找起, df -h 截图, vim /etc/fstab  …<br>本当我已经卯足力气发挥我在祖安多年学来的技术要怼人的时候  <img src="https://imgur.com/4yUa4zW.png" alt="">  <img src="https://imgur.com/cY7ux06.png" alt=""> </p>
<p>突然发现了我的一个迷之操作… <img src="https://imgur.com/iFBtw0B.png" alt="">  </p>
<pre><code>fdisk /dev/vdb
mkfs.ext3 /dev/vdb
...
mount /dev/vdb1 /data</code></pre><p>这一刻, 老夫似乎明白了什么…<br>简单来说, 我分区了 /dev/vdb1. 但是却在格式化的时候格式化了 /dev/vdb !!! <img src="https://imgur.com/lg1l2Vz.png" alt=""> 1 没了!!!</p>
<p>我抓我自己, 这种操作没想到出现在自己身上了 <img src="https://imgur.com/FKcBB4Y.png" alt="">  </p>
<p>怎么办, 完了, 大清完了. 怎么办, 难道现在就要细软跑了么 <img src="https://imgur.com/r3QpOw9.png" alt="">   </p>
<p>本来想自己擦屁股, 看有没有办法将数据恢复的<br>但是我看到了一条让我打消想法的指令 <img src="https://imgur.com/FhTyJMk.png" alt="">   </p>
<p>(指令应该是对面运维尝试修复而执行的, 具体是啥已经忘了, 不过看了 man 手册, 大概意思是重新扫描修复磁盘, 我在我的测试机上试了试, emm… 是的, 很干净)  <img src="https://imgur.com/tRtuVf4.png" alt=""></p>
<p>彳亍口巴, 看来铁定要回去卖煎蛋饼了…  </p>
<p>犹豫再三, 想了想对面运维小哥, 想了想自己, 想了想还未表白的美术妹子.<br>我还是毅然地走向了老大… <img src="https://imgur.com/n671WzG.png" alt=""></p>
<p>// ———————————–  </p>
<p>后续:<br>老大不愧是老江湖! 叫我不要声张 <img src="https://imgur.com/MRQpKkV.png" alt=""><br>我的最后一点良心也给他们留下了罪证, 没有删 history.</p>
<p>最后, 事情还是没被发现, 事情不了了之 (运维小哥怎么样我就不知道了, 毕竟那是整台服务器的数据, 玩家可能已经炸锅了…)<br><img src="https://imgur.com/yVT26JL.png" alt="">  </p>
]]></content>
  </entry>
  <entry>
    <title>leetcode/PermutationInString</title>
    <url>/2020/03/27/leetcode/PermutationInString/</url>
    <content><![CDATA[<h1 id="Permutation-in-String"><a href="#Permutation-in-String" class="headerlink" title="Permutation in String"></a>Permutation in String</h1><p><img src="https://imgur.com/b1Y77Az.png" alt=""></p>
<p>是否存在等价子串</p>
<a id="more"></a>



<h2 id="my-solution"><a href="#my-solution" class="headerlink" title="my solution"></a>my solution</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkInclusion</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s2.<span class="built_in">size</span>() &lt; s1.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;v : s1) ++mp[v];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, b = <span class="number">0</span>; i &lt; s2.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mp.count(s2[i])) &#123;</span><br><span class="line">                <span class="keyword">while</span> (b &lt; i &amp;&amp; mp.count(s2[b]) != <span class="number">0</span>)</span><br><span class="line">                    ++mp[s2[b++]];</span><br><span class="line">                b = i + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (--mp[s2[i]] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (mp[s2[i]] &lt; <span class="number">0</span>)</span><br><span class="line">                    ++mp[s2[b++]];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i - b == s1.<span class="built_in">size</span>() - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (s2.<span class="built_in">size</span>() - b &lt; s1.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>用的是滑动窗口来做. 其中 map 存放元素. 不过可以不用高级数据结构. 因为小写英文字母总共也就 26 个, 其下标做索引. 还可以省去一个 int. 有一些优化的点, 可以通过最优算法来借鉴. </p>
<h2 id="the-best-solution"><a href="#the-best-solution" class="headerlink" title="the best solution"></a>the best solution</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">match</span><span class="params">(<span class="keyword">int</span> map1[], <span class="keyword">int</span> map2[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (map1[i] != map2[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkInclusion</span><span class="params">(<span class="built_in">string</span> str, <span class="built_in">string</span> <span class="built_in">text</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str.length() &gt; <span class="built_in">text</span>.length())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> *textMap = (<span class="keyword">int</span>*)<span class="built_in">calloc</span>(<span class="number">26</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">        <span class="keyword">int</span> *strMap = (<span class="keyword">int</span> *)<span class="built_in">calloc</span>(<span class="number">26</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">        <span class="comment">// creating the maps with the relevant chars</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            textMap[<span class="built_in">text</span>[i] - <span class="string">'a'</span>]++;</span><br><span class="line">            strMap[str[i] - <span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// sliding window</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">text</span>.length() - str.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(match(strMap, textMap))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            textMap[<span class="built_in">text</span>[i + str.length()] - <span class="string">'a'</span>]++;</span><br><span class="line">            textMap[<span class="built_in">text</span>[i] - <span class="string">'a'</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> match(strMap, textMap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>一个关键的点是我不必一开始就将所有的 s2 获取. 这是我没想到的. (其实这也不难想到, 为什么呢 = =)</p>
<p>他也是滑动窗口. 这没有什么特别好说的. 这里顺便说一下 calloc. 这是一个附带初始化的 malloc. </p>
]]></content>
  </entry>
  <entry>
    <title>leetcode/SubtreeOfAnotherTree</title>
    <url>/2020/03/27/leetcode/SubtreeOfAnotherTree/</url>
    <content><![CDATA[<h1 id="Subtree-of-Another-Tree"><a href="#Subtree-of-Another-Tree" class="headerlink" title="Subtree of Another Tree"></a>Subtree of Another Tree</h1><p><img src="https://imgur.com/UJvmRho.png" alt=""></p>
<p>判断是否存在子树</p>
<a id="more"></a>



<h2 id="my-solution"><a href="#my-solution" class="headerlink" title="my solution"></a>my solution</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode* s, TreeNode* t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!t) <span class="keyword">return</span> !s;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> findRoot(s, t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">findRoot</span><span class="params">(TreeNode *s, TreeNode *t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!s) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (s-&gt;val == t-&gt;val &amp;&amp; isMatch(s, t)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> findRoot(s-&gt;left, t) || findRoot(s-&gt;right, t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(TreeNode *s, TreeNode *t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!t) <span class="keyword">return</span> !s;</span><br><span class="line">        <span class="keyword">if</span> (!s) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s-&gt;val != t-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> isMatch(s-&gt;left, t-&gt;left) &amp;&amp; isMatch(s-&gt;right, t-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>简单解释的话, 就是 “归归” 算法 😂. 递归套递归, 尽管我十分不情愿. 但是因为这不是个 bst 的缘故. 只有在递归中去判断(这个判断也需要递归)才比较高效, 不然如何判断”是否存在其他节点的值和这个节点相等, 也能进行判断”就会成为一个比较费力的问题. 写出 “归归” 就像🐮被挤出了最后一滴一样不情愿😭.</p>
<h2 id="the-best-solution"><a href="#the-best-solution" class="headerlink" title="the best solution"></a>the best solution</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">eq</span><span class="params">(TreeNode* s, TreeNode* t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!s &amp;&amp; !t) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!s || !t) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> s-&gt;val == t-&gt;val &amp;&amp; eq(s-&gt;left, t-&gt;left) </span><br><span class="line">            &amp;&amp; eq(s-&gt;right, t-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode* s, TreeNode* t)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> s &amp;&amp; (eq(s, t) || isSubtree(s-&gt;left, t) || isSubtree(s-&gt;right, t));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://encrypted-tbn0.gstatic.com/images?q=tbn%3AANd9GcT5uw13DUFeKPYfuH6JCGMIm7c1CJ5BDdQtApGTGhFgQbCr0IyY" alt=""></p>
<p>哈哈哈, 老哥你也是 “归归” 啊.</p>
<p>咳咳, 不过比我少了一个函数, 仔细看看. </p>
<pre><code>if (!t) return !s;
if (!s) return false;
// ---------------------
if (!s &amp;&amp; !t) return true;
if (!s || !t) return false;</code></pre><p>就这两个表达式的处理而言, 老夫觉得自己要胜一筹! 第一个表达式就是如果 t 为假, 那么 s 为 true 则 false, 反之亦可. </p>
<p>而第二个表达式可以基于第一个表达式, 这时候 t 已经不可能为 false 了. 如果 s 为真, 直接返回 false 就好. </p>
]]></content>
  </entry>
  <entry>
    <title>other/newAnddelete</title>
    <url>/2020/03/27/other/newAnddelete/</url>
    <content><![CDATA[<h1 id="new-And-delete"><a href="#new-And-delete" class="headerlink" title="new And delete"></a>new And delete</h1><p>When I was a trainee at the training institution. I was shocked when my teacher shows me the secret blow ‘new’ and ‘delete’. I still remember that day even I can’t fully understand it. It’s time to resolve it by myself!</p>
<p>至今我还记得在培训的时候, 讲师给我演示了 new 和 delete 的内部实现时我的震惊. 虽然当时没有完全理解. 是时候自己看看了.</p>
<a id="more"></a>



<h2 id="new-class"><a href="#new-class" class="headerlink" title="new class"></a>new class</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">    int i &#x3D; 0;</span><br><span class="line">    char c &#x3D; 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    A *pa &#x3D; new A;</span><br><span class="line">    pa-&gt;i &#x3D; 10;</span><br><span class="line">    printf(&quot;%d\n&quot;, pa-&gt;i);</span><br><span class="line">    delete pa;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; -------------------------------</span><br><span class="line">main:</span><br><span class="line">.LFB4945:</span><br><span class="line">        .loc 1 11 0</span><br><span class="line">        .cfi_startproc</span><br><span class="line">        pushq   %rbp</span><br><span class="line">        .cafi_def_cfa_offset 16</span><br><span class="line">        .cfi_offset 6, -16</span><br><span class="line">        movq    %rsp, %rbp</span><br><span class="line">        .cfi_def_cfa_register 6</span><br><span class="line">        pushq   %rbx</span><br><span class="line">        subq    $24, %rsp</span><br><span class="line">        .cfi_offset 3, -24</span><br><span class="line">        .loc 1 12 0</span><br><span class="line">        movl    $8, %edi</span><br><span class="line">        call    _Znwm@PLT</span><br><span class="line">        movq    %rax, %rbx</span><br><span class="line">        movq    %rbx, %rdi</span><br><span class="line">        call    _ZN1AC1Ev</span><br><span class="line">        movq    %rbx, -24(%rbp)</span><br><span class="line">        .loc 1 13 0</span><br><span class="line">        movq    -24(%rbp), %rax</span><br><span class="line">        movl    $10, (%rax)</span><br><span class="line">        .loc 1 14 0</span><br><span class="line">        movq    -24(%rbp), %rax</span><br><span class="line">        movl    (%rax), %eax</span><br><span class="line">        movl    %eax, %esi</span><br><span class="line">        leaq    .LC0(%rip), %rdi</span><br><span class="line">        movl    $0, %eax</span><br><span class="line">        call    printf@PLT</span><br><span class="line">        .loc 1 15 0</span><br><span class="line">        movq    -24(%rbp), %rax</span><br><span class="line">        movl    $8, %esi	&#x2F;&#x2F; 第二个参数是大小</span><br><span class="line">        movq    %rax, %rdi	&#x2F;&#x2F; 第一个参数是 this</span><br><span class="line">        call    _ZdlPvm@PLT</span><br><span class="line">        .loc 1 16 0</span><br><span class="line">        movl    $0, %eax</span><br><span class="line">        addq    $24, %rsp</span><br><span class="line">        popq    %rbx</span><br><span class="line">        popq    %rbp</span><br><span class="line">        .cfi_def_cfa 7, 8</span><br><span class="line">        ret</span><br><span class="line">        .cfi_endproc</span><br></pre></td></tr></table></figure>

<p>没有什么好说的, 分配空间, 调用构造. 然后析构.</p>
<h2 id="new-an-array-of-classes"><a href="#new-an-array-of-classes" class="headerlink" title="new an array of classes"></a>new an array of classes</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">    int i &#x3D; 0;</span><br><span class="line">    char c &#x3D; 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    A *pa &#x3D; new A[2];</span><br><span class="line">    pa-&gt;i &#x3D; 10;</span><br><span class="line">    printf(&quot;%d\n&quot;, pa-&gt;i);</span><br><span class="line">    delete[] pa;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; -------------------------------</span><br><span class="line">main:</span><br><span class="line">.LFB4945:</span><br><span class="line">        .loc 1 11 0</span><br><span class="line">        .cfi_startproc</span><br><span class="line">        pushq   %rbp</span><br><span class="line">        .cfi_def_cfa_offset 16</span><br><span class="line">        .cfi_offset 6, -16</span><br><span class="line">        movq    %rsp, %rbp</span><br><span class="line">        .cfi_def_cfa_register 6</span><br><span class="line">        pushq   %r13</span><br><span class="line">        pushq   %r12</span><br><span class="line">        pushq   %rbx</span><br><span class="line">        subq    $24, %rsp</span><br><span class="line">        .cfi_offset 13, -24</span><br><span class="line">        .cfi_offset 12, -32</span><br><span class="line">        .cfi_offset 3, -40</span><br><span class="line">        .loc 1 12 0</span><br><span class="line">        movl    $16, %edi</span><br><span class="line">        call    _Znam@PLT</span><br><span class="line">        movq    %rax, %r13</span><br><span class="line">        movq    %r13, %rax</span><br><span class="line">        movl    $1, %ebx</span><br><span class="line">        movq    %rax, %r12</span><br><span class="line">.L4:</span><br><span class="line">        .loc 1 12 0 is_stmt 0 discriminator 3</span><br><span class="line">        testq   %rbx, %rbx	&#x2F;&#x2F; 推出循环的条件~</span><br><span class="line">        js      .L3</span><br><span class="line">        .loc 1 12 0 discriminator 2</span><br><span class="line">        movq    %r12, %rdi</span><br><span class="line">        call    _ZN1AC1Ev</span><br><span class="line">        addq    $8, %r12</span><br><span class="line">        subq    $1, %rbx</span><br><span class="line">        jmp     .L4	&#x2F;&#x2F; 循环~</span><br><span class="line">.L3:</span><br><span class="line">        .loc 1 12 0</span><br><span class="line">        movq    %r13, -40(%rbp)</span><br><span class="line">        .loc 1 13 0 is_stmt 1</span><br><span class="line">        movq    -40(%rbp), %rax</span><br><span class="line">        movl    $10, (%rax)</span><br><span class="line">        .loc 1 14 0</span><br><span class="line">        movq    -40(%rbp), %rax</span><br><span class="line">        addq    $8, %rax</span><br><span class="line">        movl    $20, (%rax)</span><br><span class="line">                .loc 1 15 0</span><br><span class="line">        movq    -40(%rbp), %rax</span><br><span class="line">        movl    (%rax), %eax</span><br><span class="line">        movl    %eax, %esi</span><br><span class="line">        leaq    .LC0(%rip), %rdi</span><br><span class="line">        movl    $0, %eax</span><br><span class="line">        call    printf@PLT</span><br><span class="line">        .loc 1 16 0</span><br><span class="line">        movq    -40(%rbp), %rax</span><br><span class="line">        addq    $8, %rax</span><br><span class="line">        movl    (%rax), %eax</span><br><span class="line">        movl    %eax, %esi</span><br><span class="line">        leaq    .LC0(%rip), %rdi</span><br><span class="line">        movl    $0, %eax</span><br><span class="line">        call    printf@PLT</span><br><span class="line">        .loc 1 17 0</span><br><span class="line">        cmpq    $0, -40(%rbp)</span><br><span class="line">        je      .L5</span><br><span class="line">        .loc 1 17 0 is_stmt 0 discriminator 1</span><br><span class="line">        movq    -40(%rbp), %rax</span><br><span class="line">        movq    %rax, %rdi</span><br><span class="line">        call    _ZdaPv@PLT	&#x2F;&#x2F; 删除数组只有 this?</span><br><span class="line">.L5:</span><br><span class="line">        .loc 1 18 0 is_stmt 1</span><br><span class="line">        movl    $0, %eax</span><br><span class="line">        addq    $24, %rsp</span><br><span class="line">        popq    %rbx</span><br><span class="line">        popq    %r12</span><br><span class="line">        popq    %r13</span><br><span class="line">        popq    %rbp</span><br><span class="line">        .cfi_def_cfa 7, 8</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>

<p>也没有什么特别惊艳的, 得看看 _ZdaPv</p>
<h2 id="ZdaPv"><a href="#ZdaPv" class="headerlink" title="_ZdaPv"></a>_ZdaPv</h2><p><img src="https://imgur.com/nZAfmgn.png" alt=""></p>
<p><img src="https://imgur.com/kom6PWG.png" alt=""></p>
<p>…</p>
<p>跟吐了… 🤮 </p>
<p>不知道有多少层 jnmp, 多少个循环… 或许不是现在🤣… </p>
<p>不过, 还好嘛… 至少知道了如何操作的… 虽然不知道细节.</p>
<p>不过根据推断, 分配的只有 16 字节, 那么意思是应该没有额外的空间用于保存数组大小(虽然有可能在函数内部, 但感觉可能性不大) </p>
<p>emm… 果然我还是不安分的人呢…  </p>
<p>我果然还是喜欢做这一类的事情.</p>
]]></content>
  </entry>
  <entry>
    <title>leetcode/SubarraySumEqualsk</title>
    <url>/2020/03/24/leetcode/SubarraySumEqualsk/</url>
    <content><![CDATA[<h1 id="Subarray-Sum-Equals-k"><a href="#Subarray-Sum-Equals-k" class="headerlink" title="Subarray Sum Equals k"></a>Subarray Sum Equals k</h1><p><img src="https://imgur.com/QchplcW.png" alt=""></p>
<p>连续和次数</p>
<a id="more"></a>



<h2 id="my-solution"><a href="#my-solution" class="headerlink" title="my solution"></a>my solution</h2><p>问题在于数字是有符号的. 那么如果用单纯的首位前进的方式的话, 就无法得知何时应该首前进, 而何时尾前进. </p>
<p>比如数字: [1, 2, -4], 求和 -1. 当你在 1 看到 2 时, 可能觉得之后的数字都是增加的 然后就不继续了. </p>
<p>(PS: 这里突然看到一个人生哲学, 你知道下一次是失败还是成功, 但是不知道这之后又是什么, 大多数都只看到直接的结果, 而很少看到结果之后的东西. 这是我没放弃这道题的原因 :), 本来没什么好的点子, 按照我的做法, 会留到以后做的, 或许解决近在咫尺了呢?)</p>
<p>所以采用了最简单的方法: </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">            nums[i] += nums[i - <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, sub = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; nums.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] - sub == k) </span><br><span class="line">                    ++ret;</span><br><span class="line">            &#125;</span><br><span class="line">            sub = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>肉眼可见的平方级/2. 虽然通过了, 但效率极低</p>
<h2 id="the-best-solution"><a href="#the-best-solution" class="headerlink" title="the best solution"></a>the best solution</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; h;</span><br><span class="line">        h[<span class="number">0</span>]++;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="keyword">if</span> ( h.count(sum - k) )</span><br><span class="line">                count += h[sum-k];</span><br><span class="line">            ++h[sum];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>所以说思路啊 = = … </p>
<p>很简单的, 核心是 sum - k, 其含义是符合的已走距离, 比如当前 sum 是 10, 而 k 为 2. 那么所有之前 sum 为 8 的点, , 其距离至当前点的和都可以满足条件. 这也是为什么 0 一开始初始化为 1 的原因. 因为那等同于起点.</p>
]]></content>
  </entry>
  <entry>
    <title>read/OptimizationAndIndexes</title>
    <url>/2020/03/23/read/OptimizationAndIndexes/</url>
    <content><![CDATA[<h1 id="Optimization-and-Indexes"><a href="#Optimization-and-Indexes" class="headerlink" title="Optimization and Indexes"></a>Optimization and Indexes</h1><p>Indexes are used to find rows with specific column values quickly. Without an index, MySQL must<br>begin with the first row and then read through the entire table to find the relevant rows. The larger the<br>table, the more this costs. If the table has an index for the columns in question, MySQL can quickly<br>determine the position to seek to in the middle of the data file without having to look at all the data. This<br>is much faster than reading every row sequentially.</p>
<p>index 用于加速查询. </p>
<p>(PS: 就最简单来说, 索引相当于一个人的特征. 查询数据时不一定需要完全匹配, 也不一定一开始就需要完全匹配搜索, 这时候使用索引就相当于找人时使用年龄, 性别等特征来寻找一样, 是一个很简单也很重要的概念. 如何寻找并规定 index 是极其重要的一环)</p>
<a id="more"></a>



<p>Most MySQL indexes (PRIMARY KEY, UNIQUE, INDEX, and FULLTEXT) are stored in B-trees.<br>Exceptions: Indexes on spatial data types use R-trees; MEMORY tables also support hash indexes;<br>InnoDB uses inverted lists for FULLTEXT indexes.</p>
<p>大多数 MySQL 索引类型为 B-trees. 除了某些特殊案例: 特殊数据类型使用 R-trees. 内存表支持 hash 索引. InnoDB 对全文索引使用倒排序表. </p>
<p>In general, indexes are used as described in the following discussion. Characteristics specific to hash<br>indexes (as used in MEMORY tables) are described in Section 8.3.9, “Comparison of B-Tree and Hash<br>Indexes”.<br>MySQL uses indexes for these operations:<br>• To find the rows matching a WHERE clause quickly.</p>
<ul>
<li>加速查询</li>
</ul>
<p>• To eliminate rows from consideration. If there is a choice between multiple indexes, MySQL normally<br>uses the index that finds the smallest number of rows (the most selective index).<br>• If the table has a multiple-column index, any leftmost prefix of the index can be used by the<br>optimizer to look up rows. For example, if you have a three-column index on (col1, col2,<br>col3), you have indexed search capabilities on (col1), (col1, col2), and (col1, col2,<br>col3).</p>
<p>• To retrieve rows from other tables when performing joins. MySQL can use indexes on columns<br>more efficiently if they are declared as the same type and size. In this context, VARCHAR and CHAR<br>are considered the same if they are declared as the same size. For example, VARCHAR(10) and<br>CHAR(10) are the same size, but VARCHAR(10) and CHAR(15) are not.<br>For comparisons between nonbinary string columns, both columns should use the same character<br>set. For example, comparing a utf8 column with a latin1 column precludes use of an index.<br>Comparison of dissimilar columns (comparing a string column to a temporal or numeric column, for<br>example) may prevent use of indexes if values cannot be compared directly without conversion. For<br>a given value such as 1 in the numeric column, it might compare equal to any number of values in<br>the string column such as ‘1’, ‘ 1’, ‘00001’, or ‘01.e1’. This rules out use of any indexes for<br>the string column.</p>
<p>同样长度和类型的索引在多表查询时可以提高效率. 类型不一致, 长度不一致, 字符集不一致 等都会造成无法使用索引的情况. </p>
<p>• To find the MIN() or MAX() value for a specific indexed column key_col. This is optimized by a<br>preprocessor that checks whether you are using WHERE key_part_N = constant on all key<br>parts that occur before key_col in the index. In this case, MySQL does a single key lookup for each<br>MIN() or MAX() expression and replaces it with a constant. If all expressions are replaced with<br>constants, the query returns at once. For example:<br>SELECT MIN(key_part2),MAX(key_part2)<br>FROM tbl_name WHERE key_part1=10;<br>• To sort or group a table if the sorting or grouping is done on a leftmost prefix of a usable index (for<br>example, ORDER BY key_part1, key_part2). If all key parts are followed by DESC, the key<br>is read in reverse order. (Or, if the index is a descending index, the key is read in forward order.)</p>
<ul>
<li>加速 ORDER BY</li>
</ul>
<p>• In some cases, a query can be optimized to retrieve values without consulting the data rows. (An<br>index that provides all the necessary results for a query is called a covering index.) If a query uses<br>from a table only columns that are included in some index, the selected values can be retrieved from<br>the index tree for greater speed:<br>SELECT key_part3 FROM tbl_name<br>WHERE key_part1=1<br>Indexes are less important for queries on small tables, or big tables where report queries process most<br>or all of the rows. When a query needs to access most of the rows, reading sequentially is faster than<br>working through an index. Sequential reads minimize disk seeks, even if not all the rows are needed for<br>the query. See Section 8.2.1.23, “Avoiding Full Table Scans” for details.</p>
<p>索引存在两种不适用的情况 : 一种是对于数据少的表查询. 另外一种是需要访问大部分表数据的查询, 这种情况下的顺序读取要比索引快, 即使大部分数据都不需要. </p>
<h3 id="Primary-Key-Optimization"><a href="#Primary-Key-Optimization" class="headerlink" title="Primary Key Optimization"></a>Primary Key Optimization</h3><p>The primary key for a table represents the column or set of columns that you use in your most vital<br>queries. It has an associated index, for fast query performance. Query performance benefits from<br>the NOT NULL optimization, because it cannot include any NULL values. With the InnoDB storage<br>engine, the table data is physically organized to do ultra-fast lookups and sorts based on the primary<br>key column or columns.</p>
<p>表的主键是查询中使用的列. 主键有相关的索引, 用于加速查询. </p>
<p>If your table is big and important, but does not have an obvious column or set of columns to use as a<br>primary key, you might create a separate column with auto-increment values to use as the primary key.<br>These unique IDs can serve as pointers to corresponding rows in other tables when you join tables<br>using foreign keys.</p>
<p>如果没有明显的列作为主键, 可以创建一个自增列作为主键. 唯一 ID 可作为外键.</p>
<h3 id="Multiple-Column-Indexes"><a href="#Multiple-Column-Indexes" class="headerlink" title="Multiple-Column Indexes"></a>Multiple-Column Indexes</h3><p>多列索引是由多个列组从的索引(= = 废话)… 其使用方式必须从左到右, 比如索引 (i1, i2, i3), 则使用 (i1), (i1, i2), (i1, i2, i3) 查询时可使用索引, 其余情况均不可使用索引 (与顺序无关, 与存在有关).</p>
<h3 id="Hash-Index-Characteristics"><a href="#Hash-Index-Characteristics" class="headerlink" title="Hash Index Characteristics"></a>Hash Index Characteristics</h3><p>Hash indexes have somewhat different characteristics from those just discussed:<br>• They are used only for equality comparisons that use the = or &lt;=&gt; operators (but are very fast). They<br>are not used for comparison operators such as &lt; that find a range of values. Systems that rely on<br>this type of single-value lookup are known as “key-value stores”; to use MySQL for such applications,<br>use hash indexes wherever possible.</p>
<p>只能用于等式/不等式. (PS: 意料之中, hash 并没有任何比较)</p>
<p>• The optimizer cannot use a hash index to speed up ORDER BY operations. (This type of index cannot<br>be used to search for the next entry in order.)</p>
<p>不能用于 ORDER BY 优化 (PS: 同理)</p>
<p>• MySQL cannot determine approximately how many rows there are between two values (this is used<br>by the range optimizer to decide which index to use). This may affect some queries if you change a<br>MyISAM or InnoDB table to a hash-indexed MEMORY table.</p>
<p>不能得知两值之间存在多少行/ </p>
<p>• Only whole keys can be used to search for a row. (With a B-tree index, any leftmost prefix of the key<br>can be used to find rows.)</p>
<p>只支持全值匹配. </p>
<p>(PS: 这些限制和特性的根源就是 hash 自身的特性)</p>
<h3 id="Use-of-Index-Extensions"><a href="#Use-of-Index-Extensions" class="headerlink" title="Use of Index Extensions"></a>Use of Index Extensions</h3><p>InnoDB automatically extends each secondary index by appending the primary key columns to it.</p>
<pre><code>Consider this table definition:
CREATE TABLE t1 (
i1 INT NOT NULL DEFAULT 0,
i2 INT NOT NULL DEFAULT 0,
d DATE DEFAULT NULL,
PRIMARY KEY (i1, i2),
INDEX k_d (d)
) ENGINE = InnoDB;</code></pre><p>This table defines the primary key on columns (i1, i2). It also defines a secondary index k_d on<br>column (d), but internally InnoDB extends this index and treats it as columns (d, i1, i2).<br>The optimizer takes into account the primary key columns of the extended secondary index when<br>determining how and whether to use that index. This can result in more efficient query execution plans<br>and better performance.<br>The optimizer can use extended secondary indexes for ref, range, and index_merge index access,<br>for Loose Index Scan access, for join and sorting optimization, and for MIN()/MAX() optimization.<br>The following example shows how execution plans are affected by whether the optimizer uses<br>extended secondary indexes. Suppose that t1 is populated with these rows:</p>
<p>MySQL 自动扩展次级索引. </p>
<h3 id="Optimizer-Use-of-Generated-Column-Indexes"><a href="#Optimizer-Use-of-Generated-Column-Indexes" class="headerlink" title="Optimizer Use of Generated Column Indexes"></a>Optimizer Use of Generated Column Indexes</h3><p>MySQL supports indexes on generated columns. For example:</p>
<pre><code>CREATE TABLE t1 (f1 INT, gc INT AS (f1 + 1) STORED, INDEX (gc));</code></pre><p>The generated column, gc, is defined as the expression f1 + 1. The column is also indexed and the<br>optimizer can take that index into account during execution plan construction. In the following query,<br>the WHERE clause refers to gc and the optimizer considers whether the index on that column yields a<br>more efficient plan:</p>
<pre><code>SELECT * FROM t1 WHERE gc &gt; 9;</code></pre><p>The optimizer can use indexes on generated columns to generate execution plans, even in the<br>absence of direct references in queries to those columns by name. This occurs if the WHERE, ORDER<br>BY, or GROUP BY clause refers to an expression that matches the definition of some indexed generated<br>column. The following query does not refer directly to gc but does use an expression that matches the<br>definition of gc:</p>
<pre><code>SELECT * FROM t1 WHERE f1 + 1 &gt; 9;</code></pre><p>The optimizer recognizes that the expression f1 + 1 matches the definition of gc and that gc<br>is indexed, so it considers that index during execution plan construction. You can see this using<br>EXPLAIN:</p>
<pre><code>mysql&gt; EXPLAIN SELECT * FROM t1 WHERE f1 + 1 &gt; 9\G
*************************** 1. row ***************************
id: 1
select_type: SIMPLE
table: t1
partitions: NULL
type: range
possible_keys: gc
key: gc
key_len: 5
ref: NULL
rows: 1
filtered: 100.00
Extra: Using index condition</code></pre><p>generated column 指的是一个包含其他字段的表达式. </p>
<h3 id="Descending-Indexes"><a href="#Descending-Indexes" class="headerlink" title="Descending Indexes"></a>Descending Indexes</h3><p>MySQL supports descending indexes: DESC in an index definition is no longer ignored but causes<br>storage of key values in descending order. Previously, indexes could be scanned in reverse order but<br>at a performance penalty. A descending index can be scanned in forward order, which is more efficient.<br>Descending indexes also make it possible for the optimizer to use multiple-column indexes when the<br>most efficient scan order mixes ascending order for some columns and descending order for others.<br>Consider the following table definition, which contains two columns and four two-column index<br>definitions for the various combinations of ascending and descending indexes on the columns:</p>
<pre><code>CREATE TABLE t (
c1 INT, c2 INT,
INDEX idx1 (c1 ASC, c2 ASC),
INDEX idx2 (c1 ASC, c2 DESC),
INDEX idx3 (c1 DESC, c2 ASC),
INDEX idx4 (c1 DESC, c2 DESC)
);</code></pre><p>The table definition results in four distinct indexes. The optimizer can perform a forward index scan for<br>each of the ORDER BY clauses and need not use a filesort operation:</p>
<pre><code>ORDER BY c1 ASC, c2 ASC -- optimizer can use idx1
ORDER BY c1 DESC, c2 DESC -- optimizer can use idx4
ORDER BY c1 ASC, c2 DESC -- optimizer can use idx2
ORDER BY c1 DESC, c2 ASC -- optimizer can use idx3</code></pre><p>可以指定索引列的顺序, 以用于 ORDER BY 优化.</p>
<h3 id="Indexed-Lookups-from-TIMESTAMP-Columns"><a href="#Indexed-Lookups-from-TIMESTAMP-Columns" class="headerlink" title="Indexed Lookups from TIMESTAMP Columns"></a>Indexed Lookups from TIMESTAMP Columns</h3><p>Temporal values are stored in TIMESTAMP columns as UTC values, and values inserted into and<br>retrieved from TIMESTAMP columns are converted between the session time zone and UTC. (This is<br>the same type of conversion performed by the CONVERT_TZ() function. If the session time zone is<br>UTC, there is effectively no time zone conversion.)</p>
<p>在 TIMESTAMP 中的值以 UTC 规范存储. 读取和写入在会话时区和 UTC 之间转换. (效果和使用 CONVERT_TZ 函数一样. 如果时区已经是 UTC 了, 那么不需要转换)</p>
<p>Due to conventions for local time zone changes such as Daylight Saving Time (DST), conversions<br>between UTC and non-UTC time zones are not one-to-one in both directions. UTC values that are<br>distinct may not be distinct in another time zone. The following example shows distinct UTC values that<br>become identical in a non-UTC time zone:</p>
<pre><code>mysql&gt; CREATE TABLE tstable (ts TIMESTAMP);
mysql&gt; SET time_zone = &apos;UTC&apos;; -- insert UTC values
mysql&gt; INSERT INTO tstable VALUES
(&apos;2018-10-28 00:30:00&apos;),
(&apos;2018-10-28 01:30:00&apos;);
mysql&gt; SELECT ts FROM tstable;
+---------------------+
| ts |
+---------------------+
| 2018-10-28 00:30:00 |
| 2018-10-28 01:30:00 |
+---------------------+
mysql&gt; SET time_zone = &apos;MET&apos;; -- retrieve non-UTC values
mysql&gt; SELECT ts FROM tstable;
+---------------------+
| ts |
+---------------------+
| 2018-10-28 02:30:00 |
| 2018-10-28 02:30:00 |
+---------------------+</code></pre><h1 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h1><h2 id="why-b-trees"><a href="#why-b-trees" class="headerlink" title="why b-trees ?"></a>why b-trees ?</h2><p>很好奇为什么是 b 树, 到底优势在哪里? <a href="https://stackoverflow.com/questions/6211118/b-trees-vs-binary-trees" target="_blank" rel="noopener">answer</a></p>
<p>Algorithmic complexity is the same, since O(logb n) = O(c log n) = O(log n) but the constant factors, which are hidden in big-O notation, could vary noticeably, depending on implementation and hardware.</p>
<p>算法的复杂度是一样的.</p>
<p>B-trees were designed for platter hard disks, which have a large access time (moving the head into position) after which an entire physical sector is read. Making the B-tree nodes as large as the sector minimizes the number of access times and maximizes the useful data out of each read operation.</p>
<p>B-trees 为硬盘而设计, 将其节点设置为最小扇区大小可以减少访问时间, 最大化利用每个读取出的数据.</p>
<p>But if you are working out of memory you have a negligible access time, therefore a better comparison is to count the number of single words accessed by your algorithm.</p>
<p>如果用完了内存, 将会有轻微的消耗. 一个对比点是计算算法访问的单个字符数.</p>
<p>For example, let’s plan a data structure to store 220 keys of 1 word each, for a total of 4MiB of raw data on a 32bit machine.</p>
<p>A binary search tree will have 220 nodes, each holding one key and two pointers (3 words). Depth will be log2(220) = 20. The average search will have to read the key and one of the pointers from each node in its path, from the root all the way down = <strong>40 words</strong>.</p>
<p>A B-tree made for hard disks will have 4kB nodes. Each node could be stored internally as a sorted array of key and pointer couples, between 256 and 512 of them. What is the average search going to look like? Considering an average 3/4 fill, each node will contain 384 entries, and its internal binary search will have to visit on average log2(384) = 5.95 keys. The average depth will be log384(220) = 2.33, so our search will have to read on average 2.33 times 5.95 keys, or about <strong>14 words</strong>.</p>
<p>(PS: 这里因为格式的问题, 220 的含义是 2的 20次方. 这里想表达的是: 如果是 bst 存储, 每个节点可能分布在不同的扇区上, 一次磁盘访问得到的有用信息最坏的情况是只能使用一次, 而 B-trees 将其尽可能最大化, 为 s(扇区大小) / n(单个节点大小) 次, 所以虽然搜索的效率是基本一致的, 但是其每次 I/O 所得的有效率是完全不同的. 这是 B-trees 广泛应用于数据库的根源所在.)</p>
<p>In the case of a low-fanout (branching factor) B-tree, with each node holding between 16 and 32 keys, the average fill will be 24 keys, the average depth log24(220) = 4.36, the binary search in each node will make log2(24) = 4.58 comparisons, and the overall average search will have to read about <strong>20 words</strong>.</p>
<p>Keep in mind that the last two data structures achieve a better result than binary trees because they <strong>optimize read operations</strong> over modifications. To insert a key into one of these B-trees you would have to rewrite on average an entire 384-word or 24-word node, if not more than one, while in the binary-tree case a write operation would still only need to touch up to 40 words.</p>
<p>(PS: 这里说的是关于数据插入, B-trees 可能存在最坏情况, 虽然存在的最好情况优于 bst)</p>
<h2 id="R-trees"><a href="#R-trees" class="headerlink" title="R-trees"></a><a href="https://en.wikipedia.org/wiki/R-tree" target="_blank" rel="noopener">R-trees</a></h2><p>R-trees 是专用于空间存储的数据结构. 其结构和 B-trees 类似, 专用于存储空间信息, 子节点和父节点的关系为相交. 父节点包含子节点(但不一定完全)</p>
<p><strong>R-trees</strong> are tree data structures used for spatial access methods, i.e., for indexing multi-dimensional information such as geographical coordinates, rectangles or polygons.</p>
<p>R-trees 是用于索引多维信息, 如地理坐标, 矩阵, 或多边形的数据结构.</p>
<p>(PS: 我这里再次深思, 什么是数据结构? 数据的组织方式. 数据的组织方式由其访问方式及存储方式决定. 不同的数据结构就是为了不同的目的而生的. 例如 B-trees 它针对访问做了优化. 尽可能减少其 I/O, 以提高效率. 变量的前后, 热点. 都是很重要的点. 再考虑一下 B+tree, 他的优点是叶子节点包含所有数据, 当进行全表访问时, 就是一个线性的时间, 同时, 可以使用二分. 可能是处于这样的目的, 才有了优化版本的 B+trees. 而 R-trees , 用于多维信息. 其父子节点的关系变成了类似包含/被包含的关系. 可以处理一些例如 xx 离 xx 多远. xx 附近有哪些建筑… 广泛来说, 是 “组织”. 身边的事物都有组织, 公司的管理级. 省市区的划分. 电脑的构成… )</p>
]]></content>
  </entry>
  <entry>
    <title>other/aboutUseServiceToControlMysqld</title>
    <url>/2020/03/12/other/aboutUseServiceToControlMysqld/</url>
    <content><![CDATA[<h1 id="aboutUseServiceToControlMysqld"><a href="#aboutUseServiceToControlMysqld" class="headerlink" title="aboutUseServiceToControlMysqld"></a>aboutUseServiceToControlMysqld</h1><p>通常是通过 service 这个指令来控制 mysql 的. 作为一条有梦想的咸鱼. 只使用 service 而不用 mysql 原始指令, 这怎么能行<del>(￣▽￣)</del>*. 所以就试了试 (作死) 使用 mysql 原生的指令来控制. 试了试发现, 其实还是有一些坑的.</p>
<p>No zuo no die.</p>
<a id="more"></a>



<h2 id="mysqld"><a href="#mysqld" class="headerlink" title="mysqld"></a>mysqld</h2><p>根据 mysql 官方文档 4-3 节开头的: </p>
<pre><code>This section describes mysqld, the MySQL server, and several programs that are used to start the server.</code></pre><p>可知 mysqld 就是 mysql 的服务端. </p>
<h3 id="mysqld-safe"><a href="#mysqld-safe" class="headerlink" title="mysqld_safe"></a>mysqld_safe</h3><p>mysqld_safe is the recommended way to start a mysqld server on Unix. mysqld_safe adds some<br>safety features such as restarting the server when an error occurs and logging runtime information to<br>an error log</p>
<p>一中附带一些功能的 mysqld</p>
<h3 id="mysql-server"><a href="#mysql-server" class="headerlink" title="mysql.server"></a>mysql.server</h3><p>MySQL distributions on Unix and Unix-like system include a script named mysql.server, which starts<br>the MySQL server using mysqld_safe. It can be used on systems such as Linux and Solaris that use<br>System V-style run directories to start and stop system services. It is also used by the macOS Startup<br>Item for MySQL.</p>
<p>一个使用 mysqld 的脚本.</p>
<h2 id="Zuo"><a href="#Zuo" class="headerlink" title="Zuo"></a>Zuo</h2><p>一开始我是想 service 关闭之后直接 mysqld 的, 结果 mysqld 并不建议使用 root 启动:</p>
<pre><code>2020-03-11T09:19:32.477114Z 0 [ERROR] [MY-010123] [Server] Fatal error: Please read &quot;Security&quot; section of the manual to find out how to run mysqld as root!
2020-03-11T09:19:32.477401Z 0 [ERROR] [MY-010119] [Server] Aborting</code></pre><p>google 了一下, 需要指定<code>--user=root</code>, 但是不能正常运行, 为什么呢? 查了一下 log </p>
<pre><code>Could not create unix socket lock file /var/run/mysqld/mysqld.sock.lock.</code></pre><p>于是又 google 了一下, 简单的方案是创建 /var/run/mysqld/ 这个文件夹. 这个文件夹的用处是:</p>
<pre><code>This directory was once intended for system information data describing the system since it was booted. These functions have been moved to /run; this directory exists to ensure compatibility with systems and software using an older version of this specification.</code></pre><p>好像有点不妙… 为什么需要我来创建? 这时候我有点明白为什么答案大多都是使用 service 启动了.</p>
<p>结果是正常运行了. 但是表现很奇怪, 首先是进程无反应. 好像一直在等待输入. 但是用其他的 ssh 上去试 mysql 的功能是正常的. 并且把当前 ssh 关了也是正常的.</p>
<p>这时候我准备试试关闭了, 查了一下, 比较推荐的方案是 <code>mysqladmin -u root -p shutdown</code> , 使用了之后输入 mysql root 密码就好了. 关闭也比较正常. 但是当我再使用 service 启动时候, 问题出现了.</p>
<pre><code>● mysql.service - MySQL Community Server
   Loaded: loaded (/lib/systemd/system/mysql.service; enabled; vendor preset: enabled)
   Active: failed (Result: exit-code) since Wed 2020-03-11 16:42:24 CST; 17min ago
     Docs: man:mysqld(8)
           http://dev.mysql.com/doc/refman/en/using-systemd.html
  Process: 8961 ExecStart=/usr/sbin/mysqld (code=exited, status=1/FAILURE)
  Process: 8926 ExecStartPre=/usr/share/mysql-8.0/mysql-systemd-start pre (code=exited, status=0/SUCCESS)
 Main PID: 8961 (code=exited, status=1/FAILURE)
   Status: &quot;Server startup in progress&quot;
    Error: 13 (Permission denied)
      CPU: 343ms

Mar 11 16:42:24 VM-0-13-debian systemd[1]: Starting MySQL Community Server...
Mar 11 16:42:24 VM-0-13-debian systemd[1]: mysql.service: Main process exited, code=exited, status=1/FAILURE
Mar 11 16:42:24 VM-0-13-debian systemd[1]: Failed to start MySQL Community Server.
Mar 11 16:42:24 VM-0-13-debian systemd[1]: mysql.service: Unit entered failed state.
Mar 11 16:42:24 VM-0-13-debian systemd[1]: mysql.service: Failed with result &apos;exit-code&apos;.</code></pre><p>看了看 log 文件, 没什么头绪, google 了一下没有任何成果</p>
<pre><code>mysqld: File &apos;./binlog.index&apos; not found (OS errno 13 - Permission denied)</code></pre><p>看到 permission denied 的时候, 突然想了想, 去 /var/lib/mysql 下去看看, 原来经过之前的 root 登录. 其中一些文件所有者已经被改成 root 了 (我不完全确定是这个原因, 但是好像只有这个原因了) 后 chown 更改所有者后变正常了.</p>
<p>这时候我又想了想. service 是如何启动的呢? 它是用 mysql 这个用户启动的么? 我想尝试切换程 mysql 来试试, 但是 su 后无改变, whoami 依旧是 root , 我还以为长久不切其他用户, 用错了指令, 但是好像并不是这样. 我想了想. 去看看 /etc/password, 然后发现了这一行</p>
<pre><code>mysql:x:107:112:MySQL Server,,,:/var/lib/mysql:/bin/false</code></pre><p>哦. 怪不得, mysql 用户好像被做了限制, 所以我改成 /bin/bash 之后达到了预期的效果. </p>
<p>但是 mysqld 的执行并不如人意.</p>
<pre><code>13 2020-03-11T09:22:14.311301Z 0 [ERROR] [MY-010273] [Server] Could not create unix socket lock file /var/run/mysqld/mysqld.sock.lock.  12 2020-03-11T09:22:14.311311Z 0 [ERROR] [MY-010268] [Server] Unable to setup unix socket lock file.</code></pre><p>:( 它又要我创建文件. 那算了吧. 如果每启动次我都需要创建一次的话, 那未免也太低效了…</p>
<p>(PS: 其实中途的时候我没注意我登录的用户, 因为是多窗口, 我不小心把内网的主机的 mysql 给关了! （；´д｀）ゞ谢天谢地, 还好是内网. 我关闭的时候是直接查进程 kill 的, 导致 mysql.sock 文件依旧在, 还出了点小问题. 但是问题又来了! 我用 mysql 居然能登录, 还能正常 SQL !!! w(ﾟДﾟ)w.什么鬼… 这或许和之前 mysqld 的行为有关系)</p>
]]></content>
  </entry>
  <entry>
    <title>other/aboutProcess</title>
    <url>/2020/03/11/other/aboutProcess/</url>
    <content><![CDATA[<h1 id="aboutProcess"><a href="#aboutProcess" class="headerlink" title="aboutProcess"></a>aboutProcess</h1><p>记录一下关于进程的一些信息</p>
<p>take note something about process</p>
<a id="more"></a>



<h2 id="definition"><a href="#definition" class="headerlink" title="definition"></a>definition</h2><p>进程是运行中的程序, 一个可执行程序可以简单看作一个结构体, 其包含运行程序所需的几个段. 以及一些可选的 dbeug 信息, 和其他如链接信息 …</p>
<h2 id="structure-wiki"><a href="#structure-wiki" class="headerlink" title="structure wiki"></a>structure <a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format" target="_blank" rel="noopener">wiki</a></h2><h3 id="File-layout"><a href="#File-layout" class="headerlink" title="File layout"></a>File layout</h3><p><a href="https://upload.wikimedia.org/wikipedia/commons/e/e4/ELF_Executable_and_Linkable_Format_diagram_by_Ange_Albertini.png" target="_blank" rel="noopener">picture</a></p>
<p>Each ELF file is made up of one ELF header, followed by file data. The data can include:</p>
<ul>
<li><p>Program header table, describing zero or more <a href="https://en.wikipedia.org/wiki/Memory_segmentation" target="_blank" rel="noopener">memory segments</a> </p>
<p>程序头表, 零或多个内存段</p>
</li>
<li><p>Section header table, describing zero or more sections</p>
<p>段头表, 零个或多个段</p>
</li>
<li><p>Data referred to by entries in the program header table or section header table</p>
<p>通过在程序头表和段头表的入口引用的数据</p>
</li>
</ul>
<h3 id="File-header"><a href="#File-header" class="headerlink" title="File header"></a>File header</h3><p>The ELF header defines whether to use <a href="https://en.wikipedia.org/wiki/32-bit" target="_blank" rel="noopener">32-</a> or <a href="https://en.wikipedia.org/wiki/64-bit_computing" target="_blank" rel="noopener">64-bit</a> addresses. The header contains three fields that are affected by this setting and offset other fields that follow them. The ELF header is 52 or 64 bytes long for 32-bit and 64-bit binaries respectively.</p>
<p>ELF ( excutable linkable format ) 头定义了是 32 位还是 64 位寻址. 分别位 52 字节 和 64 字节大小.</p>
<p>(数据结构表实在是太大了😨, 这里不方便展示, 有需要请去 wiki. )</p>
<pre><code>Section Headers:
[Nr] Name              Type             Address           Offset
       Size              EntSize          Flags  Link  Info  Align
[ 0]                   NULL             0000000000000000  00000000
   0000000000000000  0000000000000000           0     0     0</code></pre><p>其中我还发现了 align, 其数值 1, 4, 8, 16 不等, 我这是 64 位的执行程序. 数据段是 8, 代码段为 16.</p>
<p>(PS: 关于其数据结构, 可以通过 readelf 这个指令来查看, 我还是太小看段的数量了, 有 35 个, 其中包含重要的 .text .rodata .data .bss .debug_info .debug_info. 其中我尝试使用 obkcopy 删除 debug 信息, 发现原先的段数量变少了, 35 -&gt; 30. 也就是数, 如果由需要的话, 可以继续增加段的数量, 这可能由一个类似 TCP/IP header lenth 的东西来指定.</p>
<h3 id="Program-header"><a href="#Program-header" class="headerlink" title="Program header"></a>Program header</h3><p>The program header table tells the system how to create a process image. It is found at file offset <code>e_phoff</code>, and consists of <code>e_phnum</code> entries, each with size <code>e_phentsize</code>. The layout is slightly different in <a href="https://en.wikipedia.org/wiki/32-bit" target="_blank" rel="noopener">32-bit</a> ELF vs <a href="https://en.wikipedia.org/wiki/64-bit" target="_blank" rel="noopener">64-bit</a> ELF, because the <code>p_flags</code> are in a different structure location for alignment reasons. Each entry is structured as:</p>
<p>程序头表告诉系统如何创建程序映像.</p>
<p>(数据结构表实在是太大了😨, 这里不方便展示, 有需要请去 wiki. )</p>
<pre><code>Program Headers:
Type           Offset             VirtAddr           PhysAddr
               FileSiz            MemSiz              Flags  Align</code></pre><p>其中的 flags 字段和文件一样也是有三个: RWX, 我突然有了大胆的想法😎.</p>
<p>这里也有 align 字段, 一些字段都和我之前学过的东西有挂钩, 比如 虚拟地址内存大小(我很好奇为什么 Size 没写全)</p>
<p>还有一些关于动态链接, 映射 和一些我也不知道的信息. readelf 及 elf 结构是值得学习的知识.</p>
<h2 id="command"><a href="#command" class="headerlink" title="command"></a>command</h2><h3 id="get-stat"><a href="#get-stat" class="headerlink" title="get stat"></a>get stat</h3><p>the pimary command in linux to get process status is ‘ps’.  </p>
<p>ps 有两种格式, 一种是标准的, 使用的指令都需要带 dash. 一种是 BSD 语法. 不带 dash. 但是兼容. 所以你带 dash 也不会出错, 不过会给你个警告.</p>
<p>(PS: 个人比较推荐的指令是 ps -elyjf, 其中 e 意为所有进程, ly 经常联用可以看到更多的信息, 比如 RSS PRI. j 意为 jobs, 可以看到组 ID 和 session ID 方便 kill. f 好像可以显示更多的东西, 文档的解释是 Do full-format, 表现上最重要的是会将命令行完全展开.)</p>
<pre><code>This version of ps accepts several kinds of options:
1   UNIX options, which may be grouped and must be preceded by a dash.
2   BSD options, which may be grouped and must not be used with a dash.
3   GNU long options, which are preceded by two dashes.</code></pre><h4 id="fileds"><a href="#fileds" class="headerlink" title="fileds"></a>fileds</h4><p>其中我经常看到以下字段:</p>
<ul>
<li><p>S </p>
<p>status, 状态, 通常为 R(running or runable) 和 S(interruptible sleep). 在这方面标准不如 BSD 好, BSD 还会显示其他的状态.</p>
</li>
<li><p>UID        </p>
<p>用户 ID. 通常是字符串, 如 root</p>
</li>
<li><p>PID  </p>
<p>process ID. 很常用的用于辨别进程的 ID</p>
</li>
<li><p>PPID  </p>
<p>parent process ID. 父进程进程 ID.</p>
</li>
<li><p>PGID   </p>
<p>process group ID. 用户组 ID.</p>
</li>
<li><p>SID  </p>
<p>session ID, 会话 ID.</p>
</li>
<li><p>C </p>
<p>CPU 利用率, 很多都是 0. 文档中的描述是: cpu utilization of the process in “##.#” format.  Currently, it is the CPU time used divided by the time the process has been running  (cputime/realtime ratio), expressed as a percentage.  It will not add up to 100% unless you are lucky.  (alias pcpu). (哈哈, 意思是 CPU 超过 100% 效率就很值么? 我观察这个值都非常低, 但是内存使用率居高不下, 果然 I/O 才是服务器的瓶颈所在)</p>
</li>
<li><p>PRI  </p>
<p>priority 优先级, 这个值应该是越小越好, 通常的进程都是 80. renice 可以赋予新的 nice 调整, 可调整范围是 19 ~ -20. </p>
</li>
<li><p>NI   </p>
<p>这个 和 PRI 对应. 是调整的优先级, 比如 PRI 为 60, NI 为 -20. 意味原始进程 PRI 为 80, 经调整 -20 = 60.</p>
</li>
<li><p>RSS    </p>
<p>resident set size. 意味有多少内存被分配给了这个进程. (很重要的指令)</p>
</li>
<li><p>SZ </p>
<p>进程核心映像大小. size in physical pages of the core image of the process.  This includes text, data, and stack space.  Device mappings are currently excluded; this is subject to change.  See vsz and rss.</p>
</li>
<li><p>WCHAN  </p>
<p>address of the kernel function where the process is sleeping (use wchan if you want the kernel function name).  Running tasks will display a dash (‘-‘) in this column.</p>
<p>正在等待的内核事件, 可以查看 /boot/System.map (有7w多个…)</p>
</li>
<li><p>STIME </p>
<p>start time, 进程开始事件</p>
</li>
<li><p>TTY          </p>
<p>伪 tty 设备文件</p>
</li>
<li><p>TIME </p>
<p>累计 CPU 时间.</p>
</li>
<li><p>CMD</p>
<p>执行程序时所用的指令. 通过 -f 选项可以查看完整的.</p>
</li>
</ul>
<p>还有其他的 ps 指令, 例如 pgrep.</p>
<h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h3><p>kill 用来给进程发送信号, 其默认行为为 SIG_TERM. 终止进程, 我觉得这可能就是为什么叫 kill 的原因.</p>
<p>其指令本身没有什么特别的, 关键是指令的种类:</p>
<pre><code> 1) SIGHUP         2) SIGINT         3) SIGQUIT         4) SIGILL         5) SIGTRAP
 6) SIGABRT         7) SIGBUS         8) SIGFPE         9) SIGKILL        10) SIGUSR1
11) SIGSEGV        12) SIGUSR2        13) SIGPIPE        14) SIGALRM        15) SIGTERM
16) SIGSTKFLT    17) SIGCHLD        18) SIGCONT        19) SIGSTOP        20) SIGTSTP
21) SIGTTIN        22) SIGTTOU        23) SIGURG        24) SIGXCPU        25) SIGXFSZ
26) SIGVTALRM    27) SIGPROF        28) SIGWINCH    29) SIGIO        30) SIGPWR
31) SIGSYS        34) SIGRTMIN    35) SIGRTMIN+1    36) SIGRTMIN+2    37) SIGRTMIN+3
38) SIGRTMIN+4    39) SIGRTMIN+5    40) SIGRTMIN+6    41) SIGRTMIN+7    42) SIGRTMIN+8
43) SIGRTMIN+9    44) SIGRTMIN+10    45) SIGRTMIN+11    46) SIGRTMIN+12    47) SIGRTMIN+13
48) SIGRTMIN+14    49) SIGRTMIN+15    50) SIGRTMAX-14    51) SIGRTMAX-13    52) SIGRTMAX-12
53) SIGRTMAX-11    54) SIGRTMAX-10    55) SIGRTMAX-9    56) SIGRTMAX-8    57) SIGRTMAX-7
58) SIGRTMAX-6    59) SIGRTMAX-5    60) SIGRTMAX-4    61) SIGRTMAX-3    62) SIGRTMAX-2
63) SIGRTMAX-1    64) SIGRTMAX</code></pre><p>关于其描述, 可以 <a href="https://www.bogotobogo.com/Linux/linux_process_and_signals.php#signals" target="_blank" rel="noopener">参考</a> .</p>
<h2 id="about-proc"><a href="#about-proc" class="headerlink" title="about /proc"></a>about /proc</h2><p>/proc 是一个虚拟挂载目录, 里面包括了一些系统信息, 以及以 PID 为名的进程信息. </p>
<p>我记得我之前看过, 这里就不做笔记了, 详细 <a href="https://www.tecmint.com/exploring-proc-file-system-in-linux/" target="_blank" rel="noopener">参考</a></p>
]]></content>
  </entry>
  <entry>
    <title>other/somethingAboutBackspace</title>
    <url>/2020/03/10/other/somethingAboutBackspace/</url>
    <content><![CDATA[<h1 id="关于-backspace-是密码的一部分"><a href="#关于-backspace-是密码的一部分" class="headerlink" title="关于 backspace 是密码的一部分"></a>关于 backspace 是密码的一部分</h1><p>在使用 hexo deploy 输入用户名/密码, 或其他特殊需要输入密码的场合, backspace 总是被当作密码的一部分.</p>
<p>这可以理解, 因为这个本身就是一种按键, 只不过大多数时候被赋予了删除字符的功能.</p>
<p>处于好奇, 搜索了一下相关资料</p>
<p>Backspace is traded as part of password when I use ‘hexo’ and other spacial situation that I need to enter password.</p>
<p>I can understand this because ‘backspace’ is also a normal key that traded as a function in some special situation .</p>
<a id="more"></a>



<h2 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h2><p>from <a href="https://unix.stackexchange.com/questions/50493/clear-erase-a-mistyped-invisible-password-on-a-shell-terminal-in-linux" target="_blank" rel="noopener">stackExchange</a></p>
<p>Characters like Ctrl+L are handled by the <strong>application</strong>. In the case of entering input into the shell, like <code>bash</code>, it clears the screen. Some applications, like <code>emacs</code>, use it to redraw the screen and/or recenter the cursor.</p>
<p>C+L 都被应用所管理. 在输入时, 比如 bash. 将会清屏. </p>
<p>Characters like Ctrl+U at a password prompt are handled by the <a href="http://en.wikipedia.org/wiki/Line_discipline" target="_blank" rel="noopener"><strong>TTY line discipline</strong></a>. They’ll work any time the input terminal is in the “canonical” line-editing mode, which is what mode your programs are in while you’re entering a password. In this mode, it’s the Linux kernel itself that is interpreting these characters. You can see what functions are assigned to which keys in the output of <code>stty -a</code>:</p>
<p>C+U被当作密码提示, 由 TTY line discipline 管理. 当输入密码, 进入行编辑模式时, 就会被其管理. linux 内核解释这些字符, 可以通过 <code>stty -a</code> 指令查看一些特殊的键被赋予的功能.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">speed 38400 baud; rows 45; columns 128; line &#x3D; 0;</span><br><span class="line">intr &#x3D; ^C; quit &#x3D; ^\; erase &#x3D; ^?; kill &#x3D; ^U; eof &#x3D; ^D; eol &#x3D; &lt;undef&gt;; eol2 &#x3D; &lt;undef&gt;; swtch &#x3D; &lt;undef&gt;; start &#x3D; ^Q; stop &#x3D; ^S;</span><br><span class="line">susp &#x3D; ^Z; rprnt &#x3D; ^R; werase &#x3D; ^W; lnext &#x3D; ^V; flush &#x3D; ^O; min &#x3D; 1; time &#x3D; 0;</span><br><span class="line">-parenb -parodd cs8 -hupcl -cstopb cread -clocal -crtscts</span><br><span class="line">-ignbrk -brkint -ignpar -parmrk -inpck -istrip -inlcr -igncr icrnl ixon -ixoff -iuclc -ixany -imaxbel iutf8</span><br><span class="line">opost -olcuc -ocrnl onlcr -onocr -onlret -ofill -ofdel nl0 cr0 tab0 bs0 vt0 ff0</span><br><span class="line">isig icanon iexten echo echoe echok -echonl -noflsh -xcase -tostop -echoprt echoctl echoke</span><br></pre></td></tr></table></figure>

<p>Here, you can see that Ctrl+U is tied to <code>kill</code>, which (according to the <a href="http://linux.die.net/man/1/stty" target="_blank" rel="noopener">stty man page</a>) will “erase the current line”. You could also use <code>stty</code> to change this mapping:</p>
<p>通过 stty 的 man 手册可以查看这些指令的意义(看到里面的C+S了吧, 有时候 windows 习惯性保存带到 linux 的下场就是 ‘死机’ 📴)  (我理解 stty 中的 s 可能是 soft 的意思)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stty kill ^E   # make ctrl-e erase the line</span><br></pre></td></tr></table></figure>

<p><a href="http://www.linusakesson.net/programming/tty/index.php" target="_blank" rel="noopener">This page</a> has a lot of great information about the TTY layer if you’re interested.</p>
<h2 id="other"><a href="#other" class="headerlink" title="other"></a>other</h2><h3 id="关于-line-discipline"><a href="#关于-line-discipline" class="headerlink" title="关于 line discipline"></a>关于 line discipline</h3><p>from <a href="">wiki</a></p>
<p>A <strong>line discipline</strong> (<strong>LDISC</strong>) is a layer in the <a href="https://en.wikipedia.org/wiki/Computer_terminal" target="_blank" rel="noopener">terminal</a> subsystem in some <a href="https://en.wikipedia.org/wiki/Unix-like" target="_blank" rel="noopener">Unix-like</a> systems.<a href="https://en.wikipedia.org/wiki/Line_discipline#cite_note-1" target="_blank" rel="noopener">[1]</a> The terminal subsystem consists of three layers: the upper layer to provide the <a href="https://en.wikipedia.org/wiki/Device_node#Character_devices" target="_blank" rel="noopener">character device</a> interface, the lower hardware driver to communicate with the hardware or <a href="https://en.wikipedia.org/wiki/Pseudo_terminal" target="_blank" rel="noopener">pseudo terminal</a>, and the middle line discipline to implement behavior common to terminal devices.</p>
<p>LDISC 时一个类 UNIX 系统终端的子系统中的一层. 其完整为三层, 顶层提供一个字符设备界面. 下层硬件驱动与硬件/伪终端交互. 中层 ‘line discipline’ 实现常见的行为给终端设备(我理解这个行为可能是普通字符的回显以及特殊字符的解释)</p>
<p>The line discipline glues the low level device driver code with the high level generic interface routines (such as read(2), write(2) and <a href="https://en.wikipedia.org/wiki/Ioctl" target="_blank" rel="noopener">ioctl</a>(2)), and is responsible for implementing the semantics associated with the device.<a href="https://en.wikipedia.org/wiki/Line_discipline#cite_note-2" target="_blank" rel="noopener">[2]</a> The policy is separated from the device driver so that the same serial hardware driver can be used by devices that require different data handling.</p>
<p>‘line discipline’ 将底层驱动设备代码和高层泛型界面理解粘合在一起. 其实现了与设备相关的语义. 不同的设备驱动有不同的策略. 以用于同样的硬件驱动能被需要不同数据管理的设备所使用.</p>
<p>For example, the standard line discipline processes the data it receives from the hardware driver and from applications writing to the device according to the requirements of a terminal on a <a href="https://en.wikipedia.org/wiki/Unix-like" target="_blank" rel="noopener">Unix-like</a> system. On input, it handles special characters such as the interrupt character (typically <a href="https://en.wikipedia.org/wiki/Control-C" target="_blank" rel="noopener">Control-C</a>) and the erase and kill characters (typically <a href="https://en.wikipedia.org/wiki/Backspace" target="_blank" rel="noopener">backspace</a> or <a href="https://en.wikipedia.org/wiki/Delete_key" target="_blank" rel="noopener">delete</a>, and Control-U, respectively) and, on output, it replaces all the <a href="https://en.wikipedia.org/wiki/Linefeed" target="_blank" rel="noopener">LF</a> characters with a <a href="https://en.wikipedia.org/wiki/Carriage_return" target="_blank" rel="noopener">CR</a>/<a href="https://en.wikipedia.org/wiki/Linefeed" target="_blank" rel="noopener">LF</a> sequence.</p>
<p>比如: 标准 ‘line discipline’ 程序处理来自硬件驱动和引用的数据. 根据系统终端的需求写入到设备. 在输入中, 其管理如中断字符的特殊字符, 实现响应功能. 在输入中, 将换行符表现为换行.</p>
<p>Some <a href="https://en.wikipedia.org/wiki/Unix-like" target="_blank" rel="noopener">Unix-like</a> systems use <a href="https://en.wikipedia.org/wiki/STREAMS" target="_blank" rel="noopener">STREAMS</a> to implement line disciplines.</p>
<p>(这里提到了流, 关于 <a href="https://en.wikipedia.org/wiki/STREAMS" target="_blank" rel="noopener">wiki</a> 中对于 流的解释: a stream is a chain of <a href="https://en.wikipedia.org/wiki/Coroutine" target="_blank" rel="noopener">coroutines</a> that <a href="https://en.wikipedia.org/wiki/Message_passing" target="_blank" rel="noopener">pass messages</a> between a program and a device driver (or between a pair of programs). 流是两者间传递信息的协同链.)</p>
<h3 id="关于-character-device"><a href="#关于-character-device" class="headerlink" title="关于 character device"></a>关于 character device</h3><p>from <a href="https://en.wikipedia.org/wiki/Device_node#Character_devices" target="_blank" rel="noopener">wiki</a></p>
<p>In <a href="https://en.wikipedia.org/wiki/Unix-like" target="_blank" rel="noopener">Unix-like</a> <a href="https://en.wikipedia.org/wiki/Operating_systems" target="_blank" rel="noopener">operating systems</a>, a <strong>device file</strong> or <strong>special file</strong> is an <a href="https://en.wikipedia.org/wiki/Interface_(computer_science)" target="_blank" rel="noopener">interface</a> to a <a href="https://en.wikipedia.org/wiki/Device_driver" target="_blank" rel="noopener">device driver</a> that appears in a <a href="https://en.wikipedia.org/wiki/File_system" target="_blank" rel="noopener">file system</a> as if it were an ordinary <a href="https://en.wikipedia.org/wiki/Computer_file" target="_blank" rel="noopener">file</a>. </p>
<p>设备文件又称特殊文件, 是一个设备驱动的接口, 他能被当作一个普通文件一样执行.</p>
<h4 id="Character-devices"><a href="#Character-devices" class="headerlink" title="Character devices"></a>Character devices</h4><p><em>Character special files</em> or <em>character devices</em> provide unbuffered, direct access to the hardware device. They do not necessarily allow programs to read or write single characters at a time; that is up to the device in question. The character device for a hard disk, for example, will normally require that all reads and writes are aligned to block boundaries and most certainly will not allow reading a single byte.</p>
<p>字符特殊文件/字符设备提供了无缓冲, 直接访问硬件设备. 硬盘上的字符设备, 通常需要所有的读取和写入对其块边界. 不允许读取单个字节.</p>
<p>Character devices are sometimes known as <em>raw devices</em> to avoid the confusion surrounding the fact that a character device for a piece of block-based hardware will typically require programs to read and write aligned blocks.</p>
<h4 id="Block-devices"><a href="#Block-devices" class="headerlink" title="Block devices"></a>Block devices</h4><p><em>Block special files</em> or <em>block devices</em> provide buffered access to hardware devices, and provide some abstraction from their specifics.<a href="https://en.wikipedia.org/wiki/Device_file#cite_note-5" target="_blank" rel="noopener">[5]</a> Unlike character devices, block devices will always allow the programmer to read or write a block of any size (including single characters/bytes) and any alignment. The downside is that because block devices are buffered, the programmer does not know how long it will take before written data is passed from the kernel’s buffers to the actual device, or indeed in what order two separate writes will arrive at the physical device. Additionally, if the same hardware exposes both character and block devices, there is a risk of data corruption due to clients using the character device being unaware of changes made in the buffers of the block device.</p>
<p>块特殊文件/块设备提供了带缓冲的硬件设备访问. 同时还提供了一些抽象. 与字符设备不同的是, 块设备总是允许程序读取/写入任意大小任意对其的块 ( 这不坑👨🐎… 这不是应该是上面那种的定义么, 所以说, 历史错误啊… ). 因为块设备是带缓冲的, 不知何时数据会被写入. 也不知多个不同的写入者谁先写入. </p>
<p>Most systems create both block and character devices to represent hardware like hard disks. FreeBSD and Linux notably do not; the former has removed support for block devices,<a href="https://en.wikipedia.org/wiki/Device_file#cite_note-6" target="_blank" rel="noopener">[6]</a> while the latter creates only block devices. In Linux, to get a character device for a disk one must use the “raw” driver, though one can get the same effect as opening a character device by opening the block device with the Linux-specific <code>O_DIRECT</code> flag.</p>
<p>linux 中可以通过打开块设备时指定 O_DIRECT 标识来模拟字符设备.</p>
<h4 id="Pseudo-devices"><a href="#Pseudo-devices" class="headerlink" title="Pseudo-devices"></a>Pseudo-devices</h4><p>Device nodes on Unix-like systems do not necessarily have to correspond to <a href="https://en.wikipedia.org/wiki/Physical_device" target="_blank" rel="noopener">physical devices</a>. Nodes that lack this correspondence form the group of <em>pseudo-devices</em>. They provide various functions handled by the operating system. Some of the most commonly used (character-based) pseudo-devices include:</p>
<p>类 Unix 系统的设备节点不必符合物理设备, 缺失这样条件的设备组成了伪设备. 它们提供了由操作系统管理的各种功能. </p>
<ul>
<li><a href="https://en.wikipedia.org/wiki//dev/null" target="_blank" rel="noopener">/dev/null</a> – accepts and discards all input written to it; provides an <a href="https://en.wikipedia.org/wiki/End-of-file" target="_blank" rel="noopener">end-of-file</a> indication when read from.</li>
<li><a href="https://en.wikipedia.org/wiki//dev/zero" target="_blank" rel="noopener">/dev/zero</a> – accepts and discards all input written to it; produces a continuous stream of <a href="https://en.wikipedia.org/wiki/Null_character" target="_blank" rel="noopener">null characters</a> (zero-value bytes) as output when read from.</li>
<li><a href="https://en.wikipedia.org/wiki//dev/full" target="_blank" rel="noopener">/dev/full</a> – produces a continuous stream of null characters (zero-value bytes) as output when read from, and generates an <a href="https://en.wikipedia.org/wiki/Errno.h" target="_blank" rel="noopener">ENOSPC</a> (“disk full”) error when attempting to write to it.</li>
<li><a href="https://en.wikipedia.org/wiki//dev/random" target="_blank" rel="noopener">/dev/random</a> – produces bytes generated by the kernel’s <a href="https://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator" target="_blank" rel="noopener">cryptographically secure pseudorandom number generator</a>. Its exact behavior varies by implementation, and sometimes variants such as /dev/urandom or /dev/arandom are also provided.</li>
</ul>
<p>Additionally, BSD-specific pseudo-devices with an <a href="https://en.wikipedia.org/wiki/Ioctl" target="_blank" rel="noopener">ioctl</a> interface may also include:</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki//dev/pf" target="_blank" rel="noopener">/dev/pf</a> – allows userland processes to control <a href="https://en.wikipedia.org/wiki/PF_(firewall)" target="_blank" rel="noopener">PF</a> through an ioctl interface.</li>
<li><a href="https://en.wikipedia.org/wiki//dev/bio" target="_blank" rel="noopener">/dev/bio</a> – provides ioctl access to devices otherwise not found as /dev nodes, used by <a href="https://en.wikipedia.org/wiki/Bioctl" target="_blank" rel="noopener">bioctl</a> to implement <a href="https://en.wikipedia.org/wiki/RAID" target="_blank" rel="noopener">RAID</a> management in <a href="https://en.wikipedia.org/wiki/OpenBSD" target="_blank" rel="noopener">OpenBSD</a> and <a href="https://en.wikipedia.org/wiki/NetBSD" target="_blank" rel="noopener">NetBSD</a>.</li>
<li><a href="https://en.wikipedia.org/wiki//dev/sysmon" target="_blank" rel="noopener">/dev/sysmon</a> – used by NetBSD’s <a href="https://en.wikipedia.org/wiki/Envsys" target="_blank" rel="noopener">sysmon_envsys</a> framework for <a href="https://en.wikipedia.org/wiki/System_monitor" target="_blank" rel="noopener">hardware monitoring</a>, accessed in the userland through <a href="https://en.wikipedia.org/wiki/Proplib(3)" target="_blank" rel="noopener">proplib(3)</a> by the envstat utility.<a href="https://en.wikipedia.org/wiki/Device_file#cite_note-envstat-7" target="_blank" rel="noopener">[7]</a></li>
</ul>
<p>(PS: 当我看到 /dev/full 的时候, 突然有了 ( ‵▽′)ψ😈 想法, /dev/null 是空文件, 经常用于清空文件, 比如 “cat /dev/null &gt; file”. 那么 full 呢? 那当然是来填充文件的吧? 欸 是不是能和某个东西联系在一起? 是的, 删库😱… 如果我把东西删了之后, 再使用这个东西来填充无用数据, 那么是否意味着如果我把磁盘弄满, 至少通过磁盘自身恢复数据的方法无法使用了呢? </p>
<p>对此我进行了小测试(当然在我的主机上…), 它首先似乎受最大文件大小限制, 可以通过 ‘getconf FILESIZEBITS’ 获得. 获得的单位因该是以 GB 计算的. 我使用的主机是 64GB, 假设磁盘是 1TB, 那么至少需要 20 个并发的指令才能填满, 似乎不太难😊. 好了, 就先研究到这里)</p>
<h3 id="关于-TTY"><a href="#关于-TTY" class="headerlink" title="关于 TTY"></a>关于 TTY</h3><p>from <a href="http://www.linusakesson.net/programming/tty/index.php" target="_blank" rel="noopener">document</a> </p>
<h4 id="The-use-cases"><a href="#The-use-cases" class="headerlink" title="The use cases"></a>The use cases</h4><p><img src="http://www.linusakesson.net/programming/tty/case1.png" alt="Diagram"></p>
<p>A user types at a terminal (a physical teletype). This terminal is connected through a pair of wires to a <em>UART</em> (Universal Asynchronous Receiver and Transmitter) on the computer. The operating system contains a <em>UART driver</em> which manages the physical transmission of bytes, including parity checks and flow control. In a naive system, the UART driver would then deliver the incoming bytes directly to some application process. But such an approach would lack the following essential features:</p>
<p>用户在终端(一个物理电传打字机)输入. 终端和 UART(通用异步接收传递)驱动(管理物理字节传输, 包括 parity 检测和流控制) 由一对电线连接. 在原始的系统中, UART 会直接将输入输入递送到应用程序中. 这会缺失一些重要的特性.</p>
<p><strong>Line editing.</strong> Most users make mistakes while typing, so a backspace key is often useful. This could of course be implemented by the applications themselves, but in accordance with the UNIX design philosophy, applications should be kept as simple as possible. So as a convenience, the operating system provides an editing buffer and some rudimentary editing commands (backspace, erase word, clear line, reprint), which are enabled by default inside the <em>line discipline</em>. Advanced applications may disable these features by putting the line discipline in <em>raw</em> mode instead of the default <em>cooked</em> (or <em>canonical</em>) mode. Most interactive applications (editors, mail user agents, shells, all programs relying on <code>curses</code> or <code>readline</code>) run in raw mode, and handle all the line editing commands themselves. The line discipline also contains options for character echoing and automatic conversion between carriage returns and linefeeds. Think of it as a primitive kernel-level <code>sed(1)</code>, if you like.</p>
<p>输入数据错误时, 经常需要使用 backspace 键. 这当然可以由应用自身实现. 但是根据 UNIX 设计的理念, 应用应该尽可能简洁. 所以为了简便起见, 操作系统提供了编辑缓冲和一些基本的编辑命令(backspace, ease word, clear line, reprint) 在 line discipline 中默认启用. 其他高级应用可能通过将其置于原始模式取消这些特性. 大多交互应用(编辑器, 用户邮件代理, shell, 所有依赖于 curses/ readline 的应用程序) 运行于原始模式. 自行管理行编辑命令. line discipline 还包含字符回显和自动转换回车和换行. </p>
<p><strong>Session management.</strong> The user probably wants to run several programs simultaneously, and interact with them one at a time. If a program goes into an endless loop, the user may want to kill it or suspend it. Programs that are started in the background should be able to execute until they try to write to the terminal, at which point they should be suspended. Likewise, user input should be directed to the foreground program only. The operating system implements these features in the <em>TTY driver</em> (<code>drivers/char/tty_io.c</code>).</p>
<p>用户当然希望同时运行多个程序并可以与其交互. 如果程序陷入死循环. 用户希望能暂停/关闭它. 程序在进入后台后应当依旧能运行, 直到它尝试向终端写入. 用户输入应当仅直接发送给前端程序. 操作系统将这些特性实现在了 TTY 驱动中.</p>
<p>An operating system process is “alive” (has an <em>execution context</em>), which means that it can perform actions. The TTY driver is not alive; in object oriented terminology, the TTY driver is a passive object. It has some data fields and some methods, but the only way it can actually do something is when one of its methods gets called from the context of a process or a kernel interrupt handler. The line discipline is likewise a passive entity.</p>
<p>一个程序是’活跃的’ 意味着它能执行操作. TTY 驱动并不是, 它是被动对象. 它拥有一些数据字段和方法. 仅当其方法被进程/内核中处理程序的上下文调用的时候才能做事. (就像一个库一样)</p>
<p>Together, a particular triplet of UART driver, line discipline instance and TTY driver may be referred to as a <em>TTY device</em>, or sometimes just TTY. A user process can affect the behaviour of any TTY device by manipulating the corresponding device file under <code>/dev</code>. Write permissions to the device file are required, so when a user logs in on a particular TTY, that user must become the owner of the device file. This is traditionally done by the <code>login(1)</code> program, which runs with root privileges.</p>
<p>合在一起, 一个特定的三重: UART 驱动, line discipline 实例, 和 TTY 驱动. 统称为 TTY 驱动. 或者有时直接称为 TTY. 用户进程可以通过对 /dev 下的设备文件的管理来改变任意 TTY 设备的行为. 这需要对于设备文件的写权限, 所以当用户登录特定的 TTY 时, 用户必须称为这个设备文件的所有者. 这通常由运行时带有 root 权限 login 程序来实现.</p>
<p>The physical line in the previous diagram could of course be a long-distance phone line:</p>
<p><img src="http://www.linusakesson.net/programming/tty/case2.png" alt="Diagram"></p>
<p>This does not change much, except that the system now has to handle a modem hangup situation as well.</p>
<p>Let’s move on to a typical desktop system. This is how the Linux console works:</p>
<p><img src="http://www.linusakesson.net/programming/tty/case3.png" alt="Diagram"></p>
<p>The TTY driver and line discipline behave just like in the previous examples, but there is no UART or physical terminal involved anymore. Instead, a video terminal (a complex state machine including a <em>frame buffer</em> of characters and graphical character attributes) is emulated in software, and rendered to a VGA display.</p>
<p>当数据输入时, 会通过一系列的交换最终由 TTY 发给进程, 而当数据输出时, 会原路 (但从 terminal emulator 开始分开) 发送给输出设备 (显示屏…)</p>
<p>The console subsystem is somewhat rigid. Things get more flexible (and abstract) if we move the terminal emulation into userland. This is how <code>xterm(1)</code> and its clones work:</p>
<p><img src="http://www.linusakesson.net/programming/tty/case4.png" alt="Diagram"></p>
<p>To facilitate moving the terminal emulation into userland, while still keeping the TTY subsystem (session management and line discipline) intact, the <em>pseudo terminal</em> or <em>pty</em> was invented. And as you may have guessed, things get even more complicated when you start running pseudo terminals inside pseudo terminals, à la <code>screen(1)</code> or <code>ssh(1)</code>.</p>
<p>这里有主从 TTY, 伪终端. 这里作者提到了 ssh. 我查了一下 PTY 相关的东西, 发现了 关于 ssh ‘-t’ 和 ‘-T’ 选项的说明. 就有了 <a href="https://security.stackexchange.com/questions/107933/what-exactly-does-ssh-t-userdomain-verify-do" target="_blank" rel="noopener">stackExchange</a> 和 <a href="https://stackoverflow.com/questions/42505339/why-use-t-with-ssh" target="_blank" rel="noopener">stackOverflow</a> 的解释. </p>
<p>-T: 这个选项不生产 PTY, 终端运行于本地, 这或许就是 PTY(pseudo) 为什么叫 PTY 的原因. github 的 ssh 也是带 -T 选项的, 因为如果为每个用户提供一个 tty 的话… </p>
<p>Now let’s take a step back and see how all of this fits into the process model.</p>
<h4 id="Processes"><a href="#Processes" class="headerlink" title="Processes"></a>Processes</h4><p>A Linux process can be in one of the following states:</p>
<p><img src="http://www.linusakesson.net/programming/tty/linuxprocess.png" alt="Process states"></p>
<table>
<thead>
<tr>
<th>R</th>
<th>Running or runnable (on run queue)</th>
</tr>
</thead>
<tbody><tr>
<td>D</td>
<td>Uninterruptible sleep (waiting for some event)</td>
</tr>
<tr>
<td>S</td>
<td>Interruptible sleep (waiting for some event or signal)</td>
</tr>
<tr>
<td>T</td>
<td>Stopped, either by a job control signal or because it is being traced by a debugger.</td>
</tr>
<tr>
<td>Z</td>
<td>Zombie process, terminated but not yet reaped by its parent.</td>
</tr>
</tbody></table>
<p>(PS: 看到这里的时候, 我有点遗忘 ps 的细节了, 去看了看 ps 的说明. 然后明白了之前有次面试的事情了. 当时我还很好奇为什么会有人在我回答了查看所有进程的命令行后再问我一次. 我当时答的时 ps -axu (-aux?) 都是不对的. 而后者更是大错特错. 我最初需要这条指令时, 仅仅只是在网上查了下(误导我, 可恶啊…) 然后就全信了, 之后就只是瞄了一眼 man 手册. 并未过多在意. 这态度非常有问题, 包括之前的一个 C++ 空对象, 我给它赋值时依旧会出错, 我还好奇为什么, 因为我根本没仔细想过析构的问题. 作为一个技术人员, 我感觉很羞愧. 包括这次的笔记, 如果不是处于好奇, 也不会牵扯出这么多东西来, 学习是一个越学越少的过程. 我应当时刻这样警醒自己.)</p>
<p>By running <code>ps l</code>, you can see which processes are running, and which are sleeping. If a process is sleeping, the <code>WCHAN</code> column (“wait channel”, the name of the wait queue) will tell you what kernel event the process is waiting for.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ps l</span><br><span class="line">F   UID   PID  PPID PRI  NI    VSZ   RSS WCHAN  STAT TTY        TIME COMMAND</span><br><span class="line">0   500  5942  5928  15   0  12916  1460 wait   Ss   pts&#x2F;14     0:00 -&#x2F;bin&#x2F;bash</span><br><span class="line">0   500 12235  5942  15   0  21004  3572 wait   S+   pts&#x2F;14     0:01 vim index.php</span><br><span class="line">0   500 12580 12235  15   0   8080  1440 wait   S+   pts&#x2F;14     0:00 &#x2F;bin&#x2F;bash -c (ps l) &gt;&#x2F;tmp&#x2F;v727757&#x2F;1 2&gt;&amp;1</span><br><span class="line">0   500 12581 12580  15   0   4412   824 -      R+   pts&#x2F;14     0:00 ps l</span><br></pre></td></tr></table></figure>

<p>The “<code>wait</code>“ wait queue corresponds to the <code>wait(2)</code> syscall, so these processes will be moved to the running state whenever there’s a state change in one of their child processes. There are two sleeping states: Interruptible sleep and uninterruptible sleep. Interruptible sleep (the most common case) means that while the process is part of a wait queue, it may actually also be moved to the running state when a signal is sent to it. If you look inside the kernel source code, you will find that any kernel code which is waiting for an event must check if a signal is pending after schedule() returns, and abort the syscall in that case.</p>
<p>有可中断和不可中断睡眠. 中断睡眠意味着如果进程在等待队列中, 那么其可以在信号发送给它时更新为运行态. 任何等待事件的内核代码都必须在调度返回后检查信号挂起.</p>
<p>In the <code>ps</code> listing above, the <code>STAT</code> column displays the current state of each process. The same column may also contain one or more attributes, or flags:</p>
<table>
<thead>
<tr>
<th>s</th>
<th>This process is a session leader.</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>This process is part of a foreground process group.</td>
</tr>
</tbody></table>
<p>These attributes are used for job control.</p>
<h3 id="Jobs-and-sessions"><a href="#Jobs-and-sessions" class="headerlink" title="Jobs and sessions"></a>Jobs and sessions</h3><p>Job control is what happens when you press <code>^Z</code> to suspend a program, or when you start a program in the background using <code>&amp;</code>. A job is the same as a process group. Internal shell commands like <code>jobs</code>, <code>fg</code> and <code>bg</code> can be used to manipulate the existing jobs within a <em>session</em>. Each session is managed by a <em>session leader</em>, the shell, which is cooperating tightly with the kernel using a complex protocol of signals and system calls.</p>
<p>The following example illustrates the relationship between processes, jobs and sessions:</p>
<p>工作管理在按下 C+Z 挂起程序或使用 &amp; 使程序后台执行时发生. 一个工作就是一个经进程组. linux 提供了 jobs, fg, bg 在会话中管理现有工作. 每个绘画都由一个会话 leader 管理. shell , 和内核经由复杂的信号和系统调用协议密切合作. </p>
<p>(PS: 关于 <a href="https://en.wikipedia.org/wiki/Process_group" target="_blank" rel="noopener">process group</a> , 简单来说就是一组进程, 而会话是一组进程组)</p>
<h4 id="The-following-shell-interactions…"><a href="#The-following-shell-interactions…" class="headerlink" title="The following shell interactions…"></a>The following shell interactions…</h4><p><img src="http://www.linusakesson.net/programming/tty/exampleterm.png" alt="Screenshot"></p>
<h4 id="…correspond-to-these-processes…"><a href="#…correspond-to-these-processes…" class="headerlink" title="…correspond to these processes…"></a>…correspond to these processes…</h4><p><img src="http://www.linusakesson.net/programming/tty/examplediagram.png" alt="Table"></p>
<h4 id="…and-these-kernel-structures"><a href="#…and-these-kernel-structures" class="headerlink" title="…and these kernel structures."></a>…and these kernel structures.</h4><ul>
<li><p>TTY Driver (/dev/pts/0).</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Size: 45x13</span><br><span class="line">  Controlling process group: (101)</span><br><span class="line">Foreground process group: (103)</span><br><span class="line">  UART configuration (ignored, since this is an xterm):</span><br><span class="line">    Baud rate, parity, word length and much more.</span><br><span class="line">  Line discipline configuration:</span><br><span class="line">    cooked&#x2F;raw mode, linefeed correction,</span><br><span class="line">    meaning of interrupt characters etc.</span><br><span class="line">  Line discipline state:</span><br><span class="line">    edit buffer (currently empty),</span><br><span class="line">    cursor position within buffer etc.</span><br></pre></td></tr></table></figure>
</li>
<li><p>pipe0</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Readable end (connected to PID 104 as file descriptor 0)</span><br><span class="line">Writable end (connected to PID 103 as file descriptor 1)</span><br><span class="line">Buffer</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>The basic idea is that every pipeline is a job, because every process in a pipeline should be manipulated (stopped, resumed, killed) simultaneously. That’s why <code>kill(2)</code> allows you to send signals to entire process groups. By default, <code>fork(2)</code> places a newly created child process in the same process group as its parent, so that e.g. a <code>^C</code> from the keyboard will affect both parent and child. But the shell, as part of its session leader duties, creates a new process group every time it launches a pipeline.</p>
<p>基础的想法是每个管道都是一个工作. 因为每个管道中的进程都需要被同时管理. 默认在使用 fork 时会创建一个新子程序到同样的进程组中, 就和它的父进程一样. 所以 C+C 会影响父子进程, 但是 shell 作为会话 leader, 当创建一个新的管道的时候, 将会创建一个新的进程组.</p>
<p>The TTY driver keeps track of the foreground process group id, but only in a passive way. The session leader has to update this information explicitly when necessary. Similarly, the TTY driver keeps track of the size of the connected terminal, but this information has to be updated explicitly, by the terminal emulator or even by the user.</p>
<p>TTY 被动持续跟踪前台程序组 id. 会话 leader 必须在必要时更新这些信息(调用?). 同样的, TTY 驱动持续跟踪已连接终端大小.</p>
<p>As you can see in the diagram above, several processes have <code>/dev/pts/0</code> attached to their standard input. But only the foreground job (the <code>ls | sort</code> pipeline) will receive input from the TTY. Likewise, only the foreground job will be allowed to write to the TTY device (in the default configuration). If the cat process were to attempt to write to the TTY, the kernel would suspend it using a signal.</p>
<p>(我也没想到因为一个好奇能牵扯这些东西出来…)</p>
]]></content>
  </entry>
  <entry>
    <title>leetcode/NextGreaterElementII</title>
    <url>/2020/03/06/leetcode/NextGreaterElementII/</url>
    <content><![CDATA[<h2 id="Next-Greater-Element-II"><a href="#Next-Greater-Element-II" class="headerlink" title="Next Greater Element II"></a>Next Greater Element II</h2><p><img src="https://imgur.com/wvepI5B.png" alt=""></p>
<p>数组找最大值</p>
<a id="more"></a>



<h3 id="my-solution"><a href="#my-solution" class="headerlink" title="my solution"></a>my solution</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nextGreaterElements(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        nums.reserve(nums.<span class="built_in">size</span>() * <span class="number">2</span>);</span><br><span class="line">        back_insert_iterator&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; bi (nums);</span><br><span class="line">        copy(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), bi);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (cnt &lt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stk.empty() &amp;&amp; nums[stk.top()] &lt; nums[cnt]) &#123;</span><br><span class="line">                nums[stk.top()] = nums[cnt];</span><br><span class="line">                stk.pop();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cnt &lt; nums.<span class="built_in">size</span>() / <span class="number">2</span>)</span><br><span class="line">                stk.push(cnt);</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stk.empty()) &#123;</span><br><span class="line">            nums[stk.top()] = <span class="number">-1</span>;</span><br><span class="line">            stk.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nums.resize(nums.<span class="built_in">size</span>() / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>用两个拼接的数组来解决循环的问题, 下一个最大数字分为两种情况</p>
<ol>
<li>下一个数字比现在的数字大, 那么就可以直接替换当前数字, 并且在栈中继续这个过程</li>
<li>下一个数字小于等于当前数字, 入栈, 继续下次循环</li>
</ol>
<p>当遍历到最后时, 有下一个最大数字的数字已经被填充了, 栈中剩余的数字即未找到下一个最大数字的数字</p>
<p>这个算法需要一倍额外的空间, 以及一个栈. 额外空间主要是因为数字会改变, 但是被改变的数字可能是其他数字所需要的数字. 暂时没有想到其他的方法. 而栈是用作记录, 在极端情况下 { 3, 2, 1…} 它等同于一倍的额外空间.</p>
<p>时间上, 是一个 O(n) 的算法. (平均情况比 n 大一些)</p>
<p><img src="https://imgur.com/pqr2rn6.png" alt=""></p>
<p>加上 ‘fast IO’ 的话还算个不错的结果, 我非常好奇有没有不用额外空间的算法.</p>
<h3 id="the-best-solution"><a href="#the-best-solution" class="headerlink" title="the best solution"></a>the best solution</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nextGreaterElements(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; next_greater(n);</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> next_greater;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> maxi=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) maxi = nums[i] &gt; nums[maxi]? i:maxi;</span><br><span class="line"></span><br><span class="line">        next_greater[maxi] = - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> p;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=(maxi<span class="number">-1</span>+n)%n; i!=maxi; i=(i<span class="number">-1</span>+n)%n)&#123;</span><br><span class="line">            p = (i+<span class="number">1</span>)%n;</span><br><span class="line">            <span class="keyword">while</span>(p != <span class="number">-1</span> &amp;&amp; nums[i] &gt;= nums[p]) p = next_greater[p];</span><br><span class="line">            next_greater[i] = p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            p = next_greater[i];</span><br><span class="line">            next_greater[i] = p == <span class="number">-1</span>? p: nums[next_greater[i]];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> next_greater;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>emmm… 我怎么感觉这个算法很邋遢… </p>
<p>从一开始的一次完整循环找最大值, 但是循环中不做其他事情(其实是可以想办法做一些能提高效率事情的, 一个完整的循环只用来找最大值, 太浪费了) . 循环问题它用取余来避免, 这是意料之中的. 也用了额外一倍的空间, 循环有三个, 两次肉眼可见完整的循环. 感觉并没有其他最优算法一样, 给人眼前一亮的感觉 = =.</p>
<p>The first cycle of this algorithm just find the max without anything can help efficiency. It used the same extra space and two complete cycles. It doesn’t feel as good as the other best algorithms.</p>
]]></content>
  </entry>
  <entry>
    <title>leetcode/FindtheDuplicateNumber</title>
    <url>/2020/02/29/leetcode/FindtheDuplicateNumber/</url>
    <content><![CDATA[<h2 id="Find-the-Duplicate-Number"><a href="#Find-the-Duplicate-Number" class="headerlink" title="Find the Duplicate Number"></a>Find the Duplicate Number</h2><p><img src="https://imgur.com/TuxxCiA.png" alt=""></p>
<a id="more"></a>



<h3 id="my-solution"><a href="#my-solution" class="headerlink" title="my solution"></a>my solution</h3><p>我的做法偏向于数学, 我是这样思考的: n 个数的话, 原本的总和 Sn 是可以直接求出来的. 这个原本的总和和实际总和(Sn1)的差距就是重复数组所造成的影响(Sn2), 我也可以通过 O(n) 来算出有多少个数字不存在, 名为 cnt. 因为重复数字只会有一个, 其间的差 (Sn1 + Sn2 - Sn) / cnt 的结果就是重复的数字. 比如:</p>
<pre><code>6 7
1 3 3 | 2 + 1 = 3
6 7
2 2 3 | 1 + 1 = 2

10 8
1 2 2 3 | 4 - 2 = 2
10 9
2 2 2 3 | 9 + 1 + 4 - 10 / 2 = 2</code></pre><p>假设数字[1, 3, 3] 其 Sn = 6, Sn1 = 7, Sn2 = 2, 则由之前的公式可得: (7 + 2 - 6) / 1 = 3.</p>
<p>其余案例依旧如此. 代码如下 : </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            sum += nums[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), i) == nums.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                ++cnt;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)((sum - (<span class="number">1</span> + nums.<span class="built_in">size</span>()) * nums.<span class="built_in">size</span>() / <span class="number">2</span>) / cnt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://imgur.com/LWP332a.png" alt=""></p>
<p>这是个 O(n) 复杂度的算法, 但是其中那个 find 很耗时, 应该是算法的核心瓶颈. </p>
<p>并且 <code>nums.size()) * nums.size() / 2</code> 要注意一下, 这里我假设是从左往右的, 但是如果计算机不这么做, 可能会有问题.</p>
<h2 id="the-best-solution"><a href="#the-best-solution" class="headerlink" title="the best solution"></a>the best solution</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> slow&#123; nums[<span class="number">0</span>] &#125;;</span><br><span class="line">        <span class="keyword">int</span> fast&#123; nums[nums[<span class="number">0</span>]] &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[nums[fast]];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (fast != slow) &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这和之前我做过的一道链表题的解法十分相似, 思路是这样的: 一个人走得快, 另一个人走得慢. 快的人的距离一直是慢的人的两倍, 所以一开始 slow 是 nums[0], 而并非 0. 因为 0 和 1 的差距和 1 和 2 的差距虽然都只有1, 但前者并没有倍数关系. 而当走了 n 步时(fast 走了 2n步) 两人碰撞. 此时 fast 再重新开始, 以同样的速度开始行走, 那么 n 步后, 一定会相遇(我不太确定是否一定是 n 步, 但最多 n 步). 此时 slow 和 fast 的位置肯定是不同的 (while 的条件保证了其不同) 所以最后的值就是重复的数字. 之所以需要两次, 是因为第一次的结果可能会出现偶然的情况, 比如都指向同一个数字. </p>
<p>第一次的循环结束, 意味着有两个下标指向的数值是相同的(偶然情况会指向同一个下标). 也就是说, 在第一次结束时, 答案就已经有可能得到了</p>
<p><img src="https://imgur.com/NuDtTwh.png" alt=""></p>
<p>将标注的代码增加后, 也可以得到答案. </p>
<p>而第二次循环是为了规避偶然情况, 比如 [3,1,3,4,2] 到第一次循环结束 slow 是 4, fast 是 3. 刚好, 其实他们指向的是同一个数字, 针对这种情况, 就有了第二次循环. 而之所以第二次循环从 0 开始, 是因为这里需要的是步数一致. 一定会得到答案么? 再仔细想想这个例子, 其循环周期为: 3, 4, 2, 3, 4, 2… 当然, 第二次是以 2 开始的, 所以是 2, 3, 4…</p>
<p>emm… [挠头…] </p>
<p>这个算法有两个前提条件:</p>
<ol>
<li>数组中的数字都能当作下标, 也就是不超过数组长度</li>
<li>重复的数字只能有一个, 不然可能会造成死循环</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>read/Arithmetic</title>
    <url>/2020/02/26/read/Arithmetic/</url>
    <content><![CDATA[<h2 id="Arithmetic"><a href="#Arithmetic" class="headerlink" title="Arithmetic"></a>Arithmetic</h2><p>之前就听说计算机只会做加法运算, 其余运算都是通过演化而来的, 这次在看 <computer organization and design the hardwareSoftware interface> 的时候, 它单独拿出了一节讲这个东西, 所以就做个笔记 :)</p>
<p>Computer can do add arithmetic only, other arithmetics are based on it.</p>
<a id="more"></a>



<h2 id="add"><a href="#add" class="headerlink" title="add"></a>add</h2><p>加法要注意一下溢出, 可以参考一下我之前的笔记</p>
<p>the key point of add arithmetic is overflow, about <a href="https://yucangs.github.io/2020/01/10/other/overFlowAndCarry/" target="_blank" rel="noopener">overflow</a></p>
<h2 id="Sub"><a href="#Sub" class="headerlink" title="Sub"></a>Sub</h2><p>减法就是加上负数, 而负数的计算方式之前有做<a href="https://yucangs.github.io/2020/01/10/other/encode/" target="_blank" rel="noopener">笔记</a></p>
<h2 id="mul"><a href="#mul" class="headerlink" title="mul"></a>mul</h2><p><img src="https://imgur.com/wYT63l2.png" alt=""></p>
<p>In this example, we restricted the decimal digits to 0 and 1. With only two<br>choices, each step of the multiplication is simple:</p>
<p>将十进制数转换为二进制, 根据每一位数字执行不同的选择: </p>
<ol>
<li>Just place a copy of the multiplicand (1 ? multiplicand) in the proper place<br>if the multiplier digit is a 1, or</li>
<li>Place 0 (0 ? multiplicand) in the proper place if the digit is 0.<br>Although the decimal example above happens to use only 0 and 1, multiplication<br>of binary numbers must always use 0 and 1, and thus always off ers only these two<br>choices.</li>
</ol>
<p>1 即拷贝, 0 什么也不做</p>
<p><img src="https://imgur.com/jYot1g7.png" alt=""></p>
<p><img src="https://imgur.com/JLBNTK0.png" alt=""></p>
<p>第二张图就简明多了, 简述了乘法运算的原理.</p>
<h2 id="Div"><a href="#Div" class="headerlink" title="Div"></a>Div</h2><p><img src="https://imgur.com/EIhJokd.png" alt=""></p>
<p><img src="https://imgur.com/3RiHAfk.png" alt=""></p>
<p>就和普通的除法运算步骤是一样的</p>
]]></content>
  </entry>
  <entry>
    <title>read/InterVirtualizationTechnology</title>
    <url>/2020/02/12/read/InterVirtualizationTechnology/</url>
    <content><![CDATA[<h2 id="InterVirtualizationTechnology"><a href="#InterVirtualizationTechnology" class="headerlink" title="InterVirtualizationTechnology"></a>InterVirtualizationTechnology</h2><p>长久以来一直对虚拟化一知半解，什么是虚拟化，为什么要虚拟化，虚拟化的优劣，虚拟化的原理是什么…… 这篇笔记收集自网上的信息，然后归纳一下。理解其中某些原因。</p>
<p>from ：<a href="https://www.hardwaresecrets.com/everything-you-need-to-know-about-the-intel-virtualization-technology/" target="_blank" rel="noopener">Everything you need to know about the Intel virtuallization technology</a></p>
<a id="more"></a>

<p>Several Intel CPUs come with the Intel Virtualization Technology (VT). Formerly known as Vanderpool, this technology enables a CPU to act as if you have several independent computers, in order to enable several operating systems to run at the same time on the same machine. In this tutorial we will explain everything you need to know about this technology.</p>
<p>部分 CPU 具有虚拟化技术。这种技术使 CPU 运行起来好像是有多个独立的电脑一样，让多个操作系统在同一时间、同一机器上运行。</p>
<p>Intel’s virtualization technology is available in two versions: VT-x, for x86 processors; and VT-i, for Itanium (i.e., IA-64) processors. In this tutorial we will be covering the details of the VT-x technology.</p>
<p>Inter 虚拟化技术应用于两个版本：VT-x（x86处理器），VT-i（IA-64处理器）</p>
<p>Virtualization technology is nothing new. There is some software on the market that enables virtualization; probably <a href="https://www.vmware.com/" target="_blank" rel="noopener">VMware</a> is the most famous one. (<a href="https://en.wikipedia.org/wiki/Comparison_of_platform_virtual_machines" target="_blank" rel="noopener">Click here for a complete list of virtualization software available on the market</a>.) With this technique, you can “partition” a single computer to act as if it were several independent computers, allowing the system to run several operating systems at the same time. These operating systems can even be different (e.g., you can run Windows in one virtual machine and Linux in another).</p>
<p>已有一些软件使用了虚拟化技术，其中 VMware 是最出名的之一。使用这个技术可以在单个电脑上运行多个操作系统，就像多个电脑一样。这些操作系统可以彼此不兼容。</p>
<p>Multi-core technology allows a single processor to have more than one physical processor inside. For example, a computer with one dual-core processor acts as if it were a computer with two CPUs installed, working under a mode called symmetrical multiprocessing (SMP). Even though multi-core CPUs have more than one processor inside, they cannot be used independently. The operating system is run by the first CPU core, and the additional cores the CPU may have must be used by the same operating system. So, based on any explanation, there is no difference between a single-core CPU and a multi-core one.</p>
<p>多核技术使单个处理器可以拥有多个物理处理器。一个双核的处理器可以像一个双 CPU 的电脑一样，运行于一个叫做<a href="https://www.wisegeek.com/what-is-symmetric-multiprocessing.htm" target="_blank" rel="noopener">对称多处理器</a>的模式。即使多核处理器拥有多个处理单元，但不能独立使用。单核 CPU 和多核 CPU 并无太大区别。</p>
<p>Hyper-Threading technology simulates an additional processor per CPU core. For example, a dual-core CPU with Hyper-Threading technology is seen by the operating system as if it were a quad-core CPU. These additional processors cannot run separate operating systems, so for the operating system the Hyper-Threading technology has the same effect as the multi-core technology.</p>
<p>超线程技术将每个 CPU 核心模拟一个额外的处理单元。一个双核的 CPU 在超线程技术下，在操作系统的视角看起来就像一个四核的处理器。这些额外的处理器不能运行不同的操作系统。对操作系统而言，超线程技术带来的好处和多核技术是一样的。</p>
<p>The diagrams below may help you understand the differences between those technologies.</p>
<p><a href="https://s3.amazonaws.com/hs-wordpress/wp-content/uploads/2017/12/12214556/263_011.gif" target="_blank" rel="noopener"><img src="https://s3.amazonaws.com/hs-wordpress/wp-content/uploads/2017/12/12214556/263_011.gif" alt="Multitasking"></a><strong>Figure 1:</strong> Multitasking</p>
<p><a href="https://s3.amazonaws.com/hs-wordpress/wp-content/uploads/2017/12/12214554/263_021.gif" target="_blank" rel="noopener"><img src="https://s3.amazonaws.com/hs-wordpress/wp-content/uploads/2017/12/12214554/263_021.gif" alt="Multi-core or Hyper-Threading"></a><strong>Figure 2:</strong> Multi-core or Hyper-Threading</p>
<p><a href="https://s3.amazonaws.com/hs-wordpress/wp-content/uploads/2017/12/12214544/263_031.gif" target="_blank" rel="noopener"><img src="https://s3.amazonaws.com/hs-wordpress/wp-content/uploads/2017/12/12214544/263_031.gif" alt="Virtualization"></a><strong>Figure 3:</strong> Virtualization</p>
<p>（可以看出，虚拟化技术为每个 OS 提供了虚拟的 CPU）</p>
<p>If you pay close attention, Virtualization Technology uses the same idea as the Virtual 8086 (V86) mode, which has been available since the 386 processor. With the V86 mode you can create several virtual 8086 machines to run DOS-based programs at the same time, each one “thinking” that it is running in a completely independent computer. With VT you can create several “complete” virtual machines to run full operating systems simultaneously.</p>
<p>If there is software such as VMware that enables virtualization, why implement Virtualization Technology inside the CPU? The advantage is that CPUs with Virtualization Technology have some new instructions to control virtualization. With them, controlling software (called VMM, Virtual Machine Monitor) can be simpler, thus improving performance compared to software-based solutions. When the CPU has support to Virtualization Technology, the virtualization is said to be hardware-based or hardware-assisted.</p>
<p>如果已经有了类似 VMware 的软体支持虚拟化，为什么要在 CPU 中实现虚拟化技术呢？因为虚拟化技术使用了特殊的 CPU 指令，这些指令带来了额外的益处。（在 <a href="https://en.wikipedia.org/wiki/X86_instruction_listings" target="_blank" rel="noopener">x86 instruction sets</a> 中，带有 VM 开头的指令应该就是虚拟化指令）</p>
<p>Processors with Virtualization Technology have an extra instruction set called Virtual Machine Extensions or VMX. VMX brings 10 new virtualization-specific instructions to the CPU: VMPTRLD, VMPTRST, VMCLEAR, VMREAD, VMWRITE, VMCALL, VMLAUNCH, VMRESUME, VMXOFF, and VMXON.</p>
<p>There are two modes to run under virtualization: VMX root operation and VMX non-root operation. Usually, only the virtualization controlling software, called Virtual Machine Monitor (VMM), runs under root operation, while operating systems running on top of the virtual machines run under non-root operation. Software running on top of virtual machines is also called “guest software.”</p>
<p>有两种虚拟模式在虚拟化中运行：VMX root 和 VMX non-root 操作。通常只有虚拟化控制软件(VMM)才运行于 root 操作下，操作系统运行于虚拟机的顶层，处于 non-root 操作。运行于虚拟机顶层的软件又称“访客软件”</p>
<p>To enter virtualization mode, the software should execute the VMXON instruction and then call the VMM software. The VMM software can enter each virtual machine using the VMLAUNCH instruction, and exit it by using the VMRESUME instruction. If the VMM wants to shutdown and exit the virtualization mode, it executes the VMXOFF instruction.</p>
<p>软件通过执行 VMXON 指令并调用 VMM 软件进入虚拟模式。VMM 可以使用 VMLAUNCH 指令进入每个虚拟机，并通过使用 VMRESUME 指令退出。（为什么是 resume ？）通过使用 VMXOFF 指令关闭并推出虚拟模式。</p>
<p><a href="https://s3.amazonaws.com/hs-wordpress/wp-content/uploads/2017/12/12214536/263_041.gif" target="_blank" rel="noopener"><img src="https://s3.amazonaws.com/hs-wordpress/wp-content/uploads/2017/12/12214536/263_041.gif" alt="Operation of the Virtualization Technology"></a><strong>Figure 4:</strong> Operation of the Virtualization Technology</p>
<p>Each guest shown in Figure 4 can be a different operating system, running its own programs (even several programs at the same time as we have shown in Figure 3).</p>
<p>每个“访客”可以是不同的操作系统，运行自己的程序。</p>
<p>More recent processors have an extension called EPT (Extended Page Tables), which allows each guest to have its own page table to keep track of memory addresses. Without this extension, the VMM has to exit the virtual machine to perform address translations. This exiting-and-returning task reduces performance. Therefore, the EPT increases virtualization performance.</p>
<p>处理器有额外的 EPT (扩展页表)功能，可以使“访客”拥有自己的页表，以用于追踪内存地址。如果没有这个额外扩展，VMM 必须退出虚拟机执行地址转换，这会影响性能/</p>
<p>Even though the Intel Virtualization Technology was released in 2005, not all current processors from Intel support this technology. The easiest way to verify if your CPU supports this technology is to run the <a href="https://downloadcenter.intel.com/Detail_Desc.aspx?DwnldID=7838" target="_blank" rel="noopener">Intel Processor Identification Utility</a>. After you download and install this program, run it and go to the “CPU Technologies” tab. There you will see, besides “Intel (R) Virtualization Technology,” whether your CPU supports it or not. Also, you can see whether your CPU supports the Extended Page Tables (EPT), besides “Intel VT-x with Extended Page Tables.” See Figure 5.</p>
<p><a href="https://s3.amazonaws.com/hs-wordpress/wp-content/uploads/2017/12/12214518/263_051.gif" target="_blank" rel="noopener"><img src="https://s3.amazonaws.com/hs-wordpress/wp-content/uploads/2017/12/12214518/263_051.gif" alt="Detecting support for the Intel Virtualization Technology"></a><strong>Figure 5:</strong> Detecting support for the Intel Virtualization Technology</p>
<p>最后再补充一下 Intel 官方虚拟化技术文档 <a href="https://www.intel.com/content/www/us/en/virtualization/virtualization-technology/intel-virtualization-technology.html" target="_blank" rel="noopener">InterVitrualizationTechnololy</a></p>
<p>Virtualization abstracts hardware that allows multiple workloads to share a common set of resources. On shared virtualized hardware, a variety of workloads can co-locate while maintaining full isolation from each other, freely migrate across infrastructures, and scale as needed.o</p>
<p>虚拟化抽象硬件，使多个工作站共享同一份资源。在共享虚拟硬件上，多个工作站可以在保证其完全隔离的情况下协作，自由地在架构中迁移资源，按其所需自适应。</p>
<p>Businesses tend to gain significant capital and operational efficiencies through virtualization because it leads to improved server utilization and consolidation, dynamic resource allocation and management, workload isolation, security, and automation. Virtualization makes on-demand self-provisioning of services and software-defined orchestration of resources possible, scaling anywhere in a hybrid cloud on-premise or off-premise per specific business needs.</p>
<p>企业期望通过虚拟化减少支出，提高效率。</p>
<p>Intel® Virtualization Technology (Intel® VT) represents a growing portfolio of technologies and features that make virtualization practical by eliminating performance overheads and improving security. Intel® Virtualization Technology (Intel® VT) provides hardware assist to the virtualization software, reducing its size, cost, and complexity. Special attention is also given to reduce the virtualization overheads occurring in cache, I/O, and memory. Over the last decade or so, a significant number of hypervisor vendors, solution developers, and users have been enabled with Intel® Virtualization Technology<br>(Intel® VT), which is now serving a broad range of customers in the consumer, enterprise, cloud, communication, technical computing, and many more sectors.</p>
<p>Intel® Virtualization Technology (Intel® VT) portfolio currently includes (but not limited to):</p>
<p><strong>CPU virtualization</strong> features enable faithful abstraction of the full prowess of Intel® CPU to a virtual machine (VM). All software in the VM can run without any performance or compatibility hit, as if it was running natively on a dedicated CPU. Live migration from one Intel® CPU generation to another, as well as nested virtualization, is possible.</p>
<p>CPU 虚拟化：为 VM 提供了 CPU 的抽象。所有 VM 运行的软件不会带来性能或兼容性的缺失。就像使用专有的 CPU 一样。</p>
<p><strong>Memory virtualization</strong> features allow abstraction isolation and monitoring of memory on a per virtual machine (VM) basis. These features may also make live migration of VMs possible, add to fault tolerance, and enhance security. Example features include direct memory access (DMA) remapping and <a href="https://software.intel.com/en-us/articles/best-practices-for-paravirtualization-enhancements-from-intel-virtualization-technology-ept-and-vt-d" target="_blank" rel="noopener">extended page tables</a> (EPT), including their extensions: accessed and dirty bits, and fast switching of EPT contexts.</p>
<p>内存 虚拟化：提供基于每个虚拟机的抽象隔离和内存监视。这些特性可能使 VMs 的实时迁移可实现。增加容错力和安全性。比如直接内存访问(DMA)，重映射和扩展页表(EPT)，包括他们的扩展：访问和脏位，快速切换 EPT 上下文。</p>
<p>I/O virtualization** features facilitate offloading of multi-core packet processing to network adapters as well as direct assignment of virtual machines to virtual functions, including disk I/O. Examples include Intel® Virtualization Technology for Directed I/O (VT-d), Virtual Machine Device Queues (VMDQ), <a href="https://cdrdv2.intel.com/v1/dl/getcontent/321211" target="_blank" rel="noopener">Single Root I/O Virtualization</a> (SR-IOV, a PCI-SIG standard), and <a href="https://www.intel.com/content/www/us/en/io/data-direct-i-o-technology.html" target="_blank" rel="noopener">Intel® Data Direct I/O Technology (Intel® DDIO) enhancements</a>.</p>
<p><strong>Intel® Graphics Virtualization Technology</strong> (<a href="https://01.org/blogs/skjain/2014/intel®-graphics-virtualization-update" target="_blank" rel="noopener">Intel® GVT</a>) allows VMs to have full and/or shared assignment of the graphics processing units (GPU) as well as the video transcode accelerator engines integrated in Intel <a href="http://ark.intel.com/products/65732/Intel-Xeon-Processor-E3-1230V2-8M-Cache-3_30-GHz" target="_blank" rel="noopener">system-on-chip products</a>. It enables usages such as workstation remoting, desktop-as-a-service, media streaming, and online gaming.</p>
<p>Intel® Graphics Virtualization Technology</p>
<p><strong>Virtualization of Security and Network functions</strong> enables transformation of traditional network and security workloads into compute. Virtual functions can be deployed on standard high volume servers anywhere in the data center, network nodes, or cloud, and smartly co-located with business workloads. Examples of technologies making it happen include <a href="https://www.intel.com/content/www/us/en/architecture-and-technology/intel-quick-assist-technology-overview.html" target="_blank" rel="noopener">Intel® QuickAssist Technology (Intel® QAT) </a>and the <a href="https://www.intel.com/content/www/us/en/communications/data-plane-development-kit.html" target="_blank" rel="noopener">Data Plane Development Kit (DPDK)</a>.</p>
<p>其他有关 Intel VT 的信息：</p>
<p><a href="https://www.youtube.com/watch?v=XItj08D5KPk" target="_blank" rel="noopener">video</a></p>
<p><a href="https://itpeernetwork.intel.com/a-peek-into-extended-page-tables/#gs.waxaq1" target="_blank" rel="noopener">EPT</a></p>
]]></content>
  </entry>
  <entry>
    <title>other/auto+const+pointer</title>
    <url>/2020/02/10/other/auto+const+pointer/</url>
    <content><![CDATA[<h2 id="auto-const-pointer"><a href="#auto-const-pointer" class="headerlink" title="auto+const+pointer"></a>auto+const+pointer</h2><p>在项目中遇到了需要使用auto的场景，那是一个复杂类型的指针。使用时出了一些疑问，所以有了这篇笔记。</p>
<p>I’ve got a problem when I need to use the ‘auto’ keyword in a project. This’s why I wrote this note.</p>
<a id="more"></a>

<p>参考以下代码：</p>
<p>think flowing codes</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;i;</span><br><span class="line"><span class="keyword">auto</span> p2 = p;</span><br></pre></td></tr></table></figure>
<p>此时我想要 p2 安全一些，我不想改变 i 的值，那么或许可以这样做：</p>
<p>if I want p2 to be safer and don’t want to change the value of ‘i’, maybe I can do this:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> <span class="keyword">const</span> p2 = p; <span class="comment">// or const auto p2 = p; ?</span></span><br></pre></td></tr></table></figure>

<p>这里 consnt 在 auto 位置不影响其语义，p2 依旧可以改变 i 的值。（ps：双 const 会报错）</p>
<p>The position of ‘const’ at ‘auto’ doesn’t affect anything. The value of ‘i’ still can be changed by ‘p2’. (PS: double-const will get an error)</p>
<p>我想要的是一个双 const 的指针，如何实现呢？</p>
<p>I want a double-const pointer, how can get it?</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> <span class="keyword">const</span>* <span class="keyword">const</span> p2 = p;</span><br></pre></td></tr></table></figure>

<p>Emmm, 好像并不是很有意义写这篇笔记</p>
<p>it seems doesn’t make sense to write this note…</p>
]]></content>
  </entry>
  <entry>
    <title>read/ICMPTheInternetControlMessageProtocol</title>
    <url>/2020/01/18/read/ICMPTheInternetControlMessageProtocol/</url>
    <content><![CDATA[<h3 id="5-6-ICMP-The-Internet-Control-Message-Protocol"><a href="#5-6-ICMP-The-Internet-Control-Message-Protocol" class="headerlink" title="5.6 ICMP: The Internet Control Message Protocol"></a>5.6 ICMP: The Internet Control Message Protocol</h3><p>The Internet Control Message Protocol (ICMP), specified in [RFC 792], is used by<br>hosts and routers to communicate network-layer information to each other. The most<br>typical use of ICMP is for error reporting. For example, when running an HTTP<br>session, you may have encountered an error message such as “Destination network<br>unreachable.” This message had its origins in ICMP. At some point, an IP router was<br>unable to find a path to the host specified in your HTTP request. That router created<br>and sent an ICMP message to your host indicating the error.</p>
<p>ICMP 用于主机和路由彼此通讯, 传递网络层信息. 最典型的用法是错误报告. </p>
<a id="more"></a>

<p>ICMP is often considered part of IP, but architecturally it lies just above IP, as<br>ICMP messages are carried inside IP datagrams. That is, ICMP messages are carried<br>as IP payload, just as TCP or UDP segments are carried as IP payload. Similarly,<br>when a host receives an IP datagram with ICMP specified as the upper-layer protocol<br>(an upper-layer protocol number of 1), it demultiplexes the datagram’s contents to<br>ICMP, just as it would demultiplex a datagram’s content to TCP or UDP.</p>
<p>ICMP 通常被认为是 IP 的一部分. 但是结构上它处于 IP 的上层. ICMP 信息位于 IP 数据包中. ICMP 信息作为 IP 的负载, 就像 TCP/UDP 段一样. 当主机接收到附带 ICMP, 并指定为上层协议的 IP 数据报时. 解复用数据报的内容给 ICMP. 就像解复用数据报内容给 TCP/UDP 一样.</p>
<p>ICMP messages have a type and a code field, and contain the header and the first<br>8 bytes of the IP datagram that caused the ICMP message to be generated in the first<br>place (so that the sender can determine the datagram that caused the error). Selected<br>ICMP message types are shown in Figure 5.19. Note that ICMP messages are used<br>not only for signaling error conditions.</p>
<p>ICMP 消息有一个类型和代码字段 (后面这段我读不通…). ICMP 不仅仅用于错误消息传递.</p>
<p>The well-known ping program sends an ICMP type 8 code 0 message to the<br>specified host. The destination host, seeing the echo request, sends back a type 0<br>code 0 ICMP echo reply. Most TCP/IP implementations support the ping server<br>directly in the operating system; that is, the server is not a process. Chapter 11 of<br>[Stevens 1990] provides the source code for the ping client program. Note that the<br>client program needs to be able to instruct the operating system to generate an ICMP<br>message of type 8 code 0.</p>
<p>ping 程序就是由 ICMP 实现的. ping 会发送一个类型为 8, 代码为 0 的消息给指定主机, 当指定主机看到这个回显消息时, 返回一个类型 0, 代码 0 的消息. 这通常实现于操作系统. 这意味这这个服务并不是一个过程.</p>
<p>Another interesting ICMP message is the source quench message. This message<br>is seldom used in practice. Its original purpose was to perform congestion control—to<br>allow a congested router to send an ICMP source quench message to a host to force<br>that host to reduce its transmission rate. We have seen in Chapter 3 that TCP has its<br>own congestion-control mechanism that operates at the transport layer, without the<br>use of network-layer feedback such as the ICMP source quench message.</p>
<p>另一个消息是 source quench (我不知道该怎么中文称呼它 :( … ) 消息, 它用于拥塞控制. 但是 TCP 已经有自己的拥塞控制方法了, 用不着它, 所以很少被使用.</p>
<p>In Chapter 1 we introduced the Traceroute program, which allows us to trace a<br>route from a host to any other host in the world. Interestingly, Traceroute is imple-<br>mented with ICMP messages. To determine the names and addresses of the routers<br>between source and destination, Traceroute in the source sends a series of ordinary IP<br>datagrams to the destination. Each of these datagrams carries a UDP segment with an<br>unlikely UDP port number. The first of these datagrams has a TTL of 1, the second of 2,<br>the third of 3, and so on. The source also starts timers for each of the datagrams. When<br>the nth datagram arrives at the nth router, the nth router observes that the TTL of the<br>datagram has just expired. According to the rules of the IP protocol, the router discards<br>the datagram and sends an ICMP warning message to the source (type 11 code 0). This<br>warning message includes the name of the router and its IP address. When this ICMP<br>message arrives back at the source, the source obtains the round-trip time from the<br>timer and the name and IP address of the nth router from the ICMP message.</p>
<p>第一章中我们提出了 Traceroute 程序. Traceroute 也是基于 ICMP 实现的. Traceroute 发送一系列原始 IP 数据报到目的地. 每个数据报携带一个不可能的 UDP 端口的 UDP 段 (???). 第一个数据报的 TTL 设置为 1, 第二个为 2, 依次循环. 源主机同时开启定时器, 当数据报到达第 n 个路由时, TTL 过期, 路由丢弃该数据报, 返回一个 ICMP 警告信息 (类型 11, 代码 0). 这个警告信息包含路由名及其 IP 地址. Traceroute 由此实现.</p>
<p>How does a Traceroute source know when to stop sending UDP segments?<br>Recall that the source increments the TTL field for each datagram it sends. Thus, one<br>of the datagrams will eventually make it all the way to the destination host. Because<br>this datagram contains a UDP segment with an unlikely port number, the destination<br>host sends a port unreachable ICMP message (type 3 code 3) back to the source.</p>
<p>Traceroute 何时停止发送 UDP 段呢? 因为 TTL 不断增加, 最终会到达目的地, 但是因为发送的 UDP 数据报的目的端口是一个不可能的端口, 所以目的主机返回一个 ICMP 端口不可达消息 (类型 3, 代码 3).</p>
<p>When the source host receives this particular ICMP message, it knows it does not<br>need to send additional probe packets. (The standard Traceroute program actually<br>sends sets of three packets with the same TTL; thus the Traceroute output provides<br>three results for each TTL.)</p>
<p>当源主机收到这个特殊的 ICMP 消息后, 就知晓已到达目的地.</p>
<p>(我 google 了一下, 当中途路由变化会发生什么, 得到的答案是: 什么都不会发生, Traceroute 并不保证这个… )</p>
<p>In this manner, the source host learns the number and the identities of routers<br>that lie between it and the destination host and the round-trip time between the two<br>hosts. Note that the Traceroute client program must be able to instruct the operating<br>system to generate UDP datagrams with specific TTL values and must also be able to<br>be notified by its operating system when ICMP messages arrive. Now that you under-<br>stand how Traceroute works, you may want to go back and play with it some more.</p>
<p>A new version of ICMP has been defined for IPv6 in RFC 4443. In addition to<br>reorganizing the existing ICMP type and code definitions, ICMPv6 also added new<br>types and codes required by the new IPv6 functionality. These include the “Packet<br>Too Big” type and an “unrecognized IPv6 options” error code.</p>
<p>为 IPv6 定义了新的 ICMP 规范. 包括 “包太大了”, “未识别 IPv6”.</p>
]]></content>
  </entry>
  <entry>
    <title>read/routingAlgorithms</title>
    <url>/2020/01/16/read/routingAlgorithms/</url>
    <content><![CDATA[<h2 id="routing-algorithms"><a href="#routing-algorithms" class="headerlink" title="routing algorithms"></a>routing algorithms</h2><p>​    • A centralized routing algorithm computes the least-cost path between a source<br>and destination using complete, global knowledge about the network. That is, the<br>algorithm takes the connectivity between all nodes and all link costs as inputs.<br>This then requires that the algorithm somehow obtain this information before<br>actually performing the calculation. The calculation itself can be run at one site<br>(e.g., a logically centralized controller as in Figure 5.2) or could be replicated in<br>the routing component of each and every router (e.g., as in Figure 5.1). The key<br>distinguishing feature here, however, is that the algorithm has complete informa-<br>tion about connectivity and link costs. Algorithms with global state information<br>are often referred to as link-state (LS) algorithms, since the algorithm must<br>be aware of the cost of each link in the network. We’ll study LS algorithms in<br>Section 5.2.1.</p>
<p>​    集中式的路由算法计算从起点到终点的最少成本时, 知晓整个网络的成本情况. 意思是, 这个算法需要所有相连节点的成本作为输入. 这需要在实际执行计算前, 在某处获取这些信息. 这个计算本身可以在某个站点, 也可以在每个路由中. 基于全局状态信息的算法经常被成为 link-state(LS) 算法. 因为算法需要注意整个网络, 每个节点的成本情况. </p>
<p>​    • In a decentralized routing algorithm, the calculation of the least-cost path is<br>carried out in an iterative, distributed manner by the routers. No node has com-<br>plete information about the costs of all network links. Instead, each node begins<br>with only the knowledge of the costs of its own directly attached links. Then,<br>through an iterative process of calculation and exchange of information with its<br>neighboring nodes, a node gradually calculates the least-cost path to a destination<br>or set of destinations. The decentralized routing algorithm we’ll study below in<br>Section 5.2.2 is called a distance-vector (DV) algorithm, because each node main-<br>tains a vector of estimates of the costs (distances) to all other nodes in the net-<br>work. Such decentralized algorithms, with interactive message exchange between<br>neighboring routers is perhaps more naturally suited to control planes where the<br>routers interact directly with each other, as in Figure 5.1.</p>
<p>​    分散式的路由算法, 其计算最小成本路径的计算通过路由以迭代, 分布的方式计算. 没有节点知晓整个网络节点成本信息. 每个节点在仅知晓自身直连的节点信息的状态下开始, 然后通过列点的方式计算, 并与邻近节点交换细信息, 逐步计算一个/多个节点的最小成本路径. 分散式路由算法进程被成为 distance-vector(DV) 算法, 因为每个节点管理一个保存连接节点成本的向量. 这样的分散算法, 需要在邻近节点交换信息, 或许更加适合和其他节点交互的路由.</p>
<p>​    A second broad way to classify routing algorithms is according to whether they<br>are static or dynamic. In static routing algorithms, routes change very slowly over<br>time, often as a result of human intervention (for example, a human manually editing<br>a link costs). Dynamic routing algorithms change the routing paths as the network<br>traffic loads or topology change. A dynamic algorithm can be run either periodically<br>or in direct response to topology or link cost changes. While dynamic algorithms<br>are more responsive to network changes, they are also more susceptible to problems<br>such as routing loops and route oscillation.</p>
<p>​    第二个区分路由算法的方式是根据其是静态/动态的. 在静态路由算法中, 路由变化十分缓慢, 通常是由于人为干涉. 动态路由算法随着网络流量负载/拓扑变化时更改路由路径. 动态路由算法可以是周期性的, 也可以是直接由拓扑响应/链接成本变化改变. 当动态路由越积极响应网络变化, 也就越容器出现问题, 比如路由循环/路由振荡.</p>
<p>​    A third way to classify routing algorithms is according to whether they are load-<br>sensitive or load-insensitive. In a load-sensitive algorithm, link costs vary dynami-<br>cally to reflect the current level of congestion in the underlying link. If a high cost<br>is associated with a link that is currently congested, a routing algorithm will tend<br>to choose routes around such a congested link. While early ARPAnet routing algo-<br>rithms were load-sensitive [McQuillan 1980], a number of difficulties were encoun-<br>tered [Huitema 1998]. Today’s Internet routing algorithms (such as RIP, OSPF, and<br>BGP) are load-insensitive, as a link’s cost does not explicitly reflect its current (or<br>recent past) level of congestion.</p>
<p>​    第三种区分路由算法的方式是根据其是负载敏感的/负载不敏感的. 在负载敏感的算法中, 连接成本变化反应了当前底层的堵塞状态. 如果链接有高负载, 那么当前链接堵塞. 路由算法将会重新选择路由以然后这个堵塞节点. 早先 ARPAnet的路由算法就是负载敏感的, 今天 Internet 路由算法是负载不敏感的, 当前链接的负载不反应底层的堵塞情况.</p>
<h3 id="5-2-1-The-Link-State-LS-Routing-Algorithm"><a href="#5-2-1-The-Link-State-LS-Routing-Algorithm" class="headerlink" title="5.2.1 The Link-State (LS) Routing Algorithm"></a>5.2.1 The Link-State (LS) Routing Algorithm</h3><p>Recall that in a link-state algorithm, the network topology and all link costs are<br>known, that is, available as input to the LS algorithm. In practice this is accom-<br>plished by having each node broadcast link-state packets to all other nodes in<br>the network, with each link-state packet containing the identities and costs of<br>its attached links. In practice (for example, with the Internet’s OSPF routing<br>protocol, discussed in Section 5.3) this is often accomplished by a link-state<br>broadcast algorithm [Perlman 1999]. The result of the nodes’ broadcast is that<br>all nodes have an identical and complete view of the network. Each node can<br>then run the LS algorithm and compute the same set of least-cost paths as every<br>other node.</p>
<p>回想一下, 在 LS 算法知晓网络的拓扑和链接成本. 实际上是由每个节点广播自身的 link-state 包给网络上其他所有节点来实现的, 每个 link-state 包包含了身份验证和其已附加的链接的负载. 经常由 link-state 广播算法实现. 节点广播的结果是: 所有节点都有统一, 完成的关于整个网络的视图. 每个节点可以运行 LS 算法, 计算得到和其他节点相同的最小负载路径.</p>
<p>The link-state routing algorithm we present below is known as Dijkstra’s<br>algorithm, named after its inventor. A closely related algorithm is Prim’s algo-<br>rithm; see [Cormen 2001] for a general discussion of graph algorithms. Dijkstra’s<br>algorithm computes the least-cost path from one node (the source, which we will<br>refer to as u) to all other nodes in the network. Dijkstra’s algorithm is iterative and<br>has the property that after the kth iteration of the algorithm, the least-cost paths<br>are known to k destination nodes, and among the least-cost paths to all destination<br>nodes, these k paths will have the k smallest costs. Let us define the following<br>notation:</p>
<p>下面将要提出的路由算法名为 Dijkstra 算法. 这个算法从一个节点到网络中的所有其他节点开始, 计算最小负载路径. Dijkstra 算法是迭代的, 在 k 次迭代后依旧有这样的性质. </p>
<p>• D(v): cost of the least-cost path from the source node to destination v as of this<br>iteration of the algorithm.</p>
<p>从起点到重点的最小负载路径负载.</p>
<p>• p(v): previous node (neighbor of v) along the current least-cost path from the<br>source to v.</p>
<p>最小负载路径的上一个节点.</p>
<p>• N′: subset of nodes; v is in N′ if the least-cost path from the source to v is defini-<br>tively known.</p>
<p>节点子集</p>
<p>The centralized routing algorithm consists of an initialization step followed by<br>a loop. The number of times the loop is executed is equal to the number of nodes in<br>the network. Upon termination, the algorithm will have calculated the shortest paths<br>from the source node u to every other node in the network.</p>
<p>集中路由算法由一个初始化步骤和一个循环组成. 循环执行次数与网络中的节点数一致. 运算结束后, 算法将会得出从源节点 u 到网络中每个节点的最小负载路径. </p>
<pre><code>Link-State (LS) Algorithm for Source Node u
1 Initialization:
2 N’ = {u}
3 for all nodes v
4 if v is a neighbor of u
5 then D(v) = c(u,v)
6 else D(v) = ∞
7
8 Loop
9 find w not in N’ such that D(w) is a minimum
10 add w to N’
11 update D(v) for each neighbor v of w and not in N’:
12 D(v) = min(D(v), D(w)+ c(w,v) )
13 /* new cost to v is either old cost to v or known
14 least path cost to w plus cost from w to v */
15 until N’= N</code></pre><p><img src="https://imgur.com/aYU2AT9.png" alt=""></p>
<p><img src="https://imgur.com/w1FDgP2.png" alt=""></p>
<p>As an example, let’s consider the network in Figure 5.3 and compute the least-<br>cost paths from u to all possible destinations. A tabular summary of the algorithm’s<br>computation is shown in Table 5.1, where each line in the table gives the values of<br>the algorithm’s variables at the end of the iteration. Let’s consider the few first steps<br>in detail.</p>
<p>参考图 5.3, 思考以下细节.</p>
<p>• In the initialization step, the currently known least-cost paths from u to its directly<br>attached neighbors, v, x, and w, are initialized to 2, 1, and 5, respectively. Note in<br>particular that the cost to w is set to 5 (even though we will soon see that a lesser-cost<br>path does indeed exist) since this is the cost of the direct (one hop) link from u to<br>w. The costs to y and z are set to infinity because they are not directly connected<br>to u.</p>
<p>在初始化步骤, 当前从 u 到其直连节点 v, x, w 初始化为 2, 1, 5. 因为 y 和 z 没有直连节点, 所以初始化为无穷大.</p>
<p>• In the first iteration, we look among those nodes not yet added to the set N′ and<br>find that node with the least cost as of the end of the previous iteration. That node<br>is x, with a cost of 1, and thus x is added to the set N′. Line 12 of the LS algorithm<br>is then performed to update D(v) for all nodes v, yielding the results shown in the<br>second line (Step 1) in Table 5.1. The cost of the path to v is unchanged. The cost<br>of the path to w (which was 5 at the end of the initialization) through node x is<br>found to have a cost of 4. Hence this lower-cost path is selected and w’s predeces-<br>sor along the shortest path from u is set to x. Similarly, the cost to y (through x) is<br>computed to be 2, and the table is updated accordingly.</p>
<p>第一次迭代, 查找还未添加进 N’ 集合的节点, 获取上一次迭代得到的最小负载节点. 在此例中为 x, 负载 1. 随后 x 加入 N’ 集合. LS 算法第 12 行执行更新 D(v) 运算. 得到的返回在表 5.1 的第二行. 到节点 v 的负载并未改变, w 路径的负载变为了 4. </p>
<p>• In the second iteration, nodes v and y are found to have the least-cost paths (2),<br>and we break the tie arbitrarily and add y to the set N′ so that N′ now contains u,<br>x, and y. The cost to the remaining nodes not yet in N′, that is, nodes v, w, and z,<br>are updated via line 12 of the LS algorithm, yielding the results shown in the third<br>row in Table 5.1.</p>
<p>在第二次迭代中, v 和 y 节点找到了最小负载路径, 并且增加 y 节点到 N’ 中. </p>
<p>• And so on . . .</p>
<p>以此类推…</p>
<p>(LS 算法需要知晓所有节点信息, 其算法复杂度为 O(n * n), 因为每个节点都有可能会改变其他所有节点, 其本质是将已有的节点距离(根据比较获得/最初的无穷大)和新得到的拼接距离做比较, 经过 (n * n) 次循环, 得到的距离就是最短距离)</p>
<h3 id="5-2-2-The-Distance-Vector-DV-Routing-Algorithm"><a href="#5-2-2-The-Distance-Vector-DV-Routing-Algorithm" class="headerlink" title="5.2.2 The Distance-Vector (DV) Routing Algorithm"></a>5.2.2 The Distance-Vector (DV) Routing Algorithm</h3><p>Whereas the LS algorithm is an algorithm using global information, the distance-<br>vector (DV) algorithm is iterative, asynchronous, and distributed. It is distributed in<br>that each node receives some information from one or more of its directly attached<br>neighbors, performs a calculation, and then distributes the results of its calculation<br>back to its neighbors. It is iterative in that this process continues on until no more<br>information is exchanged between neighbors. (Interestingly, the algorithm is also<br>self-terminating—there is no signal that the computation should stop; it just stops.)<br>The algorithm is asynchronous in that it does not require all of the nodes to operate in<br>lockstep with each other. We’ll see that an asynchronous, iterative, self-terminating,<br>distributed algorithm is much more interesting and fun than a centralized algorithm!<br>Before we present the DV algorithm, it will prove beneficial to discuss an impor-<br>tant relationship that exists among the costs of the least-cost paths. Let d x (y) be the<br>cost of the least-cost path from node x to node y. Then the least costs are related by<br>the celebrated Bellman-Ford equation, namely,</p>
<p>不同于 LS 算法使用全局信息, distance-vector(DV) 算法是迭代, 异步, 分布的. </p>
<p>其分布在各个节点上, 接收来自直连节点的信息, 计算, 然后返回其计算结果. 直至没有节点需要交换信息. </p>
<p>这个算法还是异步算法, 不需要所有节点彼此间同步运算. 我们将会见到, 一个异步, 迭代, 自销毁, 的分布算法比集中算法有趣的多. </p>
<pre><code>Distance-Vector (DV) Algorithm
At each node, x:
1 Initialization:
2 for all destinations y in N:
3 D x (y)= c(x,y)/* if y is not a neighbor then c(x,y)= ∞ */
4 for each neighbor w
5 D w (y) = ? for all destinations y in N
6 for each neighbor w
7 send distance vector D x = [D x (y): y in N] to w
8
9 loop
10 wait (until I see a link cost change to some neighbor w or
11 until I receive a distance vector from some neighbor w)
12
13 for each y in N:
14 D x (y) = min v {c(x,v) + D v (y)}
15
16 if Dx(y) changed for any destination y
17 send distance vector D x = [D x (y): y in N] to all neighbors
18
19 forever</code></pre><p>In the DV algorithm, a node x updates its distance-vector estimate when it either<br>sees a cost change in one of its directly attached links or receives a distance-vector<br>update from some neighbor. But to update its own forwarding table for a given des-<br>tination y, what node x really needs to know is not the shortest-path distance to y but<br>instead the neighboring node v<em>(y) that is the next-hop router along the shortest path<br>to y. As you might expect, the next-hop router v</em>(y) is the neighbor v that achieves<br>the minimum in Line 14 of the DV algorithm. (If there are multiple neighbors v that<br>achieve the minimum, then v<em>(y) can be any of the minimizing neighbors.) Thus,<br>in Lines 13–14, for each destination y, node x also determines v</em>(y) and updates its<br>forwarding table for destination y.</p>
<p>在 DV 算法中, 当邻近节点的负载发生变化, 或接收到一个来自邻近节点的 distance-vector 更新时, 会更新自身的 distance-vector 估计. 但是为了更新自身某个节点 y 的转发表, x 实际需要知道的并不是到 y 的最短路径, 而是邻近节点到 y 的最短路径. 如你所料, 邻近节点的最短路径来自 DV 算法第 14 行. </p>
<p>Recall that the LS algorithm is a centralized algorithm in the sense that it<br>requires each node to first obtain a complete map of the network before running the<br>Dijkstra algorithm. The DV algorithm is decentralized and does not use such global<br>information. Indeed, the only information a node will have is the costs of the links<br>to its directly attached neighbors and information it receives from these neighbors.<br>Each node waits for an update from any neighbor (Lines 10–11), calculates its new<br>distance vector when receiving an update (Line 14), and distributes its new distance<br>vector to its neighbors (Lines 16–17). DV-like algorithms are used in many routing<br>protocols in practice, including the Internet’s RIP and BGP, ISO IDRP, Novell IPX,<br>and the original ARPAnet.</p>
<p>LS 算法是集中算法, 其需要先获取所有网络节点信息. 而 DV 算法是分布的, 不需要. 实际上需要的仅仅是邻近节点的信息. 类 DV 算法在现实中应用广泛, 包括 internet 的 RIP, BGP, IOS IDRP, Novell IPX 已经最初的 ARPAnet. (以上我都不知道 :( … )</p>
<p><img src="https://imgur.com/E4wSJ2o.png" alt=""></p>
<p>Figure 5.6 illustrates the operation of the DV algorithm for the simple three-<br>node network shown at the top of the figure. The operation of the algorithm is illus-<br>trated in a synchronous manner, where all nodes simultaneously receive distance<br>vectors from their neighbors, compute their new distance vectors, and inform their<br>neighbors if their distance vectors have changed. After studying this example, you<br>should convince yourself that the algorithm operates correctly in an asynchronous<br>manner as well, with node computations and update generation/reception occurring<br>at any time.</p>
<p>图 5.6 阐释了 DV 算法在简单的三节点网络上的的操作. 算法以异步形式体现. 所有节点同时接收来自邻近节点的 distance-vector. 计算其新 distance vectors, 然后同时其邻近节点(如果有改变的话). </p>
<p>The leftmost column of the figure displays three initial routing tables for each<br>of the three nodes. For example, the table in the upper-left corner is node x’s ini-<br>tial routing table. Within a specific routing table, each row is a distance vector—<br>specifically, each node’s routing table includes its own distance vector and that<br>of each of its neighbors. Thus, the first row in node x’s initial routing table is<br>D x = [D x (x), D x (y), D x (z)] = [0, 2, 7]. The second and third rows in this table are<br>the most recently received distance vectors from nodes y and z, respectively. Because<br>at initialization node x has not received anything from node y or z, the entries in<br>the second and third rows are initialized to infinity.</p>
<p>After initialization, each node sends its distance vector to each of its two neigh-<br>bors. This is illustrated in Figure 5.6 by the arrows from the first column of tables<br>to the second column of tables. For example, node x sends its distance vector D x =<br>[0, 2, 7] to both nodes y and z. After receiving the updates, each node recomputes its<br>own distance vector. For example, node x computes<br>The second column therefore displays, for each node, the node’s new distance vector<br>along with distance vectors just received from its neighbors. Note, for example, that</p>
<p>初始化后, 每个节点将自身的 distance-vector 发生给其邻近节点. 通过图 5.6 的箭头表示. </p>
<p>(应该只会发送变化的节点吧? 不然处理起来应该不太方便)</p>
<p>node x’s estimate for the least cost to node z, D x (z), has changed from 7 to 3. Also<br>note that for node x, neighboring node y achieves the minimum in line 14 of the DV<br>algorithm; thus at this stage of the algorithm, we have at node x that v<em>(y) = y and<br>v</em>(z) = y.<br>After the nodes recompute their distance vectors, they again send their updated<br>distance vectors to their neighbors (if there has been a change). This is illustrated in<br>Figure 5.6 by the arrows from the second column of tables to the third column of<br>tables. Note that only nodes x and z send updates: node y’s distance vector didn’t<br>change so node y doesn’t send an update. After receiving the updates, the nodes then<br>recompute their distance vectors and update their routing tables, which are shown in<br>the third column.</p>
<p>在节点重计算 distance vectors 后, 再重新发送他们已更新的 distance vectors 给其邻近节点</p>
<p>The process of receiving updated distance vectors from neighbors, recomputing<br>routing table entries, and informing neighbors of changed costs of the least-cost path<br>to a destination continues until no update messages are sent. At this point, since no<br>update messages are sent, no further routing table calculations will occur and the<br>algorithm will enter a quiescent state; that is, all nodes will be performing the wait in<br>Lines 10–11 of the DV algorithm. The algorithm remains in the quiescent state until<br>a link cost changes, as discussed next.</p>
<p>(DV 算法是分布的, 它只需要知道其邻近节点信息, 也只需要与邻近节点交互)</p>
<h2 id="A-Comparison-of-LS-and-DV-Routing-Algorithms"><a href="#A-Comparison-of-LS-and-DV-Routing-Algorithms" class="headerlink" title="A Comparison of LS and DV Routing Algorithms"></a>A Comparison of LS and DV Routing Algorithms</h2><p>The DV and LS algorithms take complementary approaches toward computing rout-<br>ing. In the DV algorithm, each node talks to only its directly connected neighbors,<br>but it provides its neighbors with least-cost estimates from itself to all the nodes<br>(that it knows about) in the network. The LS algorithm requires global information.<br>Consequently, when implemented in each and every router, e.g., as in Figure 4.2 and<br>5.1, each node would need to communicate with all other nodes (via broadcast), but<br>it tells them only the costs of its directly connected links. Let’s conclude our study<br>of LS and DV algorithms with a quick comparison of some of their attributes. Recall<br>that N is the set of nodes (routers) and E is the set of edges (links).</p>
<p>DV 和 LS 是两个互补的算法. DV 只需要和其邻近节点交互. 但是其需要交互自身到其他所有节点的最小负载估计. LS 算法需要全局信息, 因此, 在路由上实现时, 每个节点需要和其他所有节点交互(通过广播). 但是只会发送直连节点的信息. 让我们通过一个快速的对比来总结一下 LS 和 DV 算法(N 代表节点结合, E 代表边集合) </p>
<p>• Message complexity. We have seen that LS requires each node to know the cost<br>of each link in the network. This requires O(|N| |E|) messages to be sent. Also,<br>whenever a link cost changes, the new link cost must be sent to all nodes. The DV<br>algorithm requires message exchanges between directly connected neighbors at<br>each iteration. We have seen that the time needed for the algorithm to converge<br>can depend on many factors. When link costs change, the DV algorithm will<br>propagate the results of the changed link cost only if the new link cost results in a<br>changed least-cost path for one of the nodes attached to that link.</p>
<p>信息复杂度: LS 需要每个节点都知道网络中的链接负载. 无论何时链接负载变化, 都必须发送给其余节点. DV 算法需要邻近节点间的信息交换. 这个算法所需时间基于很多因素. 当链接负载发生变化, 信息仅在最小负载路径发生变化时才传播给邻近节点.</p>
<p>• Speed of convergence. We have seen that our implementation of LS is an O(|N| 2 )<br>algorithm requiring O(|N| |E|)) messages. The DV algorithm can converge slowly<br>and can have routing loops while the algorithm is converging. DV also suffers<br>from the count-to-infinity problem.</p>
<p>收敛速度(???): </p>
<p>• Robustness. What can happen if a router fails, misbehaves, or is sabotaged?<br>Under LS, a router could broadcast an incorrect cost for one of its attached links<br>(but no others). A node could also corrupt or drop any packets it received as part<br>of an LS broadcast. But an LS node is computing only its own forwarding tables;<br>other nodes are performing similar calculations for themselves. This means route<br>calculations are somewhat separated under LS, providing a degree of robustness.<br>Under DV, a node can advertise incorrect least-cost paths to any or all destina-<br>tions. (Indeed, in 1997, a malfunctioning router in a small ISP provided national<br>backbone routers with erroneous routing information. This caused other routers<br>to flood the malfunctioning router with traffic and caused large portions of the<br>Internet to become disconnected for up to several hours [Neumann 1997].) More<br>generally, we note that, at each iteration, a node’s calculation in DV is passed on<br>to its neighbor and then indirectly to its neighbor’s neighbor on the next iteration.<br>In this sense, an incorrect node calculation can be diffused through the entire<br>network under DV.</p>
<p>稳定性: 当路由失败, 错误行为, 或者被蓄意破坏时会发生什么? 在 LS 算法中, 路由会广播错误的负载给每个连接的路由(不是其他所有). 节点也可能丢失接收到的广播. 但是 LS 算法仅在只是路由上计算(也就只影响自身). 这意为着节点计算是分离的. 增强了一定的稳定性. 而在 DV 算法中, 节点可能会通知错误的最小负载给邻近节点. 周而复始, 一个节点的计算会影响到其他所有节点.</p>
<p>In the end, neither algorithm is an obvious winner over the other; indeed, both algo-<br>rithms are used in the Internet.</p>
<p>所以, 两种算法各有其优. 都在 Internet 中有使用到.</p>
]]></content>
  </entry>
  <entry>
    <title>read/newFeaturesInC++14</title>
    <url>/2020/01/15/read/newFeaturesInC++14/</url>
    <content><![CDATA[<h2 id="new-features-in-c-14"><a href="#new-features-in-c-14" class="headerlink" title="new features in c++14"></a>new features in c++14</h2><p>From : <a href="https://en.wikipedia.org/wiki/C%2B%2B14" target="_blank" rel="noopener">wiki</a></p>
<h2 id="New-language-features-edit"><a href="#New-language-features-edit" class="headerlink" title="New language features[edit]"></a>New language features[<a href="https://en.wikipedia.org/w/index.php?title=C%2B%2B14&action=edit&section=1" target="_blank" rel="noopener">edit</a>]</h2><p>These are the features added to the core language of C++14.</p>
<h3 id="Function-return-type-deduction-edit"><a href="#Function-return-type-deduction-edit" class="headerlink" title="Function return type deduction[edit]"></a>Function return type deduction[<a href="https://en.wikipedia.org/w/index.php?title=C%2B%2B14&action=edit&section=2" target="_blank" rel="noopener">edit</a>]</h3><p>C++11 allowed <a href="https://en.wikipedia.org/wiki/Lambda_function_(computer_programming)" target="_blank" rel="noopener">lambda functions</a> to deduce the return type based on the type of the expression given to the return statement. C++14 provides this ability to all functions. It also extends these facilities to lambda functions, allowing return type deduction for functions that are not of the form <code>return expression;</code>.<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-wong1-3" target="_blank" rel="noopener">[3]</a></p>
<p>c++允许 lambda 表达式根据返回值表达式推测返回值类型, c++14将其范围提升到了所有函数. </p>
<p>(后面这句我不明白它是什么意思)</p>
<p>In order to induce return type deduction, the function must be declared with <code>auto</code> as the return type, but without the trailing return type specifier in C++11:</p>
<p>为了引进返回值推测, 需要在声明时在返回值类型上带上 auto 关键字. 而不需要尾随返回值说明符.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">auto DeduceReturnType();   &#x2F;&#x2F; Return type to be determined.</span><br></pre></td></tr></table></figure>

<p>If multiple return expressions are used in the function’s implementation, then they must all deduce the same type.<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-deduce-4" target="_blank" rel="noopener">[4]</a></p>
<p>如果函数实现中存在多个返回值表达式, 它们必须被能被推测为一种类型. </p>
<p>Functions that deduce their return types can be forward declared, but they cannot be used until they have been defined. Their definitions must be available to the translation unit that uses them.</p>
<p>返回值类型推导可以前向声明. 但是直到被定义时才能使用. 定义必须能被翻译单元使用.</p>
<p><a href="https://en.wikipedia.org/wiki/Recursion" target="_blank" rel="noopener">Recursion</a> can be used with a function of this type, but the recursive call must happen after at least one return statement in the definition of the function:<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-deduce-4" target="_blank" rel="noopener">[4]</a></p>
<p>递归函数也可以使用返回值推导, 但是必须在至少一个返回语句之后使用.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">auto Correct(int i)</span><br><span class="line">&#123;</span><br><span class="line">  if (i &#x3D;&#x3D; 1)</span><br><span class="line">    return i;             &#x2F;&#x2F; return type deduced as int</span><br><span class="line"></span><br><span class="line">  return Correct(i-1)+i;  &#x2F;&#x2F; ok to call it now</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">auto Wrong(int i)</span><br><span class="line">&#123;</span><br><span class="line">  if (i !&#x3D; 1)</span><br><span class="line">    return Wrong(i-1)+i;  &#x2F;&#x2F; Too soon to call this. No prior return statement.</span><br><span class="line"></span><br><span class="line">  return i;               &#x2F;&#x2F; return type deduced as int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Alternate-type-deduction-on-declaration-5"><a href="#Alternate-type-deduction-on-declaration-5" class="headerlink" title="Alternate type deduction on declaration[5]"></a>Alternate type deduction on declaration<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-5" target="_blank" rel="noopener">[5]</a></h3><p>In C++11, two methods of type deduction were added. <code>auto</code> was a way to create a variable of the appropriate type, based on a given expression. <code>decltype</code> was a way to compute the type of a given expression. However, <code>decltype</code> and <code>auto</code> deduce types in different ways. In particular, <code>auto</code> always deduces a non-reference type, as though by using <code>std::decay</code>, while <code>auto&amp;&amp;</code> always deduces a reference type. However, <code>decltype</code> can be prodded into deducing a reference or non-reference type, based on the value category of the expression and the nature of the expression it is deducing:<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-wong1-3" target="_blank" rel="noopener">[3]</a></p>
<p>在 c++11, 引进了两种类型推导. <code>auto</code> 和 <code>decltype</code> <code>auto</code> 总是推导出非引用类型, <code>decltype</code> 则推导出完整的类型.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int   i;</span><br><span class="line">int&amp;&amp; f();</span><br><span class="line">auto          x3a &#x3D; i;     &#x2F;&#x2F; decltype(x3a) is int</span><br><span class="line">decltype(i)   x3d &#x3D; i;     &#x2F;&#x2F; decltype(x3d) is int</span><br><span class="line">auto          x4a &#x3D; (i);   &#x2F;&#x2F; decltype(x4a) is int</span><br><span class="line">decltype((i)) x4d &#x3D; (i);   &#x2F;&#x2F; decltype(x4d) is int&amp;</span><br><span class="line">auto          x5a &#x3D; f();   &#x2F;&#x2F; decltype(x5a) is int</span><br><span class="line">decltype(f()) x5d &#x3D; f();   &#x2F;&#x2F; decltype(x5d) is int&amp;&amp;</span><br></pre></td></tr></table></figure>

<p>C++14 adds the <code>decltype(auto)</code> syntax. This allows <code>auto</code> declarations to use the <code>decltype</code> rules on the given expression.</p>
<p>c++ 增加了 <code>decltype(auto)</code> 语法, 这使 <code>auto</code> 声明可以在指定表达式上使用 <code>decltype</code> 规则.</p>
<p>The <code>decltype(auto)</code> syntax can also be used with <a href="https://en.wikipedia.org/wiki/C%2B%2B14#Function_return_type_deduction" target="_blank" rel="noopener">return type deduction</a>, by using <code>decltype(auto)</code> syntax instead of <code>auto</code> for the function’s return type deduction.<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-deduce-4" target="_blank" rel="noopener">[4]</a></p>
<p><code>decltype(auto)</code> 语法还可以在返回值类型推导上使用.</p>
<h3 id="Relaxed-constexpr-restrictions-edit"><a href="#Relaxed-constexpr-restrictions-edit" class="headerlink" title="Relaxed constexpr restrictions[edit]"></a>Relaxed constexpr restrictions[<a href="https://en.wikipedia.org/w/index.php?title=C%2B%2B14&action=edit&section=4" target="_blank" rel="noopener">edit</a>]</h3><p><a href="https://en.wikipedia.org/wiki/C%2B%2B11" target="_blank" rel="noopener">C++11</a> introduced the concept of a constexpr-declared function; a function which could be executed at compile time. Their return values could be consumed by operations that require constant expressions, such as an integer template argument. However, C++11 constexpr functions could only contain a single expression that is returned (as well as <code>static_assert</code>s and a small number of other declarations).</p>
<p>c++引进了常量声明函数(一个可以在编译期执行的函数). 他么的返回值可以被常量表达式使用. 然而, c++11 常量表达式函数只能包含单个返回的表达式</p>
<p>C++14 relaxes these restrictions. Constexpr-declared functions may now contain the following:<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-wong1-3" target="_blank" rel="noopener">[3]</a></p>
<p>c++14 取消了这些限制, 常量表达式函数可以包含以下: </p>
<ul>
<li><p>Any declarations except:</p>
<ul>
<li><p><code>static</code> or <code>thread_local</code> variables.</p>
<p><code>staic</code> 或 <code>thread_local</code> 变量.</p>
</li>
<li><p>Variable declarations without initializers.</p>
<p>没有初始化的变量声明(???)</p>
</li>
</ul>
</li>
<li><p>The conditional branching statements <code>if</code> and <code>switch</code>.</p>
<p>if 和 switch 条件语句</p>
</li>
<li><p>Any looping statement, including range-based <code>for</code>.</p>
<p>任何循环语句, 包括基于循环的 for</p>
</li>
<li><p>Expressions which change the value of an object if the lifetime of that object began within the constant expression function. This includes calls to any non-<code>const</code> <code>constexpr</code>-declared non-static member functions.</p>
<p>可更改开始于常量表达式函数的对象的值. 这包括任何对非常属性, 常量表达式定义, 非静态成员函数的调用.</p>
</li>
</ul>
<p><code>goto</code> statements are forbidden in C++14 relaxed constexpr-declared functions.</p>
<p>Also, C++11 stated that all non-static member functions that were declared <code>constexpr</code> were also implicitly declared <code>const</code>, with respect to <code>this</code>. That has since been removed; non-static member functions may be non-<code>const</code>.<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-6" target="_blank" rel="noopener">[6]</a> However, per the restrictions above, a non-<code>const</code> <code>constexpr</code> member function can only modify a class member if that object’s lifetime began within the constant expression evaluation.</p>
<p>C++11规定所有非静态, 被 <code>constexpr</code> 声明的成员函数是隐式声明为 <code>const</code> 的. 这同样也被移除了, 非静态成员函数可以是 <code>non-const</code> 的. 然而, 根据上面的限制, 一个 <code>non-const</code> <code>constexpr</code> 的成员函数只能更改对象生命周期随常量表达式求值开始的对象的成员(???) </p>
<p>(我在其他文档中并未看到具体的关于更改值的介绍, 我简单理解的话, constexpr 现已可以支持循环和分支语句, 并且可以包含 static 和 thread_local 变量)</p>
<h3 id="Variable-templates-edit"><a href="#Variable-templates-edit" class="headerlink" title="Variable templates[edit]"></a>Variable templates[<a href="https://en.wikipedia.org/w/index.php?title=C%2B%2B14&action=edit&section=5" target="_blank" rel="noopener">edit</a>]</h3><p>In prior versions of <a href="https://en.wikipedia.org/wiki/C%2B%2B" target="_blank" rel="noopener">C++</a>, only functions, classes or type aliases could be templated. C++14 now allows the creation of variables that are templated. An example given in the proposal is a variable <code>pi</code> that can be read to get the value of <a href="https://en.wikipedia.org/wiki/Pi" target="_blank" rel="noopener">pi</a> for various types (e.g., <code>3</code> when read as an integral type; the closest value possible with <code>float</code>, <code>double</code> or <code>long double</code> precision when read as <code>float</code>, <code>double</code> or <code>long double</code>, respectively; etc.).</p>
<p>在之前版本的 C++ 中, 类/类型别名可以模板化, C++14 允许创建变量模板. </p>
<p>The usual rules of templates apply to such declarations and definitions, including specialization.<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-isocpp-7" target="_blank" rel="noopener">[7]</a><a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-8" target="_blank" rel="noopener">[8]</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">constexpr T pi &#x3D; T(3.141592653589793238462643383);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Usual specialization rules apply:</span><br><span class="line">template&lt;&gt;</span><br><span class="line">constexpr const char* pi&lt;const char*&gt; &#x3D; &quot;pi&quot;;</span><br></pre></td></tr></table></figure>



<h3 id="Aggregate-member-initialization-edit"><a href="#Aggregate-member-initialization-edit" class="headerlink" title="Aggregate member initialization[edit]"></a>Aggregate member initialization[<a href="https://en.wikipedia.org/w/index.php?title=C%2B%2B14&action=edit&section=6" target="_blank" rel="noopener">edit</a>]</h3><p><a href="https://en.wikipedia.org/wiki/C%2B%2B11" target="_blank" rel="noopener">C++11</a> added member initializers, expressions to be applied to members at class scope if a constructor did not initialize the member itself. The definition of aggregates was changed to explicitly exclude any class with member initializers; therefore, they are not allowed to use aggregate initialization.</p>
<p>C++14 relaxes this restriction,<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-wong1-3" target="_blank" rel="noopener">[3]</a> allowing aggregate initialization on such types. If the braced init list does not provide a value for that argument, the member initializer takes care of it.<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-9" target="_blank" rel="noopener">[9]</a></p>
<p>(我不明白说的什么, 成员初始化不是 C++11 就有的么?)</p>
<h3 id="Binary-literals-edit"><a href="#Binary-literals-edit" class="headerlink" title="Binary literals[edit]"></a>Binary literals[<a href="https://en.wikipedia.org/w/index.php?title=C%2B%2B14&action=edit&section=7" target="_blank" rel="noopener">edit</a>]</h3><p>Numeric literals in C++14 can be specified in <a href="https://en.wikipedia.org/wiki/Binary_number" target="_blank" rel="noopener">binary form</a>.<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-wong1-3" target="_blank" rel="noopener">[3]</a> The syntax uses the prefixes <code>0b</code> or <code>0B</code>. The syntax is also used in other languages e.g. <a href="https://en.wikipedia.org/wiki/Java_(programming_language)" target="_blank" rel="noopener">Java</a>, <a href="https://en.wikipedia.org/wiki/C_Sharp_(programming_language)" target="_blank" rel="noopener">C#</a>, <a href="https://en.wikipedia.org/wiki/Swift_(programming_language)" target="_blank" rel="noopener">Swift</a>, <a href="https://en.wikipedia.org/wiki/Go_(programming_language)" target="_blank" rel="noopener">Go</a>, <a href="https://en.wikipedia.org/wiki/Scala_(programming_language)" target="_blank" rel="noopener">Scala</a>, <a href="https://en.wikipedia.org/wiki/Ruby_(programming_language)" target="_blank" rel="noopener">Ruby</a>, <a href="https://en.wikipedia.org/wiki/Python_(programming_language)" target="_blank" rel="noopener">Python</a>, <a href="https://en.wikipedia.org/wiki/OCaml" target="_blank" rel="noopener">OCaml</a>, and as an unofficial extension in some C compilers since at least 2007.<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-gccbinaryliteralbugreport-10" target="_blank" rel="noopener">[10]</a></p>
<h3 id="Digit-separators-edit"><a href="#Digit-separators-edit" class="headerlink" title="Digit separators[edit]"></a>Digit separators[<a href="https://en.wikipedia.org/w/index.php?title=C%2B%2B14&action=edit&section=8" target="_blank" rel="noopener">edit</a>]</h3><p>In C++14, the single-quote character may be used arbitrarily as a <a href="https://en.wikipedia.org/wiki/Integer_literal#Digit_separators" target="_blank" rel="noopener">digit separator</a> in numeric literals, both <a href="https://en.wikipedia.org/wiki/Integer_literal" target="_blank" rel="noopener">integer literals</a> and floating point literals.<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-11" target="_blank" rel="noopener">[11]</a> This can make it easier for human readers to parse large numbers through <a href="https://en.wikipedia.org/wiki/Subitizing" target="_blank" rel="noopener">subitizing</a>.</p>
<p>auto integer_literal = 1’000’000;<br> auto floating_point_literal = 0.000’015’3;<br> auto binary_literal = 0b0100’1100’0110;<br> auto silly_example = 1’0’0’000’00;</p>
<p>C++14中, 单引号专用于整数/浮点数表示, 使人看起来可以更加清晰(woo, 真是个人性化的功能)</p>
<h3 id="Generic-lambdas-edit"><a href="#Generic-lambdas-edit" class="headerlink" title="Generic lambdas[edit]"></a>Generic lambdas[<a href="https://en.wikipedia.org/w/index.php?title=C%2B%2B14&action=edit&section=9" target="_blank" rel="noopener">edit</a>]</h3><p>In C++11, <a href="https://en.wikipedia.org/wiki/Anonymous_function" target="_blank" rel="noopener">lambda function</a> parameters need to be declared with concrete types. C++14 relaxes this requirement, allowing lambda function parameters to be declared with the <code>auto</code> type specifier.<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-isocpp-7" target="_blank" rel="noopener">[7]</a></p>
<p>在 C++11 中, lambda 函数参数声明必须具有具体的类型, C++14 放松了这个要求, 允许 lambda 函数参数使用 auto 关键字声明, 如下: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">auto lambda &#x3D; [](auto x, auto y) &#123;return x + y;&#125;;</span><br></pre></td></tr></table></figure>

<p>Concerning <code>auto</code> type deduction, generic lambdas follow the rules of template argument deduction (which are similar, but not identical in all respects[*<a href="https://en.wikipedia.org/wiki/Wikipedia:Please_clarify" target="_blank" rel="noopener">clarification needed</a>*]). The code above is equivalent to this:<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-12" target="_blank" rel="noopener">[12]</a></p>
<p>关于 auto 类型推导, 泛型 lambdas 遵循模板参数推导原则. 上述代码等同于以下:</p>
<p>(其实也证实了, 与其说是匿名函数, 不如说是带 () 重载的匿名类)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct</span><br><span class="line">&#123;</span><br><span class="line">  template&lt;typename T, typename U&gt;</span><br><span class="line">    auto operator()(T x, U y) const &#123;return x + y;&#125;</span><br><span class="line">&#125; lambda&#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>Generic lambdas are essentially templated functor lambdas.</p>
<p>泛型 lambdas 是更高效的函数模板</p>
<h3 id="Lambda-capture-expressions-edit"><a href="#Lambda-capture-expressions-edit" class="headerlink" title="Lambda capture expressions[edit]"></a>Lambda capture expressions[<a href="https://en.wikipedia.org/w/index.php?title=C%2B%2B14&action=edit&section=10" target="_blank" rel="noopener">edit</a>]</h3><p>C++11 lambda functions capture variables declared in their outer scope by value-copy or by reference. This means that value members of a lambda cannot be move-only types.<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-13" target="_blank" rel="noopener">[13]</a> C++14 allows captured members to be initialized with arbitrary expressions. This allows both capture by value-move and declaring arbitrary members of the lambda, without having a correspondingly named variable in an outer scope.<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-isocpp-7" target="_blank" rel="noopener">[7]</a></p>
<p>C++11 在其所在作用域中按值/引用捕获变量, 这意味着 lambda 成员的值不能是 move-only 类型. C++14 循序被捕获变量以任意形式初始化. 这使所有捕获可以值/移动, 以及声明任意的 lambda 成员, 而不需要在外层作用域中有对应的已命名成员.</p>
<p>This is done via the use of an initializer expression:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">auto lambda &#x3D; [value &#x3D; 1] &#123;return value;&#125;;</span><br></pre></td></tr></table></figure>

<p>The lambda function <code>lambda</code> returns 1, which is what <code>value</code> was initialized with. The declared capture deduces the type from the initializer expression as if by <code>auto</code>.</p>
<p>声明捕获像 auto 一样推导初始化表达式.</p>
<p>This can be used to capture by move, via the use of the standard <code>std::move</code> function:</p>
<p>还可以用于捕获移动语义(赞啊 -v- )</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">std::unique_ptr&lt;int&gt; ptr(new int(10));</span><br><span class="line">auto lambda &#x3D; [value &#x3D; std::move(ptr)] &#123;return *value;&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="The-attribute-deprecated-edit"><a href="#The-attribute-deprecated-edit" class="headerlink" title="The attribute [[deprecated]][edit]"></a>The attribute <code>[[deprecated]]</code>[<a href="https://en.wikipedia.org/w/index.php?title=C%2B%2B14&action=edit&section=11" target="_blank" rel="noopener">edit</a>]</h3><p>The <code>deprecated</code> attribute allows marking an entity <a href="https://en.wikipedia.org/wiki/Deprecated" target="_blank" rel="noopener">deprecated</a>, which makes it still legal to use but puts users on notice that use is discouraged and may cause a warning message to be printed during compilation. An optional <a href="https://en.wikipedia.org/wiki/String_literal" target="_blank" rel="noopener">string literal</a> can appear as the argument of <code>deprecated</code>, to explain the rationale for deprecation and/or to suggest a replacement.</p>
<p>deprecated 属性可以标记一个整体为’废弃的’, 继续使用这个整体是合法的, 但是用户会在编译时收到一个警告. </p>
<p>deprecated 可以增加字符串文本, 用作警示语.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[deprecated]] int f();</span><br><span class="line"></span><br><span class="line">[[deprecated(&quot;g() is thread-unsafe. Use h() instead&quot;)]]</span><br><span class="line">void g( int&amp; x );</span><br><span class="line"></span><br><span class="line">void h( int&amp; x );</span><br><span class="line"></span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">  int a &#x3D; f(); &#x2F;&#x2F; warning: &#39;f&#39; is deprecated</span><br><span class="line">  g(a); &#x2F;&#x2F; warning: &#39;g&#39; is deprecated: g() is thread-unsafe. Use h() instead</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(在 gcc (Debian 6.3.0-18+deb9u1) 6.3.0 20170516 版本下, 对于类的支持有所不足)</p>
<h2 id="New-standard-library-features-edit"><a href="#New-standard-library-features-edit" class="headerlink" title="New standard library features[edit]"></a>New standard library features[<a href="https://en.wikipedia.org/w/index.php?title=C%2B%2B14&action=edit&section=12" target="_blank" rel="noopener">edit</a>]</h2><h3 id="Shared-mutexes-and-locking-edit"><a href="#Shared-mutexes-and-locking-edit" class="headerlink" title="Shared mutexes and locking[edit]"></a>Shared mutexes and locking[<a href="https://en.wikipedia.org/w/index.php?title=C%2B%2B14&action=edit&section=13" target="_blank" rel="noopener">edit</a>]</h3><p>C++14 adds a shared timed mutex and a companion shared lock type.<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-wong3-14" target="_blank" rel="noopener">[14]</a><a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-15" target="_blank" rel="noopener">[15]</a></p>
<p>C++14 增加了共享互斥锁, 以及他的’伴侣’共享锁类型.</p>
<p>(这里有点不好说, mutex 本身是一把锁, 而 lock 也是锁的意思, 不过是加锁, lock(mutex), emm, 应该是这意思)</p>
<h3 id="Heterogeneous-lookup-in-associative-containers-edit"><a href="#Heterogeneous-lookup-in-associative-containers-edit" class="headerlink" title="Heterogeneous lookup in associative containers[edit]"></a>Heterogeneous lookup in associative containers[<a href="https://en.wikipedia.org/w/index.php?title=C%2B%2B14&action=edit&section=14" target="_blank" rel="noopener">edit</a>]</h3><p>The <a href="https://en.wikipedia.org/wiki/C%2B%2B_Standard_Library" target="_blank" rel="noopener">C++ Standard Library</a> defines four associative container classes. These classes allow the user to look up a value based on a value of that type. The map containers allow the user to specify a key and a value, where lookup is done by key and returns a value. However, the lookup is always done by the specific key type, whether it is the key as in maps or the value itself as in sets.</p>
<p>C++ 标准库定义了四种关联的容器类, 这些类型使用户可以检查基于该值类型的值. 然而, 检查总是需要指定类型来完成 (??? 卧槽 你想干嘛???)</p>
<p>C++14 allows the lookup to be done via an arbitrary type, so long as the comparison operator can compare that type with the actual key type.<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-wong2-16" target="_blank" rel="noopener">[16]</a> This would allow a map from <code>std::string</code> to some value to compare against a <code>const char*</code> or any other type for which an <code>operator&lt;</code>overload is available. It is also useful for indexing composite objects in a <code>std::set</code> by the value of a single member without forcing the user of <code>find</code> to create a dummy object (for example creating an entire <code>struct Person</code> to find a person by name).</p>
<p>C++14 允许检查可以经由任意类型完成, 只要对比操作可以和正确的键类型对比. 这使 map&lt;std::string&gt;可以和 const char* 类型的值或其他有有效 &lt; 重载的操作符的类型(为什么一定是 <code>&lt;</code> ?  <code>&gt;</code> 它不香么?) </p>
<p>当要检查一个集合中的复合类型时, 不需要创建一个复杂的复合类型也可以检索 (比如: 检索 struct person, 可以使用他的名字, 而并不需要创建一个 person 对象)</p>
<p>To preserve backwards compatibility, heterogeneous lookup is only allowed when the comparator given to the associative container allows it. The standard library classes <code>std::less&lt;&gt;</code> and <code>std::greater&lt;&gt;</code> are augmented to allow heterogeneous lookup.<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-17" target="_blank" rel="noopener">[17]</a></p>
<p>为了保持向后兼容性, heterogeneous 检查只在关联的容器允许对比器时才适用. 标准库 std::less&lt;&gt;, std::greater&lt;&gt; 被 heterogeneous 检查接纳 (诶, 我不知道这该怎么写…)</p>
<p>(这是我在网上找到的代码, 其中两个包含 thread::id 的重载缺一不可, 也就是说编译器都会用到)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ThreadCmp</span> &#123;</span></span><br><span class="line">  <span class="keyword">using</span> is_transparent = <span class="keyword">void</span>;</span><br><span class="line">  <span class="comment">// Regular overload.</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::thread&amp; a, <span class="keyword">const</span> <span class="built_in">std</span>::thread&amp; b)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.get_id() &lt; b.get_id();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Transparent overloads</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::thread&amp; a, <span class="built_in">std</span>::thread::id b)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.get_id() &lt; b;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="built_in">std</span>::thread::id a, <span class="keyword">const</span> <span class="built_in">std</span>::thread&amp; b)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &lt; b.get_id();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//bool operator()(std::thread::id a, std::thread::id b) const &#123;</span></span><br><span class="line">  <span class="comment">//  return a &lt; b;</span></span><br><span class="line">  <span class="comment">//&#125;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::thread, ThreadCmp&gt; threads;</span><br><span class="line">    <span class="comment">// Can't construct an instance of `std::thread` with the same id, just to do the lookup.</span></span><br><span class="line">    <span class="comment">// But we can look up by id instead.</span></span><br><span class="line">    <span class="built_in">std</span>::thread::id id = this_thread::get_id();;</span><br><span class="line">    <span class="keyword">auto</span> it = threads.<span class="built_in">find</span>(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h3 id="Standard-user-defined-literals-edit"><a href="#Standard-user-defined-literals-edit" class="headerlink" title="Standard user-defined literals[edit]"></a>Standard user-defined literals[<a href="https://en.wikipedia.org/w/index.php?title=C%2B%2B14&action=edit&section=15" target="_blank" rel="noopener">edit</a>]</h3><p>C++11 defined the syntax for user-defined literal suffixes, but the standard library did not use any of them. C++14 adds the following standard literals:<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-wong2-16" target="_blank" rel="noopener">[16]</a></p>
<p>C++14 增加了以下标准字面量</p>
<ul>
<li><p>“s”, for creating the various <code>std::basic_string</code> types.</p>
<p>“s”, 创建各种 <code>std::basic_string</code> 类型</p>
</li>
<li><p>“h”, “min”, “s”, “ms”, “us”, “ns”, for creating the corresponding <code>std::chrono::duration</code> time intervals.</p>
<p>“h”, “min”, “s”, “ms”, “us”, “ns”, 创建对应的 <code>std::chrono::duration</code> 时间间隔</p>
</li>
<li><p>“if”, “i”, “il”, for creating the corresponding <code>std::complex</code>, <code>std::complex</code> and <code>std::complex</code> imaginary numbers.</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">auto str &#x3D; &quot;hello world&quot;s; &#x2F;&#x2F; auto deduces string</span><br><span class="line">auto dur &#x3D; 60s;            &#x2F;&#x2F; auto deduces chrono::seconds</span><br><span class="line">auto z   &#x3D; 1i;             &#x2F;&#x2F; auto deduces complex&lt;double&gt;</span><br></pre></td></tr></table></figure>

<p>The two “s” literals do not interact, as the string one only operates on <a href="https://en.wikipedia.org/wiki/String_literal" target="_blank" rel="noopener">string literals</a>, and the one for seconds operates only on numbers.<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-18" target="_blank" rel="noopener">[18]</a></p>
<h3 id="Tuple-addressing-via-type-edit"><a href="#Tuple-addressing-via-type-edit" class="headerlink" title="Tuple addressing via type[edit]"></a>Tuple addressing via type[<a href="https://en.wikipedia.org/w/index.php?title=C%2B%2B14&action=edit&section=16" target="_blank" rel="noopener">edit</a>]</h3><p>The <code>std::tuple</code> type introduced in C++11 allows an aggregate of typed values to be indexed by a compile-time constant integer. C++14 extends this to allow fetching from a tuple by type instead of by index.<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-wong2-16" target="_blank" rel="noopener">[16]</a> If the tuple has more than one element of the type, a compile-time error results:<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-19" target="_blank" rel="noopener">[19]</a></p>
<p>C++14 扩展了 <code>std::tuple</code> , 可以通过类型来获取元素, 如果 tuple 有多个相同类型, 则会出错.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tuple&lt;string, string, int&gt; t(&quot;foo&quot;, &quot;bar&quot;, 7);</span><br><span class="line">int i &#x3D; get&lt;int&gt;(t);        &#x2F;&#x2F; i &#x3D;&#x3D; 7</span><br><span class="line">int j &#x3D; get&lt;2&gt;(t);          &#x2F;&#x2F; Same as before: j &#x3D;&#x3D; 7</span><br><span class="line">string s &#x3D; get&lt;string&gt;(t);  &#x2F;&#x2F; Compile-time error due to ambiguity</span><br></pre></td></tr></table></figure>



<h3 id="Smaller-library-features-edit"><a href="#Smaller-library-features-edit" class="headerlink" title="Smaller library features[edit]"></a>Smaller library features[<a href="https://en.wikipedia.org/w/index.php?title=C%2B%2B14&action=edit&section=17" target="_blank" rel="noopener">edit</a>]</h3><p><code>std::make_unique</code> can be used like <code>std::make_shared</code> for <code>std::unique_ptr</code> objects.<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-isocpp-7" target="_blank" rel="noopener">[7]</a></p>
<p><code>std::integral_constant</code> gained an <code>operator()</code> overload to return the constant value.<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-wong2-16" target="_blank" rel="noopener">[16]</a></p>
<p>The class template <code>std::integer_sequence</code> and related alias templates were added for representing compile-time integer sequences, such as the indices of elements in a parameter pack.<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-intseqs-20" target="_blank" rel="noopener">[20]</a></p>
<p>The global <code>std::begin</code>/<code>std::end</code> functions were augmented with <code>std::cbegin</code>/<code>std::cend</code> functions, which return constant iterators, and <code>std::rbegin</code>/<code>std::rend</code> and <code>std::crbegin</code>/<code>std::crend</code> which return reverse iterators.</p>
<p>The <code>std::exchange</code> function template assigns a new value to a variable and returns the old value.<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-exchange-21" target="_blank" rel="noopener">[21]</a></p>
<p>New overloads of <code>std::equal</code>, <code>std::mismatch</code>, and <code>std::is_permutation</code> take a pair of iterators for the second range, so that the caller does not need to separately check that the two ranges are of the same length.<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-robustseqs-22" target="_blank" rel="noopener">[22]</a></p>
<p>The <code>std::is_final</code> type trait detects if a class is marked <code>final</code>.</p>
<p>The <code>std::quoted</code> stream I/O manipulator allows inserting and extracting strings with embedded spaces, by placing delimiters (defaulting to double-quotes) on output and stripping them on input, and escaping any embedded delimiters.<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-quoted-23" target="_blank" rel="noopener">[23]</a></p>
<h2 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h2><ol>
<li><p>类型推导, type deduce</p>
<p>以 <code>auto</code> 为主, 可以推导返回值而不需返回值后置语法. 同时 <code>decltype</code> 可以用于推导 auto 的原类型</p>
</li>
<li><p>常量表达式加强 <code>constexpr</code></p>
<p><code>constexpr</code> 中可以有静态变量, thread_local 变量, 可以有分支和循环语句</p>
</li>
<li><p>值模板 variable template</p>
<p>不仅类, 现在值也可以模板化</p>
</li>
<li><p>数字分隔符 digit separators</p>
<p>使数字更加易读</p>
</li>
<li><p>加强 lambda</p>
<p>lambda 的参数可以是 auto 推导的了, 同时 lambda 的捕获增加了移动语义, 还可以不是外部成员(也就是自建变量)</p>
</li>
<li><p>关键字 [[deprecated]]</p>
<p>用于警示用户</p>
</li>
<li><p>新的字面量, “s”, “h”, “min” … </p>
<p>新的字面量, 用于快捷创建变量, 而不需显式转换类型</p>
</li>
<li><p>新的 tuple 元素索引方式</p>
<p>可以用类型来检索了呢 :)</p>
</li>
</ol>
<p>以上是我从 C++14 中印象比较深刻的新特性</p>
<p>these are my impressive new features in c++14 </p>
]]></content>
  </entry>
  <entry>
    <title>other/memoryAndCache</title>
    <url>/2020/01/10/other/memoryAndCache/</url>
    <content><![CDATA[<p>#内层对齐补齐与分支目标缓冲器<br>    出自《C++反汇编技术分析与揭秘》<br>    此书我并没有读完，收获是对于底层更加了解，有2个点更加清楚了</p>
<h2 id="内存对齐与补齐，为什么是4字节"><a href="#内存对齐与补齐，为什么是4字节" class="headerlink" title="内存对齐与补齐，为什么是4字节"></a>内存对齐与补齐，为什么是4字节</h2><ul>
<li><p>CPU运算的第二梯队是cache（高速缓冲区），它的访问速度仅次于寄存器</p>
</li>
<li><p>cache中有虚拟地址映射，当运算时会从中拿到地址进行寻址操作</p>
</li>
<li><p>同时32位机的寄存器位数为32位，我们常用的数据整形int和指针的大小也为4字节</p>
</li>
<li><p>思考2个问题：</p>
<ul>
<li><p>一般常用的数据类型基本是4字节以上（除单个的char和short）</p>
</li>
<li><p>cache的内存十分宝贵，里面保存的地址是否有必要精确到1位  </p>
<p>对于cache进行了优化，其中保存的内存地址会丢弃后两位，丢弃之后，寻址操作只能基于4字节的倍数<br>所以对齐补齐是以4字节为基础的</p>
</li>
</ul>
</li>
</ul>
<h2 id="对于循环的优化"><a href="#对于循环的优化" class="headerlink" title="对于循环的优化"></a>对于循环的优化</h2><ul>
<li><p>先考虑流水线优化，其原理很简单：<br>  A B C D四个工人，当一个任务来的时候，顺序是A-&gt;B-&gt;C-&gt;D<br>  当A做完了，继续来了第2个任务，在此时，B在做第一个任务的第二步，参考如图：</p>
<ol>
<li><p>A B C D</p>
</li>
<li><p>&emsp;A B C D    </p>
</li>
<li><p>&emsp; &emsp;A B C D</p>
</li>
<li><p>……  </p>
<p>其核心是，如果只有一个任务，那么就需要花费一整段工作时间<br>而如果是多个任务，例如2个任务，那么就是5/4的时间，以此类推</p>
</li>
</ol>
</li>
<li><p>分支目标缓冲器，考虑下面的循环：  </p>
<pre><code>/**
*@brief 外层循环做10次
*/
for (int i = 0; i &lt; 10; ++i)
{
    /**
    *@brief 内层做1000次循环，第一次不预测，预测成功999次，第1001次预测失败
    */
    for (int j = 0; j &lt; 1000; ++j)
    {
        //...
    }
}</code></pre><p>  分支目标缓冲器要结合流水线优化来理解<br>  当第一个分支启动时，分支目标缓冲器不进行预测，当第二次循环进行时，进行预测，预测成功，直到失败<br>  分支目标缓冲器是经验主义，预测越多，优化更好，如果多次失败，则会刷新<br>  （intel的CPU是这样的，当进行一个分支时，下一个分支已经在进行预测了，它对true/false的情况进行预测<br>  ，也就是在这次分支执行时，下一次分支已经准备好了（其中的同步这些则是更底层的知识了）如果预测失败则会回流，<br>  如果预测成功，将会节省时间以达到提升性能的目的）</p>
<p>  如果外层分支进行10次，内层分支进行1000次，那么1次不预测，999次成功，最后一次失败，这样的操作重复10次<br>  则 10 x 999 = 9990 次<br>  如果外层分支进行1000次，内层分支进行10次，那么1次不预测，9次成功，最后一次失败，这样的操作重复1000次<br>  则 9 x 1000 = 9000 次<br>  分支预测是经验主义，预测越多，优化也就更好，所以：<br>  <strong>多重循环，内层循环次数应大于外层循环次数</strong><br>  PS：这需要结合CPU来考虑，intel的CPU是这样的，AMD就不知道了</p>
</li>
</ul>
<p>至于switch，if，等等，都有优化，具体以后再补，分支的结构类似于函数调用，都会发生跳转（inline例外）<br>PS：强推程序应当了解底层知识，编译器优化和汇编，如果了解了底层，很多知识点都能迎刃而解<br>当然，前提是有那耐心，一个简单的除法编译器都可能会优化成一堆计算机处理比较简单，而人理解起来就很头疼的代码<br>那涉及到数学方面的知识，并且不简单…</p>
]]></content>
  </entry>
  <entry>
    <title>other/encode</title>
    <url>/2020/01/10/other/encode/</url>
    <content><![CDATA[<p>#为什么是-128<del>127?<br>我们常说char类型数据占1个字节,范围是-128</del>127<br>OK,1字节八位,1位为符号为,7位存储数据,但是为什么负数要比正数多一个呢?</p>
<p>这涉及到补码和反码的概念,8位能表示2^8+1种变化(我更偏向于称它为变化,因为计算机中的二进制是我们赋予他的意义,这里+1指的是0)<br>也就是0<del>255,256个数字,所以-128</del>127是正确的<br>考虑一下0会如何被表示:</p>
<pre><code>在符号位为正的情况下为 0000 0000  
在符号位为负的情况下为 1000 0000  </code></pre><p>同样的数,他们表示方式重叠了,这显然不好<br>所以CPU采用了正数和负数表示方式不同的方法来解决这个问题<br>负数的表现方式为 补码: 反码 + 1</p>
<p>##反码<br>就和它的名字一样,它的意义是除符号位外,其他所有位取反<br>例如 0000 0000 取反为 0111 1111</p>
<p>##补码<br>补码即为反码 + 1</p>
<p>有了以上知识,那么可以得知以下二进制表示多少(假设为1 byte):</p>
<pre><code>1111 1111 反码:1000 0000 补码:1000 0001 表示 -1
1000 0000 反码:1111 1111 补码:(这里不好表示o(*￣▽￣*)ブ) 表示:-128</code></pre><p>所以,为什么负数比正数多了一个呢?<br>因为计算机内部结构(补码)造成了负数比正数能多表达一个(这一个是来自于-0这个概念,因为我们更加偏向于+0而不是-0,<br>所以就让正数吃亏了,也不仅仅是这样,在很多我无法举例但的确存在的某些”骚操作”里面,这种方式给予了很大的支持)</p>
<p>这里也映射了很多概念,比如一个数已经表示最大了(比如char的127)我将它+1 为什么他表示了-128?</p>
<pre><code>127二进制 0111 1111
+1之后 1000 0000(很熟悉吧,就在上面,这表示了负最大)</code></pre><p>PS:底层的东西很有趣,不然为什么编译原理和操作系统凭什么被认为是程序三大浪漫(还有一个是图形学,<br>emmm 三大浪漫有很多争议,有些认为应当包含数据库和算法,新的三大浪漫还有人工智能和机器视觉等等)</p>
<p>PS:关于符号位扩展</p>
<p>思考下面代码<br>    (x &lt;&lt; 1) &gt;&gt; 1<br>x左移一位后又右移一位, 乍一看并没有什么改变, 这涉及到符号位的扩展问题  </p>
<p>对于移位操作, 左移都补0, 而右移因为反码的关系:正数移位补0, 而负数移位补1, 所以当x左移改变了符号位时,再右移,它的值将会发生改变<br>具体改变的规律是符号位发生改变, 而数值上的体现涉及到负数会补码, 所以改变前后可能是两个看起来完全不同但其实有规律的值</p>
]]></content>
  </entry>
  <entry>
    <title>other/overFlowAndCarry</title>
    <url>/2020/01/10/other/overFlowAndCarry/</url>
    <content><![CDATA[<p>##对于溢出和越界的理解(overflow/outside range)</p>
<p>x86汇编flag寄存器有两个表示位, 分别位OF/CF, 溢出标志位/进位标志位<br>其中OF只对有符号数有效, 例如:<br>当两个1字节大小的数字相加时, A: 0111 1111 (127), B: 0000 0001 (1)<br>A + B = 128, 对应二进制位是 1000 0000, 但是对于有符号数来说, 这是负数, 计算结果是错误的<br>这里错误的原因是计算结果<strong>占用了一个不该它占有的有效位</strong><br>不该它占有: 它占有了符号位, 这个位错误地被计算结果改变<br>有效: 这个符号位是被合理分配的, 并不是未定义的</p>
<p>CF只对无符号数有效, 例如:<br>当两个1字节大小的数字相加时, A: 1111 1111 (255), B: 0000 0001 (1)<br>A + B = 256, 对应二进制位是 1 0000 0000, 1字节大小存不下9bit, 计算结果无法保存, 产生错误<br>错误原因是: 计算结果<strong>超出了合理的范围, 这个位未被定义</strong><br>同样不该它占有, 但是同时这是个<strong>未被定义的空间</strong>  </p>
<p>那么就可以简单看出, 从寄存器角度, 溢出/越界的区分了, <strong>那个位是否有效</strong><br>(但是也不一定…)</p>
<pre><code>vector&lt;int&gt; veci{1, 2, 3};
vector&lt;int&gt;::iterator it1 = veci.begin();
vector&lt;int&gt;::iterator it2 = veci.begin() + 1; 

veci.erase(it1);
// @note 这里的erase会报错, 因为在上一句代码中, begin迭代器所指向的数据被删除了, 
//     删除之后, begin迭代器之后的元素重新排序(往前移), 此时的it2已经不指向它原先希望指向的位置了  
//     可能它指向了新的begin迭代器之后的位置, 也可能指向begin了, 直接的结果是: 它失效了  
veci.erase(it2);</code></pre><p>在上段代码中, it2实际可能还是指向一个元素的, (实际VS debug中, it2指向了第三个元素, 也就是3)<br>it2并未失效, 它依旧指向一块内存,(至少在VS debug中这样) 但是这是块<strong>不该它占有的内存</strong><br>按照上述我们对溢出/越界的定义, 这种问题属于溢出  </p>
<p>但是很可惜, 报错信息是:<br>“vector erase iterator outside range”<br>emmmmmmmmmm, 也就是说, 它认为这是越界…<br>所以我的理解可能是错的, 但是我还是认为这样子理解没有什么问题(大概… :) )</p>
<p>或许这样说更好, 有符号数, 只有7位数值, 两个7位数值无论如何计算也不会超过8位<br>而无符号数, 8位数值, 计算是可能超过8位的</p>
]]></content>
  </entry>
  <entry>
    <title>other/CreatesoFileinLinux</title>
    <url>/2020/01/10/other/CreatesoFileinLinux/</url>
    <content><![CDATA[<h3 id="Step"><a href="#Step" class="headerlink" title="Step"></a>Step</h3><ol>
<li>编写动态库源文件  </li>
<li>将动态库源文件编译链接生成动态库文件  </li>
<li>在执行源文件中添加头文件声明  </li>
<li>使用动态库文件  </li>
</ol>
<hr>
<h4 id="Step1"><a href="#Step1" class="headerlink" title="Step1:"></a>Step1:</h4><p>…</p>
<h4 id="Step2"><a href="#Step2" class="headerlink" title="Step2:"></a>Step2:</h4><pre><code>gcc/g++ -fPIC -shared -o [libname].so [sourcefile]</code></pre><p>example:  </p>
<pre><code>gcc -fPIC -shared -o tlib.so tlib.c</code></pre><p>这样就会生成一个<code>tlib.so</code>的动态库文件<br>其中<code>-fPIC</code>的含义是: Position Independent Code (位置无关代码)</p>
<h4 id="Step3"><a href="#Step3" class="headerlink" title="Step3:"></a>Step3:</h4><p>添加声明可以在单独的头文件中添加, 也可以直接在使用的源文件内添加  </p>
<h4 id="Step4"><a href="#Step4" class="headerlink" title="Step4:"></a>Step4:</h4><pre><code>gcc t.c -L. tlib.so  </code></pre><p>会生成一个默认的<code>a.out</code>可执行文件  </p>
<p>此时还有一个问题就是直接运行的话会报错:<br>应用程序找不到<code>.so</code>文件<br>解决方法有两种, 一种是改系统文件, 另外一种是临时告诉shell动态库的路径<br>因为这个是测试用例, 介绍第二种  </p>
<pre><code>LD_LIBRARY_PATH=. ./a.out  </code></pre><p>执行此命令可以解决报错问题, 其中<code>LD_LIBRARY_PATH=.</code>的含义是:<br>告诉shell, 库的路径在当前路径下(如果库放在别的路径, 将<code>.</code>替换即可)  </p>
<p>以上经验来自<a href="https://www.cnblogs.com/jiqingwu/p/linux_dynamic_lib_create.html" target="_blank" rel="noopener">博客园</a>  </p>
<hr>
<p>顺便: 第一次写了<code>makefile</code>, 用作上述的动态库管理  </p>
<blockquote>
<p>make build: 生成动态库, 可执行文件<br>make doit: 执行程序(如果文件并不存在, 先生成文件)<br>make clean: 清除生成的文件</p>
</blockquote>
<pre><code> 1 build: tlib.so a.out
 2 
 3 tlib.so: tlib.c
 4           gcc -fPIC -shared -o $@ $&lt;
 5 
 6 a.out: t1.c
 7           gcc $&lt; -L. tlib.so
 8 
 9 doit: build 
10           LD_LIBRARY_PATH=. ./a.out
11 
12 file = tlib.so a.out
13 clean: 
14           rm $(file)</code></pre><p>书写makedile和核心就是搞清楚依赖关系<br>其中<code>build</code>为创建动态库和可执行文件, 所以依赖于<code>tlib.so</code>和<code>a.out</code><br>而<code>tlib.so</code>依赖于<code>tlib.c</code>, <code>a.out</code>依赖于<code>t1.c</code><br>…</p>
<p>有一份<a href="https://www.kancloud.cn/kancloud/make-command/45593" target="_blank" rel="noopener">make教程</a></p>
<p>上述所用到的基础makefile规则并不难理解, 这里不做赘述  </p>
]]></content>
  </entry>
  <entry>
    <title>leetcode/234PalindromeLinkedList</title>
    <url>/2020/01/10/leetcode/234PalindromeLinkedList/</url>
    <content><![CDATA[<h2 id="234-Palindrome-Linked-List"><a href="#234-Palindrome-Linked-List" class="headerlink" title="234 Palindrome Linked List"></a>234 Palindrome Linked List</h2><p><img src="https://imgur.com/NFvwG9E.png" alt=""></p>
<p>判断链表是否是回文链表, 可以的话, O(n)时间复杂度, O(1)空间复杂度.</p>
<p>Determine whether the given single-linked list is a palindrome linked list.</p>
<p>Flow up: O(n) time and O(1) space.</p>
<h3 id="my-solution"><a href="#my-solution" class="headerlink" title="my solution"></a>my solution</h3><p>单链表, 时间O(n), 空间O(1), 同时满足有点难啊 = = … </p>
<p>It’s a little difficult to solve this question with both O(n) time and O(1) space.</p>
<p>我能相出的办法仅在知道链表长度/链表尾节点的情况下适用.</p>
<p>I can solve this if I know the length of the linked list</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">            ListNode* <span class="built_in">cursor</span> = head;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">cursor</span>) &#123;</span><br><span class="line">                ++n;</span><br><span class="line">                <span class="built_in">cursor</span> = <span class="built_in">cursor</span>-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            ListNode *prev = head;</span><br><span class="line">            LisTNode *next = prev-&gt;next;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">                ListNode *tmp = next-&gt;next;</span><br><span class="line">                next-&gt;next = prev;</span><br><span class="line"></span><br><span class="line">                prev = next;</span><br><span class="line">                next = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// // this methond redirect two nodes in one cycle</span></span><br><span class="line">            <span class="comment">// cursor = head;</span></span><br><span class="line">            <span class="comment">// ListNode *prev = nullptr;</span></span><br><span class="line">            <span class="comment">// LisTNode *next = cursor-&gt;next;</span></span><br><span class="line">            <span class="comment">// for (int i = 1; i &lt; n / 2; ++i) &#123;</span></span><br><span class="line">            <span class="comment">//     cursor-&gt;next = prev;</span></span><br><span class="line">            <span class="comment">//     ListNode *tmp = next-&gt;next;</span></span><br><span class="line">            <span class="comment">//     next-&gt;next = cursor;</span></span><br><span class="line">            <span class="comment">//     </span></span><br><span class="line">            <span class="comment">//     prev = next;</span></span><br><span class="line">            <span class="comment">//     cursor = tmp;</span></span><br><span class="line">            <span class="comment">//     next = cursor-&gt;next;</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (n &amp; <span class="number">1</span>)</span><br><span class="line">                next = next-&gt;next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (next-&gt;val != prev-&gt;val)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                next = next-&gt;next;</span><br><span class="line">                prev = prev-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>知道了节点长度的话, 不断反向节点, 直到到达中间节点, 然后从中间节点向两端对比就好了, 两次循环各遍历一半的节点. 所以还算 O(1), 空间只需要必须的用于遍历的节点, O(1)也满足. 但问题就是这是节点长度的情况下. 所以很好奇什么算法可以满足这两个需求. (其实看了之后感觉 = = , emmm… 没有很惊艳)</p>
<p>If know the length of the linked list, reverse nodes until the center of the linked list, then compare elements between the center node. </p>
<h3 id="best-solution"><a href="#best-solution" class="headerlink" title="best solution"></a>best solution</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow-&gt;next = reverseList(slow-&gt;next);</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (slow) &#123;</span><br><span class="line">            <span class="keyword">if</span> (head-&gt;val != slow-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* currentHead = head;</span><br><span class="line">        <span class="keyword">while</span> (head-&gt;next) &#123;</span><br><span class="line">            ListNode* p = head-&gt;next;</span><br><span class="line">            head-&gt;next = p-&gt;next;</span><br><span class="line">            p-&gt;next = currentHead;</span><br><span class="line">            currentHead = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> currentHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>办法几乎和我相同, 核心就是那个中间节点, 结果是用这种方法来解决的… 怎么没想到呢 = =, 学到了学到了… </p>
<p>还有就是, 我在奇偶长度上花了些心思, 所以从 1 开始循环, 并且对两种情况做了处理. </p>
<p>但是这种方法的话, 因为并不是由内向外, 所以奇偶不重要, 也不需要额外的代码来处理了. </p>
]]></content>
  </entry>
  <entry>
    <title>other/gdb</title>
    <url>/2020/01/09/other/gdb/</url>
    <content><![CDATA[<h3 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h3><p>gdb是一个 c/c++ debug 工具</p>
<p>没有一个教程和文档比 gdb 官方手册更加详细和准确</p>
<p>这个文件只是简单地介绍其中一小部分频繁使用的功能, 具体需要结合 gdb<br>的官方文档使用</p>
<p>(gdb非常强大, 其文档有400多页, 完全是一本参考书的规格)</p>
<p>( 同时gdb也做到了透明, 大多数时候你使用它只需掌握极少的几条指令(基础功能中的指令) )</p>
<h3 id="基础功能"><a href="#基础功能" class="headerlink" title="基础功能"></a>基础功能</h3><h4 id="n-next"><a href="#n-next" class="headerlink" title="n : next"></a>n : next</h4><p>用于跳转到下一条语句, 同时会先执行当前语句, 可配合 number 跳转多行</p>
<h4 id="s-step"><a href="#s-step" class="headerlink" title="s : step"></a>s : step</h4><p>进入函数调用</p>
<h4 id="b-break"><a href="#b-break" class="headerlink" title="b : break"></a>b : break</h4><p>断点</p>
<h4 id="c-continue"><a href="#c-continue" class="headerlink" title="c : continue"></a>c : continue</h4><p>继续执行</p>
<h4 id="p-print"><a href="#p-print" class="headerlink" title="p : print"></a>p : print</h4><p>打印变量信息, ptype 可以打印类型信息(用于类, 它会将类的所有成员都打印出来)</p>
<h4 id="l-：list"><a href="#l-：list" class="headerlink" title="l ：list"></a>l ：list</h4><p>查看当前行附近的代码信息, 可以指定行号和函数, 可以用于跳转到指定文件</p>
<h4 id="bt-backtrace"><a href="#bt-backtrace" class="headerlink" title="bt : backtrace"></a>bt : backtrace</h4><p>调用回溯, 查看当前调用栈</p>
<h4 id="f-frame"><a href="#f-frame" class="headerlink" title="f : frame"></a>f : frame</h4><p>与 bt 的信息配合, 使用 number 指定跳转到某条函数调用之前</p>
<h4 id="info"><a href="#info" class="headerlink" title="info"></a>info</h4><p>这条指令用于观察gdb指令的当前信息  </p>
<p>例如: info breakpoints, info frame, info watchpoints, info record… </p>
<h4 id="u-until"><a href="#u-until" class="headerlink" title="u : until"></a>u : until</h4><p>跳出当前循环, 或者配合 number 指定执行到何处</p>
<h4 id="finish"><a href="#finish" class="headerlink" title="finish"></a>finish</h4><p>完成当前函数调用, 跳转到函数调用的最后一条语句</p>
<h3 id="中级功能"><a href="#中级功能" class="headerlink" title="中级功能"></a>中级功能</h3><h4 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h4><p>观察点, 可以用来观察一个变量或者表达式的变化</p>
<h4 id="checkpoint"><a href="#checkpoint" class="headerlink" title="checkpoint"></a>checkpoint</h4><p>检查点用来保存当前进度, 可以在执行若干语句之后回到当前检查点</p>
<h4 id="record"><a href="#record" class="headerlink" title="record"></a>record</h4><p>记录命令的使用信息, 实用之处在于: 使用其中的 full 模式, 可以实现 reverse 操作</p>
<p>比如 reverse-next, 这将会反向执行到上一个语句</p>
<h4 id="forward-search-search"><a href="#forward-search-search" class="headerlink" title="forward-search/search"></a>forward-search/search</h4><p>前向搜索/搜索</p>
<h4 id="inferior"><a href="#inferior" class="headerlink" title="inferior"></a>inferior</h4><p>gdb支持debug多个进程</p>
<h4 id="thread"><a href="#thread" class="headerlink" title="thread"></a>thread</h4><p>gdb支持debug多线程程序</p>
<h4 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h4><p>捕获一个事件</p>
<h4 id="singal"><a href="#singal" class="headerlink" title="singal"></a>singal</h4><p>捕获一个信号</p>
<h4 id="win-winheight"><a href="#win-winheight" class="headerlink" title="win  : winheight"></a>win  : winheight</h4><p>进入可视化模式, 简单来说就是代码界面拥有了窗口, 同时一系列信息也会显示在上面</p>
<p>(不过这个模式实际上会出现会显示错误, 比如会显示删除符号, 显示tab键之类的问题, 我不知道这算不算bug…)</p>
<p>(或许我使用方式不对? )</p>
<h4 id="e-edit"><a href="#e-edit" class="headerlink" title="e : edit"></a>e : edit</h4><p>你可以在 gdb 中直接更改源文件, 不过这好像有点鸡肋…</p>
<h4 id="disassemble"><a href="#disassemble" class="headerlink" title="disassemble"></a>disassemble</h4><p>反编译代码, 显示 machine code</p>
<h4 id="diaplay"><a href="#diaplay" class="headerlink" title="diaplay"></a>diaplay</h4><p>自动显示变量</p>
<h4 id="set-convenience-variable"><a href="#set-convenience-variable" class="headerlink" title="set (convenience variable)"></a>set (convenience variable)</h4><p>使用该指令可以保存变量, 之后你可以用在任何命令的表达式里面, 记得前面加美元($)前缀</p>
<pre><code>(gdb) set {int}0x604010 = 4
(gdb) p v[0]
$16 = (__gnu_cxx::__alloc_traits&lt;std::allocator&lt;int&gt; &gt;::value_type &amp;) @0x604010: 4
(gdb) set {int}0x604010 = 5
(gdb) p v[0]
$17 = (__gnu_cxx::__alloc_traits&lt;std::allocator&lt;int&gt; &gt;::value_type &amp;) @0x604010: 5</code></pre><p>它可以用于对内存赋值!!!</p>
<pre><code>(gdb) p $rbx
$18 = 1
(gdb) set $rbx = 200
(gdb) p $rbx
$19 = 200</code></pre><p>也可以用于对寄存器赋值!!!</p>
<h4 id="convenience-function-10-12"><a href="#convenience-function-10-12" class="headerlink" title="convenience function (10.12)"></a>convenience function (10.12)</h4><p>gdb提供了一系列的函数以供使用, 例如:</p>
<pre><code>$_strlen(str)     $_streq(str1, str2)      $_regex(str, regex) </code></pre><p>前面依旧要加 ‘$’ 符号</p>
<h4 id="register-这个我超喜欢的-10-13"><a href="#register-这个我超喜欢的-10-13" class="headerlink" title="register (这个我超喜欢的) (10.13)"></a>register (这个我超喜欢的) (10.13)</h4><p>这个指令支持你查看寄存器的内容, 使用方法是</p>
<pre><code>p $register</code></pre><p>(这个或许应该放在 p 中, 不过我觉得这应该放在高级内容中)</p>
<p>我依稀记得之前我曾经因为无法在运行时看内存内容而苦恼  </p>
<p>现在这个问题随着gdb的深入学习而解决了, 以后我分析汇编的时候, 可以更加深入了</p>
<p>并且支持使用 set 来改变内容!!</p>
<h4 id="info-os-args"><a href="#info-os-args" class="headerlink" title="info os [args]"></a>info os [args]</h4><p>查看系统相关信息, 比如:</p>
<pre><code>info os files</code></pre><p>将会查看系统使用文件描述符的信息</p>
<h4 id="trace-13"><a href="#trace-13" class="headerlink" title="trace (13)"></a>trace (13)</h4><p>按照 gdb 官方文档的描述, 这个指令是用来调试那些对于实时性有要求的程序  </p>
<p>但是我也没能理解这个指令是如何使用的, 同时有这么一句话</p>
<pre><code>The tracepoint facility is currently available only for remote targets
追溯点当前只对远程目标有效</code></pre><p>这个指令的内容占了整个 13 章节, 应该相当重要. 所以这里仅仅记录一下, 或许以后会用到</p>
<pre><code>14 Debugging Programs That Use Overlays</code></pre><p>=========</p>
<p>后续内容(从 13 章往后)是一些高级内容(以置于我不得不将这段主题的标题改成中级功能…)</p>
<p>比如大型程序, 远程调试 … </p>
<p>暂不研究</p>
<h3 id="other"><a href="#other" class="headerlink" title="other"></a>other</h3><p>源自<a href="http://www.waider.ie/music/lyrics/gdb.html" target="_blank" rel="noopener">http://www.waider.ie/music/lyrics/gdb.html</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">GDB!</span><br><span class="line">based on _Tragedy_ by Barry, Robin <span class="keyword">and</span> Maurice Gibb</span><br><span class="line"></span><br><span class="line">Here<span class="number">'</span>s vi</span><br><span class="line">In a lost <span class="keyword">and</span> lonely part of code</span><br><span class="line">Held in time</span><br><span class="line">In a world of bugs my head explodes</span><br><span class="line">Goin<span class="number">'</span> <span class="built_in">home</span></span><br><span class="line">I just can<span class="number">'</span>t make it all alone</span><br><span class="line">I really should be coding you, coding you</span><br><span class="line"><span class="built_in">running</span> you, <span class="built_in">running</span> you</span><br><span class="line"></span><br><span class="line">CHORUS:</span><br><span class="line">GDB when the program<span class="number">'</span>s wrong <span class="keyword">and</span> the debug<span class="number">'</span>s on</span><br><span class="line">It<span class="number">'</span>s GDB when the system dies <span class="keyword">and</span> you don<span class="number">'</span>t know why</span><br><span class="line">It<span class="number">'</span>s hard to bear</span><br><span class="line">With no one to help you</span><br><span class="line">You're going nowhere</span><br><span class="line">GDB when you <span class="built_in">press</span> control <span class="keyword">and</span> the box just rolls</span><br><span class="line">It<span class="number">'</span>s GDB when the system dies <span class="keyword">and</span> you don<span class="number">'</span>t know why</span><br><span class="line">It<span class="number">'</span>s hard to bear</span><br><span class="line">With no one beside you</span><br><span class="line">You're going nowhere</span><br><span class="line"></span><br><span class="line">Night <span class="keyword">and</span> Day</span><br><span class="line">There<span class="number">'</span>s a burning down inside of me</span><br><span class="line">Burning code</span><br><span class="line">And a kernel that won<span class="number">'</span>t let me be</span><br><span class="line">Down it goes</span><br><span class="line"><span class="keyword">and</span> I just can<span class="number">'</span>t take it all alone</span><br><span class="line">I really should be coding you, coding you</span><br><span class="line">Running you, <span class="built_in">running</span> you</span><br><span class="line"></span><br><span class="line">REPEAT CHORUS</span><br><span class="line"></span><br><span class="line"><span class="function">REPEAT <span class="title">CHORUS</span><span class="params">(fade)</span></span></span><br></pre></td></tr></table></figure>
<p>源自<a href="https://www.gnu.org/music/gdb-song.html" target="_blank" rel="noopener">https://www.gnu.org/music/gdb-song.html</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Let<span class="number">'</span>s start at the very beginning, a very good place to start,</span><br><span class="line">When you're learning to sing, its Do, Re, Mi; </span><br><span class="line">When you're learning to code, its G, D, B. </span><br><span class="line">(<span class="built_in">background</span>) G, D, B.</span><br><span class="line"></span><br><span class="line">The first three letters just happen to be, G, D, B.</span><br><span class="line"></span><br><span class="line">(<span class="built_in">background</span>) G, D, B.</span><br><span class="line"></span><br><span class="line">(Chorus)</span><br><span class="line"></span><br><span class="line">G!,</span><br><span class="line">GNU!, it<span class="number">'</span>s Stallman<span class="number">'</span>s hope,</span><br><span class="line">D,</span><br><span class="line">a <span class="keyword">break</span> I <span class="built_in">set</span> myself.</span><br><span class="line">B,</span><br><span class="line">debug that rotten code,</span><br><span class="line">Run,</span><br><span class="line">a far, far way to go.</span><br><span class="line">Print,</span><br><span class="line">to see what you have done,</span><br><span class="line">Set,</span><br><span class="line">a patch that follows <span class="built_in">print</span>.</span><br><span class="line">Quit,</span><br><span class="line"><span class="keyword">and</span> recompile your code - - -</span><br><span class="line">That will bring it back to G,</span><br><span class="line">                              D,</span><br><span class="line">                                 B,</span><br><span class="line">                                    &lt;link&gt;</span><br><span class="line">(Resume from the Chorus)</span><br></pre></td></tr></table></figure>
<p>感觉, 嗯, 很有气势</p>
]]></content>
  </entry>
  <entry>
    <title>leetcode/48RotateImage</title>
    <url>/2020/01/09/leetcode/48RotateImage/</url>
    <content><![CDATA[<h1 id="Rotate-Image"><a href="#Rotate-Image" class="headerlink" title="Rotate Image"></a>Rotate Image</h1><p><img src="https://i.imgur.com/7hLPAwu.png" alt="">  </p>
<blockquote>
<p>顺时针90度旋转矩阵<br>要求就地更改(不能创建另外一个矩阵)</p>
</blockquote>
<h2 id="我的做法"><a href="#我的做法" class="headerlink" title="我的做法"></a>我的做法</h2><p>思路:  </p>
<blockquote>
<p>使用下标来获取元素更方便<br>从外层到内层, 一层层旋转, 每次旋转n个, 每层旋转4次<br>不可避免需要保存一组数值  </p>
</blockquote>
<p>具体代码:  </p>
<pre><code>class Solution {
public:
    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
        int n = matrix.size();

        for (int i = 0; i &lt; n / 2; ++i){
            // backup first stream
            vector&lt;int&gt; backup ((matrix.begin() + i)-&gt;begin() + i + 1, 
                (matrix.begin() + i)-&gt;end() - i);

                for (int col = i + 1, row = n - i - 2; col &lt; n - i; ++col, --row)
                    matrix[i][col] = matrix[row][i];

                for (int row = i, col = i; row &lt; n - i - 1; ++row, ++col)
                    matrix[row][i] = matrix[n - 1 - i][col];

                for (int col = i, row = n - i - 1; col &lt; n - i - 1; ++col, --row)
                    matrix[n - 1 - i][col] = matrix[row][n - i - 1];

                for (int row = n - 1 - i, t = backup.size() - 1; t &gt;= 0; --row, --t)
                    matrix[row][n - i - 1] = backup[t];
        }
    }
};</code></pre><p>最后结果:  </p>
<p><img src="https://i.imgur.com/IgjHagZ.png" alt="">  </p>
<h2 id="dalao的做法"><a href="#dalao的做法" class="headerlink" title="dalao的做法"></a>dalao的做法</h2><pre><code>class Solution {
public:
    void swapLR(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
        int n = matrix.size();
        for (int i = 0; i &lt; n; i++) {
            int l = 0;
            int r = n-1;
            while(l&lt;r) {
                int temp = matrix[i][l];
                matrix[i][l++] = matrix[i][r];
                matrix[i][r--] = temp;
            }
        }
    }

    void swapdig(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
        int n = matrix.size();
        for (int i = 0; i &lt; n-1; i++) {
            for (int j = 0; j &lt; n-1-i; j++) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[n-1-j][n-1-i];
                matrix[n-1-j][n-1-i] = temp;
            }
        }
    }

    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
        swapLR(matrix);
        swapdig(matrix);
    }
};</code></pre><p>首先分析 swapLR 函数:  </p>
<blockquote>
<p>emmmm, 它好像将左右的数据对换了<br><img src="https://i.imgur.com/6uc80iU.png" alt=""><br>emmm, 还是看不懂有什么规律, </p>
</blockquote>
<p><img src="https://i.imgur.com/fjWYKBX.png" alt="">  </p>
<p>6啊…, 更改后的行就是最终结果的列, 只要遍历倒叙一遍就可以了<br>这种思路是如何得出的? 需要哪方面的知识么?<br>思路这种东西好难弥补, 我自认为不出意外的话, 是无法想到这一点的</p>
]]></content>
  </entry>
  <entry>
    <title>leetcode/42TrappingRainWater</title>
    <url>/2020/01/09/leetcode/42TrappingRainWater/</url>
    <content><![CDATA[<h2 id="Trapping-Rain-Water"><a href="#Trapping-Rain-Water" class="headerlink" title="Trapping Rain Water"></a>Trapping Rain Water</h2><p><a href="https://leetcode.com/problems/trapping-rain-water/description/" target="_blank" rel="noopener">原地址</a></p>
<p><img src="https://i.imgur.com/o9Cwc3k.png" alt=""></p>
<p>大致描述: 给出一个数组, 按如上所述, 求出蓝色方块的数量<br>(就像一个山脉一样, 看这样的山脉降雨后能留下多少水)</p>
<h3 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路:"></a>我的思路:</h3><p>排错:  </p>
<ol>
<li>必须有3个以上的山脉才有可能有积水, 所以数组长度必定大于3  </li>
<li>左右为平地的数组下标截断, 直到有山脉为止</li>
</ol>
<p>做法:  </p>
<ol>
<li>从左到右依次拿到符合条件的格子下标(比如第一次是(1, 3) )  </li>
<li>计算改区域的雨水  </li>
<li>重复第一步, 直到结束</li>
</ol>
<p>// 具体代码在42_.txt中  </p>
<h3 id="dalao的思路"><a href="#dalao的思路" class="headerlink" title="dalao的思路"></a>dalao的思路</h3><p>// 具体代码在42_2.txt中</p>
<p><img src="https://i.imgur.com/ZIGTZ9P.png" alt=""></p>
<p><img src="https://i.imgur.com/psX9onj.png" alt="">  </p>
<p>分析:<br>一个格子中能不能存水取决于左右格子的高度<br>算法从左到右一次, 从有到左一次.<br>每次假设该格子以左/右单方面最大能放多少水<br>将同一格的两次数据求最小, 这就是该下标实际能存多少水<br>最后减去本身的实体格子, 也就得到了空下的格子  </p>
<p>算法复杂度为O(n)</p>
]]></content>
  </entry>
  <entry>
    <title>leetcode/21MergeTwoSortedLists</title>
    <url>/2020/01/09/leetcode/21MergeTwoSortedLists/</url>
    <content><![CDATA[<p><img src="https://i.imgur.com/YPfIfKp.png" alt=""></p>
<p>排序两个链表  </p>
<p>思路:  </p>
<p>每次对比两条链表的当前节点,  按适当顺序插入的同时需要注意一点</p>
<p>如果小的节点的接下来的值依旧小于大的节点, 那么需要继续往下遍历, 知道遇到一个节点大于大的节点  </p>
<p>这样的话一次循环中就可以排序多个节点, 循环的次数就可以变少  </p>
<p>代码:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!l1 &amp;&amp; l2) <span class="keyword">return</span> l2;</span><br><span class="line">		<span class="keyword">if</span> (!l2 &amp;&amp; l1) <span class="keyword">return</span> l1;</span><br><span class="line"></span><br><span class="line">        ListNode *smaller = l1-&gt;val &gt; l2-&gt;val ?</span><br><span class="line">            l2 : l1;</span><br><span class="line">        ListNode *bigger = l1-&gt;val &gt; l2-&gt;val ?</span><br><span class="line">            l1 : l2;</span><br><span class="line">        ListNode *result = smaller;</span><br><span class="line">        <span class="keyword">while</span> (smaller &amp;&amp; bigger) &#123;</span><br><span class="line">            <span class="keyword">while</span> (smaller-&gt;next &amp;&amp; smaller-&gt;next-&gt;val &lt; bigger-&gt;val)</span><br><span class="line">                smaller = smaller-&gt;next;</span><br><span class="line"></span><br><span class="line">            ListNode *tmps = smaller-&gt;next;</span><br><span class="line">            smaller-&gt;next = bigger;</span><br><span class="line"></span><br><span class="line">            smaller = bigger;</span><br><span class="line">            bigger = tmps;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>采用了一次循环对比多个的算法, 每次循环之后不必再计算谁大谁小, 身份像开关一样会互换</p>
<p>但是代码复杂度增加了</p>
<p>结果:</p>
<p><img src="https://i.imgur.com/dNx5MC7.png" alt=""></p>
<p>emmmmm…, 预差有点大…  </p>
<p>按理来说我觉得算法很好啊, 一次循环中排序了多个节点  </p>
<p>每次循环后还不需要计算谁大谁小</p>
<p>分析一下4ms的算法:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* pre=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode* crt=pre;</span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="literal">NULL</span> &amp;&amp; l2!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val&lt;l2-&gt;val) &#123;</span><br><span class="line">                crt-&gt;next=l1;</span><br><span class="line">                l1=l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                crt-&gt;next=l2;</span><br><span class="line">                l2=l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            crt=crt-&gt;next;   </span><br><span class="line">        &#125;</span><br><span class="line">        crt-&gt;next=(l1==<span class="literal">NULL</span>)?l2:l1;</span><br><span class="line">        <span class="keyword">return</span> pre-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>emmmm…  </p>
<p>他的思路很简单, 每次对比两个节点, 筛选出一个最小的</p>
<p>将筛选出节点的那条链接往下循环, 另外一条不变  </p>
<p>但是时间比我少了很多, 我仔细思考了的算法反倒没有这种单纯的算法好  </p>
<p>有点出乎意料和不服气…</p>
<p>@exprience:</p>
<p>我以后或许需要考虑 <strong>以循环次数换取减少循环复杂度</strong> 的做法了  </p>
<p>这样的话我的每次循环尽量简单, 虽然次数变多了, 但是总体的效率可能还会有提升, 比如这次 = =</p>
]]></content>
  </entry>
  <entry>
    <title>leetcode/R23._Merge_k_Sorted_Lists</title>
    <url>/2020/01/09/leetcode/R23._Merge_k_Sorted_Lists/</url>
    <content><![CDATA[<p><img src="https://i.imgur.com/0yJznlI.png" alt=""></p>
<p>排序多个链表</p>
<p>思路:</p>
<p>emmm… 采取上次的想法试试  </p>
<p>一次只排序一个, 排序多次</p>
<p>代码:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        ListNode *result = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode *backup = result;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> indexmin = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(indexmin &lt; lists.<span class="built_in">size</span>() &amp;&amp; !lists[indexmin])</span><br><span class="line">                ++indexmin;</span><br><span class="line"></span><br><span class="line">            ListNode *<span class="built_in">min</span> = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">if</span> (indexmin &lt; lists.<span class="built_in">size</span>())</span><br><span class="line">                <span class="built_in">min</span> = lists[indexmin];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (indexmin &gt; <span class="number">0</span> &amp;&amp; lists[indexmin - <span class="number">1</span>])</span><br><span class="line">                    backup-&gt;next = lists[indexmin];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; lists.<span class="built_in">size</span>(); ++i)</span><br><span class="line">                <span class="keyword">if</span> (lists[i] &amp;&amp; lists[i]-&gt;val &lt; <span class="built_in">min</span>-&gt;val) &#123;</span><br><span class="line">                    <span class="built_in">min</span> = lists[i];</span><br><span class="line">                    indexmin = i;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            backup-&gt;next = <span class="built_in">min</span>;</span><br><span class="line">            backup = backup-&gt;next;</span><br><span class="line">            lists[indexmin] = lists[indexmin]-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>一次循环内只思考得到最小的一个  </p>
<p>代码的复杂度降低了, 码字速度和debug频率也明显好多了</p>
<p>结果</p>
<p><img src="https://i.imgur.com/86K7tLZ.png" alt=""></p>
<p>emmmmmm…. , 这是我至今为止做的最差的一次leetcode…  </p>
<p>难的, 想不出好方法的. 即使有想法也不做. 所以平均来说一直还算中游  </p>
<p>不过差不多意料之中, 毕竟 hard 还是没那么容易的(除了那次用标准库偷鸡, 虽然说偷完就后悔了)</p>
<p>那么, 要不要看一下dalao的代码?  </p>
<p>算了吧, 这次没怎么仔细思考算法, 刚好想尝试一下降低循环复杂度</p>
<p>(虽然说尝试炸了, 但还算有所收获. 在时间紧迫, 还有其他适当因素的情况下, 这种做法可以说是最有效率的)  </p>
<p>没怎么思考就去看别人的答案, 那我还做leetcode干嘛…  </p>
<p>但是好像又暂时想不出什么好方法, 留到以后来优化吧…</p>
]]></content>
  </entry>
  <entry>
    <title>leetcode/F15_3Sum</title>
    <url>/2020/01/09/leetcode/F15_3Sum/</url>
    <content><![CDATA[<p><img src="https://i.imgur.com/LqfHaar.png" alt=""></p>
<p>给一个数组, 求其中三数和为零的所有组合, 要求不能重复  </p>
<p>思路:</p>
<p>遍历数组, 找出所有三数集合, 再判断是否为零, 之后用一个map去重</p>
<p>代码: </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; threeSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt; <span class="number">3</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt; repetitive;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>() - <span class="number">2</span>; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = i + <span class="number">1</span>; k &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>; ++k)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> v = k + <span class="number">1</span>; v &lt; nums.<span class="built_in">size</span>(); ++v) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nums[i] + nums[k] + nums[v] != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">int</span> nmax = <span class="built_in">max</span>(nums[i], nums[k]);</span><br><span class="line">                        nmax = <span class="built_in">max</span>(nmax, nums[v]);</span><br><span class="line">                        <span class="keyword">int</span> nmin = <span class="built_in">min</span>(nums[i], nums[k]);</span><br><span class="line">                        nmin = <span class="built_in">min</span>(nmin, nums[v]);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (!repetitive[(nmax &lt;&lt; <span class="number">4</span>) + nmin]) &#123;</span><br><span class="line">                            repetitive[(nmax &lt;&lt; <span class="number">4</span>) + nmin] = <span class="literal">true</span>;</span><br><span class="line">                            result.push_back(&#123; nmin, <span class="number">0</span> - nmin - nmax, nmax &#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>实际上map去重那里有漏洞, “精心准备”的数字有可能骗过它</p>
<p>结果:</p>
<p><img src="https://i.imgur.com/kRu2dZG.png" alt=""></p>
<p>超时了, 看到那密密麻麻的红字, 感觉有点不妙  </p>
<p><img src="https://i.imgur.com/l5lBEhM.png" alt=""></p>
<p>实测算法在数组长度为200时已经有明显的停顿</p>
<p>算法复杂度大概是 差不多O(n3) 的样子, 所以随着长度的增加, 时间复杂度的增加是很恐怖的  </p>
<p>200有明显停顿的话. 3000大概能算个痛  </p>
<p>那么得优化算法了, 怎么优化呢? 暂时想不到…  </p>
<p>优化的想法:  </p>
<p>现在的算法在第一次循环的时候会将下标[0, 1]和后续所有的下标组合</p>
<p>第二次循环的时候会将下标[1, 2]和后续所有下标组合  </p>
<p>这里明显有可以提升的空间, 因为两次里面1重叠了, 同理, 后续的组合都有重叠  </p>
<p>在200长度的算法中, 大致会有 4000000 次循环, 而最后的结果只有 6 个组合</p>
<p>想要优化的话应该从这里入手, 如何在逻辑上筛除掉一些可能但和又不为零的组合</p>
<p>怎么删除? emmmm… 想不到  </p>
]]></content>
  </entry>
  <entry>
    <title>leetcode/20ValidParentheses</title>
    <url>/2020/01/09/leetcode/20ValidParentheses/</url>
    <content><![CDATA[<p><img src="https://i.imgur.com/tKMKEzc.png" alt=""></p>
<p>判断字符串是都按正确格式闭合</p>
<p>思路:</p>
<p>当一个字符被看到时, 预料与之对应的字符, 当该字符不是预料的字符, 有两种可能</p>
<ol>
<li>失败</li>
<li>被包含, 例如 ({}), 当看到 ‘(‘ 时候, 我们想要的是 ‘)’. 但该语句是合法的</li>
</ol>
<p>如果是第二种, 那么 ‘(‘ 要被保存起来, 这种数据结构非常适合用栈来做  </p>
<p>代码:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!s.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">char</span>&gt; lettermap&#123;</span><br><span class="line">            &#123;<span class="string">'('</span>, <span class="string">')'</span>&#125;,</span><br><span class="line">            &#123;<span class="string">'&#123;'</span>, <span class="string">'&#125;'</span>&#125;,</span><br><span class="line">            &#123;<span class="string">'['</span>, <span class="string">']'</span>&#125;,</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; vch&#123; s[<span class="number">0</span>] &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lettermap[vch.back()] != s[i]) vch.push_back(s[i]);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                vch.pop_back();</span><br><span class="line">                <span class="keyword">if</span> (vch.<span class="built_in">size</span>()) &#123;&#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (++i &lt; s.<span class="built_in">size</span>())</span><br><span class="line">                    vch.push_back(s[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> !vch.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>该代码并未在循环中判断是否合法  </p>
<p>实际情况中, 可能一个非常长的字符串一开始就错了, 比如; “){}{}{}{}…”  </p>
<p>但是依旧会将整个字符串循环一次, 这样做有三点考虑:  </p>
<ol>
<li>代码更加简单, 简洁. 更容易理解</li>
<li>如果代码的确需要很多判断才能确定结果, 那么多加条件语句反而是一种额外的消耗<br>并且是O(n)复杂度, 节省的效率并不会有多少, 同时额外的消耗并不一定会比加条件语句多</li>
<li>懒</li>
</ol>
<p>PS: 如果能想到用栈结构来做这个题的话, 会方便很多.  如果没想到的话, 可能会越想越难. </p>
]]></content>
  </entry>
  <entry>
    <title>read/UnderstandingGeneratedColumns</title>
    <url>/2020/01/09/read/UnderstandingGeneratedColumns/</url>
    <content><![CDATA[<h1 id="Understanding-Generated-Columns"><a href="#Understanding-Generated-Columns" class="headerlink" title="Understanding Generated Columns"></a>Understanding Generated Columns</h1><h2 id="The-Theory"><a href="#The-Theory" class="headerlink" title="The Theory"></a>The Theory</h2><p>Generated Columns is a feature <a href="https://dev.mysql.com/doc/refman/5.7/en/mysql-nutshell.html#mysql-nutshell-additions" target="_blank" rel="noopener">released</a> on MySQL 5.7. They can be used during <code>CREATE TABLE</code>or <code>ALTER TABLE</code> statements. It is a way of storing data without actually sending it through the <code>INSERT</code> or <code>UPDATE</code> clauses in SQL. The database resolves what the data will be.</p>
<p>生成列是在 MySQL 5.7 之后发布的一个特性, 可以在 CREATE TABLE / ALTER TABLE 期间使用. 是一种存储数据而不通过 INSERT / UPDATE 子句的方法. 数据库解析数据是什么</p>
<p>There are two types of Generated Columns: <strong>Virtual</strong> and <strong>Stored</strong>. They work with:</p>
<ul>
<li>mathematical expressions (<code>product_price</code> * <code>quantity</code>)</li>
<li>built-in functions (<code>RIGHT()</code>, <code>CONCAT()</code>, <code>FROM_UNIXTIME()</code>, <code>JSON_EXTRACT()</code>)</li>
<li>literals (“2”, “new”, 0)</li>
</ul>
<p>有两种生成列: virtual 和 stored, 它们工作于: </p>
<ul>
<li>数学表达式</li>
<li>内建函数</li>
<li>复合常量</li>
</ul>
<p>Besides that, they can be indexed but they <strong>don’t</strong> allow <strong>subqueries</strong> in it.<br>A Generated Column works within the table domain. If you need subqueries on a particular column, you may have to look at <a href="http://dev.mysql.com/doc/refman/5.7/en/view-syntax.html" target="_blank" rel="noopener">Views</a>.</p>
<p>如上, 它们能够被索引, 但不允许子查询. </p>
<p>生成列在表域中工作, 如果你需要在特殊的列上子查询, 你需要考虑 view </p>
<h2 id="The-basic-example"><a href="#The-basic-example" class="headerlink" title="The basic example"></a>The basic example</h2><p>As an example I am going to use an e-commerce database as based on my past experience of what I have seen and worked. You will probably have at least these tables or something similar:</p>
<ul>
<li><code>users</code> – stores user info</li>
<li><code>products</code> – stores product info like price and description</li>
<li><code>orders</code> – stores the user_id, date of order</li>
<li><code>orders_items</code> – stores product_id, order_id, quantity and price at the time of purchase</li>
</ul>
<p>This is the whole DB: <a href="https://gist.github.com/gabidavila/7abae0b77ff6cff8899c3a57ff32679d" target="_blank" rel="noopener">Gist</a>.</p>
<p>Notice the <code>order_items</code> definition:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`orders_items`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`order_id`</span> <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`product_id`</span> <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`product_price`</span> <span class="built_in">decimal</span>(<span class="number">10</span>,<span class="number">2</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0.00'</span>,</span><br><span class="line">  <span class="string">`quantity`</span> <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>,</span><br><span class="line">  <span class="string">`created_at`</span> <span class="built_in">timestamp</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  <span class="string">`updated_at`</span> <span class="built_in">varchar</span>(<span class="number">45</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">1</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4;</span><br></pre></td></tr></table></figure>



<p>The retrieval would bring:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  <span class="string">`id`</span>, <span class="string">`order_id`</span>, <span class="string">`product_id`</span>, <span class="string">`product_price`</span>, <span class="string">`quantity`</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`orders_items`</span></span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">id</th>
<th align="left">order_id</th>
<th align="left">product_id</th>
<th align="left">product_price</th>
<th align="left">quantity</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">369</td>
<td align="left">1304</td>
<td align="left">202.18</td>
<td align="left">7</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">4</td>
<td align="left">1736</td>
<td align="left">250.40</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">270</td>
<td align="left">1404</td>
<td align="left">29.89</td>
<td align="left">5</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">256</td>
<td align="left">179</td>
<td align="left">190.40</td>
<td align="left">10</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">107</td>
<td align="left">1911</td>
<td align="left">146.98</td>
<td align="left">1</td>
</tr>
</tbody></table>
<p>One example is to get the total of that order_item row, something like <code>total_item_price</code> that would store the value of <code>product_price</code> * <code>quantity</code> to show how much the summed amount of an item would be. Some databases have the <code>MONEY</code> type to store <code>price</code>, as with MySQL it is recommended to work with <code>DECIMAL</code>.</p>
<p>上述例子获取 order_item 所有行, 应该有类似 total_item_price 的列存储 product * quantity, 显示总额.</p>
<p>一些数据库有 MONEY 类型存储价格, MySQL 推荐使用 DECIMAL</p>
<p>People solve this problem in different ways:</p>
<ul>
<li>store the calculated price on a new column to make it easier to retrieve;</li>
<li>create a view;</li>
<li>or they calculate in the application itself, which in this case might cause problems due to how the language handles floats. There are libraries to deal with money values in a lot of languages and frameworks, however, the overhead of converting each row into a money object could be costly depending on the amount of data being transferred.</li>
</ul>
<p>有几种不同的方式解决这个问题: </p>
<ul>
<li>在新的列存储计算好的值, 便于检索</li>
<li>创建视图</li>
<li>或者在应用层计算, 由于不同语言对于浮点数的管理可能造成问题. 大量的语言和框架提供了库处理这个问题.然而, 将每行转换为对象的消耗依赖于有多少数据被调入</li>
</ul>
<p>Another way I’ve seen is: people calculate in the query the total amount for the orders_items row as <code>product_price</code> * <code>quantity</code>:</p>
<p>还有一种我见过的方法 : 在查询中计算总额</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  <span class="string">`id`</span>, </span><br><span class="line">  <span class="string">`order_id`</span>, </span><br><span class="line">  <span class="string">`product_id`</span>, </span><br><span class="line">  <span class="string">`product_price`</span>, </span><br><span class="line">  <span class="string">`quantity`</span>,</span><br><span class="line">  <span class="string">`product_price`</span> * <span class="string">`quantity`</span> <span class="keyword">AS</span> total_item_price</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`orders_items`</span></span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">id</th>
<th align="left">order_id</th>
<th align="left">product_id</th>
<th align="left">product_price</th>
<th align="left">quantity</th>
<th align="left">total_item_price</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">369</td>
<td align="left">1304</td>
<td align="left">202.18</td>
<td align="left">7</td>
<td align="left">1415.26</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">4</td>
<td align="left">1736</td>
<td align="left">250.40</td>
<td align="left">3</td>
<td align="left">751.20</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">270</td>
<td align="left">1404</td>
<td align="left">29.89</td>
<td align="left">5</td>
<td align="left">149.45</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">256</td>
<td align="left">179</td>
<td align="left">190.40</td>
<td align="left">10</td>
<td align="left">1904.00</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">107</td>
<td align="left">1911</td>
<td align="left">146.98</td>
<td align="left">1</td>
<td align="left">146.98</td>
</tr>
</tbody></table>
<h2 id="Virtual-Columns"><a href="#Virtual-Columns" class="headerlink" title="Virtual Columns"></a>Virtual Columns</h2><ul>
<li>They take no disk space, except when using a Virtual Column as in a <a href="https://dev.mysql.com/doc/refman/5.7/en/create-table-secondary-indexes-virtual-columns.html" target="_blank" rel="noopener">Secondary Index</a>.</li>
<li>They are an <code>INPLACE</code> operation: it means the table definition is changed without having to recopy all the data again. <a href="http://dev.mysql.com/doc/refman/5.7/en/innodb-create-index-overview.html" target="_blank" rel="noopener">More info</a>.</li>
<li>The values are calculated on the fly during read operations and <code>BEFORE</code> triggers.</li>
</ul>
<p>Consider using virtual columns for data where changes happens in a significant number of times. The cost of a Virtual Column comes from reading a table constantly and the server has to compute every time what that column value will be.</p>
<ul>
<li>不占磁盘空间, 除非使用虚拟列作为次级索引</li>
<li>是 INPLACE 操作 : 这意味着表定义更改不需要拷贝所有数据</li>
<li>值在读取操作和 BEFORE 触发之间动态计算</li>
</ul>
<h2 id="Stored-Columns"><a href="#Stored-Columns" class="headerlink" title="Stored Columns"></a>Stored Columns</h2><ul>
<li>They do use disk space.</li>
<li>It has the same cost of adding a new column, so it is a <code>COPY</code> operation</li>
<li>Values are updated in every <code>INSERT</code> and <code>UPDATE</code> statement.</li>
</ul>
<p>You should consider using Stored Columns for when the data doesn’t change significantly or at all after creation, like for instance, the example above with the <code>orders_items</code> table. Once a purchase is made, the price of the product is stored, not being changed, neither the quantity. Considering this information we could create <code>total_item_price</code> as a Stored Column.</p>
<ul>
<li>耗费磁盘空间</li>
<li>和增加行有相等的消耗, 等价于 COPY 操作</li>
<li>值在每次 INSERT 和 UPDATE 语句中更新</li>
</ul>
<p>你需要考虑使用存储列, 以便数据没有显著变化或在创建后没有显著变化, 例如上面带有 order_items 的表. 当购买操作后, 存储产品的价格, 不会再更改, 数量也不会. 考虑到这个信息, 我们应该创建 total_item_price 存储列</p>
<h2 id="The-code"><a href="#The-code" class="headerlink" title="The code"></a>The code</h2><h3 id="Creating-a-table"><a href="#Creating-a-table" class="headerlink" title="Creating a table"></a>Creating a table</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;-- Virtual Column&#96; &#96;CREATE&#96; &#96;TABLE&#96; &#96;&#96;orders_items&#96; (&#96;&#96;&#96;id&#96; &#96;&#96;int&#96;&#96;(10) unsigned &#96;&#96;NOT&#96; &#96;NULL&#96; &#96;AUTO_INCREMENT,&#96;&#96;&#96;order_id&#96; &#96;&#96;int&#96;&#96;(10) unsigned &#96;&#96;NOT&#96; &#96;NULL&#96;&#96;,&#96;&#96;&#96;product_id&#96; &#96;&#96;int&#96;&#96;(10) unsigned &#96;&#96;NOT&#96; &#96;NULL&#96;&#96;,&#96;&#96;&#96;product_price&#96; &#96;&#96;decimal&#96;&#96;(10,2) unsigned &#96;&#96;NOT&#96; &#96;NULL&#96; &#96;DEFAULT&#96; &#96;&#39;0.00&#39;&#96;&#96;,&#96;&#96;&#96;quantity&#96; &#96;&#96;int&#96;&#96;(10) unsigned &#96;&#96;NOT&#96; &#96;NULL&#96; &#96;DEFAULT&#96; &#96;1,&#96;&#96;&#96;total_item_price&#96; &#96;&#96;decimal&#96;&#96;(10,2) &#96;&#96;AS&#96; &#96;(&#96;quantity&#96; * &#96;product_price&#96;),&#96;&#96;&#96;created_at&#96; &#96;&#96;timestamp&#96; &#96;NOT&#96; &#96;NULL&#96; &#96;DEFAULT&#96; &#96;CURRENT_TIMESTAMP&#96;&#96;,&#96;&#96;&#96;updated_at&#96; &#96;&#96;varchar&#96;&#96;(45) &#96;&#96;NOT&#96; &#96;NULL&#96; &#96;DEFAULT&#96; &#96;&#39;CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP&#39;&#96;&#96;,&#96;&#96;PRIMARY&#96; &#96;KEY&#96; &#96;(&#96;id&#96;)&#96;&#96;) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;1 &#96;&#96;DEFAULT&#96; &#96;CHARSET&#x3D;utf8mb4;&#96; &#96;-- Stored Column&#96; &#96;CREATE&#96; &#96;TABLE&#96; &#96;&#96;orders_items&#96; (&#96;&#96;&#96;id&#96; &#96;&#96;int&#96;&#96;(10) unsigned &#96;&#96;NOT&#96; &#96;NULL&#96; &#96;AUTO_INCREMENT,&#96;&#96;&#96;order_id&#96; &#96;&#96;int&#96;&#96;(10) unsigned &#96;&#96;NOT&#96; &#96;NULL&#96;&#96;,&#96;&#96;&#96;product_id&#96; &#96;&#96;int&#96;&#96;(10) unsigned &#96;&#96;NOT&#96; &#96;NULL&#96;&#96;,&#96;&#96;&#96;product_price&#96; &#96;&#96;decimal&#96;&#96;(10,2) unsigned &#96;&#96;NOT&#96; &#96;NULL&#96; &#96;DEFAULT&#96; &#96;&#39;0.00&#39;&#96;&#96;,&#96;&#96;&#96;quantity&#96; &#96;&#96;int&#96;&#96;(10) unsigned &#96;&#96;NOT&#96; &#96;NULL&#96; &#96;DEFAULT&#96; &#96;1,&#96;&#96;&#96;total_item_price&#96; &#96;&#96;decimal&#96;&#96;(10,2) &#96;&#96;AS&#96; &#96;(&#96;quantity&#96; * &#96;product_price&#96;) STORED,&#96;&#96;&#96;created_at&#96; &#96;&#96;timestamp&#96; &#96;NOT&#96; &#96;NULL&#96; &#96;DEFAULT&#96; &#96;CURRENT_TIMESTAMP&#96;&#96;,&#96;&#96;&#96;updated_at&#96; &#96;&#96;varchar&#96;&#96;(45) &#96;&#96;NOT&#96; &#96;NULL&#96; &#96;DEFAULT&#96; &#96;&#39;CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP&#39;&#96;&#96;,&#96;&#96;PRIMARY&#96; &#96;KEY&#96; &#96;(&#96;id&#96;)&#96;&#96;) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;1 &#96;&#96;DEFAULT&#96; &#96;CHARSET&#x3D;utf8mb4;&#96;</span><br></pre></td></tr></table></figure>

<p>Notice how the definition changes on line 9 and 23: you have another keyword, <code>AS</code>, then an <em>expression</em> and specifically on line 23 you see a <code>STORED</code> keyword. In both lines they are generated columns, if nothing is specified will be a <code>VIRTUAL</code> column.</p>
<p>注意在 9 行 和 23 行的更改, 有另一个关键字, AS, 随之表达式和 STORED 关键字. 如果没有指定, 将会是一个 VIRTUAL 列</p>
<h3 id="Altering-a-table"><a href="#Altering-a-table" class="headerlink" title="Altering a table"></a>Altering a table</h3><p>It uses the same syntax as adding a column, just adding the “<strong>AS</strong> (<em>expression</em>)” after the data type:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;-- &#96;full_name&#96; as VIRTUAL COLUMN&#96;&#96;ALTER&#96; &#96;TABLE&#96; &#96;users&#96;&#96;ADD&#96; &#96;COLUMN&#96; &#96;&#96;full_name&#96; &#96;&#96;VARCHAR&#96;&#96;(500)&#96;&#96;AS&#96; &#96;(CONCAT_WS(&#96;&#96;&quot; &quot;&#96;&#96;, &#96;first_name&#96;, &#96;last_name&#96;));&#96; &#96;-- &#96;total_item_price&#96; as STORED COLUMN&#96;&#96;ALTER&#96; &#96;TABLE&#96; &#96;orders_items&#96;&#96;ADD&#96; &#96;COLUMN&#96; &#96;&#96;total_item_price&#96; &#96;&#96;DECIMAL&#96;&#96;(10, 2)&#96;&#96;AS&#96; &#96;(&#96;quantity&#96; * &#96;product_price&#96;) STORED;&#96;</span><br></pre></td></tr></table></figure>

<h2 id="JSON-fields"><a href="#JSON-fields" class="headerlink" title="JSON fields"></a>JSON fields</h2><p>It is also possible to extract data from JSON fields using generated columns. As the functions for JSON are built-in, <code>JSON_EXTRACT</code> and <code>JSON_UNQUOTE</code> as well “<strong>-&gt;</strong>” and “<strong>-&gt;&gt;</strong>” work as <em>expressions</em>for a generated column:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;-- Stored Columns&#96;&#96;ALTER&#96; &#96;TABLE&#96; &#96;&#96;twitter_users&#96;&#96;&#96;ADD&#96; &#96;COLUMN&#96; &#96;&#96;location&#96; &#96;&#96;VARCHAR&#96;&#96;(255)&#96;&#96;AS&#96; &#96;(response-&gt;&gt;&#96;&#96;&quot;$.location&quot;&#96;&#96;) STORED;&#96;</span><br></pre></td></tr></table></figure>

<h2 id="Final-considerations"><a href="#Final-considerations" class="headerlink" title="Final considerations"></a>Final considerations</h2><p>When the type is <code>STORED</code>, it must be specified after the <em>expression</em> otherwise the default behaviour will be to be <code>VIRTUAL</code>.</p>
<p>Generated columns can have indexes created as the following, no matter if stored, virtual or extracted from a JSON field:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;ALTER&#96; &#96;TABLE&#96; &#96;users&#96;&#96;ADD&#96; &#96;INDEX&#96; &#96;&#96;ix_full_name&#96; (&#96;full_name&#96;);&#96;</span><br></pre></td></tr></table></figure>

<p>Which is the <strong>same</strong> syntax for normal columns.</p>
]]></content>
  </entry>
  <entry>
    <title>read/studyNoteOfGo</title>
    <url>/2020/01/09/read/studyNoteOfGo/</url>
    <content><![CDATA[<h2 id="brief"><a href="#brief" class="headerlink" title="brief"></a>brief</h2><h4 id="短变量声明"><a href="#短变量声明" class="headerlink" title="短变量声明"></a>短变量声明</h4><p>go可以使用形如 := 的方式定义变量, 这样的用法仅允许在函数内使用</p>
<p>( 同时, 在一个 := 的使用中可以定义, 也可以赋值, 不过我不建议也不会使用这样歧义的用法)</p>
<p>(同样的, := 支持变量的类型不同, 不过这也是比较歧义的用法, 不推荐)</p>
<h4 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h4><p>go的指针并没有什么不同. 为了安全性, 它抛弃了一些灵活性</p>
<p>它不支持指针运算, 相当于一个引用 ( 我不开心 :( )</p>
<h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">i := <span class="number">0</span></span><br><span class="line">p := &amp;i</span><br><span class="line"></span><br><span class="line">p := <span class="built_in">new</span>(i)</span><br></pre></td></tr></table></figure>

<p>new 在 go 中的作用很小, 它的作用就相当于少了一个名字被占用</p>
<h4 id="多重赋值"><a href="#多重赋值" class="headerlink" title="多重赋值"></a>多重赋值</h4><p>go 会先对右边的表达式一次性求值</p>
<h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>go 采用垃圾回收, 三色标记</p>
<h4 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h4><p>slice 相当于 vector, 但他必须依赖于另一个容器, 比如数组</p>
<p>可以挑战 slice 指向数组的那些区间, 同时可以动态增长</p>
<p>增长的区间一旦超过原容器的容量, 会在不更改原容器的情况下 重新分配并拷贝元素</p>
<h3 id="json-xml…"><a href="#json-xml…" class="headerlink" title="json, xml…"></a>json, xml…</h3><p>go 提供了这些格式的转换支持</p>
<p>emmmm…, 感觉 go 使用起来很方便</p>
<p>安全的指针, 方便的变量命名, 垃圾回收, 多重赋值, 多返回值, for衍生while …  </p>
<h3 id="method"><a href="#method" class="headerlink" title="method"></a>method</h3><p>go 的方法声明和定义独立与对象本身  </p>
<p>go 的方法就像一个指定了目标的函数</p>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>go 以其不能随意命名为代价(这样的代价仅仅是不能随意首字母大小写)换来了简洁的封装规范</p>
<p>首字母大写的, 即为 public 成员, 而首字母小写的, 即为 private 成员. 这相当容易判断</p>
]]></content>
  </entry>
  <entry>
    <title>read/static_filed_in_Cpp</title>
    <url>/2020/01/09/read/static_filed_in_Cpp/</url>
    <content><![CDATA[<p>@brief</p>
<p>when I learning java by <thinking in java>, I see “The order of initialization is statics first…”. so… what about c++?</p>
<p>当我通过 thinking in java 学 java 时, 我注意到书中的一句话 “The order of initialization is statics first”. 那么, c++ 中是怎样对待的呢?</p>
<h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p>think this code:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> i2 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i;</span><br><span class="line">    A() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"hello"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A::i = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; A::i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    A::i = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; A::i &lt;&lt; <span class="built_in">endl</span>;           </span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(f)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(f)</span></span>;</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>class A has a static field i, it’s an integer with default value 10.</p>
<p>how did these codes do?</p>
<p>类 A 有一个静态字段 i, 这是一个具有默认值为10的整型字段</p>
<p>assembly time</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_ZN1A1iE:</span><br><span class="line">▹   .long▹  10</span><br><span class="line">▹   .text</span><br><span class="line">▹   .globl▹ _Z1fv</span><br><span class="line">▹   .type▹  _Z1fv, @function	</span><br><span class="line">_Z1fv:</span><br><span class="line">.LFB3324:</span><br><span class="line">▹   .cfi_startproc</span><br><span class="line">▹   pushq▹  %rbp</span><br><span class="line">▹   .cfi_def_cfa_offset 16</span><br><span class="line">▹   .cfi_offset 6, -16</span><br><span class="line">▹   movq▹   %rsp, %rbp</span><br><span class="line">▹   .cfi_def_cfa_register 6</span><br><span class="line">▹   subq▹   $16, %rsp</span><br><span class="line">▹   leaq▹   -4(%rbp), %rax</span><br><span class="line">▹   movq▹   %rax, %rdi</span><br><span class="line">▹   call▹   _ZN1AC1Ev</span><br><span class="line">▹   movl▹   _ZN1A1iE(%rip), %eax &#x2F;&#x2F; _ZN1A1iE</span><br><span class="line">▹   movl▹   %eax, %esi</span><br><span class="line">▹   leaq▹   _ZSt4cout(%rip), %rdi</span><br><span class="line">▹   call▹   _ZNSolsEi@PLT</span><br><span class="line">▹   movq▹   %rax, %rdx</span><br><span class="line">▹   movq▹   _ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_@GOTPCREL(%rip), %rax</span><br><span class="line">▹   movq▹   %rax, %rsi</span><br><span class="line">▹   movq▹   %rdx, %rdi</span><br><span class="line">▹   call▹   _ZNSolsEPFRSoS_E@PLT</span><br><span class="line">▹   movl▹   $100, _ZN1A1iE(%rip)</span><br><span class="line">▹   nop</span><br><span class="line">▹   leave                                                                                  </span><br><span class="line">▹   .cfi_def_cfa 7, 8</span><br><span class="line">▹   ret</span><br><span class="line">...</span><br><span class="line">main:</span><br><span class="line">.LFB3325:                                                                                 </span><br><span class="line">▹   .cfi_startproc</span><br><span class="line">▹   .cfi_personality 0x9b,DW.ref.__gxx_personality_v0</span><br><span class="line">▹   .cfi_lsda 0x1b,.LLSDA3325</span><br><span class="line">▹   pushq▹  %rbp</span><br><span class="line">▹   .cfi_def_cfa_offset 16</span><br><span class="line">▹   .cfi_offset 6, -16</span><br><span class="line">▹   movq▹   %rsp, %rbp</span><br><span class="line">▹   .cfi_def_cfa_register 6</span><br><span class="line">▹   pushq▹  %rbx</span><br><span class="line">▹   subq▹   $40, %rsp</span><br><span class="line">▹   .cfi_offset 3, -24</span><br><span class="line">▹   leaq▹   -20(%rbp), %rax</span><br><span class="line">▹   movq▹   %rax, %rdi</span><br><span class="line">.LEHB0:</span><br><span class="line">▹   call▹   _ZN1AC1Ev</span><br><span class="line">▹   movl▹   _ZN1A1iE(%rip), %eax &#x2F;&#x2F; _ZN1A1iE</span><br><span class="line">▹   movl▹   %eax, %esi</span><br><span class="line">▹   leaq▹   _ZSt4cout(%rip), %rdi</span><br><span class="line">▹   call▹   _ZNSolsEi@PLT</span><br><span class="line">▹   movq▹   %rax, %rdx</span><br><span class="line">▹   movq▹   _ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_@GOTPCREL(%rip), %rax</span><br><span class="line">▹   movq▹   %rax, %rsi</span><br><span class="line">▹   movq▹   %rdx, %rdi</span><br><span class="line">▹   call▹   _ZNSolsEPFRSoS_E@PLT</span><br><span class="line">▹   leaq▹   -32(%rbp), %rax</span><br><span class="line">▹   leaq▹   _Z1fv(%rip), %rsi</span><br><span class="line">▹   movq▹   %rax, %rdi</span><br><span class="line">▹   call▹   _ZNSt6threadC1IRFvvEJEEEOT_DpOT0_</span><br></pre></td></tr></table></figure>

<p>so, static value initialize while process run then copy to register while class construct function executed</p>
<p>所以, 静态变量随着程序运行而初始化, 随后在类构造函数完成后, 将其值拷贝到寄存器</p>
<p>this can also be discovered in gdb </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) b main</span><br><span class="line">Breakpoint 1 at 0x1908: file t.cpp, line 33.</span><br><span class="line">(gdb) c</span><br><span class="line">The program is not being run.</span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: &#x2F;root&#x2F;cpp&#x2F;a.out </span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">Using host libthread_db library &quot;&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libthread_db.so.1&quot;.</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at t.cpp:33</span><br><span class="line">33	    A a;</span><br><span class="line">(gdb) p A::i</span><br><span class="line">$2 &#x3D; 10</span><br><span class="line">(gdb) p &amp;A::i</span><br><span class="line">$3 &#x3D; (int *) 0x555555758100 &lt;A::i&gt;</span><br><span class="line">(gdb) p (int)0x555555758100</span><br><span class="line">$4 &#x3D; 1433764096</span><br><span class="line">(gdb) p &#123;int&#125;0x555555758100</span><br><span class="line">$5 &#x3D; 10</span><br></pre></td></tr></table></figure>



<h3 id="how-about-static-const"><a href="#how-about-static-const" class="headerlink" title="how about static const?"></a>how about static const?</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">public:</span><br><span class="line">    int i2 &#x3D; 1;</span><br><span class="line">    static int const i &#x3D; 11;</span><br><span class="line">    A() &#123; cout &lt;&lt; &quot;hello&quot; &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line">_Z1fv:</span><br><span class="line">.LFB3324:</span><br><span class="line">▹   .cfi_startproc</span><br><span class="line">▹   pushq▹  %rbp</span><br><span class="line">▹   .cfi_def_cfa_offset 16</span><br><span class="line">▹   .cfi_offset 6, -16</span><br><span class="line">▹   movq▹   %rsp, %rbp </span><br><span class="line">▹   .cfi_def_cfa_register 6</span><br><span class="line">▹   subq▹   $16, %rsp</span><br><span class="line">▹   leaq▹   -4(%rbp), %rax</span><br><span class="line">▹   movq▹   %rax, %rdi</span><br><span class="line">▹   call▹   _ZN1AC1Ev</span><br><span class="line">▹   movl▹   $11, %esi        &#x2F;&#x2F; *       </span><br><span class="line">▹   leaq▹   _ZSt4cout(%rip), %rdi</span><br><span class="line">...</span><br><span class="line">main:</span><br><span class="line">.LFB3325:</span><br><span class="line">▹   .cfi_startproc</span><br><span class="line">▹   .cfi_personality 0x9b,DW.ref.__gxx_personality_v0</span><br><span class="line">▹   .cfi_lsda 0x1b,.LLSDA3325</span><br><span class="line">▹   pushq▹  %rbp</span><br><span class="line">▹   .cfi_def_cfa_offset 16</span><br><span class="line">▹   .cfi_offset 6, -16</span><br><span class="line">▹   movq▹   %rsp, %rbp</span><br><span class="line">▹   .cfi_def_cfa_register 6</span><br><span class="line">▹   pushq▹  %rbx</span><br><span class="line">▹   subq▹   $40, %rsp</span><br><span class="line">▹   .cfi_offset 3, -24</span><br><span class="line">▹   leaq▹   -20(%rbp), %rax</span><br><span class="line">▹   movq▹   %rax, %rdi</span><br><span class="line">.LEHB0:</span><br><span class="line">▹   call▹   _ZN1AC1Ev</span><br><span class="line">▹   movl▹   $11, %esi             &#x2F;&#x2F; *                       </span><br><span class="line">▹   leaq▹   _ZSt4cout(%rip), %rdi</span><br></pre></td></tr></table></figure>

<p>if you use static const, there no space to store value, just a compile-time const value</p>
<p>如果使用static const, 则不会有空间存储值, 则是一个编译时常量</p>
]]></content>
  </entry>
  <entry>
    <title>read/SortedIndexBuilds</title>
    <url>/2020/01/09/read/SortedIndexBuilds/</url>
    <content><![CDATA[<h4 id="15-6-2-3-Sorted-Index-Builds"><a href="#15-6-2-3-Sorted-Index-Builds" class="headerlink" title="15.6.2.3 Sorted Index Builds"></a>15.6.2.3 Sorted Index Builds</h4><p>There are three phases to an index build. In the first phase, the <a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_clustered_index" target="_blank" rel="noopener">clustered index</a> is scanned, and index entries are generated and added to the sort buffer. When the <a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_sort_buffer" target="_blank" rel="noopener">sort buffer</a> becomes full, entries are sorted and written out to a temporary intermediate file. This process is also known as a “run”. In the second phase, with one or more runs written to the temporary intermediate file, a merge sort is performed on all entries in the file. In the third and final phase, the sorted entries are inserted into the <a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_b_tree" target="_blank" rel="noopener">B-tree</a>.</p>
<p>索引构建有三个阶段, 第一阶段, 扫描聚簇索引, 生成索引条目, 添加到排序缓存中. 当排序缓存被填满时, 条目数据排序并存储到临时的中间文件. 这个过程也被成为 ‘run’, 第二阶段, 随着 ‘runs’ 写入到临时中间文件, 对所有文件中的条目数据执行合并排序, 第三阶段, 排序好的条目数据插入到 B-tree 中.</p>
<p>Prior to the introduction of sorted index builds, index entries were inserted into the B-tree one record at a time using insert APIs. This method involved opening a B-tree<a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_cursor" target="_blank" rel="noopener">cursor</a> to find the insert position and then inserting entries into a B-tree page using an <a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_optimistic" target="_blank" rel="noopener">optimistic</a> insert. If an insert failed due to a page being full, a <a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_pessimistic" target="_blank" rel="noopener">pessimistic</a> insert would be performed, which involves opening a B-tree cursor and splitting and merging B-tree nodes as necessary to find space for the entry. The drawbacks of this “top-down”method of building an index are the cost of searching for an insert position and the constant splitting and merging of B-tree nodes.</p>
<p>在引进有序索引构建之前, 使用插入 APIs 一次一条, 将索引条目插入到 B-tree 中. 这个方法包括打开 B-tree 光标, 查找插入位置, 然后使用 optimistic 插入数据到 B-tree 页中.</p>
<p>如果因为页面已满而插入失败, 执行 pessimistic 插入, 包括打开 B-tree 光标, 并根据需要分裂合并 B-tree 节点, 以便为条目找到空间. </p>
<p>Sorted index builds use a “bottom-up” approach to building an index. With this approach, a reference to the right-most leaf page is held at all levels of the B-tree. The right-most leaf page at the necessary B-tree depth is allocated and entries are inserted according to their sorted order. Once a leaf page is full, a node pointer is appended to the parent page and a sibling leaf page is allocated for the next insert. This process continues until all entries are inserted, which may result in inserts up to the root level. When a sibling page is allocated, the reference to the previously pinned leaf page is released, and the newly allocated leaf page becomes the right-most leaf page and new default insert location.</p>
<p>有序索引使用自底向上方法构建索引, 使用这种方法, 所有 B-tree 层级都有一个指向最右叶子页的引用. 最右叶子页在必要的 B-tree 深度分配, 条目根据他们有序顺序插入. 当叶子节点满了, 父节点增加一个节点指针, 为下一次插入分配一个 sibling 叶子页. 这个过程持续到所有的条目插入为止, 可能导致插入到根层级.</p>
<p>当 sibling 页分配后, 指向之前固定的叶子页的引用被释放, 新分配的叶子页成为最右叶子页和新的插入位置</p>
<p>(PS. 和自平衡二叉树类似, 插入节点到尾端节点, 不断上溢到适当的位置)</p>
<h5 id="Reserving-B-tree-Page-Space-for-Future-Index-Growth"><a href="#Reserving-B-tree-Page-Space-for-Future-Index-Growth" class="headerlink" title="Reserving B-tree Page Space for Future Index Growth"></a>Reserving B-tree Page Space for Future Index Growth</h5><p>To set aside space for future index growth, you can use the <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_fill_factor" target="_blank" rel="noopener"><code>innodb_fill_factor</code></a> configuration option to reserve a percentage of B-tree page space. For example, setting <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_fill_factor" target="_blank" rel="noopener"><code>innodb_fill_factor</code></a> to 80 reserves 20 percent of the space in B-tree pages during a sorted index build. This setting applies to both B-tree leaf and non-leaf pages. It does not apply to external pages used for <a href="https://dev.mysql.com/doc/refman/8.0/en/blob.html" target="_blank" rel="noopener"><code>TEXT</code></a> or <a href="https://dev.mysql.com/doc/refman/8.0/en/blob.html" target="_blank" rel="noopener"><code>BLOB</code></a> entries. The amount of space that is reserved may not be exactly as configured, as the <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_fill_factor" target="_blank" rel="noopener"><code>innodb_fill_factor</code></a> value is interpreted as a hint rather than a hard limit.</p>
<p>为了设置空间为以后的索引增长做准备, 可以使用 innodb_fill_factor 设置存储百分比 B-tree 页空间, 比如, 设置 innodb_fill_factor 为 80, 存储 20% 的空间. 这个设置引用于所有 B-tree 叶和非叶页, 不适用于 TEXT / BLOB 条目的页. </p>
<p>存储的页面大小不一定精准, innodb_fill_factor 是一个提示, 而并不是硬限制</p>
<h5 id="Sorted-Index-Builds-and-Full-Text-Index-Support"><a href="#Sorted-Index-Builds-and-Full-Text-Index-Support" class="headerlink" title="Sorted Index Builds and Full-Text Index Support"></a>Sorted Index Builds and Full-Text Index Support</h5><p>Sorted index builds are supported for <a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_fulltext_index" target="_blank" rel="noopener">fulltext indexes</a>. Previously, SQL was used to insert entries into a fulltext index.</p>
<p>有序索引构建支持 fulltext index.</p>
<h5 id="Sorted-Index-Builds-and-Compressed-Tables"><a href="#Sorted-Index-Builds-and-Compressed-Tables" class="headerlink" title="Sorted Index Builds and Compressed Tables"></a>Sorted Index Builds and Compressed Tables</h5><p>For <a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_compression" target="_blank" rel="noopener">compressed tables</a>, the previous index creation method appended entries to both compressed and uncompressed pages. When the modification log (representing free space on the compressed page) became full, the compressed page would be recompressed. If compression failed due to a lack of space, the page would be split. With sorted index builds, entries are only appended to uncompressed pages. When an uncompressed page becomes full, it is compressed. Adaptive padding is used to ensure that compression succeeds in most cases, but if compression fails, the page is split and compression is attempted again. This process continues until compression is successful. For more information about compression of B-Tree pages, see <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-compression-internals.html" target="_blank" rel="noopener">Section 15.9.1.5, “How Compression Works for InnoDB Tables”</a>.</p>
<p>对压缩表, 之前创建索引的方法将条目添加到压缩/未压缩页面, 当更改日志逐渐增多, 压缩页需要重压缩. 如果因为空间不足而压缩失败, 也需要被分割, 在有序构建中, 条目仅仅添加到未压缩页. 当未压缩页逐渐填满, 压缩该页.</p>
<p>在大多数情况下适应的填充用作确保压缩成功, 如果压缩失败, 页被分隔, 然后再次尝试压缩. 这个过程直到压缩成功为止.</p>
<h5 id="Sorted-Index-Builds-and-Redo-Logging"><a href="#Sorted-Index-Builds-and-Redo-Logging" class="headerlink" title="Sorted Index Builds and Redo Logging"></a>Sorted Index Builds and Redo Logging</h5><p><a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_redo_log" target="_blank" rel="noopener">Redo logging</a> is disabled during a sorted index build. Instead, there is a <a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_checkpoint" target="_blank" rel="noopener">checkpoint</a> to ensure that the index build can withstand a crash or failure. The checkpoint forces a write of all dirty pages to disk. During a sorted index build, the <a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_page_cleaner" target="_blank" rel="noopener">page cleaner</a> thread is signaled periodically to flush <a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_dirty_page" target="_blank" rel="noopener">dirty pages</a> to ensure that the checkpoint operation can be processed quickly. Normally, the page cleaner thread flushes dirty pages when the number of clean pages falls below a set threshold. For sorted index builds, dirty pages are flushed promptly to reduce checkpoint overhead and to parallelize I/O and CPU activity.</p>
<p>在有序索引构建期间, redo logging 不可用. 代替其的是 checkpoint, 它确保索引构建禁得住错误和崩溃. checkpoint 强制脏页写回缓存. </p>
<h5 id="Sorted-Index-Builds-and-Optimizer-Statistics"><a href="#Sorted-Index-Builds-and-Optimizer-Statistics" class="headerlink" title="Sorted Index Builds and Optimizer Statistics"></a>Sorted Index Builds and Optimizer Statistics</h5><p>Sorted index builds may result in <a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_optimizer" target="_blank" rel="noopener">optimizer</a> statistics that differ from those generated by the previous method of index creation. The difference in statistics, which is not expected to affect workload performance, is due to the different algorithm used to populate the index.</p>
]]></content>
  </entry>
  <entry>
    <title>read/sort2</title>
    <url>/2020/01/09/read/sort2/</url>
    <content><![CDATA[<p>this is a follow-up to <a href="http://49.235.55.145/html_note/sort.html" target="_blank" rel="noopener">sort</a></p>
<p>these sort algorithms based on &lt;Algorithms, 4th&gt;</p>
<h2 id="shell-sort"><a href="#shell-sort" class="headerlink" title="shell sort"></a>shell sort</h2><p>shell sort is a better version sort algorithm based on insert sort.</p>
<p>when a[0] is the biggest number but head of array, for move the number to the end of the array, need swap length(a) elements. </p>
<p>shell sort 是基于插入排序的改良版本</p>
<p>当 a[0] 是整个数组最大的元素时, 为了移动这个元素到数组的尾端, 需要交换 length(a) 次元素. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (h &lt; v.<span class="built_in">size</span>() / <span class="number">3</span>) h = h * <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (h &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = h; j &lt; v.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = j; i &gt;= h &amp;&amp; v[i] &lt; v[i - h]; i -= h)</span><br><span class="line">                swap(v[i], v[i - h]);                         </span><br><span class="line">        &#125;</span><br><span class="line">        h /= <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="bottom-up-sort"><a href="#bottom-up-sort" class="headerlink" title="bottom-up sort"></a>bottom-up sort</h2><p>bottom-up sort is a down-top method based on merge sort.</p>
<p>bottom-up sort 基于合并排序, 是一种从底至上的方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v, <span class="keyword">int</span> b, <span class="keyword">int</span> m, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2 = v;</span><br><span class="line">    <span class="keyword">int</span> mid = m++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = b; i &lt;= e; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &gt; mid)</span><br><span class="line">            v[i] = v2[m++];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (m &gt; e)</span><br><span class="line">            v[i] = v2[b++];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (v2[b] &lt; v2[m])</span><br><span class="line">            v[i] = v2[b++];</span><br><span class="line">        <span class="keyword">else</span>·</span><br><span class="line">            v[i] = v2[m++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bottomupSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; v.<span class="built_in">size</span>(); i *= <span class="number">2</span>)&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; v.<span class="built_in">size</span>() - i; j = j + <span class="number">2</span> * i)</span><br><span class="line">			merge(v, j, j + i <span class="number">-1</span>, <span class="built_in">min</span>(<span class="keyword">int</span>(v.<span class="built_in">size</span>() - <span class="number">1</span>, j + <span class="number">2</span> * i - <span class="number">1</span>)));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="a-better-version-of-quick-sort"><a href="#a-better-version-of-quick-sort" class="headerlink" title="a better version of quick sort"></a>a better version of quick sort</h2><p>if an array with some duplicate numbers,  skip these numbers will be more effective</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QS_MIN_LENGTH 7</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> b, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b &gt;= e) <span class="keyword">return</span>;                          </span><br><span class="line"></span><br><span class="line">    <span class="comment">// if element too little, insertSort more effective than quickSort</span></span><br><span class="line">    <span class="keyword">if</span> (e - b &lt; QS_MIN_LENGTH)</span><br><span class="line">        insertSort(nums, b, e);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// meduim of three can get more effetive pivot</span></span><br><span class="line">    <span class="keyword">int</span> m = (b + e) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (nums[b] &gt; nums[m])</span><br><span class="line">        swap(nums[b], nums[m]);</span><br><span class="line">    <span class="keyword">if</span> (nums[b] &gt; nums[e])</span><br><span class="line">        swap(nums[b], nums[e]);</span><br><span class="line">    <span class="keyword">if</span> (nums[m] &gt; nums[e])</span><br><span class="line">        swap(nums[m], nums[e]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pivot = nums[m];</span><br><span class="line">    <span class="comment">// skip elements equal pivot</span></span><br><span class="line">    <span class="keyword">int</span> lt = b + <span class="number">1</span>, eq = lt, gt = e - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (eq &lt;= gt) &#123; </span><br><span class="line">        <span class="keyword">if</span> (nums[eq] &lt; pivot)</span><br><span class="line">            swap(nums[lt++], nums[eq++]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[eq] &gt; pivot)</span><br><span class="line">            swap(nums[eq], nums[gt--]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            eq++;</span><br><span class="line">    &#125;       </span><br><span class="line"></span><br><span class="line">    quickSort(nums, b, lt - <span class="number">1</span>);</span><br><span class="line">    quickSort(nums, gt + <span class="number">1</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="a-sort-algorithm-without-compare"><a href="#a-sort-algorithm-without-compare" class="headerlink" title="a sort algorithm without compare"></a>a sort algorithm without compare</h3><p>I saw a string sort algorithm without compare in &lt;algorithm 4th&gt;. so take some notes</p>
<p>I’m to lazy to write this code, please check the book…</p>
]]></content>
  </entry>
  <entry>
    <title>read/sort</title>
    <url>/2020/01/09/read/sort/</url>
    <content><![CDATA[<p><a href="https://www.hackerearth.com/zh/practice/algorithms/sorting/bubble-sort/tutorial/" target="_blank" rel="noopener">source link</a></p>
<h2 id="Sort"><a href="#Sort" class="headerlink" title="Sort"></a>Sort</h2><h3 id="Bubble-Sort"><a href="#Bubble-Sort" class="headerlink" title="Bubble Sort"></a>Bubble Sort</h3><p>Bubble is the most common algorithm to sort an array. It based on the idea of repeatedly comparing adjacent element and then swapping their  value if exist in the wrong order </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[j])</span><br><span class="line">                swap(nums[i], nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Selection-sort"><a href="#Selection-sort" class="headerlink" title="Selection sort"></a>Selection sort</h3><p>The selection sort is based on finding the minimum or maximum in an unsorted array and putting it to a sorted array</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">min</span> = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[<span class="built_in">min</span>] &gt; nums[j])</span><br><span class="line">                <span class="built_in">min</span> = j;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums[i], nums[<span class="built_in">min</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Insertion-sort"><a href="#Insertion-sort" class="headerlink" title="Insertion sort"></a>Insertion sort</h3><p>From left to right, find each element’s correct position</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = nums[i];</span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        <span class="keyword">while</span>(j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            nums[j] = nums[j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &lt;= v)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            --j;                            </span><br><span class="line">        &#125;</span><br><span class="line">        nums[j] = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Merge-sort"><a href="#Merge-sort" class="headerlink" title="Merge sort"></a>Merge sort</h3><p>Merge sort is a divide-and-conquer algorithm based on repeatedly breaking down an array to two sub-array and then merge them</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> b, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = (b + e) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> q = m + <span class="number">1</span>, p = b;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = b; i &lt;= e; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p &gt; m)</span><br><span class="line">            v.push_back(nums[q++]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (q &gt; e)</span><br><span class="line">            v.push_back(nums[p++]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[q] &gt; nums[p])</span><br><span class="line">            v.push_back(nums[p++]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            v.push_back(nums[q++]);              </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> val : v)</span><br><span class="line">        nums[b++] = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> b, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b &gt;= e) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    mergeSort(nums, b, (e + b) / <span class="number">2</span>);</span><br><span class="line">    mergeSort(nums, (e + b) / <span class="number">2</span> + <span class="number">1</span>, e);</span><br><span class="line">    merge(nums, b, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Quick-sort"><a href="#Quick-sort" class="headerlink" title="Quick sort"></a>Quick sort</h3><p>Quick sort is also a divide-and-conquer algorithm. But it reduces the space complexity and removes the use of auxiliary array that is used in merger sort<br>One of the most important factors to influence performance is the pivot.<br>I chose the pivot from the middle, front, and back of the array. Sometimes will improve performance</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partion</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> b, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = e;</span><br><span class="line">    <span class="keyword">int</span> m = (b + e) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (nums[b] &gt; nums[m])</span><br><span class="line">        swap(nums[b], nums[m]);</span><br><span class="line">    <span class="keyword">if</span> (nums[b] &gt; nums[e])</span><br><span class="line">        swap(nums[b], nums[e]);</span><br><span class="line">    <span class="keyword">if</span> (nums[m] &gt; nums[e])</span><br><span class="line">        swap(nums[m], nums[e]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> piv = nums[m];</span><br><span class="line">    swap(nums[e--], nums[m]);</span><br><span class="line">    <span class="keyword">while</span> (b &lt; e) &#123;</span><br><span class="line">        <span class="keyword">while</span> (b &lt; e &amp;&amp; nums[b] &lt; piv)</span><br><span class="line">            ++b;</span><br><span class="line">        <span class="keyword">while</span> (b &lt; e &amp;&amp; nums[e] &gt;= piv)</span><br><span class="line">            --e;</span><br><span class="line">        <span class="keyword">if</span> (b &gt;= e) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        swap(nums[b], nums[e]);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(nums[p], nums[b]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> b, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b &gt;= e) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> p = partion(nums, b, e);</span><br><span class="line">    quickSort(nums, b, p - <span class="number">1</span>);</span><br><span class="line">    quickSort(nums, p + <span class="number">1</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Heap-sort"><a href="#Heap-sort" class="headerlink" title="Heap sort"></a>Heap sort</h3><p>Heap sort uses a structure called heap to sort the array. Heap is a complete binary tree.<br>left sub-tree index = 2 * root index + 1<br>right sub-tree index = 2 * root index + 2</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> n, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> largest = i;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> r = l + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l &lt; n &amp;&amp; nums[l] &gt; nums[largest])</span><br><span class="line">        largest = l;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r &lt; n &amp;&amp; nums[r] &gt; nums[largest])</span><br><span class="line">        largest = r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">        swap(nums[i], nums[largest]);</span><br><span class="line">        heapify(nums, n, largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;                </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.<span class="built_in">size</span>() / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        heapify(nums, nums.<span class="built_in">size</span>(), i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        swap(nums[<span class="number">0</span>], nums[i]);</span><br><span class="line">        heapify(nums, i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>read/schedulerAlgorithm</title>
    <url>/2020/01/09/read/schedulerAlgorithm/</url>
    <content><![CDATA[<p>@brief</p>
<p>​    早上地铁充值时有位大妈有东西掉了, 和工作人员沟通了几分钟, 本来就睡晚了, 最后差点导致上班迟到 = =</p>
<p>​    然后突然想到这就是单线程啊… 于是就有了这篇关于 scheduler algorithm 的笔记</p>
<p>​    <a href="https://www.geeksforgeeks.org/cpu-scheduling-in-operating-systems/" target="_blank" rel="noopener">原文</a></p>
<h3 id="what-is-scheduler"><a href="#what-is-scheduler" class="headerlink" title="what is scheduler"></a>what is scheduler</h3><p><strong>Schedulers</strong> are special system software which handle process scheduling in various ways. Their main task is to select the jobs to be submitted into the system and to decide which process to run. There are <a href="https://www.geeksforgeeks.org/gate-notes-operating-system-scheduler/" target="_blank" rel="noopener">three types of Scheduler</a>:</p>
<p>schedulers 是特殊的系统软件, 通过多种方式控制进程调度. 它们主要的任务是选择任务并提交到系统, 决定哪个进程执行, 这里有三种类型的 scheduler</p>
<ol>
<li><p><strong>Long term (job) scheduler –</strong> Due to the smaller size of main memory initially all program are stored in secondary memory. When they are stored or loaded in the main memory they are called process. This is the decision of long term scheduler that how many processes will stay in the ready queue. Hence, in simple words, long term scheduler decides the degree of multi-programming of system.</p>
<p>因为主存空间较小, 最初, 所有的程序都存储在次级内存, 当它们排序或加载到主存时, 称其为进程. 这取决于 long term scheduler , 它决定有多少进程保留在你准备队列中, 因此, 简单来说, long term scheduler 决定了系统的多程序程度</p>
<p>(PS: 这里指的应该是内存和硬盘, 关于 secondary memory, 可以参考 <a href="https://chortle.ccsu.edu/Java5/Notes/chap01/ch01_7.html" target="_blank" rel="noopener">secondary memory</a>)</p>
</li>
<li><p><strong>Medium term scheduler –</strong> Most often, a running process needs I/O operation which doesn’t requires CPU. Hence during the execution of a process when a I/O operation is required then the operating system sends that process from running queue to blocked queue. When a process completes its I/O operation then it should again be shifted to ready queue. ALL these decisions are taken by the medium-term scheduler. Medium-term scheduling is a part of <strong>swapping</strong>.</p>
<p>运行中的进程经常需要 I/O 操作而并非 CPU. 因此在进程执行期间, 当需要 I/O 操作时, 操作系统将当前进程从运行中队列发送到阻塞队列. 当进程完成它的 I/O 操作时, 应该再次将它移回准备队列. 所有这些操作都由 medium-term scheduler 决定, medium-term scheduling 是 swapping 的一部分</p>
</li>
<li><p><strong>Short term (CPU) scheduler –</strong> When there are lots of processes in main memory initially all are present in the ready queue. Among all of the process, a single process is to be selected for execution. This decision is handled by short term scheduler.Let’s have a look at the figure given below. It may make a more clear view for you.</p>
<p>当由大量的进程在准备队列时, 在所有的进程中, 只有一个进程被选择执行. 这由 short term scheduler 决定. </p>
</li>
</ol>
<p><img src="https://media.geeksforgeeks.org/wp-content/uploads/22_.png" alt=""></p>
<p>(PS: 关于 CPU burst time, <a href="https://cs.stackexchange.com/questions/50438/how-does-the-os-determine-the-cpu-burst-time-of-a-process" target="_blank" rel="noopener">determine burst time</a>)</p>
<h3 id="difference-scheduling-algorithms"><a href="#difference-scheduling-algorithms" class="headerlink" title="difference scheduling algorithms"></a>difference scheduling algorithms</h3><p><strong><em>First Come First Serve (FCFS):</em></strong> Simplest scheduling algorithm that schedules according to arrival times of processes. First come first serve scheduling algorithm states that the process that requests the CPU first is allocated the CPU first. It is implemented by using the FIFO queue. When a process enters the ready queue, its PCB is linked onto the tail of the queue. When the CPU is free, it is allocated to the process at the head of the queue. The running process is then removed from the queue. FCFS is a non-preemptive scheduling algorithm.</p>
<p>最简单的调度算法根据时间进程的时间顺序调度. 先到先得调度算法声明最先请求 CPU 的进程最先被处理. 其使用 FIFO 队列实现. 当进程进入准备队列时, PCB 链接到队列的尾部(??? 啥东西???) 当 CPU 空闲时, CPU 资源被分配给队列头部的进程. 运行中进程从队列中移除, FCFS 是一个非抢先式的调度算法</p>
<p><strong>Note:</strong>First come first serve suffers from <a href="https://www.geeksforgeeks.org/convoy-effect-operating-systems/" target="_blank" rel="noopener">convoy effect</a>.</p>
<p>FCFS 受 convoy effect 影响</p>
<p><strong><em>Shortest Job First (SJF):</em></strong> Process which have the shortest burst time are scheduled first.If two processes have the same bust time then FCFS is used to break the tie. It is a non-preemptive scheduling algorithm.</p>
<p>拥有最短突发时间的进程优先调度. 当两个进程拥有同样的突发时间时, FCFS 用于解决这种情况. 它同样是一个非抢占调度算法</p>
<p><strong><em>Longest Job First (LJF):</em></strong> It is similar to SJF scheduling algorithm. But, in this scheduling algorithm, we give priority to the process having the longest burst time. This is non-preemptive in nature i.e., when any process starts executing, can’t be interrupted before complete execution.</p>
<p>类似 SJF 调度算法, 但是, 在这个调度算法中, 给予最长突发时间优先权限. 这同样也是非抢占式的. 当进程开始执行时, 不能在完成执行前被打断</p>
<p><strong><em>Shortest Remaining Time First (SRTF):</em></strong> It is preemptive mode of SJF algorithm in which jobs are schedule according to shortest remaining time.</p>
<p>是 SJF 调度算法的抢占版本, 根据最少剩余时间调度</p>
<p><strong><em>Longest Remaining Time First (LRTF):</em></strong> It is preemptive mode of LJF algorithm in which we give priority to the process having largest burst time remaining.</p>
<p>LJF 算法的抢占模式, 给予最大突发时间剩余进程优先权限</p>
<p><strong><em>Round Robin Scheduling:</em></strong> Each process is assigned a fixed time(Time Quantum/Time Slice) in cyclic way.It is designed especially for the time-sharing system. The ready queue is treated as a circular queue. The CPU scheduler goes around the ready queue, allocating the CPU to each process for a time interval of up to 1-time quantum. To implement Round Robin scheduling, we keep the ready queue as a FIFO queue of processes. New processes are added to the tail of the ready queue. The CPU scheduler picks the first process from the ready queue, sets a timer to interrupt after 1-time quantum, and dispatches the process. One of two things will then happen. The process may have a CPU burst of less than 1-time quantum. In this case, the process itself will release the CPU voluntarily. The scheduler will then proceed to the next process in the ready queue. Otherwise, if the CPU burst of the currently running process is longer than 1-time quantum, the timer will go off and will cause an interrupt to the operating system. A context switch will be executed, and the process will be put at the tail of the ready queue. The CPU scheduler will then select the next process in the ready queue.</p>
<p>每个进程每个周期被分配一个固定的时间(时间量子/时间片), 这特别为时间共享系统所设计. 准备队列被视作一个循环的队列. CPU 调度循环准备队列. 分配 CPU 资源给每个进程最多一个的时间量. </p>
<p>为了实现 round robin scheduling 将准备队列依旧保持为 FIFO 队列, 新的进程在队列的尾端加入, CPU 从队列的头部选取一个进程, 设置在一个时间量后中断的定时器, 派发这个进程. 这个进程的 CPU 突发可能少于1个时间量, 在这种情况下, 进程会自动释放 CPU 资源, 调度器继续处理准备队列的下一个进程, 其他情况下, 如果当前进程 CPU burst 超过1个时间片, 将会触发定时器, 向操作系统发出一个中断. 将会执行内容切换, 进程将会重新放入准备队列的尾端. CPU 调度将会选择准备队列的下一个进程, 以此循环.</p>
<p><strong><em>Priority Based scheduling (Non-Preemptive):</em></strong> In this scheduling, processes are scheduled according to their priorities, i.e., highest priority process is scheduled first. If priorities of two processes match, then schedule according to arrival time. Here starvation of process is possible.</p>
<p>在这个调度下, 进程根据他们的优先级调度, 比如, 高优先级的进程会有限调度. 如果两个进程的优先级相等. 则根据他们的先后顺序调度, 有可能出现饥饿线程</p>
<p><strong><em>Highest Response Ratio Next (HRRN):</em></strong> In this scheduling, processes with highest response ratio is scheduled. This algorithm avoids starvation.</p>
<pre><code>Response Ratio = (Waiting Time + Burst time) / Burst time</code></pre><p>在这种调度下, 拥有高响应比的进程有限调度, 这个算法避免饥饿</p>
<p><strong><em>Multilevel Queue Scheduling:</em></strong> According to the priority of process, processes are placed in the different queues. Generally high priority process are placed in the top level queue. Only after completion of processes from top level queue, lower level queued processes are scheduled. It can suffer from starvation.</p>
<p>根据进程的优先级, 进程被放置在不同的队列. 通常, 高优先级的进程被放置在上层队列. 只有在完成上层队列中的进程后, 低层队列中的进程才会被调度, 它有可能挨饿</p>
<p><strong><em>Multi level Feedback Queue Scheduling:</em></strong> It allows the process to move in between queues. The idea is to separate processes according to the characteristics of their CPU bursts. If a process uses too much CPU time, it is moved to a lower-priority queue.</p>
<p>允许进程在队列中移动, 这个想法根据它们的 CPU 突发特性区分进程, 如果进程使用过多的 CPU 时间, 它将会被移动到低优先级的队列</p>
<p><strong>Some useful facts about Scheduling Algorithms:</strong></p>
<ol>
<li><p>FCFS can cause long waiting times, especially when the first job takes too much CPU time.</p>
<p>FCFS 可能导致长时间等待, 特别是当第一个任务执行太久时</p>
</li>
<li><p>Both SJF and Shortest Remaining time first algorithms may cause starvation. Consider a situation when the long process is there in the ready queue and shorter processes keep coming.</p>
<p>SJF 和 shortest remaining time first 算法可能导致饥饿, 考虑当长的进程在准备队列中, 但一直有短进程不断加入的情景</p>
</li>
<li><p>If time quantum for Round Robin scheduling is very large, then it behaves same as FCFS scheduling.</p>
<p>如果 round robin 调度的时间量太长时, 情况类似于 FCFS 调度</p>
</li>
<li><p>SJF is optimal in terms of average waiting time for a given set of processes,i.e., average waiting time is minimum with this scheduling, but problems are, how to know/predict the time of next job.</p>
<p>就给定一组进程的平均等待时间而言, SJF 是最优的, 但是问题在于, 如何预测下一个任务的执行时间</p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>read/RedisMemoryOptimization</title>
    <url>/2020/01/09/read/RedisMemoryOptimization/</url>
    <content><![CDATA[<p><a href="https://redis.io/topics/memory-optimization" target="_blank" rel="noopener">原文地址</a></p>
<p>This page is a work in progress. Currently it is just a list of things you should check if you have problems with memory.</p>
<h2 id="Special-encoding-of-small-aggregate-data-types"><a href="#Special-encoding-of-small-aggregate-data-types" class="headerlink" title="Special encoding of small aggregate data types"></a>Special encoding of small aggregate data types</h2><p>Since Redis 2.2 many data types are optimized to use less space up to a certain size. Hashes, Lists, Sets composed of just integers, and Sorted Sets, when smaller than a given number of elements, and up to a maximum element size, are encoded in a very memory efficient way that uses <em>up to 10 times less memory</em> (with 5 time less memory used being the average saving).</p>
<p>从 Redis 2.2 开始, 许多数据类型经过优化后使用更少的空间. 哈希, 链表, 只由整型组成的集合, 以及已排序集合.</p>
<p>当小于一定量元素, 并且元素大小达到最大时, 数据以一种相当高效的内存方式编码, 做多可节省 10 倍的内存空间(平均是 5 倍)</p>
<p>This is completely transparent from the point of view of the user and API. Since this is a CPU / memory trade off it is possible to tune the maximum number of elements and maximum element size for special encoded types using the following redis.conf directives.</p>
<p>从用户和API的角度上来看, 这是完全透明的. </p>
<p>因为这是 CPU/内存 的权衡, 可以为使用以下 redis.conf 指令的特殊编码类型的最大元素数量和最大元素大小进行调优</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hash-max-zipmap-entries 512 (hash-max-ziplist-entries for Redis &gt;&#x3D; 2.6)</span><br><span class="line">hash-max-zipmap-value 64  (hash-max-ziplist-value for Redis &gt;&#x3D; 2.6)</span><br><span class="line">list-max-ziplist-entries 512</span><br><span class="line">list-max-ziplist-value 64</span><br><span class="line">zset-max-ziplist-entries 128</span><br><span class="line">zset-max-ziplist-value 64</span><br><span class="line">set-max-intset-entries 512</span><br></pre></td></tr></table></figure>

<p>If a specially encoded value will overflow the configured max size, Redis will automatically convert it into normal encoding. This operation is very fast for small values, but if you change the setting in order to use specially encoded values for much larger aggregate types the suggestion is to run some benchmark and test to check the conversion time.</p>
<p>如果特殊编码的值将超过配置的最大值, Redis 将自动转换其为普通编码. 对于小值转换操作非常快, 但是如果更改设置以为更大的聚合类型使用特殊编码值, 建议使用基准测试测量转换时间</p>
<h2 id="Using-32-bit-instances"><a href="#Using-32-bit-instances" class="headerlink" title="Using 32 bit instances"></a>Using 32 bit instances</h2><p>Redis compiled with 32 bit target uses a lot less memory per key, since pointers are small, but such an instance will be limited to 4 GB of maximum memory usage. To compile Redis as 32 bit binary use <em>make 32bit</em>. RDB and AOF files are compatible between 32 bit and 64 bit instances (and between little and big endian of course) so you can switch from 32 to 64 bit, or the contrary, without problems.</p>
<p>使用32位编译的redis每个键少使用很多空间, 因为指针变小了(8字节变4字节), 但是这样最多就只能使用4GB的内存. </p>
<p>使用make 32bit可以将redis编译为32位程序. RDB和AOF文件在32位和64位实例下是兼容的(同样也是大小端兼容的)所以可以从32位和64位间切换</p>
<h2 id="Bit-and-byte-level-operations"><a href="#Bit-and-byte-level-operations" class="headerlink" title="Bit and byte level operations"></a>Bit and byte level operations</h2><p>Redis 2.2 introduced new bit and byte level operations: <a href="https://redis.io/commands/getrange" target="_blank" rel="noopener">GETRANGE</a>, <a href="https://redis.io/commands/setrange" target="_blank" rel="noopener">SETRANGE</a>, <a href="https://redis.io/commands/getbit" target="_blank" rel="noopener">GETBIT</a> and <a href="https://redis.io/commands/setbit" target="_blank" rel="noopener">SETBIT</a>. Using these commands you can treat the Redis string type as a random access array. For instance if you have an application where users are identified by a unique progressive integer number, you can use a bitmap in order to save information about the sex of users, setting the bit for females and clearing it for males, or the other way around. With 100 million users this data will take just 12 megabytes of RAM in a Redis instance. You can do the same using <a href="https://redis.io/commands/getrange" target="_blank" rel="noopener">GETRANGE</a> and <a href="https://redis.io/commands/setrange" target="_blank" rel="noopener">SETRANGE</a> in order to store one byte of information for each user. This is just an example but it is actually possible to model a number of problems in very little space with these new primitives.</p>
<p>redis 2.2 引进了新的比特和位级别的操作: GETRANGE, SETRANGE, GETBIT 和 SET BIT. 使用这些命令, 你可以对待string类型像一个随机访问数组一样(??? 难道不应该是么?) 比如, 如果有这样一个app, 用户以一个唯一的整型数字标识, 你可以使用bitmap保存用户的性别, 男的置1, 女的清0, 或者其他方式. 1亿用户只需要12m的内存</p>
<p>你可以多 GETRANGE 和 SETRANGE 做同样的操作</p>
<h2 id="Use-hashes-when-possible"><a href="#Use-hashes-when-possible" class="headerlink" title="Use hashes when possible"></a>Use hashes when possible</h2><p>Small hashes are encoded in a very small space, so you should try representing your data using hashes every time it is possible. For instance if you have objects representing users in a web application, instead of using different keys for name, surname, email, password, use a single hash with all the required fields.</p>
<p>If you want to know more about this, read the next section.</p>
<h2 id="Using-hashes-to-abstract-a-very-memory-efficient-plain-key-value-store-on-top-of-Redis"><a href="#Using-hashes-to-abstract-a-very-memory-efficient-plain-key-value-store-on-top-of-Redis" class="headerlink" title="Using hashes to abstract a very memory efficient plain key-value store on top of Redis"></a>Using hashes to abstract a very memory efficient plain key-value store on top of Redis</h2><p>I understand the title of this section is a bit scaring, but I’m going to explain in details what this is about.</p>
<p>Basically it is possible to model a plain key-value store using Redis where values can just be just strings, that is not just more memory efficient than Redis plain keys but also much more memory efficient than memcached.</p>
<p>在 redis 中可以实现只使用单纯string作为值的 key-value, 比 redis plain keys 和 memcached 都要更节省内存</p>
<p>Let’s start with some fact: a few keys use a lot more memory than a single key containing a hash with a few fields. How is this possible? We use a trick. In theory in order to guarantee that we perform lookups in constant time (also known as O(1) in big O notation) there is the need to use a data structure with a constant time complexity in the average case, like a hash table.</p>
<p>But many times hashes contain just a few fields. When hashes are small we can instead just encode them in an O(N) data structure, like a linear array with length-prefixed key value pairs. Since we do this only when N is small, the amortized time for HGET and HSET commands is still O(1): the hash will be converted into a real hash table as soon as the number of elements it contains will grow too much (you can configure the limit in redis.conf).</p>
<p>This does not work well just from the point of view of time complexity, but also from the point of view of constant times, since a linear array of key value pairs happens to play very well with the CPU cache (it has a better cache locality than a hash table).</p>
<p>However since hash fields and values are not (always) represented as full featured Redis objects, hash fields can’t have an associated time to live (expire) like a real key, and can only contain a string. But we are okay with this, this was anyway the intention when the hash data type API was designed (we trust simplicity more than features, so nested data structures are not allowed, as expires of single fields are not allowed).</p>
<p>So hashes are memory efficient. This is very useful when using hashes to represent objects or to model other problems when there are group of related fields. But what about if we have a plain key value business?</p>
<p>Imagine we want to use Redis as a cache for many small objects, that can be JSON encoded objects, small HTML fragments, simple key -&gt; boolean values and so forth. Basically anything is a string -&gt; string map with small keys and values.</p>
<p>Now let’s assume the objects we want to cache are numbered, like:</p>
<ul>
<li>object:102393</li>
<li>object:1234</li>
<li>object:5</li>
</ul>
<p>This is what we can do. Every time there is to perform a SET operation to set a new value, we actually split the key into two parts, one used as a key, and used as field name for the hash. For instance the object named “object:1234” is actually split into:</p>
<ul>
<li>a Key named object:12</li>
<li>a Field named 34</li>
</ul>
<p>So we use all the characters but the latest two for the key, and the final two characters for the hash field name. To set our key we use the following command:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HSET object:12 34 somevalue</span><br></pre></td></tr></table></figure>

<p>As you can see every hash will end containing 100 fields, that is an optimal compromise between CPU and memory saved.</p>
<p>There is another very important thing to note, with this schema every hash will have more or less 100 fields regardless of the number of objects we cached. This is since our objects will always end with a number, and not a random string. In some way the final number can be considered as a form of implicit pre-sharding.</p>
<p>What about small numbers? Like object:2? We handle this case using just “object:” as a key name, and the whole number as the hash field name. So object:2 and object:10 will both end inside the key “object:”, but one as field name “2” and one as “10”.</p>
<p>How much memory we save this way?</p>
<p>I used the following Ruby program to test how this works:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">require &#39;rubygems&#39;</span><br><span class="line">require &#39;redis&#39;</span><br><span class="line"></span><br><span class="line">UseOptimization &#x3D; true</span><br><span class="line"></span><br><span class="line">def hash_get_key_field(key)</span><br><span class="line">    s &#x3D; key.split(&quot;:&quot;)</span><br><span class="line">    if s[1].length &gt; 2</span><br><span class="line">        &#123;:key &#x3D;&gt; s[0]+&quot;:&quot;+s[1][0..-3], :field &#x3D;&gt; s[1][-2..-1]&#125;</span><br><span class="line">    else</span><br><span class="line">        &#123;:key &#x3D;&gt; s[0]+&quot;:&quot;, :field &#x3D;&gt; s[1]&#125;</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">def hash_set(r,key,value)</span><br><span class="line">    kf &#x3D; hash_get_key_field(key)</span><br><span class="line">    r.hset(kf[:key],kf[:field],value)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">def hash_get(r,key,value)</span><br><span class="line">    kf &#x3D; hash_get_key_field(key)</span><br><span class="line">    r.hget(kf[:key],kf[:field],value)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">r &#x3D; Redis.new</span><br><span class="line">(0..100000).each&#123;|id|</span><br><span class="line">    key &#x3D; &quot;object:#&#123;id&#125;&quot;</span><br><span class="line">    if UseOptimization</span><br><span class="line">        hash_set(r,key,&quot;val&quot;)</span><br><span class="line">    else</span><br><span class="line">        r.set(key,&quot;val&quot;)</span><br><span class="line">    end</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This is the result against a 64 bit instance of Redis 2.2:</p>
<ul>
<li>UseOptimization set to true: 1.7 MB of used memory</li>
<li>UseOptimization set to false; 11 MB of used memory</li>
</ul>
<p>This is an order of magnitude, I think this makes Redis more or less the most memory efficient plain key value store out there.</p>
<p><em>WARNING</em>: for this to work, make sure that in your redis.conf you have something like this:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hash-max-zipmap-entries 256</span><br></pre></td></tr></table></figure>

<p>Also remember to set the following field accordingly to the maximum size of your keys and values:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hash-max-zipmap-value 1024</span><br></pre></td></tr></table></figure>

<p>Every time a hash will exceed the number of elements or element size specified it will be converted into a real hash table, and the memory saving will be lost.</p>
<p>You may ask, why don’t you do this implicitly in the normal key space so that I don’t have to care? There are two reasons: one is that we tend to make trade offs explicit, and this is a clear tradeoff between many things: CPU, memory, max element size. The second is that the top level key space must support a lot of interesting things like expires, LRU data, and so forth so it is not practical to do this in a general way.</p>
<p>But the Redis Way is that the user must understand how things work so that he is able to pick the best compromise, and to understand how the system will behave exactly.</p>
<h2 id="Memory-allocation"><a href="#Memory-allocation" class="headerlink" title="Memory allocation"></a>Memory allocation</h2><p>To store user keys, Redis allocates at most as much memory as the <code>maxmemory</code> setting enables (however there are small extra allocations possible).</p>
<p>The exact value can be set in the configuration file or set later via <a href="https://redis.io/commands/config-set" target="_blank" rel="noopener">CONFIG SET</a> (see <a href="http://redis.io/topics/lru-cache" target="_blank" rel="noopener">Using memory as an LRU cache for more info</a>). There are a few things that should be noted about how Redis manages memory:</p>
<ul>
<li>Redis will not always free up (return) memory to the OS when keys are removed. This is not something special about Redis, but it is how most malloc() implementations work. For example if you fill an instance with 5GB worth of data, and then remove the equivalent of 2GB of data, the Resident Set Size (also known as the RSS, which is the number of memory pages consumed by the process) will probably still be around 5GB, even if Redis will claim that the user memory is around 3GB. This happens because the underlying allocator can’t easily release the memory. For example often most of the removed keys were allocated in the same pages as the other keys that still exist.</li>
<li>The previous point means that you need to provision memory based on your <strong>peak memory usage</strong>. If your workload from time to time requires 10GB, even if most of the times 5GB could do, you need to provision for 10GB.</li>
<li>However allocators are smart and are able to reuse free chunks of memory, so after you freed 2GB of your 5GB data set, when you start adding more keys again, you’ll see the RSS (Resident Set Size) to stay steady and don’t grow more, as you add up to 2GB of additional keys. The allocator is basically trying to reuse the 2GB of memory previously (logically) freed.</li>
<li>Because of all this, the fragmentation ratio is not reliable when you had a memory usage that at peak is much larger than the currently used memory. The fragmentation is calculated as the amount of memory currently in use (as the sum of all the allocations performed by Redis) divided by the physical memory actually used (the RSS value). Because the RSS reflects the peak memory, when the (virtually) used memory is low since a lot of keys / values were freed, but the RSS is high, the ratio <code>mem_used / RSS</code> will be very high.</li>
</ul>
<p>If <code>maxmemory</code> is not set Redis will keep allocating memory as it finds fit and thus it can (gradually) eat up all your free memory. Therefore it is generally advisable to configure some limit. You may also want to set <code>maxmemory-policy</code> to <code>noeviction</code> (which is <em>not</em> the default value in some older versions of Redis).</p>
<p>It makes Redis return an out of memory error for write commands if and when it reaches the limit - which in turn may result in errors in the application but will not render the whole machine dead because of memory starvation.</p>
<h2 id="Work-in-progress"><a href="#Work-in-progress" class="headerlink" title="Work in progress"></a>Work in progress</h2><p>Work in progress… more tips will be added soon.</p>
]]></content>
  </entry>
  <entry>
    <title>read/MinimunWindowSubstring</title>
    <url>/2020/01/09/read/MinimunWindowSubstring/</url>
    <content><![CDATA[<p>Minimum Window Substring</p>
<p><img src="https://imgur.com/nTiEE6m.png" alt=""></p>
<p>找到字符串 S 中包含字符串 T 所有字符的最小子串</p>
<h2 id="my-solution"><a href="#my-solution" class="headerlink" title="my solution"></a>my solution</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> _ = []() &#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minWindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t.<span class="built_in">size</span>() &gt; s.<span class="built_in">size</span>()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> had = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>, e = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> tmpt = t;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; used;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> indx = tmpt.<span class="built_in">find</span>(s[i]);</span><br><span class="line">            <span class="keyword">if</span> (indx == <span class="built_in">string</span>::npos) &#123;</span><br><span class="line">                ++used[s[i]]; <span class="keyword">continue</span>; </span><br><span class="line">            &#125;</span><br><span class="line">            tmpt.erase(tmpt.<span class="built_in">begin</span>() + indx);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (had++ == <span class="number">0</span>) b = i;</span><br><span class="line">            <span class="keyword">if</span> (tmpt.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">                e = i; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (had != t.<span class="built_in">size</span>()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> rb = b, re = e;</span><br><span class="line">        <span class="keyword">while</span> (b &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">char</span> need = s[b++];</span><br><span class="line">            <span class="keyword">while</span> (b &lt; s.<span class="built_in">size</span>() &amp;&amp; t.<span class="built_in">find</span>(s[b]) == <span class="built_in">string</span>::npos) b++;</span><br><span class="line">            <span class="keyword">if</span> (b &gt;= s.<span class="built_in">size</span>()) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (used[need] &gt; <span class="number">0</span>) &#123; </span><br><span class="line">                <span class="keyword">if</span> (e - b &lt; re - rb) &#123;</span><br><span class="line">                    rb = b; re = e;</span><br><span class="line">                &#125;</span><br><span class="line">                --used[need]; <span class="keyword">continue</span>; </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (++e &lt; s.<span class="built_in">size</span>() &amp;&amp; s[e] != need)</span><br><span class="line">                ++used[s[e]];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (e &gt;= s.<span class="built_in">size</span>()) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (e - b &lt; re - rb) &#123;</span><br><span class="line">                rb = b; re = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s.substr(rb, re - rb + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>代码量挺大的… </p>
<p>简单来说, 我的想法是首先找到最左边包含所有字符的最小子串, 然后 slide window , 慢慢移动到字符 S 尾端 </p>
<p>这样的话, 复杂度就是 O(n)</p>
<h2 id="the-best-solution"><a href="#the-best-solution" class="headerlink" title="the best solution"></a>the best solution</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minWindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; hash(<span class="number">128</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c: t) hash[c]++;</span><br><span class="line">        <span class="keyword">int</span> count = t.<span class="built_in">size</span>(), start = <span class="number">0</span>, <span class="built_in">end</span> = <span class="number">0</span>, minStart, minLen = INT_MAX;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">end</span> &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(hash[s[<span class="built_in">end</span>]] &gt; <span class="number">0</span>) count--;</span><br><span class="line">            hash[s[<span class="built_in">end</span>]]--;</span><br><span class="line">            <span class="built_in">end</span>++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(count == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(hash[s[start]] == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">end</span> - start &lt; minLen) &#123;</span><br><span class="line">                        minStart = start;</span><br><span class="line">                        minLen = <span class="built_in">end</span> - start;</span><br><span class="line">                    &#125;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                hash[s[start]]++;</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(minLen == INT_MAX) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">return</span> s.substr(minStart, minLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>它也是类似 slide window 的做法, 不过比我简洁得多, 从实现角度上, 比我要好一些</p>
<p>PS : 这是 hard 难度的题, 但是做完后感觉也就那样…  </p>
<p>是不是所有 hard 难度的题其实本质上的解决方法都不难 ? 或许我对于这些的理解还不够深刻</p>
<p>感觉我再加深一下, 应该就能较为轻松应对 hard 了 :) (膨胀ing… )</p>
]]></content>
  </entry>
  <entry>
    <title>read/LocksSetbyDifferentSQLStatementsinInnoDB</title>
    <url>/2020/01/09/read/LocksSetbyDifferentSQLStatementsinInnoDB/</url>
    <content><![CDATA[<h3 id="15-7-3-Locks-Set-by-Different-SQL-Statements-in-InnoDB"><a href="#15-7-3-Locks-Set-by-Different-SQL-Statements-in-InnoDB" class="headerlink" title="15.7.3 Locks Set by Different SQL Statements in InnoDB"></a>15.7.3 Locks Set by Different SQL Statements in InnoDB</h3><p>If a secondary index is used in a search and index record locks to be set are exclusive, <code>InnoDB</code> also retrieves the corresponding clustered index records and sets locks on them.</p>
<p>如果在搜索中使用次级索引, 并且索引记录锁被设置为互斥. InnoDB 还检索相应的聚簇索引记录, 在记录上设置锁</p>
<p>If you have no indexes suitable for your statement and MySQL must scan the entire table to process the statement, every row of the table becomes locked, which in turn blocks all inserts by other users to the table. It is important to create good indexes so that your queries do not unnecessarily scan many rows.</p>
<p>如果语句没有适当的索引, MySQL 必须扫描整个表. 表的每行都被加锁, 这会导致其他用户在该表的插入操作被阻塞. 创建好的索引非常重要, 这样查询语句就不需要扫描大量行</p>
<p><code>InnoDB</code> sets specific types of locks as follows.</p>
<ul>
<li><p><a href="https://dev.mysql.com/doc/refman/8.0/en/select.html" target="_blank" rel="noopener"><code>SELECT ... FROM</code></a> is a consistent read, reading a snapshot of the database and setting no locks unless the transaction isolation level is set to <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html#isolevel_serializable" target="_blank" rel="noopener"><code>SERIALIZABLE</code></a>. For<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html#isolevel_serializable" target="_blank" rel="noopener"><code>SERIALIZABLE</code></a> level, the search sets shared next-key locks on the index records it encounters. However, only an index record lock is required for statements that lock rows using a unique index to search for a unique row.</p>
<p>SELECT … FROM 具有一致读属性, 读取数据库的快照, 除非事务隔离等级设置为序列化, 否则不加锁.</p>
<p>对序列化隔离等级, 搜索设置共享的 next-key 锁在遇到的索引记录上, 然而, 使用唯一索引去搜索唯一行的语句, 只有索引记录锁是必须的 (PS. 我不懂 = =… )</p>
</li>
<li><p><a href="https://dev.mysql.com/doc/refman/8.0/en/select.html" target="_blank" rel="noopener"><code>SELECT ... FOR UPDATE</code></a> and <a href="https://dev.mysql.com/doc/refman/8.0/en/select.html" target="_blank" rel="noopener"><code>SELECT ... FOR SHARE</code></a> statements that use a unique index acquire locks for scanned rows, and release the locks for rows that do not qualify for inclusion in the result set (for example, if they do not meet the criteria given in the <code>WHERE</code> clause). However, in some cases, rows might not be unlocked immediately because the relationship between a result row and its original source is lost during query execution. For example, in a <a href="https://dev.mysql.com/doc/refman/8.0/en/union.html" target="_blank" rel="noopener"><code>UNION</code></a>, scanned (and locked) rows from a table might be inserted into a temporary table before evaluation whether they qualify for the result set. In this circumstance, the relationship of the rows in the temporary table to the rows in the original table is lost and the latter rows are not unlocked until the end of query execution.</p>
<p>SELECT … FOR UPDATE 和 SELECT … FOR SHARE 语句使用唯一索引获取锁扫描行, 释放不符合返回集合的锁 (比如, 如果它们不在 WHERE 子句条件中). 然而, 在某些条件下, 行可能不会被立即解锁, 因为返回行和它原始资源在查询语句执行期间丢失了. 比如, 在 UNION 语句中, 来自表的已扫描(和已锁)行在它们被评估是否符合搜索结果时, 可能被插入到临时表中, 在这样的环境下, 临时表中的行与原始表中的行的关系将会丢失, 后面的行直到查询结束后才解锁</p>
</li>
<li><p>For <a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_locking_read" target="_blank" rel="noopener">locking reads</a> (<a href="https://dev.mysql.com/doc/refman/8.0/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a> with <code>FOR UPDATE</code> or <code>FOR SHARE</code>), <a href="https://dev.mysql.com/doc/refman/8.0/en/update.html" target="_blank" rel="noopener"><code>UPDATE</code></a>, and <a href="https://dev.mysql.com/doc/refman/8.0/en/delete.html" target="_blank" rel="noopener"><code>DELETE</code></a> statements, the locks that are taken depend on whether the statement uses a unique index with a unique search condition, or a range-type search condition.</p>
<p>对于加锁读(SELECT 和 FRO UPDATE 或 FOR SHARED 配合), UPDATE, 和 DELETE 语句, 是否加锁取决于语句是否使用具有唯一搜索条件或范围类型搜索条件的唯一索引</p>
<ul>
<li><p>For a unique index with a unique search condition, <code>InnoDB</code> locks only the index record found, not the <a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_gap" target="_blank" rel="noopener">gap</a> before it.</p>
<p>对于具有唯一搜索条件的唯一索引而言, InnoDB 只锁定查找到的索引记录, 不包含前面的间隙</p>
</li>
<li><p>For other search conditions, and for non-unique indexes, <code>InnoDB</code> locks the index range scanned, using <a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_gap_lock" target="_blank" rel="noopener">gap locks</a> or <a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_next_key_lock" target="_blank" rel="noopener">next-key locks</a> to block insertions by other sessions into the gaps covered by the range. For information about gap locks and next-key locks, see <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html" target="_blank" rel="noopener">Section 15.7.1, “InnoDB Locking”</a>.</p>
<p>对于其他搜索条件, 以及非唯一索引, InnoDB 锁定范围扫描的索引, 使用间隙锁或 next-key (PS. 我真不知道怎么翻译这个比较优雅 = =) 锁阻塞其他会话包含范围的插入</p>
</li>
</ul>
</li>
<li><p>For index records the search encounters, <a href="https://dev.mysql.com/doc/refman/8.0/en/select.html" target="_blank" rel="noopener"><code>SELECT ... FOR UPDATE</code></a> blocks other sessions from doing <a href="https://dev.mysql.com/doc/refman/8.0/en/select.html" target="_blank" rel="noopener"><code>SELECT ... FOR SHARE</code></a> or from reading in certain transaction isolation levels. Consistent reads ignore any locks set on the records that exist in the read view.</p>
<p>搜索所遇见的索引记录, SELECT … FOR UPDATE 阻塞其他来自 SELECT … FOR SHARE 或 来自在某一隔离级别的读取操作的会话, 一致读忽略任何在读取视图中的记录上设置的锁</p>
</li>
<li><p><a href="https://dev.mysql.com/doc/refman/8.0/en/update.html" target="_blank" rel="noopener"><code>UPDATE ... WHERE ...</code></a> sets an exclusive next-key lock on every record the search encounters. However, only an index record lock is required for statements that lock rows using a unique index to search for a unique row.</p>
<p>UPDATE … WHERE … 设置互斥 next-key 锁到每个搜索遇到的记录上, 然而, 使用唯一索引查找唯一行的语句只需要一个索引记录锁</p>
</li>
<li><p>When <a href="https://dev.mysql.com/doc/refman/8.0/en/update.html" target="_blank" rel="noopener"><code>UPDATE</code></a> modifies a clustered index record, implicit locks are taken on affected secondary index records. The <a href="https://dev.mysql.com/doc/refman/8.0/en/update.html" target="_blank" rel="noopener"><code>UPDATE</code></a> operation also takes shared locks on affected secondary index records when performing duplicate check scans prior to inserting new secondary index records, and when inserting new secondary index records.</p>
<p>当 UPDATE 更改聚簇索引记录时, 在受影响的次级索引上添加一个隐式锁. UPDATE 还会在插入新的次级索引记录前, 执行重复检查扫描时, 向受影响的次级索引记录上添加共享锁</p>
</li>
<li><p><a href="https://dev.mysql.com/doc/refman/8.0/en/delete.html" target="_blank" rel="noopener"><code>DELETE FROM ... WHERE ...</code></a> sets an exclusive next-key lock on every record the search encounters. However, only an index record lock is required for statements that lock rows using a unique index to search for a unique row.</p>
<p>DELETE FROM … WHERE … 给每个搜索遇到的记录设置一个互斥锁, 然而, (PS. 一模一样 = =)</p>
</li>
<li><p><a href="https://dev.mysql.com/doc/refman/8.0/en/insert.html" target="_blank" rel="noopener"><code>INSERT</code></a> sets an exclusive lock on the inserted row. This lock is an index-record lock, not a next-key lock (that is, there is no gap lock) and does not prevent other sessions from inserting into the gap before the inserted row.</p>
<p>INSERT 在插入行设置互斥锁, 这是一个索引记录锁, 而非 next-key 锁 (也就是说, 不是间隙锁)</p>
<p>Prior to inserting the row, a type of gap lock called an insert intention gap lock is set. This lock signals the intent to insert in such a way that multiple transactions inserting into the same index gap need not wait for each other if they are not inserting at the same position within the gap. Suppose that there are index records with values of 4 and 7. Separate transactions that attempt to insert values of 5 and 6 each lock the gap between 4 and 7 with insert intention locks prior to obtaining the exclusive lock on the inserted row, but do not block each other because the rows are nonconflicting.</p>
<p>在插入行之前, 一种称为插入意图间隙锁的间隙锁被设置. 这个锁表示意图一种插入方式 : 多个事务插入同样的索引间隙, 如果它们不是插入间隙中的同样位置, 那么不必等待其他事务完成 (PS. 例如, 你想插入 4 和 5 到 3 和7 之间, 4 和 5 虽然插入的是同样的间隙, 但是它们插入的位置是不同的, 所以不应该阻塞彼此) 假设有值为 4 和 7 的索引记录, 事务分别尝试插入值 5 和 6, 每个事务在获取行的互斥锁之前都使用插入间隙锁锁住间隙 4 到 7, 但是因为行不冲突, 所以不会阻塞彼此</p>
<p>If a duplicate-key error occurs, a shared lock on the duplicate index record is set. This use of a shared lock can result in deadlock should there be multiple sessions trying to insert the same row if another session already has an exclusive lock. This can occur if another session deletes the row. Suppose that an <code>InnoDB</code> table <code>t1</code> has the following structure:</p>
<p>如果发生重复键错误, 在重复所以记录上设置一个共享锁, 这种共享锁的用法会导致死锁 : 可能会有多个会话尝试插入同样的行, 但彼此都已经有了一个互斥锁. 如果其他的事务尝试删除行, 那么可能会出错. 假设 InnoDB 表 t1 有如下结构 : </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1 (i <span class="built_in">INT</span>, PRIMARY <span class="keyword">KEY</span> (i)) <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure>

<p>Now suppose that three sessions perform the following operations in order:</p>
<p>Session 1:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1 <span class="keyword">VALUES</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>Session 2:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1 <span class="keyword">VALUES</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>Session 3:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1 <span class="keyword">VALUES</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>Session 1:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure>

<p>The first operation by session 1 acquires an exclusive lock for the row. The operations by sessions 2 and 3 both result in a duplicate-key error and they both request a shared lock for the row. When session 1 rolls back, it releases its exclusive lock on the row and the queued shared lock requests for sessions 2 and 3 are granted. At this point, sessions 2 and 3 deadlock: Neither can acquire an exclusive lock for the row because of the shared lock held by the other.</p>
<p>会话1 的操作获取行的互斥锁, 会话2 和 会话3 都会导致重复键错误, 都请求获得共享锁. 当 会话1 回滚后, 释放它在行上的互斥锁, 排队的 会话2 和 会话3 被授权共享锁请求, 此时, 会话2 和 会话3 将会陷入死锁状态. 没有会话能获取行互斥锁, 因为彼此持有共享锁</p>
<p>A similar situation occurs if the table already contains a row with key value 1 and three sessions perform the following operations in order:</p>
<p>类似的情况还有 : 如果表已经包含了具有键值 1 的行, 三个会话顺序执行如下操作</p>
<p>Session 1:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> i = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>Session 2:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1 <span class="keyword">VALUES</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>Session 3:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1 <span class="keyword">VALUES</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>Session 1:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<p>The first operation by session 1 acquires an exclusive lock for the row. The operations by sessions 2 and 3 both result in a duplicate-key error and they both request a shared lock for the row. When session 1 commits, it releases its exclusive lock on the row and the queued shared lock requests for sessions 2 and 3 are granted. At this point, sessions 2 and 3 deadlock: Neither can acquire an exclusive lock for the row because of the shared lock held by the other.</p>
</li>
<li><p><a href="https://dev.mysql.com/doc/refman/8.0/en/insert-on-duplicate.html" target="_blank" rel="noopener"><code>INSERT ... ON DUPLICATE KEY UPDATE</code></a> differs from a simple <a href="https://dev.mysql.com/doc/refman/8.0/en/insert.html" target="_blank" rel="noopener"><code>INSERT</code></a> in that an exclusive lock rather than a shared lock is placed on the row to be updated when a duplicate-key error occurs. An exclusive index-record lock is taken for a duplicate primary key value. An exclusive next-key lock is taken for a duplicate unique key value.</p>
<p>INSERT … ON DUPLICATE KEY UPDATE 不同于简单的 INSERT, 当重复键错误发生时, 它获取行的互斥锁而非共享锁, 重复主键值获取互斥索引记录锁, 重复唯一键值获取互斥 next-key 锁</p>
</li>
<li><p><a href="https://dev.mysql.com/doc/refman/8.0/en/replace.html" target="_blank" rel="noopener"><code>REPLACE</code></a> is done like an <a href="https://dev.mysql.com/doc/refman/8.0/en/insert.html" target="_blank" rel="noopener"><code>INSERT</code></a> if there is no collision on a unique key. Otherwise, an exclusive next-key lock is placed on the row to be replaced.</p>
<p>如果没有唯一键碰撞, REPLACE 行为类似 INSERT. 其他情况下, 获取行的互斥 next-key 锁</p>
</li>
<li><p><code>INSERT INTO T SELECT ... FROM S WHERE ...</code> sets an exclusive index record lock (without a gap lock) on each row inserted into <code>T</code>. If the transaction isolation level is <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html#isolevel_read-committed" target="_blank" rel="noopener"><code>READ COMMITTED</code></a>, <code>InnoDB</code> does the search on <code>S</code> as a consistent read (no locks). Otherwise, <code>InnoDB</code> sets shared next-key locks on rows from <code>S</code>. <code>InnoDB</code> has to set locks in the latter case: During roll-forward recovery using a statement-based binary log, every SQL statement must be executed in exactly the same way it was done originally.</p>
<p><a href="https://dev.mysql.com/doc/refman/8.0/en/create-table.html" target="_blank" rel="noopener"><code>CREATE TABLE ... SELECT ...</code></a> performs the <a href="https://dev.mysql.com/doc/refman/8.0/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a> with shared next-key locks or as a consistent read, as for <a href="https://dev.mysql.com/doc/refman/8.0/en/insert-select.html" target="_blank" rel="noopener"><code>INSERT ... SELECT</code></a>.</p>
<p>INSERT INTO T SELECT … FROM S WHERE … 在每个插入到 T 的行上设置一个互斥索引记录锁. </p>
<p>如果事务隔离等级是 READ COMMITTED, InnoDB 在 S 上执行一致读, 其他情况, InnoDB 在来自 S 的行上设置共享 next-key 锁. InnoDB 需要在后一种情况下设置锁 : 在 roll-forward 恢复期间, 使用基于语句的二进制日志, 每个 SQL 语句必须以与初始语句完全相同的方式执行.</p>
<p>CREATE TABLE … SELECT … 执行带有共享 next-key 锁或一致读的 SELECT 语句, 就像 INSERT … SELECT 一样</p>
<p>When a <code>SELECT</code> is used in the constructs <code>REPLACE INTO t SELECT ... FROM s WHERE ...</code> or <code>UPDATE t ... WHERE col IN (SELECT ... FROM s ...)</code>, <code>InnoDB</code>sets shared next-key locks on rows from table <code>s</code>.</p>
<p>当 SELECT 在构造 REPLACE INTO t SELECT … FROM s WHERE … 或 UPDATE t … WHERE col IN (SELECR … FROM s …) 语句时, InnoDB 在 s 中的行上设置共享锁</p>
</li>
<li><p>While initializing a previously specified <code>AUTO_INCREMENT</code> column on a table, <code>InnoDB</code> sets an exclusive lock on the end of the index associated with the <code>AUTO_INCREMENT</code>column. In accessing the auto-increment counter, <code>InnoDB</code> uses a specific <code>AUTO-INC</code> table lock mode where the lock lasts only to the end of the current SQL statement, not to the end of the entire transaction. Other sessions cannot insert into the table while the <code>AUTO-INC</code> table lock is held; see <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-model.html" target="_blank" rel="noopener">Section 15.7.2, “InnoDB Transaction Model”</a>.</p>
<p>当初始化在表上之前指定带有 AUTO_INCREMENT 关键字的列时, InnoDB 在与 AUTO_INCREMENT 关联的索引末尾设置互斥锁. 在访问自增计数器时, InnoDB 使用特殊的 AUTO-INC 表锁模式, 锁只持续当前 SQL 语句的末尾, 而不是当前事务的末尾. 其他会话不能在 AUTO-INC 表锁已获得的情况下插入数据进该表中</p>
<p><code>InnoDB</code> fetches the value of a previously initialized <code>AUTO_INCREMENT</code> column without setting any locks.</p>
<p>InnoDB 无需加锁即可获取之前初始化的 AUTO_INCREMENT 列的值</p>
</li>
<li><p>If a <code>FOREIGN KEY</code> constraint is defined on a table, any insert, update, or delete that requires the constraint condition to be checked sets shared record-level locks on the records that it looks at to check the constraint. <code>InnoDB</code> also sets these locks in the case where the constraint fails.</p>
<p>如果表上定义了 FOREIGN KEY 约束, 任何插入, 更新, 或删除都需要检查约束条件, 在检查约束的记录上设置共享的, 记录级锁</p>
</li>
<li><p><a href="https://dev.mysql.com/doc/refman/8.0/en/lock-tables.html" target="_blank" rel="noopener"><code>LOCK TABLES</code></a> sets table locks, but it is the higher MySQL layer above the <code>InnoDB</code> layer that sets these locks. <code>InnoDB</code> is aware of table locks if <code>innodb_table_locks = 1</code>(the default) and <a href="https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_autocommit" target="_blank" rel="noopener"><code>autocommit = 0</code></a>, and the MySQL layer above <code>InnoDB</code> knows about row-level locks.</p>
<p>LOCK TABLES 设置表锁, 这是高于 InnoDB 层的 MySQL 层设置的锁. 如果 innodb_table_locks = 1 (默认) 并且 autocommit = 0, 则 InnoDB 能够感知表锁, MySQL 层知道行级锁</p>
<p>Otherwise, <code>InnoDB</code>‘s automatic deadlock detection cannot detect deadlocks where such table locks are involved. Also, because in this case the higher MySQL layer does not know about row-level locks, it is possible to get a table lock on a table where another session currently has row-level locks. However, this does not endanger transaction integrity, as discussed in <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-deadlock-detection.html" target="_blank" rel="noopener">Section 15.7.5.2, “Deadlock Detection and Rollback”</a>. See also <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-restrictions.html" target="_blank" rel="noopener">Section 15.6.1.6, “Limits on InnoDB Tables”</a>.</p>
<p>其他情况, InnoDB 的自动死锁发现机制不能察觉涉及这样的表锁的死锁, 同样, 因为在这样的情况下 MySQL 层不能察觉行级锁, 可以在另一个会话当前拥有行级锁的表上获取表锁. 然而, 这会危害事务的完整性</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>read/LimitsonInnoDBTables</title>
    <url>/2020/01/09/read/LimitsonInnoDBTables/</url>
    <content><![CDATA[<h4 id="15-6-1-6-Limits-on-InnoDB-Tables"><a href="#15-6-1-6-Limits-on-InnoDB-Tables" class="headerlink" title="15.6.1.6 Limits on InnoDB Tables"></a>15.6.1.6 Limits on InnoDB Tables</h4><p>Limits on <code>InnoDB</code> tables are described under the following topics in this section:</p>
<ul>
<li><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-restrictions.html#innodb-maximums-minimums" target="_blank" rel="noopener">Maximums and Minimums</a></li>
<li><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-restrictions.html#innodb-table-restrictions" target="_blank" rel="noopener">Restrictions on InnoDB Tables</a></li>
<li><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-restrictions.html#innodb-locking-transactions" target="_blank" rel="noopener">Locking and Transactions</a></li>
</ul>
<p>InnoDB表的限制在以下几个话题中讨论 : 最大和最小, InnoDB表的限制, 锁和事务</p>
<h5 id="Maximums-and-Minimums"><a href="#Maximums-and-Minimums" class="headerlink" title="Maximums and Minimums"></a>Maximums and Minimums</h5><ul>
<li><p>A table can contain a maximum of 1017 columns. Virtual generated columns are included in this limit.</p>
<p>表最多可以包含 1017 列, 虚拟创建的列也包含在其中</p>
</li>
<li><p>A table can contain a maximum of 64 <a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_secondary_index" target="_blank" rel="noopener">secondary indexes</a>.</p>
<p>表最多能有 64 个次级索引</p>
</li>
<li><p>The index key prefix length limit is 3072 bytes for <code>InnoDB</code> tables that use <code>DYNAMIC</code> or <code>COMPRESSED</code> row format.</p>
<p>使用 DYNAMIC 或 COMPRESSED 行存储的 InnoDB 表索引键的前缀宽度被限制在 3072 字节内 (&lt;=)</p>
<p>The index key prefix length limit is 767 bytes for <code>InnoDB</code> tables that use <code>REDUNDANT</code> or <code>COMPACT</code> row format. For example, you might hit this limit with a <a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_column_prefix" target="_blank" rel="noopener">column prefix</a>index of more than 191 characters on a <code>TEXT</code> or <code>VARCHAR</code> column, assuming a <code>utf8mb4</code> character set and the maximum of 4 bytes for each character.</p>
<p>使用 REDUNDANT 或 COMPACT  行存储的 InnoDB 表索引间的前缀宽度被限制在 767 字节内 (&lt;=)</p>
<p>Attempting to use an index key prefix length that exceeds the limit returns an error.</p>
<p>尝试使用超过限制的字节前缀宽度会返回错误</p>
<p>The limits that apply to index key prefixes also apply to full-column index keys.</p>
<p>适用于索引键前缀的限制也适用于全列索引键</p>
</li>
<li><p>If you reduce the <code>InnoDB</code> <a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_page_size" target="_blank" rel="noopener">page size</a> to 8KB or 4KB by specifying the <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_page_size" target="_blank" rel="noopener"><code>innodb_page_size</code></a> option when creating the MySQL instance, the maximum length of the index key is lowered proportionally, based on the limit of 3072 bytes for a 16KB page size. That is, the maximum index key length is 1536 bytes when the page size is 8KB, and 768 bytes when the page size is 4KB.</p>
<p>如果在创建 MySQL 实例时显式指定 innodb_page_size 减少 InnoDB 的页面大小(8kb -&gt; 4kb)索引键的最大长度也会成比例减少</p>
<p>16kb 页大小限制在 3072 字节, 8kb 页大小限制在 1536 字节, 而 4kb 页面大小限制在 768 字节</p>
</li>
<li><p>A maximum of 16 columns is permitted for multicolumn indexes. Exceeding the limit returns an error.</p>
<p>多列索引子列数不能超过 16 个</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">ERROR 1070 (42000): Too many key parts specified; max 16 parts allowed</span><br></pre></td></tr></table></figure>
</li>
<li><p>The maximum row length, except for variable-length columns (<a href="https://dev.mysql.com/doc/refman/8.0/en/binary-varbinary.html" target="_blank" rel="noopener"><code>VARBINARY</code></a>, <a href="https://dev.mysql.com/doc/refman/8.0/en/char.html" target="_blank" rel="noopener"><code>VARCHAR</code></a>, <a href="https://dev.mysql.com/doc/refman/8.0/en/blob.html" target="_blank" rel="noopener"><code>BLOB</code></a> and <a href="https://dev.mysql.com/doc/refman/8.0/en/blob.html" target="_blank" rel="noopener"><code>TEXT</code></a>), is slightly less than half of a page for 4KB, 8KB, 16KB, and 32KB page sizes. For example, the maximum row length for the default <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_page_size" target="_blank" rel="noopener"><code>innodb_page_size</code></a> of 16KB is about 8000 bytes. However, for an <code>InnoDB</code> page size of 64KB, the maximum row length is approximately 16000 bytes. <a href="https://dev.mysql.com/doc/refman/8.0/en/blob.html" target="_blank" rel="noopener"><code>LONGBLOB</code></a> and <a href="https://dev.mysql.com/doc/refman/8.0/en/blob.html" target="_blank" rel="noopener"><code>LONGTEXT</code></a> columns must be less than 4GB, and the total row length, including <a href="https://dev.mysql.com/doc/refman/8.0/en/blob.html" target="_blank" rel="noopener"><code>BLOB</code></a> and <a href="https://dev.mysql.com/doc/refman/8.0/en/blob.html" target="_blank" rel="noopener"><code>TEXT</code></a>columns, must be less than 4GB.</p>
<p>除变长列(VARBINARY, VATCHAR, BLOB, TEXT)外, 列的长度都稍少于一半页的大小. 比如, 页面大小为 16kb 的行长度最大 8000 字节左右, 然而 InnoDB 64kb 的页最大在 16000 字节左右. LONGBLOB 和 LONGTEXT 列必须少于 4GB, 整个行的长度, 包括 BLOB 和 TEXT 列, 也必须少于 4GB.</p>
<p>If a row is less than half a page long, all of it is stored locally within the page. If it exceeds half a page, variable-length columns are chosen for external off-page storage until the row fits within half a page, as described in <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-file-space.html" target="_blank" rel="noopener">Section 15.11.2, “File Space Management”</a>.</p>
<p>如果行小于页的一般, 数据则全部保存在页中, 如果超过, 变长列被选择页外存储直到列的大小符合为止</p>
</li>
<li><p>Although <code>InnoDB</code> supports row sizes larger than 65,535 bytes internally, MySQL itself imposes a row-size limit of 65,535 for the combined size of all columns:</p>
<p>尽管 InnoDB 支持超过 65535 字节的行, MySQL 自身约束列的组合大小不能超过 65535</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE t (a VARCHAR(8000), b VARCHAR(10000),</span><br><span class="line">    -&gt; c VARCHAR(10000), d VARCHAR(10000), e VARCHAR(10000),</span><br><span class="line">    -&gt; f VARCHAR(10000), g VARCHAR(10000)) ENGINE=InnoDB;</span><br><span class="line">ERROR 1118 (42000): Row size too large. The maximum row size for the</span><br><span class="line">used table type, not counting BLOBs, is 65535. You have to <span class="keyword">change</span> <span class="keyword">some</span></span><br><span class="line"><span class="keyword">columns</span> <span class="keyword">to</span> <span class="built_in">TEXT</span> <span class="keyword">or</span> BLOBs</span><br></pre></td></tr></table></figure>

<p>See <a href="https://dev.mysql.com/doc/refman/8.0/en/column-count-limit.html" target="_blank" rel="noopener">Section C.10.4, “Limits on Table Column Count and Row Size”</a>.</p>
</li>
<li><p>On some older operating systems, files must be less than 2GB. This is not a limitation of <code>InnoDB</code> itself, but if you require a large tablespace, configure it using several smaller data files rather than one large data file.</p>
<p>在一些较老的操作系统上, 文件必须小于 2GB. 这不是 InnoDB 的限制, 但是如果你需要一个大的表空间, 可以配置成使用些许较小的数据文件, 而不是一个大的数据文件</p>
</li>
<li><p>The combined size of the <code>InnoDB</code> log files can be up to 512GB.</p>
<p>InnoDB 日志文件的组合大小最大 512GB</p>
</li>
<li><p>The minimum tablespace size is slightly larger than 10MB. The maximum tablespace size depends on the <code>InnoDB</code> page size.</p>
<p>表的最小容量稍大于 10mb, 最大的表大小取决于 InnoDB 页大小</p>
<p><strong>Table 15.3 InnoDB Maximum Tablespace Size</strong></p>
<table>
<thead>
<tr>
<th>InnoDB Page Size</th>
<th>Maximum Tablespace Size</th>
</tr>
</thead>
<tbody><tr>
<td>4KB</td>
<td>16TB</td>
</tr>
<tr>
<td>8KB</td>
<td>32TB</td>
</tr>
<tr>
<td>16KB</td>
<td>64TB</td>
</tr>
<tr>
<td>32KB</td>
<td>128TB</td>
</tr>
<tr>
<td>64KB</td>
<td>256TB</td>
</tr>
</tbody></table>
<p>The maximum tablespace size is also the maximum size for a table.</p>
<p>最大表空间大小也是最大表大小</p>
</li>
<li><p>The path of a tablespace file, including the file name, cannot exceed the <code>MAX_PATH</code> limit on Windows. Prior to Windows 10, the <code>MAX_PATH</code> limit is 260 characters. As of Windows 10, version 1607, <code>MAX_PATH</code> limitations are removed from common Win32 file and directory functions, but you must enable the new behavior.</p>
<p>表空间文件的路径, 包括表名, 在 windows 上不能超过 MAX_PATH 限制, 在 win10 以前 MAX_PATH 限制为 260 字符. win10 1607 版本后移除了该限制</p>
</li>
<li><p>The default page size in <code>InnoDB</code> is 16KB. You can increase or decrease the page size by configuring the <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_page_size" target="_blank" rel="noopener"><code>innodb_page_size</code></a> option when creating the MySQL instance.</p>
<p>InnoDB 默认页大小为 16kb, 创建 MySQL 实例时可以通过设置 innodb_page_size 更改(PS. 页大小在创建后是属于表的局部常量么?)</p>
<p>32KB and 64KB page sizes are supported, but <code>ROW_FORMAT=COMPRESSED</code> is unsupported for page sizes greater than 16KB. For both 32KB and 64KB page sizes, the maximum record size is 16KB. For <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_page_size" target="_blank" rel="noopener"><code>innodb_page_size=32KB</code></a>, extent size is 2MB. For <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_page_size" target="_blank" rel="noopener"><code>innodb_page_size=64KB</code></a>, extent size is 4MB.</p>
<p>A MySQL instance using a particular <code>InnoDB</code> page size cannot use data files or log files from an instance that uses a different page size.</p>
<p>32kb 和 64kb 的页也是支持的, 但是行存储为 COMPRESSED 不支持超过 16kb 大小的页. 对于 32kb 和 64kb 大小的也, 最大记录的大小其实是 16kb. </p>
<p>MySQL 实例不能使用底层页面不一致的数据文件和日志文件</p>
</li>
</ul>
<h5 id="Restrictions-on-InnoDB-Tables"><a href="#Restrictions-on-InnoDB-Tables" class="headerlink" title="Restrictions on InnoDB Tables"></a>Restrictions on InnoDB Tables</h5><ul>
<li><p><a href="https://dev.mysql.com/doc/refman/8.0/en/analyze-table.html" target="_blank" rel="noopener"><code>ANALYZE TABLE</code></a> determines index cardinality (as displayed in the <code>Cardinality</code> column of <a href="https://dev.mysql.com/doc/refman/8.0/en/show-index.html" target="_blank" rel="noopener"><code>SHOW INDEX</code></a> output) by performing <a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_random_dive" target="_blank" rel="noopener">random dives</a> on each of the index trees and updating index cardinality estimates accordingly. Because these are only estimates, repeated runs of <a href="https://dev.mysql.com/doc/refman/8.0/en/analyze-table.html" target="_blank" rel="noopener"><code>ANALYZE TABLE</code></a> could produce different numbers. This makes<a href="https://dev.mysql.com/doc/refman/8.0/en/analyze-table.html" target="_blank" rel="noopener"><code>ANALYZE TABLE</code></a> fast on <code>InnoDB</code> tables but not 100% accurate because it does not take all rows into account.</p>
<p>ANALYZE TABLE 语句每个索引树执行随机潜水(PS. ???)更新预估索引的基数(在 SHOW INDEX 的输出中 Cardinality 列显示)</p>
<p>因为只是估计, 重复执行 ANALYZE TABLE 将会产生不同的值, 这使得 ANALYZE TABLE 在 InnoDB 上运行地很快, 但并不是 100% 正确, 因为并不会估计所有的行</p>
<p>(PS. ANALYZE TABLE 将会分析表, 其中部分分析结果可以在 SHOW INDEX 中查看. 这里以列的基数为例)</p>
<p>You can make the <a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_statistics" target="_blank" rel="noopener">statistics</a> collected by <a href="https://dev.mysql.com/doc/refman/8.0/en/analyze-table.html" target="_blank" rel="noopener"><code>ANALYZE TABLE</code></a> more precise and more stable by turning on the <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_stats_persistent" target="_blank" rel="noopener"><code>innodb_stats_persistent</code></a> configuration option, as explained in <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-persistent-stats.html" target="_blank" rel="noopener">Section 15.8.10.1, “Configuring Persistent Optimizer Statistics Parameters”</a>. When that setting is enabled, it is important to run <a href="https://dev.mysql.com/doc/refman/8.0/en/analyze-table.html" target="_blank" rel="noopener"><code>ANALYZE TABLE</code></a> after major changes to indexed column data, because the statistics are not recalculated periodically (such as after a server restart).</p>
<p>通过启用 innodb_stats_persistent 使 ANALYZE TABLE 的数据统计更加精确, 当启用这个选项后, 需要在对索引列数据进行主要更改后再使用 ANALYZE TABLE, 因为统计信息不是定期重新计算的</p>
<p>If the persistent statistics setting is enabled, you can change the number of random dives by modifying the <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_stats_persistent_sample_pages" target="_blank" rel="noopener"><code>innodb_stats_persistent_sample_pages</code></a> system variable. If the persistent statistics setting is disabled, modify the <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_stats_transient_sample_pages" target="_blank" rel="noopener"><code>innodb_stats_transient_sample_pages</code></a> system variable instead.</p>
<p>如果启用了持续性统计, 可以更改 innodb_stats_persistent_sample_pages 系统变量, 如果持久性统计设置取消, 则可以通过 innodb_stats_transient_sampke_pages 更改</p>
<p>MySQL uses index cardinality estimates in join optimization. If a join is not optimized in the right way, try using <a href="https://dev.mysql.com/doc/refman/8.0/en/analyze-table.html" target="_blank" rel="noopener"><code>ANALYZE TABLE</code></a>. In the few cases that <a href="https://dev.mysql.com/doc/refman/8.0/en/analyze-table.html" target="_blank" rel="noopener"><code>ANALYZE TABLE</code></a>does not produce values good enough for your particular tables, you can use <code>FORCE INDEX</code> with your queries to force the use of a particular index, or set the<a href="https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_max_seeks_for_key" target="_blank" rel="noopener"><code>max_seeks_for_key</code></a> system variable to ensure that MySQL prefers index lookups over table scans. See <a href="https://dev.mysql.com/doc/refman/8.0/en/optimizer-issues.html" target="_blank" rel="noopener">Section B.4.5, “Optimizer-Related Issues”</a>.</p>
<p>MySQL 在 Join 优化中使用索引基数估计, 如果 Join 不能正确优化, 尝试使用 ANALYZE_TABLE. 在少数情况下 ANALYZE_TABLE 不能为指定的表产生足够好的值, 可以使用 FORCE INDEX 配合查询, 强制使用指定的索引或者设置 max_seeks_for_key 系统变量确保 MySQL 更偏向于索引查找而不是表扫描</p>
</li>
<li><p>If statements or transactions are running on a table, and <a href="https://dev.mysql.com/doc/refman/8.0/en/analyze-table.html" target="_blank" rel="noopener"><code>ANALYZE TABLE</code></a> is run on the same table followed by a second <a href="https://dev.mysql.com/doc/refman/8.0/en/analyze-table.html" target="_blank" rel="noopener"><code>ANALYZE TABLE</code></a> operation, the second <a href="https://dev.mysql.com/doc/refman/8.0/en/analyze-table.html" target="_blank" rel="noopener"><code>ANALYZE TABLE</code></a> operation is blocked until the statements or transactions are completed. This behavior occurs because <a href="https://dev.mysql.com/doc/refman/8.0/en/analyze-table.html" target="_blank" rel="noopener"><code>ANALYZE TABLE</code></a> marks the currently loaded table definition as obsolete when <a href="https://dev.mysql.com/doc/refman/8.0/en/analyze-table.html" target="_blank" rel="noopener"><code>ANALYZE TABLE</code></a> is finished running. New statements or transactions (including a second <a href="https://dev.mysql.com/doc/refman/8.0/en/analyze-table.html" target="_blank" rel="noopener"><code>ANALYZE TABLE</code></a> statement) must load the new table definition into the table cache, which cannot occur until currently running statements or transactions are completed and the old table definition is purged. Loading multiple concurrent table definitions is not supported.</p>
<p>如果语句和事务正在运行于表上, ANALYZE TABLE 同样运行于这张表上, 之后继续执行 ANALYZE_TABLE 操作, 第二个 ANALYZE TABLE 操作将会阻塞直到之前的事务/语句执行完成. 会发生这样的情况是因为 ANALYZE_TABLE 在执行完成时会将当前加载的表标记为已过时, 新的语句/事务(包括第二个 ANALYZE_TABLE 语句)必须加载新的表到表缓存中, 改操作在当前语句/事务已经完成, 并且旧表的定义已经被清理后才能发生, 不支持加载多个并发表</p>
</li>
<li><p><a href="https://dev.mysql.com/doc/refman/8.0/en/show-table-status.html" target="_blank" rel="noopener"><code>SHOW TABLE STATUS</code></a> does not give accurate statistics on <code>InnoDB</code> tables except for the physical size reserved by the table. The row count is only a rough estimate used in SQL optimization.</p>
<p>SHOW TABLE STATUS 不提供 InnoDB 表除表存储的物理大小外, 其他统计信息的精确性, 行数量只是一个 SQL 优化中粗略的估计</p>
</li>
<li><p><code>InnoDB</code> does not keep an internal count of rows in a table because concurrent transactions might “see” different numbers of rows at the same time. Consequently, <code>SELECT COUNT(*)</code> statements only count rows visible to the current transaction.</p>
<p>InnoDB 不保存表中行的内部计数, 因为并发事务可能在同样的时间见到不同的值. </p>
<p>因此, SELECT COUNT(*) 语句只计数对当前事务可见的行</p>
<p>For information about how <code>InnoDB</code> processes <code>SELECT COUNT(*)</code> statements, refer to the <a href="https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_count" target="_blank" rel="noopener"><code>COUNT()</code></a> description in <a href="https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html" target="_blank" rel="noopener">Section 12.20.1, “Aggregate (GROUP BY) Function Descriptions”</a>.</p>
</li>
<li><p>On Windows, <code>InnoDB</code> always stores database and table names internally in lowercase. To move databases in a binary format from Unix to Windows or from Windows to Unix, create all databases and tables using lowercase names.</p>
<p>在 Windows 上, InnoDB 总是以小写存储数据库和表的名字(大小写不敏感 = =)</p>
</li>
<li><p>An <code>AUTO_INCREMENT</code> column <em>ai_col</em> must be defined as part of an index such that it is possible to perform the equivalent of an indexed <code>SELECT MAX(*ai_col*)</code> lookup on the table to obtain the maximum column value. Typically, this is achieved by making the column the first column of some table index.</p>
<p>AUTO_INCREMENT 列 ai_col 必须被定义成索引的一部分, 这样就可以执行已被索引的 SELECT MAX(ai_col) 相等性判断, 获取最大的列值. 通常都是公国将列成为列的首列来获得的</p>
</li>
<li><p><code>InnoDB</code> sets an exclusive lock on the end of the index associated with the <code>AUTO_INCREMENT</code> column while initializing a previously specified <code>AUTO_INCREMENT</code> column on a table.</p>
<p>InnoDB 在和 AUTO_INCREMENT 列相关的索引末尾设置互斥锁</p>
<p>With <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_autoinc_lock_mode" target="_blank" rel="noopener"><code>innodb_autoinc_lock_mode=0</code></a>, <code>InnoDB</code> uses a special <code>AUTO-INC</code> table lock mode where the lock is obtained and held to the end of the current SQL statement while accessing the auto-increment counter. Other clients cannot insert into the table while the <code>AUTO-INC</code> table lock is held. The same behavior occurs for “bulk inserts”with <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_autoinc_lock_mode" target="_blank" rel="noopener"><code>innodb_autoinc_lock_mode=1</code></a>. Table-level <code>AUTO-INC</code> locks are not used with <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_autoinc_lock_mode" target="_blank" rel="noopener"><code>innodb_autoinc_lock_mode=2</code></a>. For more information, See <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-auto-increment-handling.html" target="_blank" rel="noopener">Section 15.6.1.4, “AUTO_INCREMENT Handling in InnoDB”</a>.</p>
<p>innodb_automic_lock_mod 设置为 0 时, InnoDB 使用特殊的 AUTO_INC 表锁模式. 在访问自增计数器时锁被持有直到当前 SQL 语句结束</p>
</li>
<li><p>When an <code>AUTO_INCREMENT</code> integer column runs out of values, a subsequent <code>INSERT</code> operation returns a duplicate-key error. This is general MySQL behavior.</p>
<p>当 AUTO_INCREMENT 越界, 插入操作会返回 重复的键 错误, 这是通常 MySQL 的行为</p>
</li>
<li><p><code>DELETE FROM *tbl_name*</code> does not regenerate the table but instead deletes all rows, one by one.</p>
<p>DELETE FROM tbl_name 不再生表, 而是依次删除所有行 </p>
</li>
<li><p>Cascaded foreign key actions do not activate triggers.</p>
<p>级联外键操作不激活触发器</p>
</li>
<li><p>You cannot create a table with a column name that matches the name of an internal <code>InnoDB</code> column (including <code>DB_ROW_ID</code>, <code>DB_TRX_ID</code>, <code>DB_ROLL_PTR</code>, and <code>DB_MIX_ID</code>). This restriction applies to use of the names in any letter case.</p>
<p>你不能创建和内部 InnoDB 列重名的列, 包括(DB_ROW_ID, DB_TRX_ID, DB_ROLL_PTR, DB_MIX_ID)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE t1 (c1 INT, db_row_id INT) ENGINE=INNODB;</span><br><span class="line">ERROR 1166 (42000): Incorrect column name 'db_row_id'</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h5 id="Locking-and-Transactions"><a href="#Locking-and-Transactions" class="headerlink" title="Locking and Transactions"></a>Locking and Transactions</h5><ul>
<li><p><a href="https://dev.mysql.com/doc/refman/8.0/en/lock-tables.html" target="_blank" rel="noopener"><code>LOCK TABLES</code></a> acquires two locks on each table if <code>innodb_table_locks=1</code> (the default). In addition to a table lock on the MySQL layer, it also acquires an <code>InnoDB</code> table lock. Versions of MySQL before 4.1.2 did not acquire <code>InnoDB</code> table locks; the old behavior can be selected by setting <code>innodb_table_locks=0</code>. If no <code>InnoDB</code> table lock is acquired, <a href="https://dev.mysql.com/doc/refman/8.0/en/lock-tables.html" target="_blank" rel="noopener"><code>LOCK TABLES</code></a> completes even if some records of the tables are being locked by other transactions.</p>
<p>如果 innodb_table_locks = 1 则 LOCK TABLES 在每个表上获取两个锁, 除了在 MySQL 层上的锁, 还获取 InnoDB 表锁, 如果没有获取 InnoDB 表锁, 即使一些记录被其他事务锁定, LOCK TABLES 也会完成</p>
<p>In MySQL 8.0, <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_table_locks" target="_blank" rel="noopener"><code>innodb_table_locks=0</code></a> has no effect for tables locked explicitly with <a href="https://dev.mysql.com/doc/refman/8.0/en/lock-tables.html" target="_blank" rel="noopener"><code>LOCK TABLES ... WRITE</code></a>. It does have an effect for tables locked for read or write by <a href="https://dev.mysql.com/doc/refman/8.0/en/lock-tables.html" target="_blank" rel="noopener"><code>LOCK TABLES ... WRITE</code></a> implicitly (for example, through triggers) or by <a href="https://dev.mysql.com/doc/refman/8.0/en/lock-tables.html" target="_blank" rel="noopener"><code>LOCK TABLES ... READ</code></a>.</p>
</li>
<li><p>All <code>InnoDB</code> locks held by a transaction are released when the transaction is committed or aborted. Thus, it does not make much sense to invoke <a href="https://dev.mysql.com/doc/refman/8.0/en/lock-tables.html" target="_blank" rel="noopener"><code>LOCK TABLES</code></a> on<code>InnoDB</code> tables in <a href="https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_autocommit" target="_blank" rel="noopener"><code>autocommit=1</code></a> mode because the acquired <code>InnoDB</code> table locks would be released immediately.</p>
<p>通过事务获取的所有 InnoDB 锁在事务提交或退出时释放, 因此, 在 autocommit = 1 模式下没有那么必要在 InnoDB 表上显式调用 LOCK TABLES 语句, 因为获取的 InnoDB 表锁会立即释放</p>
</li>
<li><p>You cannot lock additional tables in the middle of a transaction because <a href="https://dev.mysql.com/doc/refman/8.0/en/lock-tables.html" target="_blank" rel="noopener"><code>LOCK TABLES</code></a> performs an implicit <a href="https://dev.mysql.com/doc/refman/8.0/en/commit.html" target="_blank" rel="noopener"><code>COMMIT</code></a> and <a href="https://dev.mysql.com/doc/refman/8.0/en/lock-tables.html" target="_blank" rel="noopener"><code>UNLOCK TABLES</code></a>.</p>
<p>你不能在事务中锁额外的表, 因为 LOCK TABLES 执行隐式的 COMMIT 和 UNLOCK TABLES</p>
</li>
<li><p>For limits associated with concurrent read-write transactions, see <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-undo-logs.html" target="_blank" rel="noopener">Section 15.6.6, “Undo Logs”</a>.</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>read/JVM-Memory-model</title>
    <url>/2020/01/09/read/JVM-Memory-model/</url>
    <content><![CDATA[<p><a href="https://www.journaldev.com/2856/java-jvm-memory-model-memory-management-in-java" target="_blank" rel="noopener">source link</a></p>
<h1 id="Java-JVM-Memory-Model-Memory-Management-in-Java"><a href="#Java-JVM-Memory-Model-Memory-Management-in-Java" class="headerlink" title="Java (JVM) Memory Model - Memory Management in Java"></a>Java (JVM) Memory Model - Memory Management in Java</h1><h2 id="Java-JVM-Memory-Model"><a href="#Java-JVM-Memory-Model" class="headerlink" title="Java (JVM) Memory Model"></a>Java (JVM) Memory Model</h2><p><a href="https://cdn.journaldev.com/wp-content/uploads/2014/05/Java-Memory-Model.png" target="_blank" rel="noopener"><img src="https://cdn.journaldev.com/wp-content/uploads/2014/05/Java-Memory-Model-450x186.png" alt="Java Memory Model, JVM Memory Model, Memory Management in Java, Java Memory Management"></a></p>
<p>As you can see in the above image, JVM memory is divided into separate parts. At broad level, JVM Heap memory is physically divided into two parts – <strong>Young Generation</strong> and <strong>Old Generation</strong>.</p>
<p>如上图所示, JVM 被分为了多个部分. JVM 堆物理性被分为两部分, Young Generation 和 Old Generation</p>
<h2 id="Memory-Management-in-Java-–-Young-Generation"><a href="#Memory-Management-in-Java-–-Young-Generation" class="headerlink" title="Memory Management in Java – Young Generation"></a>Memory Management in Java – Young Generation</h2><p>The young generation is the place where all the new objects are created. When the young generation is filled, garbage collection is performed. This garbage collection is called <strong>Minor GC</strong>. Young Generation is divided into three parts – <strong>Eden Memory</strong> and two <strong>Survivor Memory</strong> spaces.</p>
<p>所有新创建的对象一开始都在 young generation 中. GC 在 young generation 被填满时执行. 这个 GC 被称为 Minor GC. Young Generation 被分为三部分, Eden Memory 和两个 Survivor Memory 空间 </p>
<p>Important Points about Young Generation Spaces:</p>
<ul>
<li><p>Most of the newly created objects are located in the Eden memory space.</p>
</li>
<li><p>大部分新创建的对象位于 Eden memory 空间</p>
</li>
<li><p>When Eden space is filled with objects, Minor GC is performed and all the survivor objects are moved to one of the survivor spaces.</p>
</li>
<li><p>Minor GC 在 Eden space 被对象填充时执行, 所有的 survivor 对象被移动到其中一个 survivor 空间</p>
</li>
<li><p>Minor GC also checks the survivor objects and move them to the other survivor space. So at a time, one of the survivor space is always empty.</p>
</li>
<li><p>Minor GC 元入会检查 survivor 对象, 将其移动到其他的 survivor 空间. 所以在同一时刻, 有一个 survivor 空间一直是空的</p>
</li>
<li><p>Objects that are survived after many cycles of GC, are moved to the Old generation memory space. Usually, it’s done by setting a threshold for the age of the young generation objects before they become eligible to promote to Old generation.</p>
</li>
<li><p>在多次 GC 循环后仍幸存的对象将会被移动到 Old generation 内存空间. </p>
<p>通常, 是通过给 young generation 对象设置一个年龄的阈值来实现的 (超过这个阈值的对象将会被移动到 Old Generation 中)</p>
</li>
</ul>
<h2 id="Memory-Management-in-Java-–-Old-Generation"><a href="#Memory-Management-in-Java-–-Old-Generation" class="headerlink" title="Memory Management in Java – Old Generation"></a>Memory Management in Java – Old Generation</h2><p>Old Generation memory contains the objects that are long-lived and survived after many rounds of Minor GC. Usually, garbage collection is performed in Old Generation memory when it’s full. Old Generation Garbage Collection is called <strong>Major GC</strong> and usually takes a longer time.</p>
<p>Old Generation 内存包含在多次 Minor GC 循环后仍幸存的对象. 通常, GC 在 Old Generation 被填满时执行.</p>
<p>Old Generation GC 被成为 Major GC, 通常花费更长的时间</p>
<h3 id="Stop-the-World-Event"><a href="#Stop-the-World-Event" class="headerlink" title="Stop the World Event"></a>Stop the World Event</h3><p>All the Garbage Collections are “Stop the World” events because all application threads are stopped until the operation completes.</p>
<p>所有的 GC 都是 “Stop the World” 事件. 因为所有的应用线程阻塞直到操作完成</p>
<p>Since Young generation keeps short-lived objects, Minor GC is very fast and the application doesn’t get affected by this.</p>
<p>因为 Young generation 保持短期存活对象, Minor GC 相当快, 应用不会受此影响</p>
<p>However, Major GC takes a long time because it checks all the live objects. Major GC should be minimized because it will make your application unresponsive for the garbage collection duration. So if you have a responsive application and there are a lot of Major Garbage Collection happening, you will notice timeout errors.</p>
<p>然而, Major GC 花费较长的时间, 因为它会检查所有的存活对象, Major GC 应该尽量少使用. 因为它会在 GC 期间, 使你的程序无相应. 所以如果你有一个响应应用, 同时在应用中存在大量 Major GC 发生时, 你应该注意是否会产生超时错误</p>
<p>The duration taken by garbage collector depends on the strategy used for garbage collection. That’s why it’s necessary to monitor and tune the garbage collector to avoid timeouts in the highly responsive applications.</p>
<p>GC 占用时间取决于 GC 策略, 这就是为什么要在高响应应用程序中需要监控和调整 GC 策略的原因</p>
<h3 id="Java-Memory-Model-–-Permanent-Generation"><a href="#Java-Memory-Model-–-Permanent-Generation" class="headerlink" title="Java Memory Model – Permanent Generation"></a>Java Memory Model – Permanent Generation</h3><p>Permanent Generation or “Perm Gen” contains the application metadata required by the JVM to describe the classes and methods used in the application. Note that Perm Gen is not part of <a href="https://www.journaldev.com/4098/java-heap-space-vs-stack-memory" target="_blank" rel="noopener">Java Heap memory</a>.</p>
<p>Permanent Generation 或 “Perm Gen” 包含 JVM 所需的应用元数据, 描述应用于应用中的类和方法. 注意, Perm Gen 不是 Java Heap memory 的一部分</p>
<p>Perm Gen is populated by JVM at runtime based on the classes used by the application. Perm Gen also contains Java SE library classes and methods. Perm Gen objects are garbage collected in a full garbage collection.</p>
<p>Perm Gen 由 JVM 在运行时填充, 基于被应用程序使用的类. Perm Gen 也包含 Java SE 库类以及方法. Perm Gen 对象在完整的 GC 中被回收</p>
<h3 id="Java-Memory-Model-–-Method-Area"><a href="#Java-Memory-Model-–-Method-Area" class="headerlink" title="Java Memory Model – Method Area"></a>Java Memory Model – Method Area</h3><p>Method Area is part of space in the Perm Gen and used to store class structure (runtime constants and static variables) and code for methods and constructors.</p>
<p>Method Area 是 Perm Gen 空间的一部分. 用于存储类数据结构 (运行时常量和静态变量) 以及 方法的代码和结构</p>
<h3 id="Java-Memory-Model-–-Memory-Pool"><a href="#Java-Memory-Model-–-Memory-Pool" class="headerlink" title="Java Memory Model – Memory Pool"></a>Java Memory Model – Memory Pool</h3><p>Memory Pools are created by JVM memory managers to create a pool of <a href="https://www.journaldev.com/129/how-to-create-immutable-class-in-java" target="_blank" rel="noopener">immutable</a> objects if the implementation supports it. String Pool is a good example of this kind of memory pool. Memory Pool can belong to Heap or Perm Gen, depending on the JVM memory manager implementation.</p>
<p>内存池由 JVM 内存管理器创建, 创建一个不变量对象池 (如果实现支持的话). String 池是这种内存池的一个很好的例子. 内存池可以属于 Heap 或 Perm Gen, 取决于 JVM 内存管理器的实现</p>
<h3 id="Java-Memory-Model-–-Runtime-Constant-Pool"><a href="#Java-Memory-Model-–-Runtime-Constant-Pool" class="headerlink" title="Java Memory Model – Runtime Constant Pool"></a>Java Memory Model – Runtime Constant Pool</h3><p>Runtime constant pool is per-class runtime representation of constant pool in a class. It contains class runtime constants and static methods. Runtime constant pool is part of the method area.</p>
<p>运行时常量池是类中常量池的每个类的运行时表示. 包含类运行时常量和静态方法. 运行时常量池是 method 区域的一部分</p>
<h3 id="Java-Memory-Model-–-Java-Stack-Memory"><a href="#Java-Memory-Model-–-Java-Stack-Memory" class="headerlink" title="Java Memory Model – Java Stack Memory"></a>Java Memory Model – Java Stack Memory</h3><p>Java Stack memory is used for execution of a thread. They contain method specific values that are short-lived and references to other objects in the heap that is getting referred from the method. You should read <a href="https://www.journaldev.com/4098/java-heap-space-vs-stack-memory" target="_blank" rel="noopener">Difference between Stack and Heap Memory</a>.</p>
<p>Java 栈内存用户执行线程. 它们包含方法指定值 (生命周期短, 指向堆中的对象)</p>
<h3 id="Memory-Management-in-Java-–-Java-Heap-Memory-Switches"><a href="#Memory-Management-in-Java-–-Java-Heap-Memory-Switches" class="headerlink" title="Memory Management in Java – Java Heap Memory Switches"></a>Memory Management in Java – Java Heap Memory Switches</h3><p>Java provides a lot of memory switches that we can use to set the memory sizes and their ratios. Some of the commonly used memory switches are:</p>
<p>Java 提供了大量的内存开关, 用于设置内存大小和比例. 一些常用的内存开关有: </p>
<table>
<thead>
<tr>
<th align="left">VM Switch</th>
<th align="left">VM Switch Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-Xms</td>
<td align="left">For setting the initial heap size when JVM starts</td>
</tr>
<tr>
<td align="left">-Xmx</td>
<td align="left">For setting the maximum heap size.</td>
</tr>
<tr>
<td align="left">-Xmn</td>
<td align="left">For setting the size of the Young Generation, rest of the space goes for Old Generation.</td>
</tr>
<tr>
<td align="left">-XX:PermGen</td>
<td align="left">For setting the initial size of the Permanent Generation memory</td>
</tr>
<tr>
<td align="left">-XX:MaxPermGen</td>
<td align="left">For setting the maximum size of Perm Gen</td>
</tr>
<tr>
<td align="left">-XX:SurvivorRatio</td>
<td align="left">For providing ratio of Eden space and Survivor Space, for example if Young Generation size is 10m and VM switch is -XX:SurvivorRatio=2 then 5m will be reserved for Eden Space and 2.5m each for both the Survivor spaces. The default value is 8.</td>
</tr>
<tr>
<td align="left">-XX:NewRatio</td>
<td align="left">For providing ratio of old/new generation sizes. The default value is 2.</td>
</tr>
</tbody></table>
<p>Most of the times, above options are sufficient, but if you want to check out other options too then please check <a href="https://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html" target="_blank" rel="noopener">JVM Options Official Page</a>.</p>
<p>大多数时候, 上面的选项就足够了, 其他选项可以参见… </p>
<h3 id="Memory-Management-in-Java-–-Java-Garbage-Collection"><a href="#Memory-Management-in-Java-–-Java-Garbage-Collection" class="headerlink" title="Memory Management in Java – Java Garbage Collection"></a>Memory Management in Java – Java Garbage Collection</h3><p>Java Garbage Collection is the process to identify and remove the unused objects from the memory and free space to be allocated to objects created in future processing. One of the best features of Java programming language is the <strong>automatic garbage collection</strong>, unlike other programming languages such as C where memory allocation and deallocation is a manual process.</p>
<p>Java GC 是用于从内存中确定和移除未使用对象的进程, 释放内存, 以用于将来创建的对象. Java 的特性之一是自动垃圾回收, 不像其他语言需要手动处理 (其实也不是啦, 栈是不需要管的, 也就是 heap 需要手动释放)</p>
<p><strong>Garbage Collector</strong> is the program running in the background that looks into all the objects in the memory and find out objects that are not referenced by any part of the program. All these unreferenced objects are deleted and space is reclaimed for allocation to other objects.</p>
<p>GC 是一个运行于后台的程序, 查看在内容中的所有对象, 找到没有被程序中任何部分引用的对象. 所有这些未引用对象都会被删除, 空间会回收利用, 以用于其他对象的分配</p>
<p>One of the basic ways of garbage collection involves three steps:</p>
<ol>
<li><p><strong>Marking</strong>: This is the first step where garbage collector identifies which objects are in use and which ones are not in use.</p>
<p>Marking: 这是 GC 用于确定对象是否被使用的第一步</p>
</li>
<li><p><strong>Normal Deletion</strong>: Garbage Collector removes the unused objects and reclaim the free space to be allocated to other objects.</p>
<p>Normal Deletion: GC 移除未使用对象, 回收资源</p>
</li>
<li><p><strong>Deletion with Compacting</strong>: For better performance, after deleting unused objects, all the survived objects can be moved to be together. This will increase the performance of allocation of memory to newer objects.</p>
<p>Deletion with Compacting: 为了获得更好的性能, 在删除未使用对象后, 所有幸存对象可以移到一起, 这可以增加分配新对象的性能</p>
</li>
</ol>
<p>There are two problems with a simple mark and delete approach.</p>
<ol>
<li><p>First one is that it’s not efficient because most of the newly created objects will become unused</p>
<p>首先, 这并不高效, 因为大部分新创建的对象将会变成未使用</p>
</li>
<li><p>Secondly objects that are in-use for multiple garbage collection cycle are most likely to be in-use for future cycles too.</p>
<p>其次, 多个 GC 循环后仍使用的对象在将来也可能是使用的</p>
</li>
</ol>
<p>(总结来说就是, 大多数对象是创建后就失效的, 维护起来有一定成为. 其次, 一个多次 GC 后存在的对象在以后也大概率不会被移除, 这又会产生额外的性能损失)</p>
<p>The above shortcomings with the simple approach is the reason that <strong>Java Garbage Collection is Generational</strong> and we have <strong>Young Generation</strong> and <strong>Old Generation</strong> spaces in the heap memory. I have already explained above how objects are scanned and moved from one generational space to another based on the Minor GC and Major GC.</p>
<p>以上简单方法的缺点是 Java GC 是在堆内存中分代, 使用 Young Generation 和 Old Generation 空间的原因</p>
<h3 id="Memory-Management-in-Java-–-Java-Garbage-Collection-Types"><a href="#Memory-Management-in-Java-–-Java-Garbage-Collection-Types" class="headerlink" title="Memory Management in Java – Java Garbage Collection Types"></a>Memory Management in Java – Java Garbage Collection Types</h3><p>There are five types of garbage collection types that we can use in our applications. We just need to use the JVM switch to enable the garbage collection strategy for the application. Let’s look at each of them one by one.</p>
<p>我们可以在我们的应用中使用五种 GC, 仅需使用 JVM 开关就可使 GC 策略应用于应用. </p>
<ol>
<li><p><strong>Serial GC (-XX:+UseSerialGC)</strong>: Serial GC uses the simple <strong>mark-sweep-compact</strong> approach for young and old generations garbage collection i.e Minor and Major GC.</p>
<p>Serial GC is useful in client machines such as our simple stand-alone applications and machines with smaller CPU. It is good for small applications with low memory footprint.</p>
<p>Serial GC: Serial GC 使用最简单的 <strong>mark-sweep-compact</strong> 方法用于 young 和 old generations GC. 比如, Minor 和 Major GC.</p>
<p>Serial GC 在如我们简单的, 独立的应用和小的 CPU 上很有用, 适用于低内存占用的小型应用</p>
</li>
<li><p><strong>Parallel GC (-XX:+UseParallelGC)</strong>: Parallel GC is same as Serial GC except that is spawns N threads for young generation garbage collection where N is the number of CPU cores in the system. We can control the number of threads using <code>-XX:ParallelGCThreads=n</code> JVM option.</p>
<p>Parallel GC: Parallel GC 类似于 Serial GC, 除了为 young generation GC 产生 N 个线程 (N 是CPU核心数). 可以使用 JVM 选项控制线程的数量</p>
<p>Parallel Garbage Collector is also called throughput collector because it uses multiple CPUs to speed up the GC performance. Parallel GC uses a single thread for Old Generation garbage collection.</p>
<p>Parallel GC 也被称为吞吐量收集器, 因为它使用多个CPU提升GC性能. Parallel GC为Old Generation GC 单独分配一个线程</p>
</li>
<li><p><strong>Parallel Old GC (-XX:+UseParallelOldGC)</strong>: This is same as Parallel GC except that it uses multiple threads for both Young Generation and Old Generation garbage collection.</p>
<p>和Parallel GC相同, 但它对 Young GC 和 Old GC 都使用多线程</p>
</li>
<li><p><strong>Concurrent Mark Sweep (CMS) Collector (-XX:+UseConcMarkSweepGC)</strong>: CMS Collector is also referred as concurrent low pause collector. It does the garbage collection for the Old generation. CMS collector tries to minimize the pauses due to garbage collection by doing most of the garbage collection work concurrently with the application threads.</p>
<p>CMS 收集器也被称为并发低暂停收集器. 它为 Old generation 做 GC 操作. CMS 收集器尝试使用应用线程, 通过并发执行大部分 GC 操作来尽可能减低 GC 的暂停</p>
<p>CMS collector on the young generation uses the same algorithm as that of the parallel collector. This garbage collector is suitable for responsive applications where we can’t afford longer pause times. We can limit the number of threads in CMS collector using <code>-XX:ParallelCMSThreads=n</code> JVM option.</p>
<p>CMS 在 young generation 上像 parallel 收集器一样使用同样的算法, 这个算法适用于不能承担长时间暂停的响应程序, 可以使用选项限制 CMS 收集器使用的线程数</p>
</li>
<li><p><strong>G1 Garbage Collector (-XX:+UseG1GC)</strong>: The Garbage First or G1 garbage collector is available from Java 7 and its long term goal is to replace the CMS collector. The G1 collector is a parallel, concurrent, and incrementally compacting low-pause garbage collector.Garbage First Collector doesn’t work like other collectors and there is no concept of Young and Old generation space. It divides the heap space into multiple equal-sized heap regions. When a garbage collection is invoked, it first collects the region with lesser live data, hence “Garbage First”. You can find more details about it at Garbage-First Collector Oracle Documentation.</p>
<p>G1 GC 从 Java 7 开始支持, 它长期的目标是取代 CMS 收集器. G1 是一个并行, 并发以及递增压紧的低暂停 GC. G1 不像其他收集器, 它没有 Young 和 Old generation 的概念. 它将 heap 空间分为多个相同的 heap 区域. 当GC 执行时, 它首先清理较少存留数据的 heap 区域, 因此成为”Garbage  First”. 你可以在 Oracle 的文档中找到更多关于 G1 收集器的信息.</p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>read/IteratorsandReverseIterators</title>
    <url>/2020/01/09/read/IteratorsandReverseIterators/</url>
    <content><![CDATA[<h2 id="Iterators-and-Reverse-Iterators"><a href="#Iterators-and-Reverse-Iterators" class="headerlink" title="Iterators and Reverse Iterators"></a>Iterators and Reverse Iterators</h2><p>You can convert normal iterators into reverse iterators. Naturally, the iterators must be bidirectional<br>iterators, but note that the logical position of an iterator is moved during the conversion. Consider<br>the following program:</p>
<p>可以将普通的迭代器转换为反向迭代去(当然, 这个迭代器必须是双向的)</p>
<p>请记住, 转换后迭代器的逻辑位置会发生改变, 参考以下程序 : </p>
<pre><code>// iter/reviter2.cpp
#include &lt;iterator&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main()
{
    // create list with elements from 1 to 9
    vector&lt;int&gt; coll = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };

    // find position of element with value 5
    vector&lt;int&gt;::const_iterator pos;
    pos = find (coll.cbegin(), coll.cend(),
    5);

    // print value to which iterator pos refers
    cout &lt;&lt; &quot;pos: &quot; &lt;&lt; *pos &lt;&lt; endl;

    // convert iterator to reverse iterator rpos
    vector&lt;int&gt;::const_reverse_iterator rpos(pos);

    // print value to which reverse iterator rpos refers
    cout &lt;&lt; &quot;rpos: &quot; &lt;&lt; *rpos &lt;&lt; endl;
}</code></pre><p>This program has the following output:<br>    pos: 5<br>    rpos: 4<br>Thus, if you print the value of an iterator and convert the iterator into a reverse iterator, the value has<br>changed. This is not a bug; it’s a feature! This behavior is a consequence of the fact that ranges are<br>half open. To specify all elements of a container, you must use the position after the last argument.<br>However, for a reverse iterator, this is the position before the first element. Unfortunately, such a<br>position may not exist. Containers are not required to guarantee that the position before their first<br>element is valid. Consider that ordinary strings and arrays might also be containers, and the language<br>does not guarantee that arrays don’t start at address zero.</p>
<p>因此, 更改后迭代器的值发生了变化. 这不是一个 bug, 而是一个特性. 这是一个因半开区间而产生的结果.</p>
<p>要指定容器的所有元素, 需要使用最后一个元素后的位置. 然而, 对于反向迭代器而言, 就是一个在第一个元素之前的位置, 不幸的是, 这样的位置是不存在的. 容器不保证他们第一个位置之前的元素是有效的.</p>
<p>参考原始字符串和数组可能也会是容器, 语言不保证数组不从地址0开始</p>
<p>As a result, the designers of reverse iterators use a trick: They “physically” reverse the “half-open<br>principle.” Physically, in a range defined by reverse iterators, the beginning is not included, whereas<br>the end is. However, logically, they behave as usual. Thus, there is a distinction between the physical<br>position that defines the element to which the iterator refers and the logical position that defines the<br>value to which the iterator refers (Figure 9.3). The question is, what happens on a conversion from<br>an iterator to a reverse iterator? Does the iterator keep its logical position (the value) or its physical<br>position (the element)? As the previous example shows, the latter is the case. Thus, the value is<br>moved to the previous element (Figure 9.4) </p>
<p>结论是, 反向迭代器设计用了一个方法 : 它们物理性地反向半开区间. 物理性地, 在反向迭代器的定义中, 开始的元素不包含在内, 而尾端被包含. 然而, 逻辑上, 它们的行为和普通的迭代器一样. 因此, 定义迭代器引用的元素的物理位置和定义迭代器引用的值的逻辑位置是有区别的. </p>
<p>问题是, 当普通迭代器转换为反向迭代器的时候, 会发生什么? 迭代器会保持它的逻辑位置, 还是物理位置? 在上面的案例显示中, 属于后者. 因此, 值移动到了之前的元素位置.</p>
<p><img src="https://imgur.com/Xe1ifka.png" alt=""></p>
<p><img src="https://imgur.com/1rPZHcM.png" alt=""></p>
<h2 id="内部如何处理的"><a href="#内部如何处理的" class="headerlink" title="内部如何处理的"></a>内部如何处理的</h2><p>以上, 就是这篇笔记的原因, 我想看看反向迭代器它的内部是如何工作的</p>
<p>这次的目标是解决如下疑问</p>
<ol>
<li>普通迭代器转换成反向迭代器会做什么?</li>
<li>反向迭代器如何迭代的? </li>
<li>反向迭代器如何保证不会越界? </li>
</ol>
<p>首先, 参考一下 C++ 代码 : </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 9&gt; v&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">	<span class="keyword">auto</span> it = v.<span class="built_in">begin</span>();</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">array</span>&lt;<span class="keyword">int</span>,9&gt;::<span class="function">const_reverse_iterator <span class="title">rit</span><span class="params">(it)</span></span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *rit &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>然后是汇编代码 : </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">main:</span><br><span class="line">.LFB4368:</span><br><span class="line">▹   .cfi_startproc</span><br><span class="line">▹   pushq▹  %rbp</span><br><span class="line">▹   .cfi_def_cfa_offset 16</span><br><span class="line">▹   .cfi_offset 6, -16</span><br><span class="line">▹   movq▹   %rsp, %rbp</span><br><span class="line">▹   .cfi_def_cfa_register 6</span><br><span class="line">▹   subq▹   $64, %rsp</span><br><span class="line">▹   movl▹   $1, -64(%rbp)</span><br><span class="line">▹   movl▹   $2, -60(%rbp)</span><br><span class="line">▹   movl▹   $3, -56(%rbp)</span><br><span class="line">▹   movl▹   $4, -52(%rbp)</span><br><span class="line">▹   movl▹   $5, -48(%rbp)</span><br><span class="line">▹   movl▹   $6, -44(%rbp)</span><br><span class="line">▹   movl▹   $7, -40(%rbp)</span><br><span class="line">▹   movl▹   $8, -36(%rbp)</span><br><span class="line">▹   movl▹   $9, -32(%rbp)</span><br><span class="line">▹   leaq▹   -64(%rbp), %rax</span><br><span class="line">▹   movq▹   %rax, %rdi</span><br><span class="line">▹   call▹   _ZNSt5arrayIiLm9EE5beginEv	&#x2F;&#x2F; 上述是 array 的初始化代码</span><br><span class="line">▹   movq▹   %rax, -8(%rbp)	&#x2F;&#x2F; 构造的返回值即是 begin</span><br><span class="line">▹   movq▹   -8(%rbp), %rax</span><br><span class="line">▹   movl▹   (%rax), %eax	&#x2F;&#x2F; *it</span><br><span class="line">▹   movl▹   %eax, %esi</span><br><span class="line">▹   movl▹   $_ZSt4cout, %edi</span><br><span class="line">▹   call▹   _ZNSolsEi</span><br><span class="line">▹   movl▹   $_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_, %esi</span><br><span class="line">▹   movq▹   %rax, %rdi</span><br><span class="line">▹   call▹   _ZNSolsEPFRSoS_E</span><br><span class="line">▹   movq▹   -8(%rbp), %rdx	&#x2F;&#x2F; -8(%rbp) 即 it</span><br><span class="line">▹   leaq▹   -16(%rbp), %rax	&#x2F;&#x2F; 这是一块未使用的内存</span><br><span class="line">▹   movq▹   %rdx, %rsi</span><br><span class="line">▹   movq▹   %rax, %rdi</span><br><span class="line">▹   call▹   _ZNSt16reverse_iteratorIPKiEC1ES1_	&#x2F;&#x2F; 这应当就是 reverse_iterator 的 construct</span><br><span class="line">▹   leaq▹   -16(%rbp), %rax</span><br><span class="line">▹   movq▹   %rax, %rdi</span><br><span class="line">▹   call▹   _ZNKSt16reverse_iteratorIPKiEdeEv	&#x2F;&#x2F; 在解引用之前, 会调用这个函数</span><br><span class="line">▹   movl▹   (%rax), %eax	&#x2F;&#x2F; 返回值解引用, 即 *rit</span><br><span class="line">▹   movl▹   %eax, %esi</span><br><span class="line">▹   movl▹   $_ZSt4cout, %edi</span><br><span class="line">▹   call▹   _ZNSolsEi</span><br><span class="line">▹   movl▹   $_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_, %esi</span><br><span class="line">▹   movq▹   %rax, %rdi</span><br><span class="line">▹   call▹   _ZNSolsEPFRSoS_E</span><br><span class="line">▹   movl▹   $0, %eax</span><br><span class="line">▹   leave</span><br><span class="line">▹   .cfi_def_cfa 7, 8</span><br><span class="line">▹   ret</span><br></pre></td></tr></table></figure>

<p>可以看出, 关键点在于 “<em>ZNSt16reverse_iteratorIPKiEC1ES1</em>“ 和 “_ZNKSt16reverse_iteratorIPKiEdeEv” 将是关键</p>
<p>其中, ZNSt16reverse_iteratorIPKiEC1ES1 的代码如下所示 (没有错, 就是这个)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_ZNSt16reverse_iteratorIPKiEC2ES1_:</span><br><span class="line">.LFB4445:</span><br><span class="line">▹   .cfi_startproc</span><br><span class="line">▹   pushq▹  %rbp</span><br><span class="line">▹   .cfi_def_cfa_offset 16</span><br><span class="line">▹   .cfi_offset 6, -16</span><br><span class="line">▹   movq▹   %rsp, %rbp</span><br><span class="line">▹   .cfi_def_cfa_register 6</span><br><span class="line">▹   subq▹   $16, %rsp</span><br><span class="line">▹   movq▹   %rdi, -8(%rbp)</span><br><span class="line">▹   movq▹   %rsi, -16(%rbp)</span><br><span class="line">▹   movq▹   -8(%rbp), %rax</span><br><span class="line">▹   movq▹   %rax, %rdi</span><br><span class="line">▹   call▹   _ZNSt8iteratorISt26random_access_iterator_tagilPKiRS1_EC2Ev</span><br><span class="line">▹   movq▹   -8(%rbp), %rax</span><br><span class="line">▹   movq▹   -16(%rbp), %rdx</span><br><span class="line">▹   movq▹   %rdx, (%rax)</span><br><span class="line">▹   leave</span><br><span class="line">▹   .cfi_def_cfa 7, 8</span><br><span class="line">▹   ret</span><br></pre></td></tr></table></figure>

<p>代码除 _ZNSt8iteratorISt26random_access_iterator_tagilPKiRS1_EC2Ev 外, 就是简单地将 %rsi(-8(%rbp) 即 it) 的地址放入 %rdi(-16(%rbp) 我提到过的那块未使用的内存)</p>
<p>_ZNSt8iteratorISt26random_access_iterator_tagilPKiRS1_EC2Ev 代码如下所示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_ZNSt8iteratorISt26random_access_iterator_tagilPKiRS1_EC2Ev:</span><br><span class="line">.LFB4443:</span><br><span class="line">▹   .cfi_startproc</span><br><span class="line">▹   pushq▹  %rbp</span><br><span class="line">▹   .cfi_def_cfa_offset 16</span><br><span class="line">▹   .cfi_offset 6, -16</span><br><span class="line">▹   movq▹   %rsp, %rbp</span><br><span class="line">▹   .cfi_def_cfa_register 6</span><br><span class="line">▹   movq▹   %rdi, -8(%rbp)</span><br><span class="line">▹   popq▹   %rbp</span><br><span class="line">▹   .cfi_def_cfa 7, 8</span><br><span class="line">▹   ret</span><br><span class="line">▹   .cfi_endproc</span><br></pre></td></tr></table></figure>

<p>好像… 什么也没做 = = , 这个函数没有栈帧开辟, movq▹   %rdi, -8(%rbp) 也大概率是个无用的语句</p>
<p>那么, 可以暂时得出结论, 反向迭代器是一个二级指针, 它保存了普通迭代器的地址</p>
<p>那么, 来看另外一个函数 _ZNKSt16reverse_iteratorIPKiEdeEv</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_ZNKSt16reverse_iteratorIPKiEdeEv:</span><br><span class="line">.LFB4447:</span><br><span class="line">▹   .cfi_startproc</span><br><span class="line">▹   pushq▹  %rbp</span><br><span class="line">▹   .cfi_def_cfa_offset 16</span><br><span class="line">▹   .cfi_offset 6, -16</span><br><span class="line">▹   movq▹   %rsp, %rbp</span><br><span class="line">▹   .cfi_def_cfa_register 6</span><br><span class="line">▹   movq▹   %rdi, -24(%rbp)</span><br><span class="line">▹   movq▹   -24(%rbp), %rax</span><br><span class="line">▹   movq▹   (%rax), %rax</span><br><span class="line">▹   movq▹   %rax, -8(%rbp)</span><br><span class="line">▹   subq▹   $4, -8(%rbp)</span><br><span class="line">▹   movq▹   -8(%rbp), %rax</span><br><span class="line">▹   popq▹   %rbp</span><br><span class="line">▹   .cfi_def_cfa 7, 8</span><br><span class="line">▹   ret</span><br><span class="line">▹   .cfi_endproc</span><br></pre></td></tr></table></figure>

<p>一句话概括: 二级指针解引用 -4. 那么就和文档所说的吻合了, 反向迭代器会往前移动一个位置</p>
<p>这个函数发生在反向迭代器解引用时, 大概可以猜出它的行为</p>
<h2 id="更进一步"><a href="#更进一步" class="headerlink" title="更进一步"></a>更进一步</h2><p>疑问 1 和 疑问 2 解决了, 但是疑问 3 还未解决</p>
<p>我原来想通过更改内存值来看的, 但是貌似有什么防范操作 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Breakpoint 1, main () at t.cpp:13</span><br><span class="line">13	    array&lt;int, 9&gt; v&#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125;;</span><br><span class="line">(gdb) n</span><br><span class="line">14	    auto it &#x3D; v.begin();</span><br><span class="line">(gdb) p &#123;int&#125;0x7fffffffe480	&#x2F;&#x2F; 这里就是 it</span><br><span class="line">$16 &#x3D; 1</span><br><span class="line">(gdb) set &#123;int&#125;0x7fffffffe480 &#x3D; 100	&#x2F;&#x2F; 更改 it 中的值</span><br><span class="line">(gdb) p &#123;int&#125;0x7fffffffe480	&#x2F;&#x2F; 成功更改</span><br><span class="line">$17 &#x3D; 100</span><br><span class="line">(gdb) n</span><br><span class="line">15	    cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">(gdb) n	&#x2F;&#x2F; 本来该打印 1 的, 更改后打印了 100 </span><br><span class="line">100</span><br><span class="line">16	    array&lt;int,9&gt;::const_reverse_iterator rit(it);</span><br><span class="line">(gdb) p v	&#x2F;&#x2F; 再次验证更改是有效的</span><br><span class="line">$18 &#x3D; &#123;_M_elems &#x3D; &#123;100, 2, 3, 4, 5, 6, 7, 8, 9&#125;&#125;</span><br><span class="line">(gdb) p &#123;int&#125;0x7fffffffe47b	&#x2F;&#x2F; 根据推算, 这个就是 rend 的地址</span><br><span class="line">$19 &#x3D; 0</span><br><span class="line">(gdb) set &#123;int&#125;0x7fffffffe47b &#x3D; 200	&#x2F;&#x2F; 更改 rend ( 在程序崩溃的边缘疯狂试探 :) )</span><br><span class="line">(gdb) p &#123;int&#125;0x7fffffffe47b</span><br><span class="line">$20 &#x3D; 200</span><br><span class="line">(gdb) n</span><br><span class="line">17	    cout &lt;&lt; *rit &lt;&lt; endl;</span><br><span class="line">(gdb) n	&#x2F;&#x2F; 结果让人很失望</span><br><span class="line">0</span><br><span class="line">18	&#125;</span><br><span class="line">(gdb) p &#123;int&#125;0x7fffffffe47b &#x2F;&#x2F; 谁让你改回去的!?</span><br><span class="line">$21 &#x3D; 0</span><br></pre></td></tr></table></figure>

<p>我之后在 end 上做了同样的测试, 发现 end 也有防范操作</p>
<p>但我不知道具体是哪里防范了我这个操作, 应该是在解引用时, 但是里面代码不会更改到. </p>
<p>我还看了 objdump 的汇编代码, 依旧没有发现什么特别之处, 和编译器生成的汇编代码是一样的… </p>
<p>算了, 也算有所收获吧… </p>
]]></content>
  </entry>
  <entry>
    <title>read/InnoDBRowFormat</title>
    <url>/2020/01/09/read/InnoDBRowFormat/</url>
    <content><![CDATA[<h2 id="15-10-InnoDB-Row-Formats"><a href="#15-10-InnoDB-Row-Formats" class="headerlink" title="15.10 InnoDB Row Formats"></a>15.10 InnoDB Row Formats</h2><p>The row format of a table determines how its rows are physically stored, which in turn can affect the performance of queries and DML operations. As more rows fit into a single disk page, queries and index lookups can work faster, less cache memory is required in the buffer pool, and less I/O is required to write out updated values.</p>
<p>表的行格式化确定了如何物理存储方式, 反过来也会影响查询的性能和 DML 的操作.</p>
<p>更多的行放在单个磁盘页上, 查询和索引检索的速度会更快, 缓存池需要的空间也更少, 写出更新数据的 I/O 操作也会减少</p>
<p>The data in each table is divided into pages. The pages that make up each table are arranged in a tree data structure called a B-tree index. Table data and secondary indexes both use this type of structure. The B-tree index that represents an entire table is known as the clustered index, which is organized according to the primary key columns. The nodes of a clustered index data structure contain the values of all columns in the row. The nodes of a secondary index structure contain the values of index columns and primary key columns.</p>
<p>表的数据被分散到多个页中, 组成表的页的范围被限制在 B-tree 索引的树结构中, 表的数据和次级索引都使用这种结构</p>
<p>表示整个表的 B-tree 索引被称作聚簇索引, 根据主键列构造. 聚簇索引的节点数据结构包含行中的所有列, 而次级索引机构包含索引列和主键列(PS. 类似二级指针)</p>
<p>Variable-length columns are an exception to the rule that column values are stored in B-tree index nodes. Variable-length columns that are too long to fit on a B-tree page are stored on separately allocated disk pages called overflow pages. Such columns are referred to as off-page columns. The values of off-page columns are stored in singly-linked lists of overflow pages, with each such column having its own list of one or more overflow pages. Depending on column length, all or a prefix of variable-length column values are stored in the B-tree to avoid wasting storage and having to read a separate page.</p>
<p>可变长度列是列值存储在 B-tree 索引节点规则的一种特殊情况, 可变长度列太长, 无法存储在单个 B-tree 也中, 可变长度列存储在单独分配的磁盘页中, 这些页叫做溢出页, 这些列也叫作页外列</p>
<p>页外列以单链表形式存储在溢出页中, 每个页都有一个或多个溢出页的列表</p>
<p>取决于列的长度, 整个/前缀部分 变长列可以存储在 B-tree 中, 避免存储消耗和读取额外的页</p>
<p>The <code>InnoDB</code> storage engine supports four row formats: <code>REDUNDANT</code>, <code>COMPACT</code>, <code>DYNAMIC</code>, and <code>COMPRESSED</code>.</p>
<p>InnoDB 存储引擎支持 4 种行格式化: REDUNDANT, COMPACT, DYNAMIC  和 COMPRESSED</p>
<p><strong>Table 15.16 InnoDB Row Format Overview</strong></p>
<table>
<thead>
<tr>
<th>Row Format</th>
<th>Compact Storage Characteristics</th>
<th>Enhanced Variable-Length Column Storage</th>
<th>Large Index Key Prefix Support</th>
<th>Compression Support</th>
<th>Supported Tablespace Types</th>
</tr>
</thead>
<tbody><tr>
<td><code>REDUNDANT</code></td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>system, file-per-table, general</td>
</tr>
<tr>
<td><code>COMPACT</code></td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>system, file-per-table, general</td>
</tr>
<tr>
<td><code>DYNAMIC</code></td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>system, file-per-table, general</td>
</tr>
<tr>
<td><code>COMPRESSED</code></td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>file-per-table, general</td>
</tr>
</tbody></table>
<p>The topics that follow describe row format storage characteristics and how to define and determine the row format of a table.</p>
<ul>
<li><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-row-format.html#innodb-row-format-redundant" target="_blank" rel="noopener">REDUNDANT Row Format</a></li>
<li><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-row-format.html#innodb-row-format-compact" target="_blank" rel="noopener">COMPACT Row Format</a></li>
<li><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-row-format.html#innodb-row-format-dynamic" target="_blank" rel="noopener">DYNAMIC Row Format</a></li>
<li><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-row-format.html#innodb-row-format-compressed" target="_blank" rel="noopener">COMPRESSED Row Format</a></li>
<li><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-row-format.html#innodb-row-format-defining" target="_blank" rel="noopener">Defining the Row Format of a Table</a></li>
<li><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-row-format.html#innodb-row-format-detrmining" target="_blank" rel="noopener">Determining the Row Format of a Table</a></li>
</ul>
<h3 id="REDUNDANT-Row-Format"><a href="#REDUNDANT-Row-Format" class="headerlink" title="REDUNDANT Row Format"></a>REDUNDANT Row Format</h3><p>Tables that use the <code>REDUNDANT</code> row format store the first 768 bytes of variable-length column values (<a href="https://dev.mysql.com/doc/refman/8.0/en/char.html" target="_blank" rel="noopener"><code>VARCHAR</code></a>, <a href="https://dev.mysql.com/doc/refman/8.0/en/binary-varbinary.html" target="_blank" rel="noopener"><code>VARBINARY</code></a>, and <a href="https://dev.mysql.com/doc/refman/8.0/en/blob.html" target="_blank" rel="noopener"><code>BLOB</code></a> and <a href="https://dev.mysql.com/doc/refman/8.0/en/blob.html" target="_blank" rel="noopener"><code>TEXT</code></a> types) in the index record within the B-tree node, with the remainder stored on overflow pages. Fixed-length columns greater than or equal to 768 bytes are encoded as variable-length columns, which can be stored off-page. For example, a <code>CHAR(255)</code> column can exceed 768 bytes if the maximum byte length of the character set is greater than 3, as it is with <code>utf8mb4</code>.</p>
<p>使用 REDUNDANT 行格式化在 B-tree 节点记录中只存储变长列值的前 768 字节(VARCHAR, VARBINARY, BLOB, TEXT 类型), 剩下的存储在溢出页中, 固定长度但 &gt;= 768 字节的列被按照变长列编码, 存储到溢出页中</p>
<p>If the value of a column is 768 bytes or less, an overflow page is not used, and some savings in I/O may result, since the value is stored entirely in the B-tree node. This works well for relatively short <code>BLOB</code> column values, but may cause B-tree nodes to fill with data rather than key values, reducing their efficiency. Tables with many <code>BLOB</code>columns could cause B-tree nodes to become too full, and contain too few rows, making the entire index less efficient than if rows were shorter or column values were stored off-page.</p>
<p>如果列的值小于 768 字节, 溢出页不会被用到, 会节省一些 I/O 操作, 因为值完整存储在 B-tree 索引中(PS. 现在我中文的语序都有点乱了, 因为被英文语法的顺序影响了 = =)</p>
<p>这在相对小的 BLOB 列上表现得很好, 但是可能会导致 B-tree 节点被数据填满, 而不是键值, 效率被减少了.</p>
<p>具有太多 BLOB 列的表可能会导致 B-tree 过于充实, 包含的行过于少. 使整个索引的效率低于较短的列或者列存储在溢出页</p>
<h4 id="REDUNDANT-Row-Format-Storage-Characteristics"><a href="#REDUNDANT-Row-Format-Storage-Characteristics" class="headerlink" title="REDUNDANT Row Format Storage Characteristics"></a>REDUNDANT Row Format Storage Characteristics</h4><p>The <code>REDUNDANT</code> row format has the following storage characteristics:</p>
<ul>
<li><p>Each index record contains a 6-byte header. The header is used to link together consecutive records, and for row-level locking.</p>
<p>每个索引记录包含 6 字节的头部, 用于链接连续的记录和行级锁</p>
</li>
<li><p>Records in the clustered index contain fields for all user-defined columns. In addition, there is a 6-byte transaction ID field and a 7-byte roll pointer field.</p>
<p>在聚簇索引记录中包含了所有用户定义的列, 除此之外, 还有 6 字节的事务ID和 7 字节的回滚指针</p>
</li>
<li><p>If no primary key is defined for a table, each clustered index record also contains a 6-byte row ID field.</p>
<p>如果没有为表定义一个主键, 每个聚簇索引记录还包含 6 字节的行 ID 字段</p>
</li>
<li><p>Each secondary index record contains all the primary key columns defined for the clustered index key that are not in the secondary index.</p>
<p>每个次级记录包含为聚簇索引定义的不在次级索引中的所有主键列</p>
</li>
<li><p>A record contains a pointer to each field of the record. If the total length of the fields in a record is less than 128 bytes, the pointer is one byte; otherwise, two bytes. The array of pointers is called the record directory. The area where the pointers point is the data part of the record.</p>
<p>记录包含指向记录每个字段的指针, 如果记录中所有字段长度总和小于 128 字节, 指针大小为 1 字节, 否则为 2 字节 (PS. 这里的 pointer 可能不是指针的意思, 而是类似指示的含义, 它可能是偏移 offset)</p>
<p>指针数组被称为记录目录, 指针指向记录的数据部分</p>
</li>
<li><p>Internally, fixed-length character columns such as <a href="https://dev.mysql.com/doc/refman/8.0/en/char.html" target="_blank" rel="noopener"><code>CHAR(10)</code></a> in stored in fixed-length format. Trailing spaces are not truncated from <a href="https://dev.mysql.com/doc/refman/8.0/en/char.html" target="_blank" rel="noopener"><code>VARCHAR</code></a> columns.</p>
<p>固定长度的列, 例如 CHAR(10) 以固定长度格式化, VARCHAR 结尾空白不会被截断</p>
</li>
<li><p>Fixed-length columns greater than or equal to 768 bytes are encoded as variable-length columns, which can be stored off-page. For example, a <code>CHAR(255)</code> column can exceed 768 bytes if the maximum byte length of the character set is greater than 3, as it is with <code>utf8mb4</code>.</p>
<p>长度 &gt;= 768 字节的列即使是固定的, 也会被当做变长宽度列编码, 存储到溢出页</p>
<p>比如, 一个 CHAR(255) 的列如果字符集的长度超过3, 那么就超过了768 字节, 正如 utf8mb4</p>
</li>
<li><p>An SQL <code>NULL</code> value reserves one or two bytes in the record directory. An SQL <code>NULL</code> value reserves zero bytes in the data part of the record if stored in a variable-length column. For a fixed-length column, the fixed length of the column is reserved in the data part of the record. Reserving fixed space for <code>NULL</code> values permits columns to be updated in place from <code>NULL</code> to non-<code>NULL</code> values without causing index page fragmentation.</p>
<p>SQL NULL 值在记录目录中占有 1 或 2 个字节, 如果存储在变长列中, 在记录的数据部分不占空间. </p>
<p>对于一个固定长度的列, 存储在记录的数据部分, 为 NULL 值保留固定的长度使列的更新可以就地发生, 而不会导致索引页碎片</p>
</li>
</ul>
<h3 id="COMPACT-Row-Format"><a href="#COMPACT-Row-Format" class="headerlink" title="COMPACT Row Format"></a>COMPACT Row Format</h3><p>Tables that use the <code>COMPACT</code> row format store the first 768 bytes of variable-length column values (<a href="https://dev.mysql.com/doc/refman/8.0/en/char.html" target="_blank" rel="noopener"><code>VARCHAR</code></a>, <a href="https://dev.mysql.com/doc/refman/8.0/en/binary-varbinary.html" target="_blank" rel="noopener"><code>VARBINARY</code></a>, and <a href="https://dev.mysql.com/doc/refman/8.0/en/blob.html" target="_blank" rel="noopener"><code>BLOB</code></a> and <a href="https://dev.mysql.com/doc/refman/8.0/en/blob.html" target="_blank" rel="noopener"><code>TEXT</code></a> types) in the index record within the <a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_b_tree" target="_blank" rel="noopener">B-tree</a> node, with the remainder stored on overflow pages. Fixed-length columns greater than or equal to 768 bytes are encoded as variable-length columns, which can be stored off-page. For example, a <code>CHAR(255)</code> column can exceed 768 bytes if the maximum byte length of the character set is greater than 3, as it is with <code>utf8mb4</code>.</p>
<p>(PS. 和 REDUNDANT 一样的 = =)</p>
<p>If the value of a column is 768 bytes or less, an overflow page is not used, and some savings in I/O may result, since the value is stored entirely in the B-tree node. This works well for relatively short <code>BLOB</code> column values, but may cause B-tree nodes to fill with data rather than key values, reducing their efficiency. Tables with many <code>BLOB</code>columns could cause B-tree nodes to become too full, and contain too few rows, making the entire index less efficient than if rows were shorter or column values were stored off-page.</p>
<p>(PS. 怎么还是一样的 = = )</p>
<h4 id="COMPACT-Row-Format-Storage-Characteristics"><a href="#COMPACT-Row-Format-Storage-Characteristics" class="headerlink" title="COMPACT Row Format Storage Characteristics"></a>COMPACT Row Format Storage Characteristics</h4><p>The <code>COMPACT</code> row format has the following storage characteristics:</p>
<ul>
<li><p>Each index record contains a 5-byte header that may be preceded by a variable-length header. The header is used to link together consecutive records, and for row-level locking.</p>
<p>每个索引记录包含 5 字节的头部, 前面可能是变长头部. 头部用于链接记录和行锁</p>
</li>
<li><p>The variable-length part of the record header contains a bit vector for indicating <code>NULL</code> columns. If the number of columns in the index that can be <code>NULL</code> is <em>N</em>, the bit vector occupies <code>CEILING(*N*/8)</code> bytes. (For example, if there are anywhere from 9 to 16 columns that can be <code>NULL</code>, the bit vector uses two bytes.) Columns that are <code>NULL</code>do not occupy space other than the bit in this vector. The variable-length part of the header also contains the lengths of variable-length columns. Each length takes one or two bytes, depending on the maximum length of the column. If all columns in the index are <code>NOT NULL</code> and have a fixed length, the record header has no variable-length part.</p>
<p>变长列记录头部包含空列的位向量 NULL 列, 如果索引中可以是 NULL 的列的数量为 N, 向量占用 CEILING(N/8)字节(例如, 如果有 9 到 16 列可以为空, 向量使用 2 字节) NULL 列不占用空间, 只占用向量中的位</p>
<p>头部的变长部分也包含变长列的长度, 占用 1 到 2 个字节, 取决于列的最大长度, 如果索引中的所有列非空, 并且有一个固定的长度, 那么记录头部不会有变长长度部分</p>
</li>
<li><p>For each non-<code>NULL</code> variable-length field, the record header contains the length of the column in one or two bytes. Two bytes are only needed if part of the column is stored externally in overflow pages or the maximum length exceeds 255 bytes and the actual length exceeds 127 bytes. For an externally stored column, the 2-byte length indicates the length of the internally stored part plus the 20-byte pointer to the externally stored part. The internal part is 768 bytes, so the length is 768+20. The 20-byte pointer stores the true length of the column.</p>
<p>对于每个非空变长字段, 记录头部包含列的长度, 1 ~ 2 字节. 2 字节仅在列的部分存储在溢出页, 或最大长度超过 255 字节, 并且真实长度超过 127 字节</p>
<p>对于一个外部存储的列, 这 2 字节长度代表内部存储部分 + 20 字节的指向外部存储部分的指针 </p>
<p>内部部分是 768 字节, 长度是 768 + 20, 这 20 字节指针存储列的真实长度 (PS. 这里有点不对)</p>
</li>
<li><p>The record header is followed by the data contents of non-<code>NULL</code> columns.</p>
<p>记录头后跟着非空列的数据内容</p>
</li>
<li><p>Records in the clustered index contain fields for all user-defined columns. In addition, there is a 6-byte transaction ID field and a 7-byte roll pointer field.</p>
<p>聚簇索引记录包含所有用户定义列, 同时有 6 字节的事务 ID 和 7 字节的回滚 ID</p>
</li>
<li><p>If no primary key is defined for a table, each clustered index record also contains a 6-byte row ID field.</p>
<p>如果没有为表定义主键, 每个聚簇索引还包含 6 字节的行 ID</p>
</li>
<li><p>Each secondary index record contains all the primary key columns defined for the clustered index key that are not in the secondary index. If any of the primary key columns are variable length, the record header for each secondary index has a variable-length part to record their lengths, even if the secondary index is defined on fixed-length columns.</p>
<p>每个次级索引记录包含所有为聚簇索引定义的不在次级索引中的主键, 如果有主键列是变长的, 每个次级索引的头部有一个变长部分记录次级索引的长度, 即使次级索引是固定的列</p>
</li>
<li><p>Internally, for nonvariable-length character sets, fixed-length character columns such as <a href="https://dev.mysql.com/doc/refman/8.0/en/char.html" target="_blank" rel="noopener"><code>CHAR(10)</code></a> are stored in a fixed-length format.</p>
<p>Trailing spaces are not truncated from <a href="https://dev.mysql.com/doc/refman/8.0/en/char.html" target="_blank" rel="noopener"><code>VARCHAR</code></a> columns.</p>
<p>对非变长字符集, 像 CHAR(10) 这样的固定字符集列以固定长度格式化</p>
<p>VARCHAR 列尾部空白不会被截断</p>
</li>
<li><p>Internally, for variable-length character sets such as <code>utf8mb3</code> and <code>utf8mb4</code>, <code>InnoDB</code> attempts to store <a href="https://dev.mysql.com/doc/refman/8.0/en/char.html" target="_blank" rel="noopener"><code>CHAR(*N*)</code></a> in <em>N</em> bytes by trimming trailing spaces. If the byte length of a <a href="https://dev.mysql.com/doc/refman/8.0/en/char.html" target="_blank" rel="noopener"><code>CHAR(*N*)</code></a> column value exceeds <em>N</em> bytes, trailing spaces are trimmed to a minimum of the column value byte length. The maximum length of a <a href="https://dev.mysql.com/doc/refman/8.0/en/char.html" target="_blank" rel="noopener"><code>CHAR(*N*)</code></a> column is the maximum character byte length × <em>N</em>.</p>
<p>内部, 如 utf8mb3 和 utf8mb4 变长字符集, InnoDB 通过裁剪尾随的空格将 CHAR(N) 存储 N 字节</p>
<p>如果 CHAR(N) 列长度超过 N 字节, 尾端空白被裁剪到列值字节数的最小值, CHAR(N) 列的最大长度是最大字符字节宽度 x N</p>
<p>A minimum of <em>N</em> bytes is reserved for <a href="https://dev.mysql.com/doc/refman/8.0/en/char.html" target="_blank" rel="noopener"><code>CHAR(*N*)</code></a>. Reserving the minimum space <em>N</em> in many cases enables column updates to be done in place without causing index page fragmentation. By comparison, <a href="https://dev.mysql.com/doc/refman/8.0/en/char.html" target="_blank" rel="noopener"><code>CHAR(*N*)</code></a> columns occupy the maximum character byte length × <em>N</em> when using the <code>REDUNDANT</code> row format.</p>
<p>为 CHAR(N) 存储一个最小 N 字节空间, 存储这个最小的 N 空间在很多情况下是列值的更新就地发生, 不导致页碎片. 对比而言, 当使用 REDUNDANT 行格式化时, CHAR(N) 列占有最大字符长度  x N </p>
<p>Fixed-length columns greater than or equal to 768 bytes are encoded as variable-length fields, which can be stored off-page. For example, a <code>CHAR(255)</code> column can exceed 768 bytes if the maximum byte length of the character set is greater than 3, as it is with <code>utf8mb4</code>.</p>
<p>固定长度大于或等于 768 字节的列以变长字段编码, 存储在页外, … (PS. emm… 好像是一样的了)</p>
</li>
</ul>
<p>(PS. REDUNDANT 和 COMPACT 的区别主要有两个 : 1. COMPACT 不保存固定字段的长度 2. COMPACT 会裁剪尾随的空白字符. 所以 REDUNDANT 叫 REDUNDANT, COMPACT 叫 COMPACT, REDUNDANT 牺牲了空间换取效率)</p>
<h3 id="DYNAMIC-Row-Format"><a href="#DYNAMIC-Row-Format" class="headerlink" title="DYNAMIC Row Format"></a>DYNAMIC Row Format</h3><p>When a table is created with <code>ROW_FORMAT=DYNAMIC</code>, <code>InnoDB</code> can store long variable-length column values (for <a href="https://dev.mysql.com/doc/refman/8.0/en/char.html" target="_blank" rel="noopener"><code>VARCHAR</code></a>, <a href="https://dev.mysql.com/doc/refman/8.0/en/binary-varbinary.html" target="_blank" rel="noopener"><code>VARBINARY</code></a>, and <a href="https://dev.mysql.com/doc/refman/8.0/en/blob.html" target="_blank" rel="noopener"><code>BLOB</code></a> and <a href="https://dev.mysql.com/doc/refman/8.0/en/blob.html" target="_blank" rel="noopener"><code>TEXT</code></a> types) fully off-page, with the clustered index record containing only a 20-byte pointer to the overflow page. Fixed-length fields greater than or equal to 768 bytes are encoded as variable-length fields. For example, a <code>CHAR(255)</code> column can exceed 768 bytes if the maximum byte length of the character set is greater than 3, as it is with <code>utf8mb4</code>.</p>
<p>当表被创建为 DYNAMIC 类型时, InnoDB 能将长的变长列完全存储在页外, 聚簇索引只包含 20 字节的指向溢出页的指针. 固定长度 &gt;= 768 的字段按照变长字段存储, 比如 … (PS. 一样的, 就不比如了… = =)</p>
<p>Whether columns are stored off-page depends on the page size and the total size of the row. When a row is too long, the longest columns are chosen for off-page storage until the clustered index record fits on the <a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_b_tree" target="_blank" rel="noopener">B-tree</a> page. <a href="https://dev.mysql.com/doc/refman/8.0/en/blob.html" target="_blank" rel="noopener"><code>TEXT</code></a> and <a href="https://dev.mysql.com/doc/refman/8.0/en/blob.html" target="_blank" rel="noopener"><code>BLOB</code></a> columns that are less than or equal to 40 bytes are stored in line.</p>
<p>列是否存储在页外取决于页的大小和行的总大小. </p>
<p>当行太长时, 最长的列被选为页外存储, 直到聚簇索引记录大小适合保存在 B-tree 页, TEXT 和 BLOB 列 &lt;= 40 字节按行存储</p>
<p>The <code>DYNAMIC</code> row format maintains the efficiency of storing the entire row in the index node if it fits (as do the <code>COMPACT</code> and <code>REDUNDANT</code> formats), but the <code>DYNAMIC</code> row format avoids the problem of filling B-tree nodes with a large number of data bytes of long columns. The <code>DYNAMIC</code> row format is based on the idea that if a portion of a long data value is stored off-page, it is usually most efficient to store the entire value off-page. With <code>DYNAMIC</code> format, shorter columns are likely to remain in the B-tree node, minimizing the number of overflow pages required for a given row.</p>
<p>DYNAMIC 行存储维护在索引节点中存储整行(如果大小匹配的话)的效率(就像 COMPACT 和 REDUNDANT 一样), 但是 DYNAMIC 避免了 B-tree 被大量长列填满的问题</p>
<p>DYNAMIC 行存储基于一部分数据存储在页外的想法, 通常最有效的方法是整个值都存储在页外</p>
<p>使用 DYNAMIC 存储, 较短的行更可能保存在 B-tree 节点, 最小化行所需要的溢出页数量</p>
<p>The <code>DYNAMIC</code> row format supports index key prefixes up to 3072 bytes. </p>
<p>DYNAMIC 行存储支持索引键前缀, 最大可达 3072 字节 (PS. = = 这么大的么…) (需要设置 innodb_large_prefix=1)</p>
<p>Tables that use the <code>DYNAMIC</code> row format can be stored in the system tablespace, file-per-table tablespaces, and general tablespaces. To store <code>DYNAMIC</code> tables in the system tablespace, either disable <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_file_per_table" target="_blank" rel="noopener"><code>innodb_file_per_table</code></a> and use a regular <code>CREATE TABLE</code> or <code>ALTER TABLE</code> statement, or use the <code>TABLESPACE [=] innodb_system</code> table option with <code>CREATE TABLE</code> or <code>ALTER TABLE</code>. The <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_file_per_table" target="_blank" rel="noopener"><code>innodb_file_per_table</code></a> variable is not applicable to general tablespaces, nor is it applicable when using the <code>TABLESPACE [=] innodb_system</code> table option to store <code>DYNAMIC</code> tables in the system tablespace.</p>
<p>使用 DYNAMIC 存储的行能保存在 system tablespace, file-per-table tablespace, 以及 general tablespace 中. </p>
<p>将 DYNAMIC 表存储在 system tablespace 要么取消 innodb_file_per_table 以及使用常规的 CREATE TABLE 或 ALTER TABLE 语句, 或者在 CREATE TABLE 或 ALTER TABLE 时使用 TABLESPACE [=] innodb_system 表选项.</p>
<p>innodb_file_per_table 变量不适用于 general tablespace, 也不适用于使用 TABLESPACE [=] innodb_system 表选项去在 system tablespace 中存储 DYNAMIC 表</p>
<h4 id="DYNAMIC-Row-Format-Storage-Characteristics"><a href="#DYNAMIC-Row-Format-Storage-Characteristics" class="headerlink" title="DYNAMIC Row Format Storage Characteristics"></a>DYNAMIC Row Format Storage Characteristics</h4><p>The <code>DYNAMIC</code> row format is a variation of the <code>COMPACT</code> row format. For storage characteristics, see <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-row-format.html#innodb-compact-row-format-characteristics" target="_blank" rel="noopener">COMPACT Row Format Storage Characteristics</a>.</p>
<p>DYNAMIC 行存储是 COMPACT 行存储的一种变化</p>
<h3 id="COMPRESSED-Row-Format"><a href="#COMPRESSED-Row-Format" class="headerlink" title="COMPRESSED Row Format"></a>COMPRESSED Row Format</h3><p>The <code>COMPRESSED</code> row format uses similar internal details for off-page storage as the <code>DYNAMIC</code> row format, with additional storage and performance considerations from the table and index data being compressed and using smaller page sizes. With the <code>COMPRESSED</code> row format, the <code>KEY_BLOCK_SIZE</code> option controls how much column data is stored in the clustered index, and how much is placed on overflow pages. For more information about the <code>COMPRESSED</code> row format, see <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-compression.html" target="_blank" rel="noopener">Section 15.9, “InnoDB Table and Page Compression”</a>.</p>
<p>COMPRESSED 行存储使用和 DYNAMIC 类似的内部细节 : 页外存储, 压缩表和索引数据以使用更少的页, 考虑额外的存储和性能. </p>
<p>使用 COMPRESSED 行存储, KEY_BLOCK_SIZE 选项控制多少列数据存储在聚簇索引, 多少存储在溢出页. </p>
<p>The <code>COMPRESSED</code> row format supports index key prefixes up to 3072 bytes.</p>
<p>COMPRESSED 行存储支持索引键前缀, 最大可达 3072 字节</p>
<p>Tables that use the <code>COMPRESSED</code> row format can be created in file-per-table tablespaces or general tablespaces. The system tablespace does not support the <code>COMPRESSED</code>row format. To store a <code>COMPRESSED</code> table in a file-per-table tablespace, the <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_file_per_table" target="_blank" rel="noopener"><code>innodb_file_per_table</code></a> variable must be enabled. The <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_file_per_table" target="_blank" rel="noopener"><code>innodb_file_per_table</code></a> variable is not applicable to general tablespaces. General tablespaces support all row formats with the caveat that compressed and uncompressed tables cannot coexist in the same general tablespace due to different physical page sizes. For more information, see <a href="https://dev.mysql.com/doc/refman/8.0/en/general-tablespaces.html" target="_blank" rel="noopener">Section 15.6.3.3, “General Tablespaces”</a>.</p>
<h4 id="Compressed-Row-Format-Storage-Characteristics"><a href="#Compressed-Row-Format-Storage-Characteristics" class="headerlink" title="Compressed Row Format Storage Characteristics"></a>Compressed Row Format Storage Characteristics</h4><p>The <code>COMPRESSED</code> row format is a variation of the <code>COMPACT</code> row format. For storage characteristics, see <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-row-format.html#innodb-compact-row-format-characteristics" target="_blank" rel="noopener">COMPACT Row Format Storage Characteristics</a>.</p>
<h3 id="Defining-the-Row-Format-of-a-Table"><a href="#Defining-the-Row-Format-of-a-Table" class="headerlink" title="Defining the Row Format of a Table"></a>Defining the Row Format of a Table</h3><p>The default row format for <code>InnoDB</code> tables is defined by <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_default_row_format" target="_blank" rel="noopener"><code>innodb_default_row_format</code></a> variable, which has a default value of <code>DYNAMIC</code>. The default row format is used when the <code>ROW_FORMAT</code> table option is not defined explicitly or when <code>ROW_FORMAT=DEFAULT</code> is specified.</p>
<p>innodb_default_row_format 控制默认创建的表行存储类型 (dynamic) , 当表选项 ROW_FORMAT 没有显式指明时才会使用默认配置</p>
<p>The row format of a table can be defined explicitly using the <code>ROW_FORMAT</code> table option in a <a href="https://dev.mysql.com/doc/refman/8.0/en/create-table.html" target="_blank" rel="noopener"><code>CREATE TABLE</code></a> or <a href="https://dev.mysql.com/doc/refman/8.0/en/alter-table.html" target="_blank" rel="noopener"><code>ALTER TABLE</code></a> statement. For example:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1 (c1 <span class="built_in">INT</span>) ROW_FORMAT=DYNAMIC;</span><br></pre></td></tr></table></figure>

<p>An explicitly defined <code>ROW_FORMAT</code> setting overrides the default row format. Specifying <code>ROW_FORMAT=DEFAULT</code> is equivalent to using the implicit default.</p>
<p>The <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_default_row_format" target="_blank" rel="noopener"><code>innodb_default_row_format</code></a> variable can be set dynamically:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; SET GLOBAL innodb_default_row_format=DYNAMIC;</span><br></pre></td></tr></table></figure>

<p>Valid <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_default_row_format" target="_blank" rel="noopener"><code>innodb_default_row_format</code></a> options include <code>DYNAMIC</code>, <code>COMPACT</code>, and <code>REDUNDANT</code>. The <code>COMPRESSED</code> row format, which is not supported for use in the system tablespace, cannot be defined as the default. It can only be specified explicitly in a <a href="https://dev.mysql.com/doc/refman/8.0/en/create-table.html" target="_blank" rel="noopener"><code>CREATE TABLE</code></a> or <a href="https://dev.mysql.com/doc/refman/8.0/en/alter-table.html" target="_blank" rel="noopener"><code>ALTER TABLE</code></a> statement. Attempting to set the<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_default_row_format" target="_blank" rel="noopener"><code>innodb_default_row_format</code></a> variable to <code>COMPRESSED</code> returns an error:</p>
<p>COMPRESSED 不能用于默认设置, 只能显式指定</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SET GLOBAL innodb_default_row_format=COMPRESSED;</span><br><span class="line">ERROR 1231 (42000): Variable 'innodb_default_row_format'</span><br><span class="line">can't be <span class="keyword">set</span> <span class="keyword">to</span> the <span class="keyword">value</span> <span class="keyword">of</span> <span class="string">'COMPRESSED'</span></span><br></pre></td></tr></table></figure>

<p>Newly created tables use the row format defined by the <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_default_row_format" target="_blank" rel="noopener"><code>innodb_default_row_format</code></a> variable when a <code>ROW_FORMAT</code> option is not specified explicitly, or when<code>ROW_FORMAT=DEFAULT</code> is used. For example, the following <a href="https://dev.mysql.com/doc/refman/8.0/en/create-table.html" target="_blank" rel="noopener"><code>CREATE TABLE</code></a> statements use the row format defined by the <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_default_row_format" target="_blank" rel="noopener"><code>innodb_default_row_format</code></a> variable.</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1 (c1 <span class="built_in">INT</span>);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t2 (c1 <span class="built_in">INT</span>) ROW_FORMAT=<span class="keyword">DEFAULT</span>;</span><br></pre></td></tr></table></figure>

<p>When a <code>ROW_FORMAT</code> option is not specified explicitly, or when <code>ROW_FORMAT=DEFAULT</code> is used, an operation that rebuilds a table silently changes the row format of the table to the format defined by the <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_default_row_format" target="_blank" rel="noopener"><code>innodb_default_row_format</code></a> variable.</p>
<p>Table-rebuilding operations include <a href="https://dev.mysql.com/doc/refman/8.0/en/alter-table.html" target="_blank" rel="noopener"><code>ALTER TABLE</code></a> operations that use <code>ALGORITHM=COPY</code> or <code>ALGORITHM=INPLACE</code> where table rebuilding is required. See <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-online-ddl-operations.html" target="_blank" rel="noopener">Section 15.12.1, “Online DDL Operations”</a> for more information. <a href="https://dev.mysql.com/doc/refman/8.0/en/optimize-table.html" target="_blank" rel="noopener"><code>OPTIMIZE TABLE</code></a> is also a table-rebuilding operation.</p>
<p>The following example demonstrates a table-rebuilding operation that silently changes the row format of a table created without an explicitly defined row format.</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT @@innodb_default_row_format;</span><br><span class="line">+<span class="comment">-----------------------------+</span></span><br><span class="line">| @@innodb_default_row_format |</span><br><span class="line">+<span class="comment">-----------------------------+</span></span><br><span class="line">| dynamic                     |</span><br><span class="line">+<span class="comment">-----------------------------+</span></span><br><span class="line"></span><br><span class="line">mysql&gt; CREATE TABLE t1 (c1 INT);</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM INFORMATION_SCHEMA.INNODB_TABLES WHERE NAME LIKE 'test/t1' \G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">     TABLE_ID: 54</span><br><span class="line">         NAME: test/t1</span><br><span class="line">         FLAG: 33</span><br><span class="line">       N_COLS: 4</span><br><span class="line">        SPACE: 35</span><br><span class="line">   ROW_FORMAT: Dynamic</span><br><span class="line">ZIP_PAGE_SIZE: 0</span><br><span class="line">   SPACE_TYPE: Single</span><br><span class="line"></span><br><span class="line">mysql&gt; SET GLOBAL innodb_default_row_format=COMPACT;</span><br><span class="line"></span><br><span class="line">mysql&gt; ALTER TABLE t1 ADD COLUMN (c2 INT);</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM INFORMATION_SCHEMA.INNODB_TABLES WHERE NAME LIKE 'test/t1' \G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">     TABLE_ID: 55</span><br><span class="line">         NAME: test/t1</span><br><span class="line">         FLAG: 1</span><br><span class="line">       N_COLS: 5</span><br><span class="line">        SPACE: 36</span><br><span class="line">   ROW_FORMAT: Compact</span><br><span class="line">ZIP_PAGE_SIZE: 0</span><br><span class="line">   SPACE_TYPE: Single</span><br></pre></td></tr></table></figure>

<p>(PS. 这种情况要格外注意, 更改表操作相当于重新创建, 之前设置的一些默认选项可能已经被改变了)</p>
<p>Consider the following potential issues before changing the row format of existing tables from <code>REDUNDANT</code> or <code>COMPACT</code> to <code>DYNAMIC</code>.</p>
<ul>
<li><p>The <code>REDUNDANT</code> and <code>COMPACT</code> row formats support a maximum index key prefix length of 767 bytes whereas <code>DYNAMIC</code> and <code>COMPRESSED</code> row formats support an index key prefix length of 3072 bytes. In a replication environment, if the <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_default_row_format" target="_blank" rel="noopener"><code>innodb_default_row_format</code></a> variable is set to <code>DYNAMIC</code> on the master, and set to <code>COMPACT</code> on the slave, the following DDL statement, which does not explicitly define a row format, succeeds on the master but fails on the slave:</p>
<p>REDUNDANT 和 COMPACT 行存储支持最大 767 字节的索引键前缀, 然而 DYNAMIC 和 COMPRESSED 行存储支持的长度可达 3072 字节.</p>
<p>在同样的环境下, 如果 innodb_default_row_format 在主环境下设置为 DYNAMIC, 而在次环境下设置为 COMPACT, 下列没有显式定义行存储的语句会在主环境下成功, 而次环境会失败</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1 (c1 <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span>, c2 <span class="built_in">VARCHAR</span>(<span class="number">5000</span>), <span class="keyword">KEY</span> i1(c2(<span class="number">3070</span>)));</span><br></pre></td></tr></table></figure>

<p>For related information, see <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-restrictions.html" target="_blank" rel="noopener">Section 15.6.1.6, “Limits on InnoDB Tables”</a>.</p>
<p>(PS. 原因是 REDUNDANT 和 COMPACT 行存储限制了索引前缀必须低于 768 字节</p>
<p>这里还要加限制, 就是 c2(3070) 真正内存 &lt; 3072 )</p>
</li>
<li><p>Importing a table that does not explicitly define a row format results in a schema mismatch error if the <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_default_row_format" target="_blank" rel="noopener"><code>innodb_default_row_format</code></a> setting on the source server differs from the setting on the destination server. For more information, refer to the limitations outlined in <a href="https://dev.mysql.com/doc/refman/8.0/en/tablespace-copying.html" target="_blank" rel="noopener">Section 15.6.3.7, “Copying Tablespaces to Another Instance”</a>.</p>
<p>导入一个为显式指定行存储的表时, 被导入表的行存储和默认存储设置不一致会产生错误</p>
</li>
</ul>
<h3 id="Determining-the-Row-Format-of-a-Table"><a href="#Determining-the-Row-Format-of-a-Table" class="headerlink" title="Determining the Row Format of a Table"></a>Determining the Row Format of a Table</h3><p>To determine the row format of a table, use <a href="https://dev.mysql.com/doc/refman/8.0/en/show-table-status.html" target="_blank" rel="noopener"><code>SHOW TABLE STATUS</code></a>:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW TABLE STATUS IN test1\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           Name: t1</span><br><span class="line">         Engine: InnoDB</span><br><span class="line">        Version: 10</span><br><span class="line">     Row_format: Dynamic</span><br><span class="line">           Rows: 0</span><br><span class="line"> Avg_row_length: 0</span><br><span class="line">    Data_length: 16384</span><br><span class="line">Max_data_length: 0</span><br><span class="line">   Index_length: 16384</span><br><span class="line">      Data_free: 0</span><br><span class="line"> Auto_increment: 1</span><br><span class="line">    Create_time: 2016-09-14 16:29:38</span><br><span class="line">    Update_time: NULL</span><br><span class="line">     Check_time: NULL</span><br><span class="line">      Collation: utf8mb4_0900_ai_ci</span><br><span class="line">       <span class="keyword">Checksum</span>: <span class="literal">NULL</span></span><br><span class="line"> Create_options: </span><br><span class="line">        <span class="keyword">Comment</span>:</span><br></pre></td></tr></table></figure>

<p>Alternatively, query the <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-tables-table.html" target="_blank" rel="noopener"><code>INFORMATION_SCHEMA.INNODB_TABLES</code></a> table:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT NAME, ROW_FORMAT FROM INFORMATION_SCHEMA.INNODB_TABLES WHERE NAME='test1/t1';</span><br><span class="line">+<span class="comment">----------+------------+</span></span><br><span class="line">| NAME     | ROW_FORMAT |</span><br><span class="line">+<span class="comment">----------+------------+</span></span><br><span class="line">| test1/t1 | Dynamic    |</span><br><span class="line">+<span class="comment">----------+------------+</span></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>read/InnoDBRedoLog</title>
    <url>/2020/01/09/read/InnoDBRedoLog/</url>
    <content><![CDATA[<h3 id="15-6-5-Redo-Log"><a href="#15-6-5-Redo-Log" class="headerlink" title="15.6.5 Redo Log"></a>15.6.5 Redo Log</h3><p>By default, the redo log is physically represented on disk by two files named <code>ib_logfile0</code> and <code>ib_logfile1</code>. MySQL writes to the redo log files in a circular fashion. Data in the redo log is encoded in terms of records affected; this data is collectively referred to as redo. The passage of data through the redo log is represented by an ever-increasing <a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_lsn" target="_blank" rel="noopener">LSN</a> value.</p>
<p>默认 redo 日志通过两个叫 ib_logfile0 和 ib_logfile1 的文件物理地记录在磁盘上. MySQL 以循环方式写入到文件中. redo 日志中的数据受记录影响编码. 这些数据统称为 redo. 数据通过 redo 日志的传递由一个不断增长的 LSN 值表示</p>
<p>For related information, see <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-init-startup-configuration.html#innodb-startup-log-file-configuration" target="_blank" rel="noopener">Redo Log File Configuration</a>, and <a href="https://dev.mysql.com/doc/refman/8.0/en/optimizing-innodb-logging.html" target="_blank" rel="noopener">Section 8.5.4, “Optimizing InnoDB Redo Logging”</a>.</p>
<p>For information about data-at-rest encryption for redo logs, see <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-tablespace-encryption.html#innodb-tablespace-encryption-redo-log" target="_blank" rel="noopener">Redo Log Encryption</a>.</p>
<h4 id="Changing-the-Number-or-Size-of-Redo-Log-Files"><a href="#Changing-the-Number-or-Size-of-Redo-Log-Files" class="headerlink" title="Changing the Number or Size of Redo Log Files"></a>Changing the Number or Size of Redo Log Files</h4><ol>
<li>Stop the MySQL server and make sure that it shuts down without errors.</li>
<li>Edit <code>my.cnf</code> to change the log file configuration. To change the log file size, configure <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_log_file_size" target="_blank" rel="noopener"><code>innodb_log_file_size</code></a>. To increase the number of log files, configure<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_log_files_in_group" target="_blank" rel="noopener"><code>innodb_log_files_in_group</code></a>.</li>
<li>Start the MySQL server again.</li>
</ol>
<p>If <code>InnoDB</code> detects that the <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_log_file_size" target="_blank" rel="noopener"><code>innodb_log_file_size</code></a> differs from the redo log file size, it writes a log checkpoint, closes and removes the old log files, creates new log files at the requested size, and opens the new log files.</p>
<h4 id="Group-Commit-for-Redo-Log-Flushing"><a href="#Group-Commit-for-Redo-Log-Flushing" class="headerlink" title="Group Commit for Redo Log Flushing"></a>Group Commit for Redo Log Flushing</h4><p><code>InnoDB</code>, like any other <a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_acid" target="_blank" rel="noopener">ACID</a>-compliant database engine, flushes the <a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_redo_log" target="_blank" rel="noopener">redo log</a> of a transaction before it is committed. <code>InnoDB</code> uses <a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_group_commit" target="_blank" rel="noopener">group commit</a> functionality to group multiple such flush requests together to avoid one flush for each commit. With group commit, <code>InnoDB</code> issues a single write to the log file to perform the commit action for multiple user transactions that commit at about the same time, significantly improving throughput.</p>
<p>InnoDB 像其他 ACID 数据引擎一样, 在事务提交前冲刷 redo 日志, InnoDB 使用组提交功能, 将多个提交请求分组, 避免每次提交都冲刷记录. 在组提交中, InnoDB 为在大约同一时间提交的多次用户事务执行单次文件写入, 显著提高了吞吐量</p>
<p>For more information about performance of <code>COMMIT</code> and other transactional operations, see <a href="https://dev.mysql.com/doc/refman/8.0/en/optimizing-innodb-transaction-management.html" target="_blank" rel="noopener">Section 8.5.2, “Optimizing InnoDB Transaction Management”</a>.</p>
<h4 id="Redo-Log-Archiving"><a href="#Redo-Log-Archiving" class="headerlink" title="Redo Log Archiving"></a>Redo Log Archiving</h4><p>Backup utilities that copy redo log records may sometimes fail to keep pace with redo log generation while a backup operation is in progress, resulting in lost redo log records due to those records being overwritten. This issue most often occurs when there is significant MySQL server activity during the backup operation, and the redo log file storage media operates at a faster speed than the backup storage media. The redo log archiving feature, introduced in MySQL 8.0.17, addresses this issue by sequentially writing redo log records to an archive file in addition to the redo log files. Backup utilities can copy redo log records from the archive file as necessary, thereby avoiding the potential loss of data.</p>
<p>拷贝 redo 日志记录的备份工具可能有时会跟丢 redo 记录日志的生成速度, 当备份操作运行中, 因为这些记录被覆写而导致丢失 redo 日志记录</p>
<p>当备份操作产生大量的 MySQL 服务器活动时这个问题经常发生, 此时 redo 日志文件存储媒介操作处于比备份存储媒介操作更快的速率. 在 MySQL 8.0.17 引进的 redo 日志归档功能, 通过除写入 redo 日志外, 还序列写入 redo 日志记录到归档文件解决这个问题. 备份工具尽可能从归档文件中拷贝 redo 日志记录, 从而规避潜在的数据丢失问题</p>
<p>If redo log archiving is configured on the server, <a href="https://dev.mysql.com/doc/mysql-enterprise-backup/8.0/en/" target="_blank" rel="noopener">MySQL Enterprise Backup</a>, available with the <a href="https://www.mysql.com/products/enterprise/" target="_blank" rel="noopener">MySQL Enterprise Edition</a>, uses the redo log archiving feature when backing up a MySQL server. </p>
<p>Enabling redo log archiving on the server requires setting a value for the <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_redo_log_archive_dirs" target="_blank" rel="noopener"><code>innodb_redo_log_archive_dirs</code></a> system variable. The value is specified as a semicolon-separated list of labeled redo log archive directories. The <code>*label:directory*</code> pair is separated by a colon (<code>:</code>). For example:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; SET GLOBAL innodb_redo_log_archive_dirs='label1:directory_path1[;label2:directory_path2;…]';</span><br></pre></td></tr></table></figure>

<p>The <em>label</em> is an arbitrary identifier for the archive directory. It can be any string of characters, with the exception of colons (:), which are not permitted. An empty label is also permitted, but the colon (:) is still required in this case. A <em>directory_path</em> must be specified. The directory that is selected for the redo log archive file must exist when redo log archiving is activated, or an error is returned. The path can contain colons (‘:’), but semicolons (;) are not permitted.</p>
<p>The <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_redo_log_archive_dirs" target="_blank" rel="noopener"><code>innodb_redo_log_archive_dirs</code></a> variable must be configured before the redo log archiving can be activated. The default value is <code>NULL</code>, which does not permit activating redo log archiving.</p>
<p>Notes</p>
<p>The archive directories that you specify must satisfy the following requirements. (The requirements are enforced when redo log archiving is activated.):</p>
<ul>
<li><p>Directories must exist. Directories are not created by the redo log archive process. Otherwise, the following error is returned:</p>
<p>ERROR 3844 (HY000): Redo log archive directory ‘<em>directory_path1</em>‘ does not exist or is not a directory</p>
</li>
<li><p>Directories must not be world-accessible. This is to prevent the redo log data from being exposed to unauthorized users on the system. Otherwise, the following error is returned:</p>
<p>ERROR 3846 (HY000): Redo log archive directory ‘<em>directory_path1</em>‘ is accessible to all OS users</p>
</li>
<li><p>Directories cannot be those defined by <a href="https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_datadir" target="_blank" rel="noopener"><code>datadir</code></a>, <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_data_home_dir" target="_blank" rel="noopener"><code>innodb_data_home_dir</code></a>, <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_directories" target="_blank" rel="noopener"><code>innodb_directories</code></a>, <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_log_group_home_dir" target="_blank" rel="noopener"><code>innodb_log_group_home_dir</code></a>,<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_temp_tablespaces_dir" target="_blank" rel="noopener"><code>innodb_temp_tablespaces_dir</code></a>, <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_tmpdir" target="_blank" rel="noopener"><code>innodb_tmpdir</code></a> <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_undo_directory" target="_blank" rel="noopener"><code>innodb_undo_directory</code></a>, or <a href="https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_secure_file_priv" target="_blank" rel="noopener"><code>secure_file_priv</code></a>, nor can they be parent directories or subdirectories of those directories. Otherwise, an error similar to the following is returned:</p>
<p>ERROR 3845 (HY000): Redo log archive directory ‘<em>directory_path1</em>‘ is in, under, or over server directory ‘datadir’ - ‘<em>/path/to/data_directory</em>‘</p>
</li>
</ul>
<p>When a backup utility that supports redo log archiving initiates a backup, the backup utility activates redo log archiving by invoking the <code>innodb_redo_log_archive_start()</code> user-defined function.</p>
<p>If you are not using a backup utility that supports redo log archiving, redo log archiving can also be activated manually, as shown:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT innodb_redo_log_archive_start('label', 'subdir');</span><br><span class="line">+<span class="comment">------------------------------------------+</span></span><br><span class="line">| innodb_redo_log_archive_start('label') |</span><br><span class="line">+<span class="comment">------------------------------------------+</span></span><br><span class="line">| 0                                        |</span><br><span class="line">+<span class="comment">------------------------------------------+</span></span><br></pre></td></tr></table></figure>

<p>Or:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; DO innodb_redo_log_archive_start('label', 'subdir');</span><br><span class="line">Query OK, 0 rows affected (0.09 sec)</span><br></pre></td></tr></table></figure>

<p>Note</p>
<p>The MySQL session that activates redo log archiving (using <code>innodb_redo_log_archive_start()</code>) must remain open for the duration of the archiving. The same session must deactivate redo log archiving (using <code>innodb_redo_log_archive_stop()</code>). If the session is terminated before the redo log archiving is explicitly deactivated, the server deactivates redo log archiving implicitly and removes the redo log archive file.</p>
<p>where <em>label</em> is a label defined by <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_redo_log_archive_dirs" target="_blank" rel="noopener"><code>innodb_redo_log_archive_dirs</code></a>; <code>subdir</code> is an optional argument for specifying a subdirectory of the directory identified by <em>label</em> for saving the archive file; it must be a simple directory name (no slash (/), backslash (), or colon (:) is permitted). <code>subdir</code> can be empty, null, or it can be left out.</p>
<p>Only users with the <a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_innodb-redo-log-archive" target="_blank" rel="noopener"><code>INNODB_REDO_LOG_ARCHIVE</code></a> privilege can activate redo log archiving by invoking <code>innodb_redo_log_archive_start()</code>, or deactivate it using<code>innodb_redo_log_archive_stop()</code>. The MySQL user running the backup utility or the MySQL user activating and deactivating redo log archiving manually must have this privilege.</p>
<p>The redo log archive file path is <code>*directory_identified_by_label*/[*subdir*/]archive.*serverUUID*.000001.log</code>, where <code>*directory_identified_by_label*</code> is the archive directory identified by the <code>*label*</code> argument for <code>innodb_redo_log_archive_start()</code>. <code>*subdir*</code> is the optional argument used for <code>innodb_redo_log_archive_start()</code>.</p>
<p>For example, the full path and name for a redo log archive file appears similar to the following:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;directory_path&#x2F;subdirectory&#x2F;archive.e71a47dc-61f8-11e9-a3cb-080027154b4d.000001.log</span><br></pre></td></tr></table></figure>

<p>After the backup utility finishes copying <code>InnoDB</code> data files, it deactivates redo log archiving by calling the <code>innodb_redo_log_archive_stop()</code> user-defined function.</p>
<p>If you are not using a backup utility that supports redo log archiving, redo log archiving can also be deactivated manually, as shown:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT innodb_redo_log_archive_stop();</span><br><span class="line">+<span class="comment">--------------------------------+</span></span><br><span class="line">| innodb_redo_log_archive_stop() |</span><br><span class="line">+<span class="comment">--------------------------------+</span></span><br><span class="line">| 0                              |</span><br><span class="line">+<span class="comment">--------------------------------+</span></span><br></pre></td></tr></table></figure>

<p>Or:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; DO innodb_redo_log_archive_stop();</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br></pre></td></tr></table></figure>

<p>After the stop function completes successfully, the backup utility looks for the relevant section of redo log data from the archive file and copies it into the backup.</p>
<p>After the backup utility finishes copying the redo log data and no longer needs the redo log archive file, it deletes the archive file.</p>
<p>Removal of the archive file is the responsibility of the backup utility in normal situations. However, if the redo log archiving operation quits unexpectedly before<code>innodb_redo_log_archive_stop()</code> is called, the MySQL server removes the file.</p>
<h5 id="Performance-Considerations"><a href="#Performance-Considerations" class="headerlink" title="Performance Considerations"></a>Performance Considerations</h5><p>Activating redo log archiving typically has a minor performance cost due to the additional write activity.</p>
<p>On Unix and Unix-like operating systems, the performance impact is typically minor, assuming there is not a sustained high rate of updates. On Windows, the performance impact is typically a bit higher, assuming the same.</p>
<p>If there is a sustained high rate of updates and the redo log archive file is on the same storage media as the redo log files, the performance impact may be more significant due to compounded write activity.</p>
<p>If there is a sustained high rate of updates and the redo log archive file is on slower storage media than the redo log files, performance is impacted arbitrarily.</p>
<p>Writing to the redo log archive file does not impede normal transactional logging except in the case that the redo log archive file storage media operates at a much slower rate than the redo log file storage media, and there is a large backlog of persisted redo log blocks waiting to be written to the redo log archive file. In this case, the transactional logging rate is reduced to a level that can be managed by the slower storage media where the redo log archive file resides.</p>
]]></content>
  </entry>
  <entry>
    <title>read/implementionThreadInUserAndKernelSpace</title>
    <url>/2020/01/09/read/implementionThreadInUserAndKernelSpace/</url>
    <content><![CDATA[<p>之前就看过关于在内核以及用户空间实现线程的文章, 到现在还对于其中的一些点一知半解, 比如: 为什么实现在用户空间的线程比实现在内核空间的快?. 今天碰巧看到了这篇文章, 原文出自 &lt;modern operating system, fourth edition&gt;</p>
<h2 id="threads-implementation-in-kernel-and-user-space"><a href="#threads-implementation-in-kernel-and-user-space" class="headerlink" title="threads implementation in kernel and user space"></a>threads implementation in kernel and user space</h2><h3 id="2-2-4-Implementing-Threads-in-User-Space"><a href="#2-2-4-Implementing-Threads-in-User-Space" class="headerlink" title="2.2.4 Implementing Threads in User Space"></a>2.2.4 Implementing Threads in User Space</h3><p>There are two main places to implement threads: user space and the kernel.<br>The choice is a bit controversial, and a hybrid implementation is also possible. We<br>will now describe these methods, along with their advantages and disadvantages.</p>
<p>有两种主要的地方用于实现线程: 用户空间以及内核空间. 如何在哪里实现具有一定争议性, 同时, 一种混合的实现也是可能的. 我们将会概述这些方法, 以及他们的优点和缺点.</p>
<p>The first method is to put the threads package entirely in user space. The kernel knows nothing about them. As far as the kernel is concerned, it is managing<br>ordinary, single-threaded processes. The first, and most obvious, advantage is that<br>a user-level threads package can be implemented on an operating system that does<br>not support threads. All operating systems used to fall into this category, and even<br>now some still do. With this approach, threads are implemented by a library.</p>
<p>第一种方法是将整个线程包放到用户空间. 内核对此毫无所知. 就内核而言, 它依旧像对待单线程对象一样.</p>
<p>首先, 最明显的优点是, 用户级别的线程可以实现在一个不支持多线程的操作系统上.所有的操作系统曾经都是这种类型, 直到现在还有部分保留, 在这种方式下, 线程通过一个库实现.</p>
<p>All of these implementations have the same general structure, illustrated in<br>Fig. 2-16(a). The threads run on top of a run-time system, which is a collection of<br>procedures that manage threads. We have seen four of these already: pthread create, pthread exit, pthread join, and pthread yield, but usually there are more.</p>
<p>所有的实现有同样通用的结构, 如图2-16(a). 线程运行于运行时系统上(一系列管理线程的程序). 我们已经见过四种这样的程序了: 线程创建, 退出, 加入, 放弃(这是本书前面部分的内容, 但为什么是 pthread 呢? 难道是基于 posix 标准的线程实现?)</p>
<p><img src="https://imgur.com/ljUry5a.png" alt=""></p>
<p>When threads are managed in user space, each process needs its own private<br>thread table to keep track of the threads in that process. This table is analogous to<br>the kernel’s process table, except that it keeps track only of the per-thread proper-<br>ties, such as each thread’s program counter, stack pointer, registers, state, and so<br>forth. The thread table is managed by the run-time system. When a thread is<br>moved to ready state or blocked state, the information needed to restart it is stored<br>in the thread table, exactly the same way as the kernel stores information about<br>processes in the process table.</p>
<p>当线程管理于用户空间时, 每个进程需要拥有独有的线程表, 以用于持续跟踪进程中的线程. 这个表类似与内核的进程表, 不过它只跟踪每个线程的属性. 比如每个线程的程序计数器, 栈指针, 寄存器, 状态, 以及… </p>
<p>线程表由运行时系统管理, 当线程转变为就绪/阻塞状态时, 用于重启的信息就存储在线程表中, 就和内核在进程表中存储关于进程的信息一样.</p>
<p>When a thread does something that may cause it to become blocked locally, for<br>example, waiting for another thread in its process to complete some work, it calls a<br>run-time system procedure. This procedure checks to see if the thread must be put<br>into blocked state. If so, it stores the thread’s registers (i.e., its own) in the thread<br>table, looks in the table for a ready thread to run, and reloads the machine registers<br>with the new thread’s saved values. As soon as the stack pointer and program<br>counter have been switched, the new thread comes to life again automatically.</p>
<p>如果线程做了某些操作导致它本地阻塞时, 比如: 等待进程中的其他线程完成某些工作. 它调用一个运行时作业调度. </p>
<p>这个程序检查线程是否必须置于阻塞态, 如果是, 它在线程表中存储线程的寄存器(它自己的). 在表中查找一个就绪态线程运行, 重新加载新线程的寄存器. 同时栈指针和程序计数器也会切换, 新线程再次自动运行.</p>
<p> If the machine happens to have an instruction to store all the registers and another<br>one to load them all, the entire thread switch can be done in just a handful of in-<br>structions. Doing thread switching like this is at least an order of magnitude—<br>maybe more—faster than trapping to the kernel and is a strong argument in favor<br>of user-level threads packages.</p>
<p>如果机器开始有一个指令可以存储所有的寄存器, 同时另一个指令加载他们, 那么整个线程的切换就只需要少量的指令.</p>
<p>要完成这样的线程切换比捕获内核至少快一个数量级, 或许更快. 这是一个对用户级线程拥护者强有力的论点.</p>
<p>However, there is one key difference with processes. When a thread is finished<br>running for the moment, for example, when it calls thread yield, the code of<br>thread yield can save the thread’s information in the thread table itself. Fur-<br>thermore, it can then call the thread scheduler to pick another thread to run. The<br>procedure that saves the thread’s state and the scheduler are just local procedures,<br>so invoking them is much more efficient than making a kernel call. Among other<br>issues, no trap is needed, no context switch is needed, the memory cache need not<br>be flushed, and so on. This makes thread scheduling very fast.</p>
<p>然而, 有一个关于进程的关键不同. 当线程暂停时, 比如: 调用 yield, 保存线程的信息到线程表中.</p>
<p>更进步一, 调用线程调度, 选择另一个线程执行. 程序保存线程状态, 因为调度只是本地程序, 所以调用其会比内核调用更加高效. 其他方面, 没有捕获, 没有环境切换, 内存缓冲也不需要刷新, 等等. 这使得线程调度非常快.</p>
<p>User-level threads also have other advantages. They allow each process to have<br>its own customized scheduling algorithm. For some applications, for example,<br>those with a garbage-collector thread, not having to worry about a thread being<br>stopped at an inconvenient moment is a plus. They also scale better, since kernel<br>threads invariably require some table space and stack space in the kernel, which<br>can be a problem if there are a very large number of threads.</p>
<p>用户级线程还有其他优点. 它使每个进程都可以有自己的特定调度算法. 对于一些应用, 比如垃圾回收线程, 不用担心线程在不适当时候停下来, 这是一个优点. 他们拥有更好的伸缩性, 因为内核线程总是需要一些表空间和栈空间, 当线程逐渐增加时, 会造成麻烦.</p>
<p>Despite their better performance, user-level threads packages have some major<br>problems. First among these is the problem of how blocking system calls are im-<br>plemented. Suppose that a thread reads from the keyboard before any keys hav e<br>been hit. Letting the thread actually make the system call is unacceptable, since<br>this will stop all the threads. One of the main goals of having threads in the first<br>place was to allow each one to use blocking calls, but to prevent one blocked<br>thread from affecting the others. With blocking system calls, it is hard to see how<br>this goal can be achieved readily.</p>
<p>即使它们拥有更好的性能, 用户级线程包也有一些固有的问题. </p>
<p>首先, 如何实现阻塞的系统调用. 假如线程等待来自键盘的输入, 让这个线程准确执行系统调用是不允许的, 因为这会阻塞所有线程, 线程的首要目的之一是允许每个线程使用阻塞调用, 但是保证一个阻塞线程不会影响其他线程. 可以看出这很难实现.</p>
<p>The system calls could all be changed to be nonblocking (e.g., a read on the<br>keyboard would just return 0 bytes if no characters were already buffered), but re-<br>quiring changes to the operating system is unattractive. Besides, one argument for<br>user-level threads was precisely that they could run with existing operating sys-<br>tems. In addition, changing the semantics of read will require changes to many<br>user programs.</p>
<p>系统调用必须都变为非阻塞的(比如, 读取键盘输入应该在没有任何字符被缓存时返回0), 但是这对于操作系统而已不太友好. 次外(我真不知道怎么翻译这句…). 另外, 改变读取的语义将会影响到大量用户程序.</p>
<p>Another alternative is available in the event that it is possible to tell in advance<br>if a call will block. In most versions of UNIX, a system call, select , exists, which<br>allows the caller to tell whether a prospective read will block. When this call is<br>present, the library procedure read can be replaced with a new one that first does a<br>select call and then does the read call only if it is safe (i.e., will not block). If the<br>read call will block, the call is not made. Instead, another thread is run. The next<br>time the run-time system gets control, it can check again to see if the read is now<br>safe. This approach requires rewriting parts of the system call library, and is inef-<br>ficient and inelegant, but there is little choice. The code placed around the system<br>call to do the checking is called a jacket or wrapper.</p>
<p>在这种情况下还有另一个方法: 提前告知一个调用将会被阻塞是可行的(??? 啥意思啊 = =).</p>
<p>在多个 UNIX 版本中, 选择性地存在系统调用运行调用者判断未来的读操作将会阻塞. 当这样的调用存在时, 库程序读取替换成一个首先做判断, 然后当确定是安全的时候读取(比如, 非阻塞).不会执行会阻塞的读操作, 另一个线程将会运行. </p>
<p>在下次运行时系统获得控制时, 会再次检查读操作是否是安全的. 这个方法需要重写部分系统调用库. 不那么高效和优雅. 不过这是一个选择, 放置在系统函数周围的代码去检查的这种方法被称为 jacket 或 wrapper.</p>
<p>Somewhat analogous to the problem of blocking system calls is the problem of<br>page faults. We will study these in Chap. 3. For the moment, suffice it to say that<br>computers can be set up in such a way that not all of the program is in main memo-<br>ry at once. If the program calls or jumps to an instruction that is not in memory, a<br>page fault occurs and the operating system will go and get the missing instruction<br>(and its neighbors) from disk. This is called a page fault. The process is blocked<br>while the necessary instruction is being located and read in. If a thread causes a<br>page fault, the kernel, unaware of even the existence of threads, naturally blocks<br>the entire process until the disk I/O is complete, even though other threads might<br>be runnable.01</p>
<p>(简单来说, 这段说的是页错误, 主存和磁盘间虚拟空间内容的交换.)</p>
<p>Another problem with user-level thread packages is that if a thread starts run-<br>ning, no other thread in that process will ever run unless the first thread voluntarily<br>gives up the CPU. Within a single process, there are no clock interrupts, making it<br>impossible to schedule processes round-robin fashion (taking turns). Unless a<br>thread enters the run-time system of its own free will, the scheduler will never get a<br>chance.</p>
<p>用户级线程将面临的另一个问题是: 当线程开始执行时, 除非自愿放弃, 不然其他线程无法执行. </p>
<p>单线程程序, 不会产生时钟终端, 使用 round-robin 调度器管理进程是不可能的. 除非线程自愿进入运行时系统. 否则调度器将不会生效.</p>
<p>One possible solution to the problem of threads running forever is to have the<br>run-time system request a clock signal (interrupt) once a second to give it control,<br>but this, too, is crude and messy to program. Periodic clock interrupts at a higher<br>frequency are not always possible, and even if they are, the total overhead may be<br>substantial. Furthermore, a thread might also need a clock interrupt, interfering<br>with the run-time system’s use of the clock.</p>
<p>一个可能的方法是: 让运行时系统每秒请求一个时钟信号来控制它(总而言之这是一个馊主意).</p>
<p>Another, and really the most devastating, argument against user-level threads is<br>that programmers generally want threads precisely in applications where the<br>threads block often, as, for example, in a multithreaded Web server. These threads<br>are constantly making system calls. Once a trap has occurred to the kernel to carry<br>out the system call, it is hardly any more work for the kernel to switch threads if<br>the old one has blocked, and having the kernel do this eliminates the need for con-<br>stantly making select system calls that check to see if read system calls are safe.<br>For applications that are essentially entirely CPU bound and rarely block, what is<br>the point of having threads at all? No one would seriously propose computing the<br>first n prime numbers or playing chess using threads because there is nothing to be<br>gained by doing it that way.</p>
<p>另一个反对用户级线程的论证(也是最具破坏性的)是, 程序员通常希望线程在线程经常阻塞的应用中使用, 比如, 在一个多线程 web 服务器中. 线程不间断地使用系统调用, 一旦内核执行系统调用, 如果旧线程已被阻塞, 那么切换线程就几乎没有其他需要做的了. …(后面我翻不下去了, 大概意思是, 这样的话, 程序就没有必要使用多线程了)</p>
<p>(总结归纳一下: 大概意思是, 用户级线程最大的优点是在于其切换起来很快, 但是我们通常希望在频繁发生线程阻塞的应用中使用线程, 而在这种情况下, 线程切换所需的操作就会变少(如果旧线程已经被阻塞了的话), 那么 用户级线程存在的意义就不大了)</p>
<h3 id="2-2-5-Implementing-Threads-in-the-Kernel"><a href="#2-2-5-Implementing-Threads-in-the-Kernel" class="headerlink" title="2.2.5 Implementing Threads in the Kernel"></a>2.2.5 Implementing Threads in the Kernel</h3><p>Now let us consider having the kernel know about and manage the threads. No<br>run-time system is needed in each, as shown in Fig. 2-16(b). Also, there is no<br>thread table in each process. Instead, the kernel has a thread table that keeps track<br>of all the threads in the system. When a thread wants to create a new thread or<br>destroy an existing thread, it makes a kernel call, which then does the creation or<br>destruction by updating the kernel thread table.</p>
<p>现在, 让我们考虑让内核知道如何管理线程. 如图 2-16(b) 所示, 在进程中没有运行时系统, 也没有线程表. 内核有张线程表, 用于跟踪系统中的所有线程. 当线程想要创建或删除一个线程时, 使用一个内核调用, 然后通过更新内核线程表来创建或删除.</p>
<p>The kernel’s thread table holds each thread’s registers, state, and other infor-<br>mation. The information is the same as with user-level threads, but now kept in the<br>kernel instead of in user space (inside the run-time system). This information is a<br>subset of the information that traditional kernels maintain about their single-<br>threaded processes, that is, the process state. In addition, the kernel also maintains<br>the traditional process table to keep track of processes.</p>
<p>内核的线程表保存每个线程的寄存器, 状态, 以及其他信息. 与用户级线程保存的信息一致, 只是保存在内核中. </p>
<p>这些信息是传统内核管理的单线程进程信息的子集. 内核也同样管理传统的进程表, 以用于跟踪进程.</p>
<p>All calls that might block a thread are implemented as system calls, at consid-<br>erably greater cost than a call to a run-time system procedure. When a thread<br>blocks, the kernel, at its option, can run either another thread from the same proc-<br>ess (if one is ready) or a thread from a different process. With user-level threads,<br>the run-time system keeps running threads from its own process until the kernel<br>takes the CPU away from it (or there are no ready threads left to run).</p>
<p>所有可能阻塞线程的调用都被实现为系统调用, 相对运行时系统的调用, 明显有很大的额外消耗. 当线程阻塞时, 内核可以选择同进程下的线程运行, 也可以运行另一个进程的线程. 但用户级线程只会运行本进程的线程, 直到内核不让其使用 CPU 资源.</p>
<p>Due to the relatively greater cost of creating and destroying threads in the ker-<br>nel, some systems take an environmentally correct approach and recycle their<br>threads. When a thread is destroyed, it is marked as not runnable, but its kernel<br>data structures are not otherwise affected. Later, when a new thread must be creat-<br>ed, an old thread is reactivated, saving some overhead. Thread recycling is also<br>possible for user-level threads, but since the thread-management overhead is much<br>smaller, there is less incentive to do this.</p>
<p>因为在内核中创建和销毁线程操作相对更费力, 一些系统使用与环境相关的方法, 重利用它们的线程. </p>
<p>当线程销毁时, 将其标记为不可运行, 但是其内核数据结构不受影响, 随后, 当新线程需要创建时, 重新利用这些资源.  用户级线程也可以使用这个方法, 不过因为线程管理的消耗较小, 并不是很有必要这么做</p>
<p>Kernel threads do not require any new, nonblocking system calls. In addition,<br>if one thread in a process causes a page fault, the kernel can easily check to see if<br>the process has any other runnable threads, and if so, run one of them while wait-<br>ing for the required page to be brought in from the disk. Their main disadvantage is<br>that the cost of a system call is substantial, so if thread operations (creation, termi-<br>nation, etc.) a common, much more overhead will be incurred.</p>
<p>内核线程不需要任何新的, 非阻塞系统调用. 另外, 如果线程导致了页错误, 内核可以轻松地检查进程是否有其他线程可运行, 如果有, 在等待所需的页加载入内存中时, 执行该线程. 它们潜在的问题是: 系统调用比较耗时, 所以如果线程操作比较常见, 则会有更多的负载.</p>
<p>While kernel threads solve some problems, they do not solve all problems. For<br>example, what happens when a multithreaded process forks? Does the new proc-<br>ess have as many threads as the old one did, or does it have just one? In many<br>cases, the best choice depends on what the process is planning to do next. If it is<br>going to call exec to start a new program, probably one thread is the correct choice,<br>but if it continues to execute, reproducing all the threads is probably best.</p>
<p>内核线程依旧有一些未能解决的问题, 比如, 当多线程进程执行 fork 的时候, 会发生什么? 新的进程是否会像旧进程一样拥有同样多的线程呢? 还是只拥有一个呢? 在大多数情况下, 取决于进程将要做什么, 如果它将会调用 exec 执行一个新的程序, 当然只有一个好, 但是如果是继续运行的话, 则保留所有的线程则是最好的.</p>
<p>(PS: 在 linux posix 线程下, 默认是同样多的线程)</p>
<p>Another issue is signals. Remember that signals are sent to processes, not to<br>threads, at least in the classical model. When a signal comes in, which thread<br>should handle it? Possibly threads could register their interest in certain signals, so<br>when a signal came in it would be given to the thread that said it wants it. But what<br>happens if two or more threads register for the same signal? These are only two of<br>the problems threads introduce, and there are more.</p>
<p>另一个问题是信号. 信号是发给进程的, 而并非线程(至少在经典模型下). 当信号到达时, 那个线程来处理它呢? 可能线程会注册自己感兴趣的信号, 所以, 当信号到达, 会交由那个注册线程处理. 但是如果多个线程注册了同样的信号呢? 这仅仅是线程引入的其中两个问题.</p>
<h3 id="2-2-6-Hybrid-Implementations"><a href="#2-2-6-Hybrid-Implementations" class="headerlink" title="2.2.6 Hybrid Implementations"></a>2.2.6 Hybrid Implementations</h3><p>Various ways have been investigated to try to combine the advantages of user-<br>level threads with kernel-level threads. One way is use kernel-level threads and<br>then multiplex user-level threads onto some or all of them, as shown in Fig. 2-17.<br>When this approach is used, the programmer can determine how many kernel<br>threads to use and how many user-level threads to multiplex on each one. This<br>model gives the ultimate in flexibility.</p>
<p>已经有多种方法被研究出来, 用于融合用户级线程和内核级线程. 其中一种方法是使用内核级别线程, 然后每个内核线程使用多个用户级别线程. 如 2-17. </p>
<p>程序能够知晓多少内核线程, 多少用户线程被使用. 这种模型给予了很大的灵活性.</p>
<p><img src="https://imgur.com/Bcc4Uzh.png" alt=""></p>
<p>With this approach, the kernel is aware of only the kernel-level threads and<br>schedules those. Some of those threads may have multiple user-level threads multi-<br>plexed on top of them. These user-level threads are created, destroyed, and sched-<br>uled just like user-level threads in a process that runs on an operating system with-<br>out multithreading capability. In this model, each kernel-level thread has some set<br>of user-level threads that take turns using it.</p>
<p>在这种方法下, 内核只至少内核线程, 并调度它们. 其中一些内核线程上可能存在多个用户级线程. 这些用户线程将会在进程中管控. </p>
<p>内核线程和用户线程各有其优势, 用户线程效率更高, 但是操作系统不知情的情况下, 会产生许多逻辑上是多线程, 但物理上依旧是单线程才会产生的错误. 比如 信号, 中断. 而内核线程虽然相对效率低, 并且占用内核空间, 但是操作系统知晓是多线程, 与操作系统间有更多协作的空间.</p>
]]></content>
  </entry>
  <entry>
    <title>read/fsync</title>
    <url>/2020/01/09/read/fsync/</url>
    <content><![CDATA[<p>看 MySQL 官方文档, 有关 InnoDB 数据管理的时候, 看到有提到 fsync </p>
<p>仔细查了一下, 才发现自己好像对这东西, 乃至文件系统都一无所知…  </p>
<p>原地址 : <a href="http://blog.httrack.com/blog/2013/11/15/everything-you-always-wanted-to-know-about-fsync/" target="_blank" rel="noopener">http://blog.httrack.com/blog/2013/11/15/everything-you-always-wanted-to-know-about-fsync/</a></p>
<h1 id="Everything-You-Always-Wanted-to-Know-About-Fsync"><a href="#Everything-You-Always-Wanted-to-Know-About-Fsync" class="headerlink" title="Everything You Always Wanted to Know About Fsync()"></a>Everything You Always Wanted to Know About Fsync()</h1><p>NOV 15TH, 2013</p>
<p>And then the developer wondered:</p>
<blockquote>
<p>is my file properly sync’ed on disk ?</p>
</blockquote>
<p>You probably know <em>more or less</em> how databases (or things that look like one) store their data on disk in a <em>permanent</em> and <em>safe</em> way. Or at least, you know the basic principles. Or not ?</p>
<p>你可能或多或少知道数据库如何以持久并安全的方式将数据存储到磁盘</p>
<p>最少, 你知道基础的原则, 或者不知道?</p>
<h3 id="Being-on-AC-I-D"><a href="#Being-on-AC-I-D" class="headerlink" title="Being on AC(I)D"></a>Being on <strong>AC</strong>(I)<strong>D</strong></h3><p>There are a bunch of concepts that first must be understood: what is <strong>atomicity</strong>, <strong>consistency</strong>, and <strong>durability</strong> ? These concepts apply on databases (see <a href="http://en.wikipedia.org/wiki/ACID" target="_blank" rel="noopener">ACID</a>), but also on the underlying filesystem.</p>
<p>这里有一系列必须理解的原则: 什么是 原子性, 一致性, 持久性? </p>
<p>这些原则不仅用于数据库, 同时也用于底层文件系统</p>
<ul>
<li><p><strong>Atomicity</strong>: a write operation is fully executed at once, and is not <em>interleaved</em> with another one (if, for example, someone else is writing to the same location)</p>
<p>原子性 : 写操作一次彻底完成, 不会和另外一个写操作交错(其他写操作在同时更改同样的区域)</p>
<p>Atomicity is typically guaranteed in operations involving filename handling ; for example, for <a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/rename.html" target="_blank" rel="noopener">rename</a>, “<em>specification requires that the action of the function be atomic</em>” – that is, when renaming a file from the old name to the new one, at no circumstances should you ever see the two files at the same time.</p>
<p>涉及到文件名管理的操作通常是保存其原子性的, 比如, 重命名, 规则描述需要这个函数必须是原子的. </p>
<p>也就是说, 当重命名文件时, 不应该同时存在两个相同文件名的文件</p>
</li>
<li><p><strong>Consistency</strong>: integrity of data must be maintained when executing an operation, even in a crash event – for example, a power outage in the middle of a <code>rename()</code> operation shall not leave the filesystem in a “weird” state, with the filename being unreachable because its metadata has been corrupted. (ie. either the operation is lost, or the operation is committed.)</p>
<p>一致性 : 当执行操作时, 数据的一致性必须被维护, 即使是在崩溃事件中, 比如 : 断电不会使文件系统处于因其元数据损坏, 文件名不可被检索到的奇怪状态(即, 操作要么丢失, 要么被提交)</p>
<p>(PS. meta ? 什么是 meta ? 根据 wiki 的解释 : </p>
<p>​    <strong>Meta</strong> (from the <a href="https://en.wikipedia.org/wiki/Greek_language" target="_blank" rel="noopener">Greek</a> <em>meta-</em> μετά- meaning “after” or “beyond”) is a prefix used in <a href="https://en.wikipedia.org/wiki/English_language" target="_blank" rel="noopener">English</a> to indicate a concept that is an <a href="https://en.wikipedia.org/wiki/Abstraction" target="_blank" rel="noopener">abstraction</a> behind another concept, used to complete or add to the latter.</p>
<p>​    元是一个概念背后的抽象概念, 用来完整前者 </p>
<p>以及有 about 语义, 两者相同, 前者关联后者, metaprogramming(writing programs manipulate programs) )</p>
<p>Consistency is guaranteed on the filesystem level ; but you also need to have the same guarantee if you build a database on disk, for example by serializing/locking certain operations on a working area, and committing the transaction by changing some kind of generation number.</p>
<p>一致性在文件系统层面上确保, 但当在磁盘上构建数据库时, 也需要其确保一致性, 比如通过序列化/锁定某些在工作区域上的操作, 通过更改一些生成的数字提交事务</p>
</li>
<li><p><strong>Durability</strong>: the write operation is durable, that is, unplugging the power cord (or a kernel panic, a crash…) shall not lose any data (hitting the hard disk with a hammer is however not covered!)</p>
<p>​    写操作是耐久的, 也就是说, 拔掉电源线(或者内核错误, 崩溃)将不会丢失任何数据(用锤子砸硬盘当然不包含在其中!)( PS.挺喜欢有幽默感的作者 :) )</p>
<p>This is an important one – at a given point, you must ensure that the data is actually written on disk <em>physically</em>, preventing any loss of data in case of a sudden power outage, for example. This is absolutely critical when dealing with a client/server architecture: the client may have its connection or transaction aborted at any time without troubles (ie. the transaction will be retried later), but once the server acknowledges it, no event should ever cause it to be lost (think of responsibility in a commercial transaction, or a digital signature, for example). For this reason, having the data committed in the internal system or hard disk cache is NOT durable for obvious reasons (unless there is a guarantee that no such power outage could happen – if a battery is used on a RAID array, for example).</p>
<p>在某种观点来看, 这是很重要的一点. 你必须确保数据正确地物理性地写入了磁盘, 防止断电而引发的数据丢失</p>
<p>应用与CS模型时, 相当关键: 客户端会在任意时刻无困难断开连接/事务(换句话说, 事务会在之后重试). 但是一旦服务器确认后, 就应该没有任何事件导致它被丢失(考虑企业事务或数字签名中的责任)</p>
<p>因为这个理由, 在内部系统或硬盘缓存中提交数据是不是可一致的(除非保证没有类似断电的行为会发生 - 比如, RDID 磁盘阵列用了蓄电池)</p>
<p>On POSIX systems, durability is achieved through sync operations (<a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/fsync.html" target="_blank" rel="noopener"><code>fsync()</code></a>, <a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/fdatasync.html" target="_blank" rel="noopener"><code>fdatasync()</code></a>, <a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/aio_fsync.html" target="_blank" rel="noopener"><code>aio_fsync()</code></a>): “<em>The fsync() function is intended to force a physical write of data from the buffer cache, and to assure that after a system crash or other failure that all data up to the time of the fsync() call is recorded on the disk.</em>”. [Note: The difference between fsync() and fdatasync() is that the later does not necessarily update the meta-data associated with a file – such as the “last modified” date – but only the file data.]</p>
<p>在 POSIX 系统, 持久性通过 sync 操作(fsync, fdatasync, aio_fsync) 获得 (PS. fsync 和 fdatasync 的区别在于, 后者不冲刷 metadata) fsync 函数故意强制物理性的缓冲的数据写入, 保证在系统崩溃或其他错误之后, 所有 fsync 调用时的数据都被记录在磁盘中</p>
</li>
</ul>
<p>Now that these concepts are a bit clearer, let’s go back to our filesystem!</p>
<h3 id="Hey-What-is-a-File-By-The-Way"><a href="#Hey-What-is-a-File-By-The-Way" class="headerlink" title="Hey, What is a File, By The Way ?"></a>Hey, What is a File, By The Way ?</h3><p>If we want to simplify the concept, let’s consider the filesystem on POSIX platforms as a very simple <em>flat</em> storage manager, allowing to read/write data blobs and basic properties (such as the modified time) indexed by an <em>integer</em> number (hint: they sometimes call that the <em>inode number</em>).</p>
<p>如果想要简化这个概念, 让我们考虑在 POSIX 平台上, 文件系统作为一个非常简单的扁平存储管理器, 允许读/写二进制数据和其基础属性(比如更改时间) 被一个整型数字索引 (有时被称作 inode 数字)</p>
<p>For example, you may want to read the file #4242’s data. And later, write some data on file #1234.</p>
<p>To have a more convenient way to handle files (because “I need to send you the presentation number 155324” would not be really convenient in the real world), we use the <strong>filename/directory</strong> concepts. A file has a name, and it is <em>contained</em> within a <em>directory structure</em>. You may put files and directories in a directory, building a hierarchical structure. But everything rely on our previous basic data blobs to store both filename and the associated index.</p>
<p>为了更方便地操作文件(因为 “我需要发送你描述编号为155324” 在真实世界中很不方便) 我们使用 文件名/目录 概念. </p>
<p>文件有一个名字, 被包含一个目录结构中, 你可以将文件和目录放到另外一个目录下,  构建一个层次的结构</p>
<p>但是, 所有都依赖于之前的基础数据集合存储文件名和相关联的索引</p>
<p>As an example, reading the file <code>foo/bar.txt</code> (ie. the file <code>bar.txt</code> within the <code>foo</code> directory) will require to access the data blob associated with the directory <code>foo</code>. After parsing this opaque data blob, the system will fetch the entry for <code>bar.txt</code>, and open the associated data blob. (And yes, there is obviously a root entry, storing references to first-level entries, allowing to access any file top-down)</p>
<p>If I now want to create a new file named <code>foo/baz.txt</code>, it will require the system to access the data blob associated with the directory <code>foo</code>, add an entry named <code>baz.txt</code> with a new allocated index for the upcoming file, and write the updated directory blob back, and from this point, write to the newly allocated blob. The operation therefore involves <strong>two</strong> data structures: the <strong>directory entry</strong>, and the <strong>file</strong> itself.</p>
<h3 id="Keeping-My-File-name-Safe"><a href="#Keeping-My-File-name-Safe" class="headerlink" title="Keeping My File(name) Safe"></a>Keeping My File(name) Safe</h3><p>Let’s go back to our database problem: what is the impact of having <em>two</em> data structures for our files ?</p>
<p><strong>Atomicity</strong> and <strong>consistency</strong> of filenames are handled for us by the filesystem, so this is not really a bother.</p>
<p>What about <strong>durability</strong> ?</p>
<p>让我们回到数据库的问题(PS. 我觉得, 好像越说越多了 = =) : 如果我们的文件有两个数据结构的话, 会怎样? </p>
<p>文件名原子性和一致性由我们通过文件系统控制, 这不会造成什么麻烦, 但是持久性呢?</p>
<p>We know that <code>fsync()</code> provides guarantees related to data and meta-data sync’ing. But if you look closer to the specification, the only data involved are the one related to the file itself – not its directory entry. The “metadata” concept involves modified time, access time etc. – <strong>not</strong> the <em>directory entry</em> itself.</p>
<p>我们知道 fsync 提供相关文件和元数据的同步保证</p>
<p>但是深入了解规格, 唯一涉及的数据是和文件本身相关的数据, 不是它的目录入口</p>
<p>元数据概念包含更改时间, 访问时间等等, 但不包含目录入口</p>
<p>It would be cumbersome for a filesystem to provide this guarantee, by the way: on POSIX systems, you can have an arbitrary number of directory links to a filename (or to another directory entry). The most common case is <em>one</em>, of course. But you may delete a file being used (the file entry will be removed by the system when the file is closed) – the very reason why erasing a log file which is flooding a filesystem is a futile and deadly action – in such case, the number of links will be <em>zero</em>. And you may also create as many <a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/link.html" target="_blank" rel="noopener">hard-links</a> as you want for a given file/directory entry.</p>
<p>Therefore, in theory, you may create a file, write some data, synchronize it, close the file, and see your <a href="http://upload.wikimedia.org/wikipedia/en/e/e0/Gollum.PNG" target="_blank" rel="noopener">precious</a> file lost forever because of a power outage. Oh, the filesystem must guarantee consistency, of course, but not durability unless <em>explicitly</em> asked by the client – which means that a filesystem check <em>may</em> find your directory entry partially written, and decide to achieve consistency by taking the previous directory blob entry, <strong>wiping</strong> the unreferenced file entry (note: if you are “lucky” enough, the file will be expelled in <code>lost+found</code>)</p>
<p>The filesystem can, of course, decide to be gentle, and commit all filename operations when fsync’ing. It may also, such as for ext3, commit <a href="https://ext4.wiki.kernel.org/index.php/Ext3_Data%3DOrdered_vs_Data%3DWriteback_mode" target="_blank" rel="noopener"><strong>everything</strong></a> when fsync’ing a file – causing the <a href="http://lwn.net/Articles/328363/" target="_blank" rel="noopener">infamous</a> and <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=421482" target="_blank" rel="noopener">horrendous</a> lags in firefox or thunderbird.</p>
<p>But if you need to have <strong>guarantees</strong>, and not just <em>hope</em> the filesystem “<em>will be gentle<em>”, and do not want to “</em>trust the filesystem*” (yes, someone actually told me that: you *need</em> to “trust the filesystem” – I swear it), you have to actually make sure that your <strong>filename</strong> entry is properly sync’ed on disk following the POSIX specification.</p>
<p>Oh, and by the way: according to <a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/fsync.html" target="_blank" rel="noopener">POSIX</a>, <em>The fsync() function is intended to force a physical write of data from the buffer cache, and to assure that after a system crash or other failure that all data up to the time of the fsync() call is recorded on the disk</em>.</p>
<p><em>But</em> things are sometimes a bit obscure on the implementation side :</p>
<ul>
<li><p><a href="http://unixhelp.ed.ac.uk/CGI/man-cgi?fsync" target="_blank" rel="noopener"><strong>Linux/ext3</strong></a>: <em>If the underlying hard disk has write caching enabled, then the data may not really be on permanent storage when fsync() / fdatasync() return.</em> (do’h!)</p>
<p>如果底层磁盘允许写入缓存, 当 fsync/fdatasync 时数据可能不会真正的永久性存储</p>
</li>
<li><p><a href="http://linux.die.net/man/2/fsync" target="_blank" rel="noopener"><strong>Linux/ext4</strong></a>: <em>The fsync() implementations in older kernels and lesser used filesystems does not know how to flush disk caches.</em> (do’h!) – issue adressed quite <a href="http://lwn.net/Articles/270891/" target="_blank" rel="noopener">recently</a></p>
</li>
<li><p><a href="https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man2/fsync.2.html" target="_blank" rel="noopener"><strong>OSX</strong></a>: <em>For applications that require tighter guarantees about the integrity of their data, Mac OS X provides the F_FULLFSYNC fcntl. The F_FULLFSYNC fcntl asks the drive to flush all buffered data to permanent storage</em> (hey, fsync was supposed to do that, no ? guys ?) <em>(Edit: no, fsync is actually not required to do that – thanks for the clarification Florent!)</em></p>
</li>
</ul>
<p>But we may assume that on Linux with <a href="http://monolight.cc/2011/06/barriers-caches-filesystems/" target="_blank" rel="noopener">ext4</a> (and OSX with proper flags ?) the system is properly propagating <a href="http://docs.fedoraproject.org/en-US/Fedora/14/html/Storage_Administration_Guide/writebarr.html" target="_blank" rel="noopener">write barriers</a>.</p>
<p>On Windows, using <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/aa364439.aspx" target="_blank" rel="noopener"><code>FlushFileBuffers()</code></a> is probably the way to go.</p>
<p>(PS. 很惭愧, 有些我没有读懂… 不过有一件事情是明白的 : 我好像对文件系统真的一无所知… )</p>
<h3 id="Syncing-Filenames"><a href="#Syncing-Filenames" class="headerlink" title="Syncing Filenames"></a>Syncing Filenames</h3><p>I told you that a filesystem was actually a bunch of <em>flat</em> data blobs with associated metadata, and that a file had actually two parts: its directory entry (let’s assume there is only one directory entry for the sake of simplicity), and its actual data. We already know how to sync the later one ; do we have a way to do the same for the directory container itself ?</p>
<p>我已经告诉你, 文件系统实际上是一堆扁平的与元数据关联的数据块, 文件实际上有两部分 : 它的目录入口(为了简单起见, 假设只有一个目录入口), 以及它的实际数据, 我们已经知道如何同步后面的一部分, 我们有同样的刚发同步目录容器自身么?</p>
<p>On POSIX, you may actually open a directory as if you were opening a file (hint: a directory is <a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap03.html" target="_blank" rel="noopener"><em>a file that contains directory entries</em></a>). It means that <code>open()</code> <em>may</em> successfully open a directory entry. But on the other hand, you generally can not open a directory entry for <em>writing</em> (see POSIX <a href="http://pubs.opengroup.org/onlinepubs/009695299/functions/open.html" target="_blank" rel="noopener">remark</a> regarding <code>EISDIR</code>: <em>The named file is a directory and oflag includes O_WRONLY or O_RDWR</em>), and this is perfectly logical: by directly writing to the internal directory entry, you may be able to mess up with the directory structure, ruining the filesystem <strong>consistency</strong>.</p>
<p>在 POSIX 下, 你可能正常地像打开一个文件一样打开目录(目录是一个包含目录入口的文件)(PS. MD 我要疯了, 它说的 directory entries 到底是什么东西, 直译目录入口? 什么鬼东西啊, inode?那怎么不叫 inode/vnode ? 根据 google 出的解答 <a href="https://unix.stackexchange.com/questions/186992/what-is-directory-entry" target="_blank" rel="noopener">https://unix.stackexchange.com/questions/186992/what-is-directory-entry</a> 那是一个目录和文件名相关的结构体)  </p>
<p>But can we fsync() written data using a file descriptor opened <em>only</em> for reading ? The question is… yes, or at least “<em>yes it should*” – even POSIX group had *editorial</em> inconsistencies regarding <a href="http://austingroupbugs.net/view.php?id=501" target="_blank" rel="noopener">fdatasync</a> and <a href="http://austingroupbugs.net/view.php?id=671" target="_blank" rel="noopener">aio_fsync()</a>, leading to incorrect <a href="http://cygwin.com/frysk/bugzilla/show_bug.cgi?id=15361" target="_blank" rel="noopener">behavior</a> on various implementations. And the reason it should execute the operation is because requesting the completion of a write operation does not have to require actual write access – which have already been checked and enforced.</p>
<p>On Windows… err, there is no clear answer. You can not call <code>FlushFileBuffers()</code> on a directory handle as far as I can see.</p>
<p>Oh, a last funny note: how do you sync the <strong>content</strong> of a <em>symbolic link</em> (and its related meta-data), that is, the filename pointed by this link ? The answer is… you can’t. Nope. This is not possible with the current standard (hint: you can not <code>open()</code> a symbolic link). Which means that if you handle some kind of database generation update based on symbolic links (ie. changing a “last-version” symlink to the latest built generation file), you have zero guarantee over durability.</p>
<h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>Does it means that we need to call <code>fsync()</code> <em>twice</em>, one on the file data, and one on its parent directory ? When you need to achieve <em>durability</em>, the answer is obviously <strong>yes</strong>. (Remember that file file/filename will be sync’ed on disk anyway by the operating system, so you do not actually need to do that for every single file – only for those you want to have a durability guarantee at a given time)</p>
<p>However, the question is causing some headache on the POSIX standard, and as a follow-up to the <a href="http://comments.gmane.org/gmane.comp.standards.posix.austin.general/6952" target="_blank" rel="noopener">austin-group</a> (ie. POSIX mailing-list) discussion, an <a href="http://austingroupbugs.net/view.php?id=672" target="_blank" rel="noopener">editorial clarification request</a> is still pending and is waiting for feedback from various implementors. (you may also have a look at the <a href="http://unix.derkeiler.com/Newsgroups/comp.unix.programmer/2013-03/msg00016.html" target="_blank" rel="noopener">comp.unix.programmer</a> discussion)</p>
<p><strong>TL;DR</strong>: syncing a file is not as simple as it seems!</p>
]]></content>
  </entry>
  <entry>
    <title>read/CreateInnoDBTables</title>
    <url>/2020/01/09/read/CreateInnoDBTables/</url>
    <content><![CDATA[<ul>
<li><h4 id="15-6-1-1-Creating-InnoDB-Tables"><a href="#15-6-1-1-Creating-InnoDB-Tables" class="headerlink" title="15.6.1.1 Creating InnoDB Tables"></a>15.6.1.1 Creating InnoDB Tables</h4></li>
</ul>
<p>  To create an <code>InnoDB</code> table, use the <a href="https://dev.mysql.com/doc/refman/8.0/en/create-table.html" target="_blank" rel="noopener"><code>CREATE TABLE</code></a> statement.</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1 (a <span class="built_in">INT</span>, b <span class="built_in">CHAR</span> (<span class="number">20</span>), PRIMARY <span class="keyword">KEY</span> (a)) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure>

<p>  You do not need to specify the <code>ENGINE=InnoDB</code> clause if <code>InnoDB</code> is defined as the default storage engine, which it is by default. To check the default storage engine, issue the following statement:</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT @@default_storage_engine;</span><br><span class="line">+<span class="comment">--------------------------+</span></span><br><span class="line">| @@default_storage_engine |</span><br><span class="line">+<span class="comment">--------------------------+</span></span><br><span class="line">| InnoDB                   |</span><br><span class="line">+<span class="comment">--------------------------+</span></span><br></pre></td></tr></table></figure>

<p>  You might still use <code>ENGINE=InnoDB</code> clause if you plan to use <a href="https://dev.mysql.com/doc/refman/8.0/en/mysqldump.html" target="_blank" rel="noopener"><strong>mysqldump</strong></a> or replication to replay the <a href="https://dev.mysql.com/doc/refman/8.0/en/create-table.html" target="_blank" rel="noopener"><code>CREATE TABLE</code></a> statement on a server where the default storage engine is not <code>InnoDB</code>.</p>
<p>  如果你计划使用 mysqldump/复制 将 CREATE TABLE 语句复现在另外一个默认存储引擎不是 InnoDB 的服务器上, 就坚持使用 ENGINE=InnoDB 子句 (不过我看 mysqldump 出的语句中会显式指定存储引擎类型)</p>
<p>  An <code>InnoDB</code> table and its indexes can be created in the <a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_system_tablespace" target="_blank" rel="noopener">system tablespace</a>, in a <a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_file_per_table" target="_blank" rel="noopener">file-per-table</a> tablespace, or in a <a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_general_tablespace" target="_blank" rel="noopener">general tablespace</a>. When <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_file_per_table" target="_blank" rel="noopener"><code>innodb_file_per_table</code></a> is enabled, which is the default, an <code>InnoDB</code> table is implicitly created in an individual file-per-table tablespace. Conversely, when <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_file_per_table" target="_blank" rel="noopener"><code>innodb_file_per_table</code></a> is disabled, an <code>InnoDB</code> table is implicitly created in the <code>InnoDB</code> system tablespace. To create a table in a general tablespace, use <a href="https://dev.mysql.com/doc/refman/8.0/en/create-table.html" target="_blank" rel="noopener"><code>CREATE TABLE ... TABLESPACE</code></a> syntax. For more information, see <a href="https://dev.mysql.com/doc/refman/8.0/en/general-tablespaces.html" target="_blank" rel="noopener">Section 15.6.3.3, “General Tablespaces”</a>.</p>
<p>  InnoDB 表及它的索引可以创建在 system tablespace, file-per-table tablespace  或 general tablespace. 当 innodb_file_per_table 启用, InnoDB 表默认创建在单独的 file-per-rable 表空间中, 相反, 则创建在 system tablespace 中. </p>
<p>  使用 CREATE TABLE … TABLESPACE 语法可以创建在 general tablespace 中</p>
<p>  When you create a table in a file-per-table tablespace, MySQL creates an <a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_ibd_file" target="_blank" rel="noopener">.ibd</a> tablespace file in a database directory under the MySQL data directory, by default. A table created in the <code>InnoDB</code> system tablespace is created in an existing <a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_ibd_file" target="_blank" rel="noopener">ibdata file</a>, which resides in the MySQL data directory. A table created in a general tablespace is created in an existing general tablespace <a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_ibd_file" target="_blank" rel="noopener">.ibd file</a>. General tablespace files can be created inside or outside of the MySQL data directory. For more information, see <a href="https://dev.mysql.com/doc/refman/8.0/en/general-tablespaces.html" target="_blank" rel="noopener">Section 15.6.3.3, “General Tablespaces”</a>.</p>
<p>  当你创建一个在 file-per-table 表空间中的表时, MySQL 在主目录下的单个数据库目录中创建 .idb 文件  </p>
<p>  在 InnoDB system 表空间中则创建在一个在 MySQL 主目录下已存在的 ibdata 文件中(PS. 那么 ibdata 文件是什么时候创建的? 如何增长?) </p>
<p>  Internally, <code>InnoDB</code> adds an entry for each table to the data dictionary. The entry includes the database name. For example, if table <code>t1</code> is created in the <code>test</code> database, the data dictionary entry for the database name is <code>&#39;test/t1&#39;</code>. This means you can create a table of the same name (<code>t1</code>) in a different database, and the table names do not collide inside <code>InnoDB</code>.</p>
<h5 id="InnoDB-Tables-and-Row-Formats"><a href="#InnoDB-Tables-and-Row-Formats" class="headerlink" title="InnoDB Tables and Row Formats"></a>InnoDB Tables and Row Formats</h5><p>  The default row format for <code>InnoDB</code> tables is defined by the <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_default_row_format" target="_blank" rel="noopener"><code>innodb_default_row_format</code></a> configuration option, which has a default value of <code>DYNAMIC</code>. <code>Dynamic</code> and<code>Compressed</code> row format allow you to take advantage of <code>InnoDB</code> features such as table compression and efficient off-page storage of long column values. To use these row formats, <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_file_per_table" target="_blank" rel="noopener"><code>innodb_file_per_table</code></a> must be enabled (the default).</p>
<p>  InnoDB 表的行格式化由 innodb_default_row_format 定义, 默认是 DYNAMIC </p>
<p>  Dynamic 和 Compressed 行格式化提供了 InnoDB 高级特性, 比如 压缩表, 高效的长列值页外存储</p>
<p>  使用这些行格式化, 必须启用 innodb_file_per_table</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> innodb_file_per_table=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t3 (a <span class="built_in">INT</span>, b <span class="built_in">CHAR</span> (<span class="number">20</span>), PRIMARY <span class="keyword">KEY</span> (a)) ROW_FORMAT=DYNAMIC;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t4 (a <span class="built_in">INT</span>, b <span class="built_in">CHAR</span> (<span class="number">20</span>), PRIMARY <span class="keyword">KEY</span> (a)) ROW_FORMAT=COMPRESSED;</span><br></pre></td></tr></table></figure>

<p>  Alternatively, you can use <a href="https://dev.mysql.com/doc/refman/8.0/en/create-table.html" target="_blank" rel="noopener"><code>CREATE TABLE ... TABLESPACE</code></a> syntax to create an <code>InnoDB</code> table in a general tablespace. General tablespaces support all row formats. For more information, see <a href="https://dev.mysql.com/doc/refman/8.0/en/general-tablespaces.html" target="_blank" rel="noopener">Section 15.6.3.3, “General Tablespaces”</a>.</p>
<p>  另外, 你可以使用 CREATE TABLE … TABLESAPCE 语法在 general tablespace 创建 InnoDB 表. general tablespace 支持所有的行格式化</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1 (c1 <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span>) <span class="keyword">TABLESPACE</span> ts1 ROW_FORMAT=DYNAMIC;</span><br></pre></td></tr></table></figure>

<p>  <a href="https://dev.mysql.com/doc/refman/8.0/en/create-table.html" target="_blank" rel="noopener"><code>CREATE TABLE ... TABLESPACE</code></a> syntax can also be used to create <code>InnoDB</code> tables with a <code>Dynamic</code> row format in the system tablespace, alongside tables with a <code>Compact</code> or<code>Redundant</code> row format.</p>
<p>  CREATE TABLE … TABLESPACE 语法也可以被用作在 system tablespace 中创建 Dynamic 格式化的表, 以及 Compacr 或 Redundant 格式化</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1 (c1 <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span>) <span class="keyword">TABLESPACE</span> = innodb_system ROW_FORMAT=DYNAMIC;</span><br></pre></td></tr></table></figure>

<p>  For more information about <code>InnoDB</code> row formats, see <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-row-format.html" target="_blank" rel="noopener">Section 15.10, “InnoDB Row Formats”</a>. For how to determine the row format of an <code>InnoDB</code> table and the physical characteristics of <code>InnoDB</code> row formats, see <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-row-format.html" target="_blank" rel="noopener">Section 15.10, “InnoDB Row Formats”</a>.</p>
<h5 id="InnoDB-Tables-and-Primary-Keys"><a href="#InnoDB-Tables-and-Primary-Keys" class="headerlink" title="InnoDB Tables and Primary Keys"></a>InnoDB Tables and Primary Keys</h5><p>  Always define a <a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_primary_key" target="_blank" rel="noopener">primary key</a> for an <code>InnoDB</code> table, specifying the column or columns that:</p>
<ul>
<li><p>Are referenced by the most important queries.</p>
</li>
<li><p>Are never left blank.</p>
</li>
<li><p>Never have duplicate values.</p>
</li>
<li><p>Rarely if ever change value once inserted.</p>
<p>通常会为 InnoDB 表定义一个主键, 说明列具有: 被最重要的查询引用, 永远不为空, 永远不重复, 一旦插入, 则很少改动</p>
<p>For example, in a table containing information about people, you would not create a primary key on <code>(firstname, lastname)</code> because more than one person can have the same name, some people have blank last names, and sometimes people change their names. With so many constraints, often there is not an obvious set of columns to use as a primary key, so you create a new column with a numeric ID to serve as all or part of the primary key. You can declare an <a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_auto_increment" target="_blank" rel="noopener">auto-increment</a> column so that ascending values are filled in automatically as rows are inserted:</p>
<p>比如, 在一个包含民众信息的表中, 不能创建以 (firstname, lastname) 组合的值为主键, 因为名字很可能重复, 一些人没有 lastname, 一些人会改变他们的名字. </p>
<p>涉及到这么多的限制, 进程没有一个明显列的集合能作为主键. 所以可以创建一个新的数字列用作整个或部分主键, 声明为 auto-increament  可以使行在插入时自增</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># The value of ID can act like a pointer between related items in different tables.</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t5 (<span class="keyword">id</span> <span class="built_in">INT</span> AUTO_INCREMENT, b <span class="built_in">CHAR</span> (<span class="number">20</span>), PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment"># The primary key can consist of more than one column. Any autoinc column must come first.</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t6 (<span class="keyword">id</span> <span class="built_in">INT</span> AUTO_INCREMENT, a <span class="built_in">INT</span>, b <span class="built_in">CHAR</span> (<span class="number">20</span>), PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>,a));</span><br></pre></td></tr></table></figure>

<p>Although the table works correctly without defining a primary key, the primary key is involved with many aspects of performance and is a crucial design aspect for any large or frequently used table. It is recommended that you always specify a primary key in the <a href="https://dev.mysql.com/doc/refman/8.0/en/create-table.html" target="_blank" rel="noopener"><code>CREATE TABLE</code></a> statement. If you create the table, load data, and then run <a href="https://dev.mysql.com/doc/refman/8.0/en/alter-table.html" target="_blank" rel="noopener"><code>ALTER TABLE</code></a> to add a primary key later, that operation is much slower than defining the primary key when creating the table.</p>
<p>尽管没有定义主键 表也可以正常运行, 但是主键包含了许多性能方面和重要的为大容量或频繁使用表做的设计, 建议你总是在表中指定一个主键. </p>
<p>在创建和加载表之后使用 ALTER TABLE 语句增加主键, 速度会远慢于一开始创建时指定主键</p>
</li>
</ul>
<h5 id="Viewing-InnoDB-Table-Properties"><a href="#Viewing-InnoDB-Table-Properties" class="headerlink" title="Viewing InnoDB Table Properties"></a>Viewing InnoDB Table Properties</h5><p>  To view the properties of an <code>InnoDB</code> table, issue a <a href="https://dev.mysql.com/doc/refman/8.0/en/show-table-status.html" target="_blank" rel="noopener"><code>SHOW TABLE STATUS</code></a> statement:</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW TABLE STATUS FROM test LIKE 't%' \G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           Name: t1</span><br><span class="line">         Engine: InnoDB</span><br><span class="line">        Version: 10</span><br><span class="line">     Row_format: Compact</span><br><span class="line">           Rows: 0</span><br><span class="line"> Avg_row_length: 0</span><br><span class="line">    Data_length: 16384</span><br><span class="line">Max_data_length: 0</span><br><span class="line">   Index_length: 0</span><br><span class="line">      Data_free: 0</span><br><span class="line"> Auto_increment: NULL</span><br><span class="line">    Create_time: 2015-03-16 15:13:31</span><br><span class="line">    Update_time: NULL</span><br><span class="line">     Check_time: NULL</span><br><span class="line">      Collation: utf8mb4_0900_ai_ci</span><br><span class="line">       <span class="keyword">Checksum</span>: <span class="literal">NULL</span></span><br><span class="line"> Create_options:</span><br><span class="line">        <span class="keyword">Comment</span>:</span><br></pre></td></tr></table></figure>

<p>  For information about <a href="https://dev.mysql.com/doc/refman/8.0/en/show-table-status.html" target="_blank" rel="noopener"><code>SHOW TABLE STATUS</code></a> output, see <a href="https://dev.mysql.com/doc/refman/8.0/en/show-table-status.html" target="_blank" rel="noopener">Section 13.7.6.36, “SHOW TABLE STATUS Syntax”</a>.</p>
<p>  <code>InnoDB</code> table properties may also be queried using the <code>InnoDB</code> Information Schema system tables:</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM INFORMATION_SCHEMA.INNODB_TABLES WHERE NAME='test/t1' \G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">     TABLE_ID: 45</span><br><span class="line">         NAME: test/t1</span><br><span class="line">         FLAG: 1</span><br><span class="line">       N_COLS: 5</span><br><span class="line">        SPACE: 35</span><br><span class="line">   ROW_FORMAT: Compact</span><br><span class="line">ZIP_PAGE_SIZE: 0</span><br><span class="line">   SPACE_TYPE: Single</span><br></pre></td></tr></table></figure>

<p>  For more information, see <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-information-schema-system-tables.html" target="_blank" rel="noopener">Section 15.14.3, “InnoDB INFORMATION_SCHEMA Schema Object Tables”</a>.</p>
]]></content>
  </entry>
  <entry>
    <title>read/Choosing_the_best_indexes_for_MySQL_query_optimization</title>
    <url>/2020/01/09/read/Choosing_the_best_indexes_for_MySQL_query_optimization/</url>
    <content><![CDATA[<h2 id="原文-https-www-eversql-com-choosing-the-best-indexes-for-mysql-query-optimization"><a href="#原文-https-www-eversql-com-choosing-the-best-indexes-for-mysql-query-optimization" class="headerlink" title="原文 : https://www.eversql.com/choosing-the-best-indexes-for-mysql-query-optimization/"></a>原文 : <a href="https://www.eversql.com/choosing-the-best-indexes-for-mysql-query-optimization/" target="_blank" rel="noopener">https://www.eversql.com/choosing-the-best-indexes-for-mysql-query-optimization/</a></h2><h2 id="Which-indexes-should-I-create-for-an-SQL-query"><a href="#Which-indexes-should-I-create-for-an-SQL-query" class="headerlink" title="Which indexes should I create for an SQL query?"></a>Which indexes should I create for an SQL query?</h2><h2 id="我应该为SQL查询创建哪些索引"><a href="#我应该为SQL查询创建哪些索引" class="headerlink" title="我应该为SQL查询创建哪些索引?"></a>我应该为SQL查询创建哪些索引?</h2><p>As a general rule of thumb, MySQL can only use one index for each table in the query. Therefore, there is no point in creating more than one index for each query. Preferably, same indexes should match as many of the queries as possible, as it will reduce the load on the database when inserting or updating data (which requires updating the indexes as well).</p>
<p>按照一般的经验法则, MySQL查询中的每个表只能使用一个索引</p>
<p>(High Performance MySQL 中澄清了, 有可能会组合, 但最好不要依赖于它)</p>
<p>所以, 为每个查询创建多个索引是没有意义的, 更恰当的情况是, 同样的索引匹配尽可能多的查询</p>
<p>因为这将会在插入或更改数据时, 减少数据库的负载(该操作同样也需要更新索引)</p>
<p>When creating an index, the most important parts are the equality conditions in the WHERE and JOIN conditions. In most cases, conditions such as name = ‘John’ will allow the database to filter most of the rows from the table and go through a small amount of rows to return the required results. Therefore, we should start indexing by adding these columns to the index.</p>
<p>当创建索引时, 最重要的是在 WHERE 和 JOIN 中的等式条件 </p>
<p>在大多数情况下, 像 name = ‘John’ 这样的条件会使数据区从表中筛选行, 通过少量的行返回需要的数据</p>
<p>我们应该通过增加这些列到索引中来开始索引</p>
<p>Then, you should look into the range conditions, but you should only add one of them – the most selective one, as MySQL can’t handle more of them. In some cases when there are no range conditions, it makes sense to add the GROUP BY / ORDER BY columns, assuming the ordering is done in only one direction (ASC / DESC).</p>
<p>然后, 你应该关注范围条件, 但是你只能增加其中一个, 可选性最大的一个, 因为MySQL不能处理更多</p>
<p>(PS. 关于 selectivity, High Performance MySQL 5.3 节中 Choosing a Good Column Order 中有介绍)</p>
<p>(简单来理解的话, 就是最具可选性, 最能分辨的列)</p>
<p>在某些情况下没有范围条件, 增加 GROUP BY/ORDER BY 列, 假设顺序由其中一个方向确定(ASC/DESC)</p>
<p>In some cases, it also makes sense to create a separate index that contains the ORDER BY clause’s columns, as MySQL sometimes chooses to use it. Please note though that for this to happen, the index should contain all columns from the ORDER BY clause and they should all be specified with the same order (ASC / DESC). This doesn’t guarantee that the database’s optimizer will pick this index rather than the other compound indexes, but it’s worth a try.</p>
<p>有时候, 也可以创建一个单独的索引包含 ORDER BY 子句的列, 因为 MySQL 有时会选择使用它</p>
<p>请记住, 为了实现这一点, 索引应该包含 ORDER BY 子句中所有的列, 并且被指定为相同的顺序(ASC/DESC) </p>
<p>这不保证数据库的优化是否会选择这个, 而不是其他组合索引, 但是值得一试</p>
<p>Also, in some cases, it makes sense to also add the columns from the SELECT clause to the index, to have a complete covering index. This only relevant if the index isn’t already ‘too large’. What’s too large? Well, no official rule of thumb here, but let’s say… 5-7 columns? Creating a covering index allows the database to not only filter using the index, but to also fetch the information required by the SELECT clause directly from the index, which saves precious I/O operations.</p>
<p>同样的, 有时增加 SELECT 中的列, 以拥有一个完整的覆盖索引也是有必要的, 但只当索引不长时, 才有意义</p>
<p>那么, 多长才是长么? emm… 没有官方规定这个, 但是估计一下… 5-7列? </p>
<p>创建覆盖索引使数据库不仅能过滤, 同时也能直接从索引中获取 SELECT 子句需要的信息, 以节省宝贵的 I/O 操作</p>
<p>Let’s look at an example to clarify: (通过一个例子理解一下)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    <span class="keyword">id</span>, first_name, last_name, age</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    employees</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    first_name = <span class="string">'John'</span></span><br><span class="line">        <span class="keyword">AND</span> last_name = <span class="string">'Brack'</span></span><br><span class="line">        <span class="keyword">AND</span> age &gt; <span class="number">25</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> age <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure>
<p>For this query, we’ll start with adding the columns <em>first_name</em> and <em>last_name</em>, which are compared with an equality operator. Then, we’ll add the <em>age</em> column which is compared with a range condition. No need to have the ORDER BY clause indexed here, as the <em>age</em> column is already in the index. Last but not least, we’ll add <em>id</em> from the SELECT clause to the index to have a covering index.</p>
<p>就这个例子, 我们应该一开始增加在 WHERE 子句中有相等比较操作的列 first_name 和 last_name</p>
<p>然后, 增加具有比较的 age 列. 在这里不需要有 ORDER BY 子句, 因为 age 列已经在索引中了 </p>
<p>最后, 但并不是最不重要的. 增加在 SELECT 子句中的 id 列, 以获得一个覆盖索引</p>
<p>So to index this query properly, you should add the index: (为了适当地索引这个查询, 你应该增加这个索引)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">employees (first_name, last_name, age, id).</span><br><span class="line">mysql : <span class="keyword">CREATE</span> <span class="keyword">INDEX</span> [INDEX_NAME] <span class="keyword">ON</span> [TABLE_NAME] (first_name, last_name, age, <span class="keyword">id</span>)</span><br></pre></td></tr></table></figure>

<p>The above is a very simplified pseudo-algorithm that will allow you to build simple indexes for rather simple SQL queries.</p>
<p>上面是一个非常简单的(= = 这东西咋翻译来着… 虚拟方法? 总之就是一种方法)</p>
<p>让你为简单的 SQL 查询构建简单的索引</p>
<p>(实际情况可能会复杂一些, 参考 High Performance MySQL 第 5 章)</p>
<p>If you’re looking for a way to automate your index creation, while also adding the benefit of a proprietary indexing algorithm and query optimization recommendations, you can try out <a href="http://www.eversql.com/?utm_source=blog&utm_campaign=p502" target="_blank" rel="noopener">EverSQL Query Optimizer</a> which does all the heavy lifting for you.</p>
<p>(广告 = =)</p>
<h2 id="What-not-to-do-when-indexing-or-writing-SQL-queries"><a href="#What-not-to-do-when-indexing-or-writing-SQL-queries" class="headerlink" title="What not to do when indexing (or writing SQL queries)?"></a>What not to do when indexing (or writing SQL queries)?</h2><h2 id="使用索引时-不要做的事情"><a href="#使用索引时-不要做的事情" class="headerlink" title="使用索引时, 不要做的事情"></a>使用索引时, 不要做的事情</h2><p>We gathered some of the most common mistakes we see programmers and database administrators do when writing queries and indexing their tables.</p>
<p>我们收集了一些当程序/DBA写查询语句和索引他们的表时, 会犯的常见错误</p>
<h3 id="Indexing-each-and-every-column-in-the-table-separately"><a href="#Indexing-each-and-every-column-in-the-table-separately" class="headerlink" title="Indexing each and every column in the table separately"></a>Indexing each and every column in the table separately</h3><h3 id="索引每一个表中每一列"><a href="#索引每一个表中每一列" class="headerlink" title="索引每一个表中每一列"></a>索引每一个表中每一列</h3><p>In most cases, MySQL won’t be able to use more than one index for each table in the query.</p>
<p>Therefore, when creating a separate index for each column in the table, the database is bound to perform only one of the search operations using an index, and the rest of them will be significantly slower, as the database can’t use an index to execute them.</p>
<p>We recommend using compound indexes (explained later in this article) rather than single-column indexes.</p>
<p>通常, MySQL不能在查询语句中, 为同一张表使用超过一个索引</p>
<p>所以, 当为表中的每个列创建一个索引, MySQL被限制只使用其中一个索引, 而其他的会慢很多</p>
<p>所以数据库不能使用索引去执行它们</p>
<p>我们建议使用复合索引(将会在这篇文章之后介绍), 而不是使用单列索引</p>
<h2 id="The-OR-operator-in-filtering-conditions"><a href="#The-OR-operator-in-filtering-conditions" class="headerlink" title="The OR operator in filtering conditions"></a>The OR operator in filtering conditions</h2><h3 id="过滤中的-OR-操作"><a href="#过滤中的-OR-操作" class="headerlink" title="过滤中的 OR 操作"></a>过滤中的 OR 操作</h3><p>Consider this query: (考虑这个查询)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    a, b</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    tbl</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    a = <span class="number">3</span> <span class="keyword">OR</span> b = <span class="number">8</span>;</span><br></pre></td></tr></table></figure>
<p>In many cases, MySQL won’t be able to use an index to apply an OR condition, and as a result, this query is not index-able.</p>
<p>Therefore, we recommend to avoid such OR conditions and consider splitting the query to two parts, combined with a UNION DISTINCT (or even better, UNION ALL, in case you know there won’t be any duplicate results)</p>
<p>通常, MySQL不能使用一个索引执行 OR 操作, 所以, 这个索引是 不可索引 的</p>
<p>所以, 我们建议避免这样的 OR 操作, 将其切分为两个部分, 由 UNION DISTINCT 组合</p>
<p>(或者更好地, UNION ALL, 你知道在这个例子中不会有重复的元素)</p>
<p>(PS. 是的, 在这样的情况下, MySQL不会使用索引 )</p>
<h2 id="The-order-of-columns-in-an-index-is-important"><a href="#The-order-of-columns-in-an-index-is-important" class="headerlink" title="The order of columns in an index is important"></a>The order of columns in an index is important</h2><h3 id="索引中列的顺序很重要"><a href="#索引中列的顺序很重要" class="headerlink" title="索引中列的顺序很重要"></a>索引中列的顺序很重要</h3><p>Let’s say I hand you my contacts phone book which is ordered by the contact’s first name and ask you to count how many people are there named “John” in the book. You’ll grab the book in both hands and say “no problem”. You will navigate to the page that holds all names starting with John, and start counting from there.</p>
<p>假设我把我的由联系人的姓作为顺序排序的通讯录给你, 问你在这个通讯录中, 有多少姓 “John” 的人</p>
<p>你会拿着这本书说”没问题”, 你会找到以 “John” 开始的书页, 然后开始计数</p>
<p>Now, let’s say I change the assignment and hand you a phone book that is ordered by the contact’s last name, but ask you to still count all contacts with the first name “John”. How would you approach that? Well, the database scratches his head in this situation as well.</p>
<p>如果我将书的顺序打乱, 以名排序, 问你同样的问题, 你如何回答这个问题? </p>
<p>数据库也会面临同样的麻烦</p>
<p>Now lets look at an SQL query to demonstrate the same behavior with the MySQL optimizer:</p>
<p>现在, 关注一个 SQL 语句来和 MySQL 优化器演示这个行为</p>
<p>Having the index contacts (first_name, last_name) is ideal here, because the index starts with our filtering condition and ends with another column in the SELECT clause.</p>
<p>如果有一个索引组合 (first_name, last_name) 在这里是很好的, 因为索引由 first_name 开始, 由 last_name 结束</p>
<p>(PS. 其实这个 High Performance MySQL 第 5 节有详细讨论) </p>
<p>(这里的优化的前提是, 该索引是 B-tree 类型, 如果是其他的, 比如 hash 类型, 那么可能就没有什么优化效果)</p>
<p>But, having the reverse index contacts (last_name, first_name) is rather useless, as the database can’t use the index for filtering, as the column we need is second in the index and not first.</p>
<p>如果有一个相反顺序的索引, 那么就是无用的</p>
<p>(因为如果是 B-tree 的话, 根本无法索引 = =)</p>
<p>The conclusion from this example is that the order of columns in an index is rather important.</p>
<p>最后点了一下题</p>
<h2 id="Adding-redundant-indexes"><a href="#Adding-redundant-indexes" class="headerlink" title="Adding redundant indexes"></a>Adding redundant indexes</h2><h2 id="增加冗余索引"><a href="#增加冗余索引" class="headerlink" title="增加冗余索引"></a>增加冗余索引</h2><p>Indexes are magnificent when trying to optimize your SQL queries and they can improve performance significantly.</p>
<p>索引在优化你的 SQL 语句和显著提升性能上很有帮助</p>
<p>But, they come with a downside as well. Each index you’re creating should be kept updated and in sync when changes occur in your databases. So for each INSERT / UPDATE / DELETE in your databases, all relevant indexes should be updated. This update can take sometime, especially with large tables / indexes.</p>
<p>但是, 它们也有一些缺点, 每个你创建的索引在你数据库变化时必须保持更新和同步</p>
<p>所以 每个 INSERT/UPDATE/DELETE 操作都会引起相关索引的更新, 这些操作所引起的索引可能会很耗时</p>
<p>Therefore, do not create indexes unless you know you’ll need them.</p>
<p>Also, we highly recommend to analyze your database once in a while, searching for any <a href="https://www.eversql.com/how-to-find-unused-indexes-in-a-mysql-database/" target="_blank" rel="noopener">redundant indexes that can be removed</a>.</p>
<p>所以, 除非你知道你需要它们, 否则不要创建无用的索引</p>
<p>同样地, 我们极力推荐每个一段时间, 分析一下数据库, 删除冗余的索引</p>
<h3 id="How-to-automate-index-creation-and-SQL-query-optimization"><a href="#How-to-automate-index-creation-and-SQL-query-optimization" class="headerlink" title="How to automate index creation and SQL query optimization?"></a>How to automate index creation and SQL query optimization?</h3><p>If you’re looking for a way to automate your index creation, while also adding the benefit of a proprietary indexing algorithm and query optimization recommendations, you can try out <a href="https://www.eversql.com/" target="_blank" rel="noopener">EverSQL Query Optimizer</a> which does all the heavy lifting for you.</p>
<p>(广告, 有兴趣可以去原页面试试)</p>
<h2 id="How-to-track-redundant-indexes-in-MySQL"><a href="#How-to-track-redundant-indexes-in-MySQL" class="headerlink" title="How to track redundant indexes in MySQL?"></a>How to track redundant indexes in MySQL?</h2><p>(这是在另一个页面的片段)</p>
<p>如何跟踪 MySQL 中冗余的索引</p>
<p>Starting MySQL 5.6, the database keeps track of index usage as part of its PERFORMANCE SCHEMA. This data can be queried using the <strong>schema_unused_indexes</strong> view, which displays indexes for which there are no events. Having no events indicates that these indexes might be redundant and unused for a while.</p>
<p>自 MySQL 5.6 开始, 数据库持续跟踪它 PERFORMANCE SCHEMA 中未使用的索引</p>
<p>这些数据可以用 schema_unused_indexes 来查询</p>
<p>显示哪些索引没有工作过, 这表示这些索引是冗余的, 在一段时间内没有使用过</p>
<p>But life isn’t that good, not yet at least. The potential obstacle here is that this information is re-counted every time MySQL is restarted. Therefore, in order to get reliable information, you should query these views a while after the MySQL instance was started. How long after the startup you’re asking? Well, that depends. My question back to you will be – how busy your database is? Do you know if all types of queries are usually executed in the database in a specific period of time? If so, that’s your window.</p>
<p>但是生活没有那么美好, 至少现在没有. 潜在的障碍是这些信息会在每次 MySQL 重启时重新统计</p>
<p>所以, 为了避免这种情况, 你应该在 MySQL 启动一段时间后去查询这些数据</p>
<p>这时间的长短取决与你数据库的忙碌程度</p>
<p>So let’s take a look at how it’s done: (让我们来看一看如何完成)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> sys.schema_unused_indexes;</span><br><span class="line"></span><br><span class="line">object_schema	object_name	index_name</span><br><span class="line">mydb			age			agecountry_index</span><br><span class="line">mydb			country		agecountry_index</span><br></pre></td></tr></table></figure>
<p>(PS. 显然, 如果数据可靠, 那么 age 表中的 agecountry_index 和 country 表中的 agecountry_index 是可以删除的)</p>
]]></content>
  </entry>
  <entry>
    <title>read/B-tree</title>
    <url>/2020/01/09/read/B-tree/</url>
    <content><![CDATA[<h2 id="原文地址-https-en-wikipedia-org-wiki-B-tree"><a href="#原文地址-https-en-wikipedia-org-wiki-B-tree" class="headerlink" title="原文地址 : https://en.wikipedia.org/wiki/B-tree"></a>原文地址 : <a href="https://en.wikipedia.org/wiki/B-tree" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/B-tree</a></h2><h2 id="B-tree"><a href="#B-tree" class="headerlink" title="B-tree"></a>B-tree</h2><p>In <a href="https://en.wikipedia.org/wiki/Computer_science" target="_blank" rel="noopener">computer science</a>, a <strong>B-tree</strong> is a self-balancing <a href="https://en.wikipedia.org/wiki/Tree_data_structure" target="_blank" rel="noopener">tree data structure</a> that maintains sorted data and allows searches, sequential access, insertions, and deletions in <a href="https://en.wikipedia.org/wiki/Logarithmic_time" target="_blank" rel="noopener">logarithmic time</a>. The B-tree is a generalization of a <a href="https://en.wikipedia.org/wiki/Binary_search_tree" target="_blank" rel="noopener">binary search tree</a> in that a node can have more than two children.<a href="https://en.wikipedia.org/wiki/B-tree#cite_note-Comer-1" target="_blank" rel="noopener">[1]</a> Unlike other <a href="https://en.wikipedia.org/wiki/Self-balancing_binary_search_tree" target="_blank" rel="noopener">self-balancing binary search trees</a>, the B-tree is well suited for storage systems that read and write relatively large blocks of data, such as discs. It is commonly used in <a href="https://en.wikipedia.org/wiki/Database" target="_blank" rel="noopener">databases</a> and <a href="https://en.wikipedia.org/wiki/File_system" target="_blank" rel="noopener">file systems</a>.</p>
<p>What, if anything, the <em>B</em> stands for has never been established.</p>
<p>在计算机科学中, B-tree 是自平衡树数据结构, 管理排序后的数据, 能常量时间内搜索. 序列访问, 插入和删除操作</p>
<p>B-tree 是二分查找树的广泛实现, 即一个节点可以有超过两个子节点</p>
<p>不像其他自平衡二分查找树, B-tree 适用于存储系统, 用作读取和写入相当庞大的数据</p>
<p>比如 discs, 通常被数据库和操作系统使用</p>
<h3 id="Overview-概览"><a href="#Overview-概览" class="headerlink" title="Overview (概览)"></a>Overview (概览)</h3><p>In B-trees, internal (<a href="https://en.wikipedia.org/wiki/Leaf_node" target="_blank" rel="noopener">non-leaf</a>) nodes can have a variable number of child nodes within some pre-defined range. When data is inserted or removed from a node, its number of child nodes changes. In order to maintain the pre-defined range, internal nodes may be joined or split. Because a range of child nodes is permitted, B-trees do not need re-balancing as frequently as other self-balancing search trees, but may waste some space, since nodes are not entirely full. The lower and upper bounds on the number of child nodes are typically fixed for a particular implementation. For example, in a <a href="https://en.wikipedia.org/wiki/2-3_tree" target="_blank" rel="noopener">2-3 B-tree</a> (often simply referred to as a <strong>2-3 tree</strong>), each internal node may have only 2 or 3 child nodes.</p>
<p>Each internal node of a B-tree contains a number of <a href="https://en.wikipedia.org/wiki/Unique_key" target="_blank" rel="noopener">keys</a>. The keys act as separation values which divide its <a href="https://en.wikipedia.org/wiki/Subtree" target="_blank" rel="noopener">subtrees</a>. For example, if an internal node has 3 child nodes (or subtrees) then it must have 2 keys: <em>a</em>1 and <em>a</em>2. All values in the leftmost subtree will be less than <em>a</em>1, all values in the middle subtree will be between <em>a</em>1 and <em>a</em>2, and all values in the rightmost subtree will be greater than <em>a</em>2.</p>
<p>在 B-tree 中, 内部(非叶子)节点可以在预定义范围内拥有可变数量的子节点</p>
<p>当从节点中插入或删除数据时, 子节点的数量改变. 为了管理预定义的范围, 内部节点可以连接或分裂</p>
<p>因为子节点的范围是受限的, B-tree 不需要像其他自平衡二分查找数一样频繁地重平衡, 但是会浪费一些空间, 因为节点不是填充满的</p>
<p>子节点数量的上限和下限通常有具体的实现固定, 比如 2-3 B-tree(通常简称 2-3 tree) 每个内部节点只有 2 个 或 3个子节点</p>
<p>每个 B-tree 的内部节点含有一些 keys, keys 充当分离的值 分离子树</p>
<p>比如, 如果内部节点有 3 个子节点(或子树) 那么, 它必须有 2 个 keys : a1 和 a2</p>
<p>所有在最左边子树的值 &lt;a1, 所有在中间子树的值 &gt;a1 &lt;a2, 在最右子树中的所有值 &gt;a2</p>
<p>(PS. 这里没有考虑 = 的情况, 不过还行, 等于放在值的左边还是右边, 不会有太大影响)</p>
<p>Usually, the number of keys is chosen to vary between {\displaystyle d}<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/e85ff03cbe0c7341af6b982e47e9f90d235c66ab" alt="d"> and {\displaystyle 2d}<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/d8106478cb4da6af49992eeb3a3b8690d27797ad" alt="2d">, where {\displaystyle d}<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/e85ff03cbe0c7341af6b982e47e9f90d235c66ab" alt="d"> is the minimum number of keys, and {\displaystyle d+1}<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/056e0c06c828dbe71a0f9021b2828ff176a3d337" alt="d+1"> is the minimum <a href="https://en.wikipedia.org/wiki/Outdegree#Indegree_and_outdegree" target="_blank" rel="noopener">degree</a> or <a href="https://en.wikipedia.org/wiki/Branching_factor" target="_blank" rel="noopener">branching factor</a> of the tree. In practice, the keys take up the most space in a node. The factor of 2 will guarantee that nodes can be split or combined. If an internal node has {\displaystyle 2d}<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/d8106478cb4da6af49992eeb3a3b8690d27797ad" alt="2d"> keys, then adding a key to that node can be accomplished by splitting the hypothetical {\displaystyle 2d+1}<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/d68ab692c5c4a44b63f3bd320249b8cb8d035191" alt="2d+1"> key node into two {\displaystyle d}<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/e85ff03cbe0c7341af6b982e47e9f90d235c66ab" alt="d"> key nodes and moving the key that would have been in the middle to the parent node. Each split node has the required minimum number of keys. Similarly, if an internal node and its neighbor each have {\displaystyle d}<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/e85ff03cbe0c7341af6b982e47e9f90d235c66ab" alt="d"> keys, then a key may be deleted from the internal node by combining it with its neighbor. Deleting the key would make the internal node have {\displaystyle d-1}<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/0195b64ba44bcc80b4c98e9d34256b4043fe519e" alt="d-1"> keys; joining the neighbor would add {\displaystyle d}<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/e85ff03cbe0c7341af6b982e47e9f90d235c66ab" alt="d"> keys plus one more key brought down from the neighbor’s parent. The result is an entirely full node of {\displaystyle 2d}<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/d8106478cb4da6af49992eeb3a3b8690d27797ad" alt="2d"> keys.</p>
]]></content>
  </entry>
  <entry>
    <title>other/aQuestionAboutStaticKeyword</title>
    <url>/2020/01/09/other/aQuestionAboutStaticKeyword/</url>
    <content><![CDATA[<h3 id="一个关于-static-的问题"><a href="#一个关于-static-的问题" class="headerlink" title="一个关于 static 的问题"></a>一个关于 static 的问题</h3><p>2019年4月22日19:42:18  </p>
<p>日常的一天, 做做 leetcode, 但是突然发现了关于 leetcode 代码优化的问题 </p>
<p><img src="https://imgur.com/cH0JYBG.png" alt=""></p>
<p>题目大概是要你中序遍历树</p>
<p>(看到题目的时候愣了一下, 怀疑自己是不是眼花了, 直到看到了 Follow up…  emmm, 好吧, 迭代)</p>
<p>总之我先用递归试了一下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left)</span><br><span class="line">            inorderTraversal(root-&gt;left);</span><br><span class="line"></span><br><span class="line">        ret.push_back(root-&gt;val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right)</span><br><span class="line">            inorderTraversal(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://imgur.com/NMNndgq.png" alt=""></p>
<p>但是它总是给我报这个错</p>
<p>这是没有理由的! 我代码中不可能无中生有</p>
<p>我怀疑这是 leetcode 平台对于用户所做的一种优化  </p>
<p>而这种优化与我使用 static 关键字相冲突</p>
]]></content>
  </entry>
  <entry>
    <title>other/O(n)</title>
    <url>/2020/01/09/other/O(n)/</url>
    <content><![CDATA[<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度用于描述算法的效率, 是衡量算法优劣的重要指标  </p>
<h3 id="O-1"><a href="#O-1" class="headerlink" title="O(1)"></a>O(1)</h3><pre><code>void func(int n){
    std::cout &lt;&lt; n &lt;&lt; std::cout;
}</code></pre><p>将自变量视作n, n在此情景下为传入的参数<br>将因变量视作t, t在此情景下为函数执行的指令次数(这个就是时间复杂度)<br>上述算法中, 无论n是多少, t都为1, 则此算法复杂度记做: O(1)</p>
<p>O(1)复杂度的算法效率不因外界因素而改变  </p>
<p>PS: 也称作常量级复杂度, 是最理想的复杂度  </p>
<h3 id="O-2n"><a href="#O-2n" class="headerlink" title="O(2n)"></a>O(2n)</h3><p>略</p>
<p>PS: 其中O(2n)就是呈2倍复杂度增加, 而O(nn)则意为n倍增加  </p>
<h3 id="O-n"><a href="#O-n" class="headerlink" title="O(n)"></a>O(n)</h3><pre><code>void func(int n){
    for(int i = 0; i &lt; n; ++i){
        std::cout &lt;&lt; i &lt;&lt; std::endl;
    }
}</code></pre><p>上述算法中 t = n + 1(其中的1为最后一次的失败), 算法复杂度为O(n)</p>
<p>O(n)复杂度的算法效率会因外界因素而改变, 其规律为: 复杂度呈1:1形式增加    </p>
<p>PS: O(n)是比较常见的复杂度, 效率一般  </p>
<h3 id="O-n-2-O-n-n"><a href="#O-n-2-O-n-n" class="headerlink" title="O(n^2)/O(n^n)"></a>O(n^2)/O(n^n)</h3><pre><code>void func(int n){
    for(int i = 0; i &lt; n; ++i){
        for(int j = 0; j &lt; n; ++i){
            std::cout &lt;&lt; i &lt;&lt; std::endl;
        }
    }
}</code></pre><p>上述算法中 t = n * n + 1, 记做: O(n^2)  </p>
<p>O(n^2)复杂度的算法效率会随外界的影响平方倍变化<br>同理, 则O(n^n)复杂度的算法效率会随外界的影响呈n次方倍增加 </p>
<p>PS: 出现这种复杂度的代码, 则需要考虑优化</p>
<h3 id="O-log-n"><a href="#O-log-n" class="headerlink" title="O(log n)"></a>O(log n)</h3><p>要想明白O(log n)时间复杂度, 则先得复习<a href="https://zh.wikipedia.org/wiki/%E5%AF%B9%E6%95%B0" target="_blank" rel="noopener">对数</a><br>(如果你还没把数学还给数学老师的话, 就不必了)</p>
<p>这东西我也不大说得清楚, 就直接粘贴网上的案例了:</p>
<p><img src="https://i.imgur.com/JGXST7I.png" alt=""></p>
<p>PS: O(log n)的复杂度计算好像不太容易, 一般人还不一定计算得出来… </p>
<p>RET: 总的来说时间复杂度就是一个随着计算数据增加, 算法效率呈何种形式增加的一种规律<br>了解一下时间复杂度是很有必要的<br>以后别人问你 你的算法效率如何的时候. 就可以回答: 我的算法时间复杂度是O(1)!  </p>
<p>以上经验参照自<a href="https://www.jianshu.com/p/f4cca5ce055a" target="_blank" rel="noopener">简书</a></p>
]]></content>
  </entry>
  <entry>
    <title>other/crontab</title>
    <url>/2020/01/09/other/crontab/</url>
    <content><![CDATA[<h3 id="需求描述"><a href="#需求描述" class="headerlink" title="需求描述"></a>需求描述</h3><p>设计一个定时关机的工具  </p>
<p>该工具使用lua语言, 通过PLINK链接服务器  </p>
<p>接收用户输入, 使用crontab/at设置定时器</p>
<h3 id="详细代码"><a href="#详细代码" class="headerlink" title="详细代码"></a>详细代码</h3><h4 id="timer-table"><a href="#timer-table" class="headerlink" title="timer table"></a>timer table</h4><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">package</span>.<span class="built_in">path</span> = <span class="built_in">package</span>.<span class="built_in">path</span> .. <span class="string">";../../script/?.lua"</span></span><br><span class="line"><span class="comment">-- inc是工具类</span></span><br><span class="line"><span class="keyword">local</span> inc = <span class="built_in">require</span>(<span class="string">"inc"</span>)</span><br><span class="line"><span class="comment">-- config记录了服务器的配置信息</span></span><br><span class="line"><span class="keyword">local</span> <span class="built_in">config</span> = <span class="built_in">require</span>(<span class="string">"config"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- timer用于处理整个定时任务</span></span><br><span class="line"><span class="keyword">local</span> timer = &#123;&#125;</span><br><span class="line">timer.file = <span class="string">"crontabtask.sh"</span>			<span class="comment">-- 文件名, 因为使用 crontab [file]形式添加任务</span></span><br><span class="line">timer.<span class="built_in">path</span> = <span class="string">"/tmp/"</span>					<span class="comment">-- 文件位于服务器那个路径下</span></span><br><span class="line">timer.fullName = timer.<span class="built_in">path</span>..timer.file	<span class="comment">-- 路径+文件名, 当前为: /tmp/crontabtask.sh</span></span><br><span class="line">timer.filenamemask = <span class="string">"CRONTAB_TASK_"</span>	<span class="comment">-- 掩码, 用于区分任务</span></span><br><span class="line">timer.servername = <span class="literal">nil</span>					<span class="comment">-- 服务器名称, 这里仅仅占位, 会在之后设置</span></span><br></pre></td></tr></table></figure>

<p>timer是任务处理表(类), 因为bash下, 没有办法直接使用vim编辑(或者说我不知道有什么办法能这么做)  </p>
<p>所以 crontab -e 的方式被舍弃了, 使用 crontab [filename] 的形式来添加任务 </p>
<p>(这样的好处是统一使用某一文件作为任务文件,  后续可以使用某种手段(比如修改配置), 来重新定义crontab -e)</p>
<p>(坏处就是动到了系统的东西, 这并不一定是好事)</p>
<h4 id="lobby"><a href="#lobby" class="headerlink" title="lobby"></a>lobby</h4><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 大厅</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timer.lobby</span><span class="params">()</span></span></span><br><span class="line">    inc.p(<span class="string">"请输入要操作的服务器ID"</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">local</span> serverID = <span class="built_in">tonumber</span>(<span class="built_in">io</span>.<span class="built_in">stdin</span>:<span class="built_in">read</span>())</span><br><span class="line">    <span class="keyword">local</span> scfg, servercfg = inc.getserverinfo(serverID)</span><br><span class="line"></span><br><span class="line">    inc.confirm_oper_server(scfg, &#123;servercfg&#125;, <span class="string">"即将操作该服务器"</span>)</span><br><span class="line">    <span class="comment">-- 检查文件是否存在</span></span><br><span class="line">    timer.checkFileExists(scfg, servercfg)</span><br><span class="line">    <span class="keyword">local</span> sFolder = <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">"%s%d.p%d"</span>, </span><br><span class="line">        <span class="built_in">config</span>.gamename, servercfg.id, servercfg.port)</span><br><span class="line">    timer.servername = sFolder</span><br><span class="line">    <span class="comment">-- 根据用户的选项, 我们重新设置了文件掩码, 加上了当前服务器名</span></span><br><span class="line">    <span class="comment">-- 这样更加安全, 也可以筛选统一主机下, 不同服务器任务了</span></span><br><span class="line">    timer.filenamemask = timer.filenamemask..timer.servername</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">        inc.p(<span class="string">"\n选择操作类型[1: 增加, 2: 删除, 4:查询]"</span>, <span class="number">10</span>)</span><br><span class="line">        <span class="keyword">local</span> operatetype = <span class="built_in">io</span>.<span class="built_in">stdin</span>:<span class="built_in">read</span>()</span><br><span class="line">        <span class="keyword">if</span> operatetype == <span class="string">'1'</span> <span class="keyword">then</span></span><br><span class="line">            <span class="comment">-- 增加定时器</span></span><br><span class="line">            timer.addTimerTask(scfg, servercfg)</span><br><span class="line">            <span class="comment">-- 判断是否增加成功</span></span><br><span class="line">            timer.isAddSuccess(scfg, servercfg)</span><br><span class="line">            <span class="comment">-- 自动刷新定时器列表</span></span><br><span class="line">            timer.searchTimerTask(scfg, servercfg)</span><br><span class="line">        <span class="keyword">elseif</span> operatetype == <span class="string">'2'</span> <span class="keyword">then</span></span><br><span class="line">            <span class="comment">-- 删除定时器</span></span><br><span class="line">            timer.deleteTimerTask(scfg, servercfg)</span><br><span class="line">            <span class="comment">-- 自动刷新定时器列表</span></span><br><span class="line">            timer.searchTimerTask(scfg, servercfg)</span><br><span class="line">        <span class="keyword">elseif</span> operatetype == <span class="string">'3'</span> <span class="keyword">then</span></span><br><span class="line">            <span class="comment">-- 预留</span></span><br><span class="line">        <span class="keyword">elseif</span> operatetype == <span class="string">'4'</span> <span class="keyword">then</span></span><br><span class="line">            <span class="comment">-- 刷新定时器列表</span></span><br><span class="line">            timer.searchTimerTask(scfg, servercfg)</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            inc.p(<span class="string">"操作码异常"</span>, <span class="number">14</span>)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>大厅界面, 先让用户选择一个操作的服务器, 设置相应的参数, 然后让用户一直操作该服务器</p>
<h4 id="checkFileExists"><a href="#checkFileExists" class="headerlink" title="checkFileExists"></a>checkFileExists</h4><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 检查文件是否存在</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timer.checkFileExists</span><span class="params">(scfg, servercfg)</span></span></span><br><span class="line">    <span class="comment">-- 看一下目录下是否存配置文件</span></span><br><span class="line">    <span class="keyword">local</span> cmds = &#123;&#125;</span><br><span class="line">    <span class="built_in">table</span>.<span class="built_in">insert</span>(cmds, <span class="string">"cd "</span>..timer.<span class="built_in">path</span>)</span><br><span class="line">    <span class="built_in">table</span>.<span class="built_in">insert</span>(cmds, <span class="string">"ls crontab*"</span>);</span><br><span class="line">    <span class="keyword">local</span> filename;</span><br><span class="line">    inc.popen_server_cmds(scfg, cmds, <span class="function"><span class="keyword">function</span> <span class="params">(res)</span></span></span><br><span class="line">        <span class="comment">-- 因为某些原因, 不用在意这行代码. 它的作用是获取文件名</span></span><br><span class="line">        filename = res[<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">end</span>, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">string</span>.<span class="built_in">find</span>(filename, <span class="string">"crontab"</span>) == <span class="literal">nil</span>) <span class="keyword">then</span></span><br><span class="line">        <span class="comment">-- 没找到配置文件, 就新建一个</span></span><br><span class="line">        inc.p(<span class="string">"未找到文件, 即将创建空文件: "</span>, <span class="number">10</span>)</span><br><span class="line">        <span class="keyword">local</span> cmds = &#123;&#125;</span><br><span class="line">        <span class="built_in">table</span>.<span class="built_in">insert</span>(cmds, <span class="string">"touch "</span>..timer.fullName)</span><br><span class="line">        inc.popen_server_cmds(scfg, cmds, <span class="literal">nil</span>, <span class="literal">true</span>)</span><br><span class="line">        inc.p(<span class="string">"创建成功: "</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="comment">-- 如果配置文件已经存在了, 那么就直接使用当前文件</span></span><br><span class="line">        inc.p(<span class="string">"已找到文件: "</span>..filename, <span class="number">10</span>)</span><br><span class="line">        timer.file = filename</span><br><span class="line">        timer.fullName = timer.<span class="built_in">path</span>..timer.file</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>检查配置文件是否已存在, 存在则世界使用它, 不存在, 则创建一个</p>
<h4 id="addTimerTask"><a href="#addTimerTask" class="headerlink" title="addTimerTask"></a>addTimerTask</h4><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 增加定时器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timer.addTimerTask</span><span class="params">(scfg, servercfg)</span></span></span><br><span class="line">    <span class="comment">-- 设置时间</span></span><br><span class="line">    <span class="keyword">local</span> timetab = &#123;&#125;</span><br><span class="line">    inc.p(<span class="string">"请输入任务名"</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">local</span> taskname = <span class="built_in">io</span>.<span class="built_in">stdin</span>:<span class="built_in">read</span>()</span><br><span class="line">    <span class="keyword">local</span> ttaskname = taskname..timer.filenamemask</span><br><span class="line">    <span class="comment">-- 检测任务名是否存在, 任务名用于删, 查任务</span></span><br><span class="line">    <span class="keyword">while</span> (timer.checkTaskName(scfg, servercfg, ttaskname) == <span class="literal">true</span>) <span class="keyword">do</span></span><br><span class="line">        inc.p(<span class="string">"任务重名, 请重新输入"</span>, <span class="number">14</span>)</span><br><span class="line">        taskname = <span class="built_in">io</span>.<span class="built_in">stdin</span>:<span class="built_in">read</span>()</span><br><span class="line">        ttaskname = taskname..timer.filenamemask</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 设置定时器触发时间</span></span><br><span class="line">    inc.p(<span class="string">"请输入服务器关闭时间(月)"</span>, <span class="number">10</span>)</span><br><span class="line">    timetab.month = <span class="built_in">io</span>.<span class="built_in">stdin</span>:<span class="built_in">read</span>()</span><br><span class="line">    inc.p(<span class="string">"请输入服务器关闭时间(日)"</span>, <span class="number">10</span>)</span><br><span class="line">    timetab.day = <span class="built_in">io</span>.<span class="built_in">stdin</span>:<span class="built_in">read</span>()</span><br><span class="line">    inc.p(<span class="string">"请输入服务器关闭时间(时)"</span>, <span class="number">10</span>)</span><br><span class="line">    timetab.hour = <span class="built_in">io</span>.<span class="built_in">stdin</span>:<span class="built_in">read</span>()</span><br><span class="line">    inc.p(<span class="string">"请输入服务器关闭时间(分)"</span>, <span class="number">10</span>)</span><br><span class="line">    timetab.minute = <span class="built_in">io</span>.<span class="built_in">stdin</span>:<span class="built_in">read</span>()</span><br><span class="line">    inc.p(<span class="string">"服务器将计划于 "</span>..timetab.month..<span class="string">"月"</span>..timetab.day..<span class="string">"日"</span>..</span><br><span class="line">        timetab.hour..<span class="string">"时"</span>..timetab.minute..<span class="string">"分 关闭, 确定? [输入y继续]"</span>, <span class="number">12</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">io</span>.<span class="built_in">stdin</span>:<span class="built_in">read</span>() ~= <span class="string">'y'</span> <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 这里构造了一条命令, 这条命令实现了添加一个定时器</span></span><br><span class="line">    <span class="comment">-- 这个定时器会到指定的服务器下, 调用 kill.net 来关闭服务器</span></span><br><span class="line">    <span class="comment">-- 关闭之后, 再使用 sed 命令, 将定时器删除, 然后重置定时器</span></span><br><span class="line">    <span class="keyword">local</span> cmds = &#123;&#125;;</span><br><span class="line">    <span class="keyword">local</span> dir = timer.getFullPath(servercfg)</span><br><span class="line">    <span class="keyword">local</span> timestamp = timetab.minute..<span class="string">' '</span>..timetab.hour..<span class="string">' '</span>..timetab.day..<span class="string">' '</span>..</span><br><span class="line">        timetab.month..<span class="string">' '</span>..<span class="string">'*'</span></span><br><span class="line">    <span class="built_in">table</span>.<span class="built_in">insert</span>(cmds, <span class="string">"echo \""</span>..timestamp..<span class="string">" echo \""</span>..ttaskname..<span class="string">"\""</span></span><br><span class="line">        ..<span class="string">';cd '</span>..dir..<span class="string">';./kill.net'</span>..</span><br><span class="line">        <span class="string">";sed -i \"/"</span>..ttaskname..<span class="string">"/d\" "</span>..timer.fullName..</span><br><span class="line">        <span class="string">";crontab "</span>..timer.fullName..<span class="string">"\" &gt;&gt; "</span>..timer.fullName)</span><br><span class="line">    <span class="built_in">print</span> (cmds[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">-- 这是一个外部工具类中的函数, 主要是使用PLINK携带用户信息和验证, 链接服务器</span></span><br><span class="line">    <span class="comment">-- 然后执行 cmds 中保存的命令</span></span><br><span class="line">    inc.popen_server_cmds(scfg, cmds, <span class="literal">nil</span>, <span class="literal">true</span>)</span><br><span class="line">    <span class="comment">-- 保存当前任务名, 用于判断任务是否成功</span></span><br><span class="line">    timer.lastTask = ttaskname;</span><br><span class="line">    timer.syncTask(scfg, servercfg)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h4 id="checkTaskName"><a href="#checkTaskName" class="headerlink" title="checkTaskName"></a>checkTaskName</h4><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 检查文件名</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timer.checkTaskName</span><span class="params">(scfg, servercfg, ttaskname)</span></span></span><br><span class="line">    <span class="keyword">local</span> cmds = &#123;&#125;</span><br><span class="line">    <span class="built_in">table</span>.<span class="built_in">insert</span>(cmds, <span class="string">"crontab -l"</span>)</span><br><span class="line">    <span class="keyword">local</span> dupname = <span class="literal">false</span></span><br><span class="line">    <span class="comment">-- 第三个参数是回调函数, res中存储了执行 cmds 后, 服务器的输出</span></span><br><span class="line">    <span class="comment">-- 使用 crontab -l 查看了当前已有的任务, 如果找到了任务名, 则说明任务名重复</span></span><br><span class="line">    inc.popen_server_cmds(scfg, cmds, <span class="function"><span class="keyword">function</span> <span class="params">(res)</span></span></span><br><span class="line">        <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">pairs</span>(res) <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">string</span>.<span class="built_in">find</span>(v, ttaskname)) <span class="keyword">then</span></span><br><span class="line">                dupname = <span class="literal">true</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span>, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dupname</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h4 id="syncTask"><a href="#syncTask" class="headerlink" title="syncTask"></a>syncTask</h4><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 同步任务</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timer.syncTask</span><span class="params">(scfg, servercfg)</span></span></span><br><span class="line">    <span class="keyword">local</span> cmds = &#123;&#125;</span><br><span class="line">    <span class="built_in">table</span>.<span class="built_in">insert</span>(cmds, <span class="string">"cd "</span>..timer.<span class="built_in">path</span>)</span><br><span class="line">    <span class="built_in">table</span>.<span class="built_in">insert</span>(cmds, <span class="string">"crontab "</span>..<span class="string">'./'</span>..timer.file);</span><br><span class="line">    <span class="comment">-- 其实就是执行 crontab [filename], 这里可以合为一句的</span></span><br><span class="line">    inc.popen_server_cmds(scfg, cmds, <span class="literal">nil</span>, <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h4 id="isAddSuccess"><a href="#isAddSuccess" class="headerlink" title="isAddSuccess"></a>isAddSuccess</h4><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 是否增加成功</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timer.isAddSuccess</span><span class="params">(scfg, servercfg)</span></span></span><br><span class="line">    <span class="keyword">local</span> cmds = &#123;&#125;</span><br><span class="line">    <span class="built_in">table</span>.<span class="built_in">insert</span>(cmds, <span class="string">"cat "</span>..timer.fullName);</span><br><span class="line">    <span class="keyword">local</span> size1 = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">-- 获取文件中的行数</span></span><br><span class="line">    inc.popen_server_cmds(scfg, cmds, <span class="function"><span class="keyword">function</span> <span class="params">(res)</span></span></span><br><span class="line">        size1 = #res</span><br><span class="line">    <span class="keyword">end</span>, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> cmds = &#123;&#125;</span><br><span class="line">    <span class="built_in">table</span>.<span class="built_in">insert</span>(cmds, <span class="string">"crontab -l"</span>);</span><br><span class="line">    <span class="keyword">local</span> size2 = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">-- 获取实际 crontab 任务的行数</span></span><br><span class="line">    inc.popen_server_cmds(scfg, cmds, <span class="function"><span class="keyword">function</span> <span class="params">(res)</span></span></span><br><span class="line">        size2 = #res</span><br><span class="line">    <span class="keyword">end</span>, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 如果行数不一致, 那么就说明加入失败</span></span><br><span class="line">    <span class="comment">-- 加入失败一般只有一种原因: 时间格式错误</span></span><br><span class="line">    <span class="comment">-- 我们也可以编写代码在执行加入前就判断, 但是判断时间的话, 涉及到平年和润年, 还涉及大小月</span></span><br><span class="line">    <span class="comment">-- 并且是服务器的时间, 所以也不能直接在windows上调用函数处理</span></span><br><span class="line">    <span class="comment">-- 考虑到这些原因, 就让linux帮我们做了这件事(反正行数不一致, 肯定是失败了)</span></span><br><span class="line">    <span class="keyword">if</span> size1 ~= size2 <span class="keyword">then</span> </span><br><span class="line">        <span class="comment">-- 添加失败就回滚一次任务</span></span><br><span class="line">        timer.rollBack(scfg, servercfg)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        inc.p(<span class="string">"添加定时任务成功"</span>, <span class="number">14</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h4 id="rollBack"><a href="#rollBack" class="headerlink" title="rollBack"></a>rollBack</h4><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 回滚一次任务</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timer.rollBack</span><span class="params">(scfg, servercfg)</span></span></span><br><span class="line">    <span class="keyword">local</span> cmds = &#123;&#125;</span><br><span class="line">    <span class="comment">-- 这里使用了 sed 来处理, 其中用到了我们之前记录的 lastTask</span></span><br><span class="line">    <span class="built_in">table</span>.<span class="built_in">insert</span>(cmds, <span class="string">"sed -i "</span>..<span class="string">'/'</span>..timer.lastTask..<span class="string">"/d"</span>..</span><br><span class="line">        <span class="string">' '</span>..timer.fullName);</span><br><span class="line">    inc.popen_server_cmds(scfg, cmds, <span class="literal">nil</span>, <span class="literal">true</span>)</span><br><span class="line">    inc.p(<span class="string">"时间格式错误, 已回滚"</span>, <span class="number">12</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h4 id="searchTimerTask"><a href="#searchTimerTask" class="headerlink" title="searchTimerTask"></a>searchTimerTask</h4><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询定时器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timer.searchTimerTask</span><span class="params">(scfg, servercfg)</span></span></span><br><span class="line">    <span class="keyword">local</span> cmds = &#123;&#125;</span><br><span class="line">    <span class="built_in">table</span>.<span class="built_in">insert</span>(cmds, <span class="string">"crontab -l"</span>)</span><br><span class="line">    inc.p(<span class="string">"\n当前已有任务: "</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">local</span> orisrc = &#123;&#125;</span><br><span class="line">    <span class="comment">-- 查看当前已有的任务</span></span><br><span class="line">    inc.popen_server_cmds(scfg, cmds, <span class="function"><span class="keyword">function</span> <span class="params">(res)</span></span></span><br><span class="line">        orisrc = res</span><br><span class="line">    <span class="keyword">end</span>, <span class="literal">true</span>)</span><br><span class="line">	</span><br><span class="line">    <span class="comment">-- 这里是为了将数据格式化成方便看懂的格式</span></span><br><span class="line">    timer.regex(orisrc, servercfg)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h4 id="regex"><a href="#regex" class="headerlink" title="regex"></a>regex</h4><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 检测记录, 筛选信息</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timer.regex</span><span class="params">(orisrc, servercfg)</span></span></span><br><span class="line">    <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">pairs</span>(orisrc) <span class="keyword">do</span></span><br><span class="line">        <span class="comment">-- 获取任务时间戳</span></span><br><span class="line">        <span class="keyword">local</span> taskstamp;</span><br><span class="line">        <span class="keyword">for</span> v2 <span class="keyword">in</span> <span class="built_in">string</span>.<span class="built_in">gmatch</span>(v, <span class="string">"%d+%s%d+%s%d+%s%d+"</span>) <span class="keyword">do</span> </span><br><span class="line">            taskstamp = v2</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">-- 获取任务名</span></span><br><span class="line">        <span class="keyword">local</span> taskname;</span><br><span class="line">        <span class="keyword">for</span> v3 <span class="keyword">in</span> <span class="built_in">string</span>.<span class="built_in">gmatch</span>(v, <span class="string">"echo.*"</span>..timer.filenamemask..<span class="string">';'</span>) <span class="keyword">do</span> </span><br><span class="line">            v3 = <span class="built_in">string</span>.<span class="built_in">sub</span>(v3, <span class="number">6</span>, #v3 - #timer.filenamemask - <span class="number">1</span>)</span><br><span class="line">            taskname = v3 </span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">-- 获取服务器名</span></span><br><span class="line">        <span class="keyword">local</span> hostname;</span><br><span class="line">        <span class="keyword">for</span> v4 <span class="keyword">in</span> <span class="built_in">string</span>.<span class="built_in">gmatch</span>(v, <span class="string">"CRONTAB_TASK.*;cd%s/data/server/"</span>) <span class="keyword">do</span> </span><br><span class="line">            v4 = <span class="built_in">string</span>.<span class="built_in">sub</span>(v4, <span class="number">14</span>, #v4 - <span class="number">17</span>)</span><br><span class="line">            hostname = v4 </span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">-- 如果这条信息是任务信息, 格式化打印出来</span></span><br><span class="line">        <span class="keyword">if</span> (taskstamp ~= <span class="literal">nil</span> <span class="keyword">and</span> taskname ~= <span class="literal">nil</span> <span class="keyword">and</span> hostname == timer.servername) <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">local</span> timetab = &#123;&#125;</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">string</span>.<span class="built_in">gmatch</span>(taskstamp, <span class="string">"%d+"</span>) <span class="keyword">do</span></span><br><span class="line">                <span class="built_in">table</span>.<span class="built_in">insert</span>(timetab, i);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">            inc.p(<span class="string">"服务器: "</span>..hostname..<span class="string">"  ========  任务名: "</span>..taskname..</span><br><span class="line">                <span class="string">"  ========  时间: "</span>..</span><br><span class="line">                timetab[<span class="number">4</span>]..<span class="string">"月"</span>..timetab[<span class="number">3</span>]..<span class="string">"日"</span>..</span><br><span class="line">                timetab[<span class="number">2</span>]..<span class="string">"时"</span>..timetab[<span class="number">1</span>]..<span class="string">"分"</span>, <span class="number">14</span>)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h4 id="deleteTimerTask"><a href="#deleteTimerTask" class="headerlink" title="deleteTimerTask"></a>deleteTimerTask</h4><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 删除定时器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timer.deleteTimerTask</span><span class="params">(scfg, servercfg)</span></span></span><br><span class="line">    inc.p(<span class="string">"请输入任务名(暂不支持中文)"</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">local</span> taskname = <span class="built_in">io</span>.<span class="built_in">stdin</span>:<span class="built_in">read</span>()</span><br><span class="line">    <span class="keyword">local</span> dir = timer.getFullPath(servercfg)</span><br><span class="line">    <span class="keyword">local</span> cmds = &#123;&#125;</span><br><span class="line">    <span class="built_in">table</span>.<span class="built_in">insert</span>(cmds, <span class="string">"cd "</span>..dir)</span><br><span class="line">    <span class="keyword">local</span> ttaskname = taskname..timer.filenamemask</span><br><span class="line">    <span class="comment">-- 执行一条 sed 命令, 删除一个任务</span></span><br><span class="line">    <span class="built_in">table</span>.<span class="built_in">insert</span>(cmds, <span class="string">"sed -i "</span>..<span class="string">'/'</span>..ttaskname..<span class="string">"/d"</span>..</span><br><span class="line">        <span class="string">' '</span>..timer.fullName);</span><br><span class="line">    inc.popen_server_cmds(scfg, cmds, <span class="literal">nil</span>, <span class="literal">true</span>)</span><br><span class="line">    <span class="comment">-- 同步一次</span></span><br><span class="line">    timer.syncTask(scfg, servercfg)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>


<h3 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h3><p>那么代码就这些了, 其中主要就是使用lua编写程序, 通过PLINK传递命令行信息</p>
<p>以此达到远程控制服务器定时器的效果</p>
<p>其中最主要的技术是: </p>
<p>lua语言基础, lua正则表达式  </p>
<p>{ crontab, sed } 命令行, 数据流重定向  </p>
<p>(emmmmmm… 看起来好像没什么厉害的…)</p>
<p>以及从&lt;重构&gt;中学到的代码技术  </p>
<p>(一开始看重构这本书的时候, 本来对里面一些降低效率的做法不太满意)</p>
<p>(但是真的使用了之后, 发现代码的确好多了, 无论是易读, 编写, 调试, 增加/删除方面, 都有明显提升)</p>
<p>(不过可惜没有运用到&lt;设计模式&gt;中的东西(或许我用到了, 只是没注意到?) )</p>
]]></content>
  </entry>
  <entry>
    <title>other/firstClassValue</title>
    <url>/2020/01/09/other/firstClassValue/</url>
    <content><![CDATA[<h4 id="第一级值"><a href="#第一级值" class="headerlink" title="第一级值"></a>第一级值</h4><p>长久以来一直不太明白之前在 lua 一本书中提到的 “第一类值”   </p>
<p>直到今天在一本书上看到类似的解释:</p>
<pre><code>一般而言, 程序设计语言总会对计算元素的可能使用方式强加上某些限制  
带有最少限制的元素具有&quot;第一级&quot;的状态, 第一级元素的某些特权包括:
* 可以用变量命名
* 可以提供给过程作为参数
* 可以由过程作为结果返回
* 可以包含在数据结构中</code></pre><p>上述说的是第一级值, 猜想应该是第一类值拥有第一级特权</p>
<h4 id="第一类函数"><a href="#第一类函数" class="headerlink" title="第一类函数"></a>第一类函数</h4><p>以下摘自 wiki 对第一类函数(first-class function)的解释</p>
<pre><code>In computer science, a programming language is said to have first-    class functions if it treats functions as first-class citizens. This means the language supports passing functions as arguments to other functions, returning them as the values from other functions, and assigning them to variables or storing them in data structures
在计算机科学中, 一个编程语言如果对他函数就像第一类公民(??)一样, 那么就说他有第一类函数
这意味着语言支持将函数作为参数传递给其他函数
从其他函数中将其作为值返回
将其复制给变量, 或者保存到数据结构中</code></pre><h4 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h4><p>顺便 wiki 说了一下什么是高阶函数</p>
<pre><code>First-class functions are a necessity for the functional programming style, in which the use of higher-order functions is a standard practice. A simple example of a higher-ordered function is the map function, which takes, as its arguments, a function and a list, and returns the list formed by applying the function to each member of the list. For a language to support map, it must support passing a function as an argument.
第一类函数对于函数化编程是必要的
其中使用高阶函数就是一个标准的实践
一个高阶函数的简单案例就是map函数
(...能意会, 但没法翻译...)
它必须支持传递函数作为参数</code></pre><h4 id="lambda-是如何工作的"><a href="#lambda-是如何工作的" class="headerlink" title="lambda 是如何工作的"></a>lambda 是如何工作的</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main() &#123;                                    </span><br><span class="line">    auto f &#x3D; [](int x, int y) &#123; return x + y; &#125;;</span><br><span class="line">    printf(&quot;%d\n&quot;,  f(1, 2) );                                                        </span><br><span class="line">    return 0;                                   </span><br><span class="line">&#125;                                               </span><br><span class="line">...</span><br><span class="line">_ZZ4mainENKUliiE_clEii:         </span><br><span class="line">.LFB3999:                       </span><br><span class="line">▹   .cfi_startproc              </span><br><span class="line">▹   pushq▹  %rbp                </span><br><span class="line">▹   .cfi_def_cfa_offset 16      </span><br><span class="line">▹   .cfi_offset 6, -16          </span><br><span class="line">▹   movq▹   %rsp, %rbp          </span><br><span class="line">▹   .cfi_def_cfa_register 6     </span><br><span class="line">▹   movq▹   %rdi, -8(%rbp)      &#x2F;&#x2F; 唯一的区别在于, 多传了一个&quot;this&quot;</span><br><span class="line">▹   movl▹   %esi, -12(%rbp)     </span><br><span class="line">▹   movl▹   %edx, -16(%rbp)     </span><br><span class="line">▹   movl▹   -16(%rbp), %eax     </span><br><span class="line">▹   movl▹   -12(%rbp), %edx     </span><br><span class="line">▹   addl▹   %edx, %eax          </span><br><span class="line">▹   popq▹   %rbp                </span><br><span class="line">▹   .cfi_def_cfa 7, 8           </span><br><span class="line">▹   ret                         </span><br><span class="line">...</span><br><span class="line">▹   subq▹   $16, %rsp</span><br><span class="line">▹   leaq▹   -1(%rbp), %rax	&#x2F;&#x2F; 这个 this 指向了当前栈帧, 但是这里为什么要 -1 ?</span><br><span class="line">▹   movl▹   $2, %edx</span><br><span class="line">▹   movl▹   $1, %esi</span><br><span class="line">▹   movq▹   %rax, %rdi            </span><br><span class="line">▹   call▹   _ZZ4mainENKUliiE_clEii</span><br></pre></td></tr></table></figure>

<p>在上面基础上, 让 lambda 捕获局部变量和全局变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int gi &#x3D; 11;</span><br><span class="line">int main() &#123;</span><br><span class="line">    int i &#x3D; 10;</span><br><span class="line">    auto f &#x3D; [i, gi](int x, int y) &#123; return i + gi + x + y; &#125;;</span><br><span class="line">    printf(&quot;%d\n&quot;,  f(1, 2) );</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">_ZZ4mainENKUliiE_clEii:     </span><br><span class="line">.LFB3999:                   </span><br><span class="line">▹   .cfi_startproc          </span><br><span class="line">▹   pushq▹  %rbp            </span><br><span class="line">▹   .cfi_def_cfa_offset 16  </span><br><span class="line">▹   .cfi_offset 6, -16      </span><br><span class="line">▹   movq▹   %rsp, %rbp      </span><br><span class="line">▹   .cfi_def_cfa_register 6 </span><br><span class="line">▹   movq▹   %rdi, -8(%rbp)  </span><br><span class="line">▹   movl▹   %esi, -12(%rbp) </span><br><span class="line">▹   movl▹   %edx, -16(%rbp) </span><br><span class="line">▹   movq▹   -8(%rbp), %rax  </span><br><span class="line">▹   movl▹   (%rax), %edx    </span><br><span class="line">▹   movl▹   gi(%rip), %eax  	&#x2F;&#x2F; @warning 即使是按值捕获, 全局变量也并未产生复制</span><br><span class="line">▹   addl▹   %eax, %edx      </span><br><span class="line">▹   movl▹   -12(%rbp), %eax </span><br><span class="line">▹   addl▹   %eax, %edx      </span><br><span class="line">▹   movl▹   -16(%rbp), %eax </span><br><span class="line">▹   addl▹   %edx, %eax      </span><br><span class="line">▹   popq▹   %rbp            </span><br><span class="line">▹   .cfi_def_cfa 7, 8       </span><br><span class="line">▹   ret                    </span><br><span class="line">...</span><br><span class="line">▹   subq▹   $16, %rsp             </span><br><span class="line">▹   movl▹   $10, -4(%rbp)         </span><br><span class="line">▹   movl▹   -4(%rbp), %eax        </span><br><span class="line">▹   movl▹   %eax, -16(%rbp)       &#x2F;&#x2F; 复制了一份 i</span><br><span class="line">▹   leaq▹   -16(%rbp), %rax       </span><br><span class="line">▹   movl▹   $2, %edx              </span><br><span class="line">▹   movl▹   $1, %esi              </span><br><span class="line">▹   movq▹   %rax, %rdi            </span><br><span class="line">▹   call▹   _ZZ4mainENKUliiE_clEii</span><br></pre></td></tr></table></figure>

<p>其中关键之处在于对待全局变量的方式, 这有可能产生错误, 事实也的确错了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,  f(<span class="number">1</span>, <span class="number">2</span>) );</span><br><span class="line">gi = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,  f(<span class="number">1</span>, <span class="number">2</span>) );</span><br><span class="line">...</span><br><span class="line"><span class="number">24</span></span><br><span class="line"><span class="number">113</span> <span class="comment">// gi 的值改变后, 输出结果也随之改变, 这不应该是按值捕获的结果</span></span><br></pre></td></tr></table></figure>

<p>那么如果我加上 mutable 去更改这个 gi 呢?</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [i, gi](<span class="keyword">int</span> x, <span class="keyword">int</span> y) <span class="keyword">mutable</span> &#123; gi = <span class="number">110</span>; <span class="keyword">return</span> i + gi + x + y; &#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,  gi);      </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,  f(<span class="number">1</span>, <span class="number">2</span>) );</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,  gi);</span><br><span class="line">...</span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="number">110</span>	<span class="comment">// 改变了! 这可是很重要的细节</span></span><br></pre></td></tr></table></figure>

<p>上述结果, 编译器(gcc 4.8.5)只有一个警告</p>
<p>但是如果不注意这个细节, 去捕获全局变量, 可能会有很严重的错误</p>
<p>接下来专注一下类类型变量, 他会如何捕获 (这里的代码就有点头疼了)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main() &#123;                                   </span><br><span class="line">    vector&lt;int&gt; v &#123;1, 2, 3, 4&#125;;                </span><br><span class="line">    int i &#x3D; 10;                                </span><br><span class="line">    auto f &#x3D; [i, gi, v](int x, int y) mutable &#123;</span><br><span class="line">        v[2] &#x3D; 10; gi &#x3D; 110;·                  </span><br><span class="line">        return i + gi + x + y; &#125;;              </span><br><span class="line">    printf(&quot;%d\n&quot;,  gi);                       </span><br><span class="line">    printf(&quot;%d\n&quot;,  f(1, 2) );                 </span><br><span class="line">    printf(&quot;%d\n&quot;,  v[2]);                     </span><br><span class="line"></span><br><span class="line">    return 0;                                  </span><br><span class="line">&#125;                                           </span><br><span class="line">...</span><br><span class="line">main:                                                          </span><br><span class="line">.LFB3998:          </span><br><span class="line">▹   pushq▹  %rbp                                                                       </span><br><span class="line">▹   movq▹   %rsp, %rbp                                         </span><br><span class="line">▹   pushq▹  %r13                                               </span><br><span class="line">▹   pushq▹  %r12                                               </span><br><span class="line">▹   pushq▹  %rbx                                               </span><br><span class="line">▹   subq▹   $72, %rsp                                          </span><br><span class="line">▹   leaq▹   -37(%rbp), %rax                                    </span><br><span class="line">▹   movq▹   %rax, %rdi                                         </span><br><span class="line">▹   call▹   _ZNSaIiEC1Ev                                       </span><br><span class="line">▹   movl▹   $._91, %r12d                                       </span><br><span class="line">▹   movl▹   $4, %r13d           &#x2F;&#x2F; 这里的 4 是告诉 vector, 有 4 个元素 (猜的)</span><br><span class="line">▹   leaq▹   -37(%rbp), %rdi                                    </span><br><span class="line">▹   movq▹   %r12, %rcx                                         </span><br><span class="line">▹   movq▹   %r13, %rbx                                         </span><br><span class="line">▹   movq▹   %r12, %rax                                         </span><br><span class="line">▹   movq▹   %r13, %rdx                                         </span><br><span class="line">▹   movq▹   %rcx, %rsi                                         </span><br><span class="line">▹   leaq▹   -64(%rbp), %rax     &#x2F;&#x2F; 按照上下文理解, 这应该就是 vector 的 this 指针   </span><br><span class="line">▹   movq▹   %rdi, %rcx                                         </span><br><span class="line">▹   movq▹   %rax, %rdi                                         </span><br><span class="line">.LEHB0:                                                        </span><br><span class="line">▹   call▹   _ZNSt6vectorIiSaIiEEC1ESt16initializer_listIiERKS0_ &#x2F;&#x2F; 真是个丑陋的小东西 &#x3D; &#x3D; </span><br><span class="line">.LEHE0:                                                        </span><br><span class="line">▹   leaq▹   -37(%rbp), %rax                                    </span><br><span class="line">▹   movq▹   %rax, %rdi                                         </span><br><span class="line">▹   call▹   _ZNSaIiED1Ev                                       </span><br><span class="line">▹   movl▹   $10, -36(%rbp)                                     </span><br><span class="line">▹   movl▹   -36(%rbp), %eax                                    </span><br><span class="line">▹   movl▹   %eax, -96(%rbp)       &#x2F;&#x2F; 上面的 10 是路标, 这个应该就是 lambda 的 this 指针</span><br><span class="line">▹   leaq▹   -64(%rbp), %rax       </span><br><span class="line">▹   leaq▹   -96(%rbp), %rdx</span><br><span class="line">▹   addq▹   $8, %rdx                                           </span><br><span class="line">▹   movq▹   %rax, %rsi                                         </span><br><span class="line">▹   movq▹   %rdx, %rdi                                         </span><br><span class="line">.LEHB1:                                                        </span><br><span class="line">▹   call▹   _ZNSt6vectorIiSaIiEEC1ERKS1_      &#x2F;&#x2F; 上面那句最长的应该是列表初始化, 而这一句                 								&#x2F;&#x2F; 可能是拷贝或者构造? </span><br><span class="line">.LEHE1:                               </span><br><span class="line">▹   movl▹   gi(%rip), %eax       </span><br><span class="line">▹   movl▹   %eax, %esi</span><br><span class="line">▹   movl▹   $.LC0, %edi</span><br><span class="line">▹   movl▹   $0, %eax</span><br><span class="line">.LEHB2:</span><br><span class="line">▹   call▹   printf</span><br><span class="line">▹   leaq▹   -96(%rbp), %rax</span><br><span class="line">▹   movl▹   $2, %edx</span><br><span class="line">▹   movl▹   $1, %esi</span><br><span class="line">▹   movq▹   %rax, %rdi</span><br><span class="line">▹   call▹   _ZZ4mainENUliiE_clEii</span><br><span class="line">...</span><br><span class="line">_ZZ4mainENUliiE_clEii:              </span><br><span class="line">.LFB4000:                           </span><br><span class="line">▹   .cfi_startproc                  </span><br><span class="line">▹   pushq▹  %rbp                    </span><br><span class="line">▹   .cfi_def_cfa_offset 16          </span><br><span class="line">▹   .cfi_offset 6, -16              </span><br><span class="line">▹   movq▹   %rsp, %rbp              </span><br><span class="line">▹   .cfi_def_cfa_register 6         </span><br><span class="line">▹   subq▹   $16, %rsp               </span><br><span class="line">▹   movq▹   %rdi, -8(%rbp)        &#x2F;&#x2F; this 指针  </span><br><span class="line">▹   movl▹   %esi, -12(%rbp)         </span><br><span class="line">▹   movl▹   %edx, -16(%rbp)         </span><br><span class="line">▹   movq▹   -8(%rbp), %rax          </span><br><span class="line">▹   addq▹   $8, %rax                </span><br><span class="line">▹   movl▹   $2, %esi                </span><br><span class="line">▹   movq▹   %rax, %rdi</span><br><span class="line">▹   call▹   _ZNSt6vectorIiSaIiEEixEm</span><br><span class="line">▹   movl▹   $10, (%rax)             &#x2F;&#x2F; 赋值</span><br><span class="line">▹   movl▹   $110, gi(%rip)</span><br><span class="line">▹   movq▹   -8(%rbp), %rax</span><br><span class="line">▹   movl▹   (%rax), %edx</span><br><span class="line">▹   movl▹   gi(%rip), %eax</span><br><span class="line">▹   addl▹   %eax, %edx</span><br><span class="line">▹   movl▹   -12(%rbp), %eax</span><br><span class="line">▹   addl▹   %eax, %edx</span><br><span class="line">▹   movl▹   -16(%rbp), %eax</span><br><span class="line">▹   addl▹   %edx, %eax</span><br><span class="line">▹   leave</span><br><span class="line">▹   .cfi_def_cfa 7, 8</span><br><span class="line">▹   ret</span><br></pre></td></tr></table></figure>
<p>值拷贝类的时候, 会将整个类拷贝一次, 并没有什么特殊的</p>
<p><strong>匿名函数与其说是函数, 不如说是类</strong> 他就像一个重载了调用运算符的类一样</p>
]]></content>
  </entry>
  <entry>
    <title>other/float</title>
    <url>/2020/01/09/other/float/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在看到&lt;深入理解计算机系统&gt;的浮点数时, 第一想法是:</p>
<ul>
<li>无法精确保存大多数浮点数</li>
<li>精度上的缺失</li>
</ul>
<h3 id="零值的比较"><a href="#零值的比较" class="headerlink" title="零值的比较"></a>零值的比较</h3><p>很多面试题都会考一道浮点数零值比较的题(一般是单精度, 双精度太长了)</p>
<p>我觉得答案应该是:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">f &gt; <span class="number">-0.000001f</span> &amp;&amp; f &lt; <span class="number">0.000001f</span></span><br></pre></td></tr></table></figure>

<p>这个题的核心在于 float 什么时候缺失精度</p>
<p>这里我没有使用等于, 因为我认为 0.000001f 和 -0.000001f 并不算缺失了精度 </p>
<p>(百度上的答案是有等于的, 我很怀疑这个答案, 甚至有人还用的是 0.00001 (눈_눈) )</p>
<p>(而google上我好像没有找到类似的答案, 再根据编译器给我的结果, 我只能如此推断)</p>
<p>下面是我推断的依据:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%f\n"</span>, <span class="number">0.000001f</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%f\n"</span>, <span class="number">0.0000006f</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%f\n"</span>, <span class="number">0.0000005f</span>);</span><br></pre></td></tr></table></figure>
<p>你觉得上面会打印什么呢?  输出结果是:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">0.000001</span></span><br><span class="line"><span class="number">0.000001</span></span><br><span class="line"><span class="number">0.000000</span></span><br></pre></td></tr></table></figure>
<p>这也就是我认为 0.000001 它并未损失精度的原因, 既然未损失, 那么就不能当做 0 值来对待</p>
<p>(再次看不起百度上的解答(눈_눈), 不过… 万一是cas错了呢?)</p>
<p>(损失精度还有更精确的 0.00000055f, 这个数字也被认为是 0.000001)</p>
<h3 id="数字的精度取决于有多少位表示"><a href="#数字的精度取决于有多少位表示" class="headerlink" title="数字的精度取决于有多少位表示"></a>数字的精度取决于有多少位表示</h3><p>上面看到了6为精度的情况, 他准确表示了0.1 (虽然它把 0.0000006f 当做了0.1…)</p>
<p>我们来看看其他的结果, 比如:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%f\n"</span>, <span class="number">255.1f</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="number">254.2f</span> == <span class="number">254.200001f</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="number">254.2f</span> == <span class="number">254.200002f</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="number">254.2f</span> == <span class="number">254.200003f</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="number">254.2f</span> == <span class="number">254.200004f</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="number">254.2f</span> == <span class="number">254.200005f</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="number">254.2f</span> == <span class="number">254.200006f</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="number">254.2f</span> == <span class="number">254.200007f</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="number">254.2f</span> == <span class="number">254.200008f</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="number">254.2f</span> == <span class="number">254.200009f</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="number">254.2f</span> == <span class="number">254.199999f</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="number">254.2f</span> == <span class="number">254.199998f</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="number">254.2f</span> == <span class="number">254.199997f</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="number">254.2f</span> == <span class="number">254.199996f</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="number">254.2f</span> == <span class="number">254.199995f</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="number">254.2f</span> == <span class="number">254.199994f</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="number">254.2f</span> == <span class="number">254.199993f</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="number">254.2f</span> == <span class="number">254.199992f</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="number">254.2f</span> == <span class="number">254.199991f</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="number">254.2f</span> == <span class="number">254.199990f</span>);</span><br></pre></td></tr></table></figure>
<p>你觉得这次又会输出什么呢?</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">255.100006</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>(输出结果我做了缩减, 不然太长了)</p>
<p>也就是说, 除了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">254.200005f</span></span><br><span class="line"><span class="number">254.200006f</span></span><br><span class="line"><span class="number">254.200007f</span></span><br><span class="line"><span class="number">254.200008f</span></span><br><span class="line"><span class="number">254.200009f</span></span><br></pre></td></tr></table></figure>
<p>之外, 编译器认为它们都是相等的, 为什么呢?</p>
<p>精度再次缺失(我只能如此猜测), 因为整数的数字过大, 剩下的留给小数的位数不足以达到6位精度  </p>
<p>所以这次的精度缩减到了5位, 而因为四舍五入(我只能再次如此猜测 (눈_눈))的关系</p>
<p>(其实说四舍五入有点不对, 应该是: 数字的二进制表示刚好进入了有效的区间)</p>
<p>一些能达到 254.20001 的数字被判段为不等, 而一些 254.19999 的数字又可四舍五入的关系被判断为相等  </p>
<p>所以, 整数数字的大小会影响小数的精度 (我感觉我在说废话 (눈_눈)), 而当整数过大时, 比如 0x7fffffffff </p>
<p>所有的小数精度全都会缺失(unsigned float 可能是例外, 不过不影响结论)</p>
<p>下面我又做了一次比较, 我将254换成了126, 输出结果是</p>
<pre><code>0 0 0 0 0 0 0 0 0 1 1 1 1 1 0 0 0 0</code></pre><p>emmm… 其实这次的有效精度还是接近5位</p>
<p>不过能够在5位之外, 能判断更多的数字了</p>
<p>(这个数字并未完全达到6位, 也许 0.000005 能判断到, 0.000004 却不能, 就像上面那样) </p>
<h3 id="底层到底对我们的代码做了什么"><a href="#底层到底对我们的代码做了什么" class="headerlink" title="底层到底对我们的代码做了什么"></a>底层到底对我们的代码做了什么</h3><p>又到了喜闻乐见的看汇编环节 ┑(￣Д ￣)┍</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> f = <span class="number">0.1f</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%f\n"</span>, f);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%f\n"</span>, f * <span class="number">2</span>);</span><br><span class="line"><span class="keyword">float</span> f2 = <span class="number">0x7fff</span> + <span class="number">0.1f</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%f\n"</span>, f2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%f\n"</span>, f2 * <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>它在汇编中的样子:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.cfi_startproc</span><br><span class="line">    pushq   %rbp</span><br><span class="line">    .cfi_def_cfa_offset 16</span><br><span class="line">    .cfi_offset 6, -16</span><br><span class="line">    movq    %rsp, %rbp</span><br><span class="line">    .cfi_def_cfa_register 6</span><br><span class="line">    subq    $16, %rsp			&#x2F;&#x2F; 依旧是开辟了16个直接的栈帧, 为什么不是8(我有两个float)?</span><br><span class="line">    movl    .LC0(%rip), %eax	&#x2F;&#x2F; .long   1036831949</span><br><span class="line">    movl    %eax, -4(%rbp)		&#x2F;&#x2F; 将变量放到了栈中</span><br><span class="line">    movss   -4(%rbp), %xmm0		&#x2F;&#x2F; 放到了浮点数寄存器中</span><br><span class="line">    cvtps2pd        %xmm0, %xmm0	&#x2F;&#x2F; emmm... PS2PD Single-Precision Double-Precision</span><br><span class="line">    						&#x2F;&#x2F; 它将两个单精度浮点数转化成了双精度, 这可不在我的预料之中 ∑(￣□￣;)</span><br><span class="line">    movl    $.LC1, %edi</span><br><span class="line">    movl    $1, %eax</span><br><span class="line">    call    printf</span><br><span class="line">    movss   -4(%rbp), %xmm0</span><br><span class="line">    addss   %xmm0, %xmm0</span><br><span class="line">    unpcklps        %xmm0, %xmm0</span><br><span class="line">    cvtps2pd        %xmm0, %xmm0</span><br><span class="line">    movl    $.LC1, %edi</span><br><span class="line">    movl    $1, %eax</span><br><span class="line">    call    printf</span><br><span class="line">    movl    .LC2(%rip), %eax	&#x2F;&#x2F; .long   1191181875</span><br><span class="line">    movl    %eax, -8(%rbp)</span><br><span class="line">    movss   -8(%rbp), %xmm0</span><br><span class="line">    cvtps2pd        %xmm0, %xmm0</span><br><span class="line">    movl    $.LC1, %edi</span><br><span class="line">    movl    $1, %eax</span><br><span class="line">    call    printf</span><br><span class="line">    movss   -8(%rbp), %xmm0</span><br><span class="line">    addss   %xmm0, %xmm0</span><br><span class="line">    unpcklps        %xmm0, %xmm0</span><br><span class="line">    cvtps2pd        %xmm0, %xmm0</span><br><span class="line">    movl    $.LC1, %edi</span><br><span class="line">    movl    $1, %eax</span><br><span class="line">    call    printf</span><br><span class="line">    movl    $0, %eax</span><br><span class="line">    leave</span><br><span class="line">    .cfi_def_cfa 7, 8</span><br><span class="line">    ret</span><br><span class="line">    .cfi_endproc</span><br></pre></td></tr></table></figure>

<p>关键点在于 .LC1 和 .LC2, 他们的数字, 不过一点数字看不出什么, 需要多一些数据</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1036831949</span> = <span class="number">0.1f</span>	= <span class="number">3</span>dcccccd</span><br><span class="line"><span class="number">1045220557</span> = <span class="number">0.2f</span> 	= <span class="number">3e4</span>ccccd</span><br><span class="line"><span class="number">1038174126</span> = <span class="number">0.11f</span>	= <span class="number">3</span>de147ae</span><br></pre></td></tr></table></figure>

<p>其中 0.1f 和 0.2f 相差 800000</p>
<p>0.1f 和 0.11f 相差 147ae1</p>
<p>emmmm… 想不出来, 或许我该再看看书</p>
<p>嗯 好的, 看完了 (￣ˇ￣)</p>
<p>大概是这样的, 根据不同的位数安排, 计算的结果也有相应的不同</p>
<p>一个浮点数, 1位符号位S, 8位阶码E, 23位小数位M  </p>
<p>其中又分为4种情况: 规格, 非规格, NaN(not a number?), 无穷大</p>
<p>(具体的细节请参考书中的介绍)</p>
<p>总之, 我们用书中的算法来检验一下这几个数字</p>
<p>首先 0.1f, 它的数字是 3dcccccd, 它是一个规格化数字</p>
<p>E = 123 - 127 = -4 , M = 5033165 / 8388735 +１</p>
<p>2的E次方 x M = 0.0999994337644472 </p>
<p>emmm… 没错, 这是一个非常接近 0.1 的数字</p>
<p>(书中说到了小数的舍入, 简单来说是四舍五入, 同时向偶数舍入, 比如 1.245 它会向 1.24 舍入)</p>
<p>(再次很好奇一些需要极其精确的小数运算是如何做到的 （ー_ー？）)</p>
<p>(像存储金额这样的小数精度, 特别是银行, 损失一个精度都很严重啊)</p>
<p><strong>规格化用于表示一些比较大的数字, 而非规格化用于表示一些相对较小的数字</strong></p>
<p>这里顺便再看一下失去精度的结果, 看看他是怎么计算的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%f\n"</span>, <span class="number">255.1f</span>);</span><br></pre></td></tr></table></figure>

<p>奇怪的是, 它有两个数字</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">111 .LC0:</span><br><span class="line">112     .long   1073741824</span><br><span class="line">113     .long   1081074483</span><br></pre></td></tr></table></figure>

<p>可惜计算不出来, 这种格式是无穷大(不太明白 (눈_눈))  </p>
<h3 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h3><p>简单来说, 其实也没有做笔记的必要  ┑(￣Д ￣)┍, 书上已经给了你答案</p>
<p>不过还好, 沉浸在思考的海洋中挺不错的(其实都快被淹死了 (눈_눈))</p>
<p>最后, <strong>若无必要, 或者非常确信浮点数的范围, 否则不要使用单精度浮点数</strong></p>
<p>如你所见, 单精度浮点数的范围很小, 一不小心还要失去精度</p>
<p>(这可能也是默认小数是双精度的原因)</p>
]]></content>
  </entry>
  <entry>
    <title>other/headFirstGoAssembly</title>
    <url>/2020/01/09/other/headFirstGoAssembly/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>下班忘把没读完的 inside the c++ object model 带回去</p>
<p>还好包里有本备用的 go, 简单看了一下前面基础部分</p>
<p>感觉就是, 很”新颖 + 轻巧”, 有很多新的概念和工具, 抛弃了一些沉重的”包袱”</p>
<p>试了一下用例, 看了一下汇编</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 package main</span><br><span class="line">2 </span><br><span class="line">3 import &quot;fmt&quot;</span><br><span class="line">4     </span><br><span class="line">5 func main() &#123;</span><br><span class="line">6     fmt.Printf(&quot;hello, world\n&quot;)</span><br><span class="line">7 &#125;</span><br></pre></td></tr></table></figure>

<p>汇编:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 # command-line-arguments                                                                 </span><br><span class="line"> 2 &quot;&quot;.main STEXT size&#x3D;88 args&#x3D;0x0 locals&#x3D;0x48                                               </span><br><span class="line"> 3     0x0000 00000 (&#x2F;test&#x2F;go&#x2F;t.go:5)  TEXT    &quot;&quot;.main(SB), $72-0                           				&#x2F;&#x2F; 非常友好地给我加上了对应的源码信息</span><br><span class="line"> 4     0x0000 00000 (&#x2F;test&#x2F;go&#x2F;t.go:5)  MOVQ    (TLS), CX                                    </span><br><span class="line"> 5     0x0009 00009 (&#x2F;test&#x2F;go&#x2F;t.go:5)  CMPQ    SP, 16(CX)                                   </span><br><span class="line"> 6     0x000d 00013 (&#x2F;test&#x2F;go&#x2F;t.go:5)  JLS 81                                               </span><br><span class="line"> 7     0x000f 00015 (&#x2F;test&#x2F;go&#x2F;t.go:5)  SUBQ    $72, SP	&#x2F;&#x2F; 这里应该是在开辟栈帧                                     </span><br><span class="line"> 8     0x0013 00019 (&#x2F;test&#x2F;go&#x2F;t.go:5)  MOVQ    BP, 64(SP)	&#x2F;&#x2F; 栈顶保存了 bp 指针                                   </span><br><span class="line"> 9     0x0018 00024 (&#x2F;test&#x2F;go&#x2F;t.go:5)  LEAQ    64(SP), BP  &#x2F;&#x2F; 重置 bp                                 </span><br><span class="line">10     0x001d 00029 (&#x2F;test&#x2F;go&#x2F;t.go:5)  FUNCDATA    $0, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)	&#x2F;&#x2F; gc ? garbage collection?</span><br><span class="line">11     0x001d 00029 (&#x2F;test&#x2F;go&#x2F;t.go:5)  FUNCDATA    $1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)</span><br><span class="line">12     0x001d 00029 (&#x2F;test&#x2F;go&#x2F;t.go:5)  FUNCDATA    $3, gclocals·9fb7f0986f647f17cb53dda1484e0f7a(SB)	&#x2F;&#x2F; 看不懂 &#x3D; &#x3D;</span><br><span class="line">13     0x001d 00029 (&#x2F;test&#x2F;go&#x2F;t.go:6)  PCDATA  $2, $1                                       </span><br><span class="line">14     0x001d 00029 (&#x2F;test&#x2F;go&#x2F;t.go:6)  PCDATA  $0, $0	&#x2F;&#x2F; 还是看不懂 &#x3D; &#x3D;</span><br><span class="line">15     0x001d 00029 (&#x2F;test&#x2F;go&#x2F;t.go:6)  LEAQ    go.string.&quot;hello, world\n&quot;(SB), AX           						&#x2F;&#x2F; 加载字符串文本, 者很方便, 我直接可以看到字符串</span><br><span class="line">16     0x0024 00036 (&#x2F;test&#x2F;go&#x2F;t.go:6)  PCDATA  $2, $0                                       </span><br><span class="line">17     0x0024 00036 (&#x2F;test&#x2F;go&#x2F;t.go:6)  MOVQ    AX, (SP)                                     </span><br><span class="line">18     0x0028 00040 (&#x2F;test&#x2F;go&#x2F;t.go:6)  MOVQ    $13, 8(SP)	&#x2F;&#x2F; 应该是指字符串长度</span><br><span class="line">19     0x0031 00049 (&#x2F;test&#x2F;go&#x2F;t.go:6)  MOVQ    $0, 16(SP)  &#x2F;&#x2F; 后续参数数量?                                 </span><br><span class="line">20     0x003a 00058 (&#x2F;test&#x2F;go&#x2F;t.go:6)  XORPS   X0, X0	&#x2F;&#x2F; 单精度异或?</span><br><span class="line">21     0x003d 00061 (&#x2F;test&#x2F;go&#x2F;t.go:6)  MOVUPS  X0, 24(SP)                                   						&#x2F;&#x2F; 代码中没有用到单精度浮点数, 为什么会有这个指令?</span><br><span class="line">22     0x0042 00066 (&#x2F;test&#x2F;go&#x2F;t.go:6)  CALL    fmt.Printf(SB) &#x2F;&#x2F; 调用                              					&#x2F;&#x2F; 这样的格式很清晰</span><br><span class="line">23     0x0047 00071 (&#x2F;test&#x2F;go&#x2F;t.go:7)  MOVQ    64(SP), BP  &#x2F;&#x2F; 返还 bp                                 </span><br><span class="line">24     0x004c 00076 (&#x2F;test&#x2F;go&#x2F;t.go:7)  ADDQ    $72, SP	&#x2F;&#x2F; 重置栈顶</span><br><span class="line">25     0x0050 00080 (&#x2F;test&#x2F;go&#x2F;t.go:7)  RET	&#x2F;&#x2F; 结束</span><br><span class="line">26     0x0051 00081 (&#x2F;test&#x2F;go&#x2F;t.go:7)  NOP</span><br><span class="line">27     0x0051 00081 (&#x2F;test&#x2F;go&#x2F;t.go:5)  PCDATA  $0, $-1                                      </span><br><span class="line">28     0x0051 00081 (&#x2F;test&#x2F;go&#x2F;t.go:5)  PCDATA  $2, $-1                                      </span><br><span class="line">29     0x0051 00081 (&#x2F;test&#x2F;go&#x2F;t.go:5)  CALL    runtime.morestack_noctxt(SB)                 								&#x2F;&#x2F; 运行时的什么?</span><br><span class="line">30     0x0056 00086 (&#x2F;test&#x2F;go&#x2F;t.go:5)  JMP 0</span><br></pre></td></tr></table></figure>

<p>FUNCDATA 我怀疑和垃圾回收有关, PCDATA 意义不明 (网上查了一下, 都和垃圾回收有关)</p>
<p>我尝试过添加一个参数, 以用作 fmt.Println(), 但是我并未在代码中找到任何有关参数的信息</p>
<p>仅仅只有一句看起来和那个参数有关</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LEAQ    &quot;&quot;..autotmp_0+64(SP), AX	&#x2F;&#x2F; 就是这句话</span><br><span class="line">PCDATA  $2, $0                  </span><br><span class="line">MOVQ    AX, 16(SP)</span><br></pre></td></tr></table></figure>
<p>而且我差点忽略的一点是, 这里参数的传递是用栈</p>
<p>顺便, 我在文件的末尾找到了这些信息, 看起来像是某种标记</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">213 gclocals·69c1753bd5f81501d95132d08af04464 SRODATA dupok size&#x3D;8        </span><br><span class="line">214     0x0000 02 00 00 00 00 00 00 00                          ........  </span><br><span class="line">215 gclocals·568470801006e5c0dc3947ea998fe279 SRODATA dupok size&#x3D;10       </span><br><span class="line">216     0x0000 02 00 00 00 02 00 00 00 00 02                    ..........</span><br><span class="line">217 gclocals·9fb7f0986f647f17cb53dda1484e0f7a SRODATA dupok size&#x3D;10       </span><br><span class="line">218     0x0000 02 00 00 00 01 00 00 00 00 01                    ..........</span><br><span class="line">219 gclocals·33cdeccccebe80329f1fdbee7f5874cb SRODATA dupok size&#x3D;8        </span><br><span class="line">220     0x0000 01 00 00 00 00 00 00 00                          ........</span><br></pre></td></tr></table></figure>

<p>我再次使用了变量存储值的形式, 然后我的数字能够正常看见了:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0034 00052 (&#x2F;test&#x2F;go&#x2F;t.go:7)  MOVQ    $100, 8(SP)	&#x2F;&#x2F; 我的数字在这里</span><br><span class="line">0x003d 00061 (&#x2F;test&#x2F;go&#x2F;t.go:7)  CALL    runtime.convT2E64(SB)</span><br><span class="line">0x0042 00066 (&#x2F;test&#x2F;go&#x2F;t.go:7)  MOVQ    16(SP), AX</span><br><span class="line">0x0047 00071 (&#x2F;test&#x2F;go&#x2F;t.go:7)  PCDATA  $2, $2</span><br><span class="line">0x0047 00071 (&#x2F;test&#x2F;go&#x2F;t.go:7)  MOVQ    24(SP), CX</span><br><span class="line">0x004c 00076 (&#x2F;test&#x2F;go&#x2F;t.go:7)  MOVQ    AX, &quot;&quot;..autotmp_1+64(SP)</span><br><span class="line">0x0051 00081 (&#x2F;test&#x2F;go&#x2F;t.go:7)  PCDATA  $2, $0</span><br><span class="line">0x0051 00081 (&#x2F;test&#x2F;go&#x2F;t.go:7)  MOVQ    CX, &quot;&quot;..autotmp_1+72(SP)</span><br><span class="line">0x0056 00086 (&#x2F;test&#x2F;go&#x2F;t.go:7)  PCDATA  $2, $1</span><br><span class="line">0x0056 00086 (&#x2F;test&#x2F;go&#x2F;t.go:7)  LEAQ    go.string.&quot;hello, world\n%d&quot;(SB), AX</span><br><span class="line">0x005d 00093 (&#x2F;test&#x2F;go&#x2F;t.go:7)  PCDATA  $2, $0</span><br><span class="line">0x005d 00093 (&#x2F;test&#x2F;go&#x2F;t.go:7)  MOVQ    AX, (SP)</span><br><span class="line">0x0061 00097 (&#x2F;test&#x2F;go&#x2F;t.go:7)  MOVQ    $15, 8(SP)</span><br><span class="line">0x006a 00106 (&#x2F;test&#x2F;go&#x2F;t.go:7)  PCDATA  $2, $1</span><br><span class="line">0x006a 00106 (&#x2F;test&#x2F;go&#x2F;t.go:7)  LEAQ    &quot;&quot;..autotmp_1+64(SP), AX</span><br><span class="line">0x006f 00111 (&#x2F;test&#x2F;go&#x2F;t.go:7)  PCDATA  $2, $0</span><br><span class="line">0x006f 00111 (&#x2F;test&#x2F;go&#x2F;t.go:7)  MOVQ    AX, 16(SP)</span><br><span class="line">0x0074 00116 (&#x2F;test&#x2F;go&#x2F;t.go:7)  MOVQ    $1, 24(SP)</span><br><span class="line">0x007d 00125 (&#x2F;test&#x2F;go&#x2F;t.go:7)  MOVQ    $1, 32(SP)</span><br><span class="line">0x0086 00134 (&#x2F;test&#x2F;go&#x2F;t.go:7)  CALL    fmt.Printf(SB)	</span><br><span class="line">						&#x2F;&#x2F; 但是在调用之前, 我并没看到我的数字被加载了, 为什么?</span><br><span class="line">						&#x2F;&#x2F; 我唯一比较怀疑的是那个 CALL runtime.convT2E64(SB)</span><br></pre></td></tr></table></figure>

<p>好吧, 我的数据再度丢失了, 我甚至不知道它是如何被传过去的…</p>
<h3 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h3><p>go的汇编基于 plan 9(一个新的操作系统), 感觉到了新的技术和观点</p>
<p>并且它也更加友好, 我明显觉得看它的汇编会更轻松一些</p>
<p>(除了那个 PCDATA, FUNCDATA, 和那个已经被我跟丢的变量)</p>
<p>emmm… 很不错, 觉得自己听了别人的建议, 去学新的语言</p>
<p>而不学现在看起来很强大, 但是已经很老了的 java 是一个正确的决定</p>
]]></content>
  </entry>
  <entry>
    <title>other/implementionThreadInUserAndKernelSpace</title>
    <url>/2020/01/09/other/implementionThreadInUserAndKernelSpace/</url>
    <content><![CDATA[<p>之前就看过关于在内核以及用户空间实现线程的文章, 到现在还对于其中的一些点一知半解, 比如: 为什么实现在用户空间的线程比实现在内核空间的快?. 今天碰巧看到了这篇文章, 原文出自 &lt;modern operating system, fourth edition&gt;</p>
<h2 id="threads-implementation-in-kernel-and-user-space"><a href="#threads-implementation-in-kernel-and-user-space" class="headerlink" title="threads implementation in kernel and user space"></a>threads implementation in kernel and user space</h2><h3 id="2-2-4-Implementing-Threads-in-User-Space"><a href="#2-2-4-Implementing-Threads-in-User-Space" class="headerlink" title="2.2.4 Implementing Threads in User Space"></a>2.2.4 Implementing Threads in User Space</h3><p>There are two main places to implement threads: user space and the kernel.<br>The choice is a bit controversial, and a hybrid implementation is also possible. We<br>will now describe these methods, along with their advantages and disadvantages.</p>
<p>有两种主要的地方用于实现线程: 用户空间以及内核空间. 如何在哪里实现具有一定争议性, 同时, 一种混合的实现也是可能的. 我们将会概述这些方法, 以及他们的优点和缺点.</p>
<p>The first method is to put the threads package entirely in user space. The kernel knows nothing about them. As far as the kernel is concerned, it is managing<br>ordinary, single-threaded processes. The first, and most obvious, advantage is that<br>a user-level threads package can be implemented on an operating system that does<br>not support threads. All operating systems used to fall into this category, and even<br>now some still do. With this approach, threads are implemented by a library.</p>
<p>第一种方法是将整个线程包放到用户空间. 内核对此毫无所知. 就内核而言, 它依旧像对待单线程对象一样.</p>
<p>首先, 最明显的优点是, 用户级别的线程可以实现在一个不支持多线程的操作系统上.所有的操作系统曾经都是这种类型, 直到现在还有部分保留, 在这种方式下, 线程通过一个库实现.</p>
<p>All of these implementations have the same general structure, illustrated in<br>Fig. 2-16(a). The threads run on top of a run-time system, which is a collection of<br>procedures that manage threads. We have seen four of these already: pthread create, pthread exit, pthread join, and pthread yield, but usually there are more.</p>
<p>所有的实现有同样通用的结构, 如图2-16(a). 线程运行于运行时系统上(一系列管理线程的程序). 我们已经见过四种这样的程序了: 线程创建, 退出, 加入, 放弃(这是本书前面部分的内容, 但为什么是 pthread 呢? 难道是基于 posix 标准的线程实现?)</p>
<p><img src="https://imgur.com/ljUry5a.png" alt=""></p>
<p>When threads are managed in user space, each process needs its own private<br>thread table to keep track of the threads in that process. This table is analogous to<br>the kernel’s process table, except that it keeps track only of the per-thread proper-<br>ties, such as each thread’s program counter, stack pointer, registers, state, and so<br>forth. The thread table is managed by the run-time system. When a thread is<br>moved to ready state or blocked state, the information needed to restart it is stored<br>in the thread table, exactly the same way as the kernel stores information about<br>processes in the process table.</p>
<p>当线程管理于用户空间时, 每个进程需要拥有独有的线程表, 以用于持续跟踪进程中的线程. 这个表类似与内核的进程表, 不过它只跟踪每个线程的属性. 比如每个线程的程序计数器, 栈指针, 寄存器, 状态, 以及… </p>
<p>线程表由运行时系统管理, 当线程转变为就绪/阻塞状态时, 用于重启的信息就存储在线程表中, 就和内核在进程表中存储关于进程的信息一样.</p>
<p>When a thread does something that may cause it to become blocked locally, for<br>example, waiting for another thread in its process to complete some work, it calls a<br>run-time system procedure. This procedure checks to see if the thread must be put<br>into blocked state. If so, it stores the thread’s registers (i.e., its own) in the thread<br>table, looks in the table for a ready thread to run, and reloads the machine registers<br>with the new thread’s saved values. As soon as the stack pointer and program<br>counter have been switched, the new thread comes to life again automatically.</p>
<p>如果线程做了某些操作导致它本地阻塞时, 比如: 等待进程中的其他线程完成某些工作. 它调用一个运行时作业调度. </p>
<p>这个程序检查线程是否必须置于阻塞态, 如果是, 它在线程表中存储线程的寄存器(它自己的). 在表中查找一个就绪态线程运行, 重新加载新线程的寄存器. 同时栈指针和程序计数器也会切换, 新线程再次自动运行.</p>
<p> If the machine happens to have an instruction to store all the registers and another<br>one to load them all, the entire thread switch can be done in just a handful of in-<br>structions. Doing thread switching like this is at least an order of magnitude—<br>maybe more—faster than trapping to the kernel and is a strong argument in favor<br>of user-level threads packages.</p>
<p>如果机器开始有一个指令可以存储所有的寄存器, 同时另一个指令加载他们, 那么整个线程的切换就只需要少量的指令.</p>
<p>要完成这样的线程切换比捕获内核至少快一个数量级, 或许更快. 这是一个对用户级线程拥护者强有力的论点.</p>
<p>However, there is one key difference with processes. When a thread is finished<br>running for the moment, for example, when it calls thread yield, the code of<br>thread yield can save the thread’s information in the thread table itself. Fur-<br>thermore, it can then call the thread scheduler to pick another thread to run. The<br>procedure that saves the thread’s state and the scheduler are just local procedures,<br>so invoking them is much more efficient than making a kernel call. Among other<br>issues, no trap is needed, no context switch is needed, the memory cache need not<br>be flushed, and so on. This makes thread scheduling very fast.</p>
<p>然而, 有一个关于进程的关键不同. 当线程暂停时, 比如: 调用 yield, 保存线程的信息到线程表中.</p>
<p>更进步一, 调用线程调度, 选择另一个线程执行. 程序保存线程状态, 因为调度只是本地程序, 所以调用其会比内核调用更加高效. 其他方面, 没有捕获, 没有环境切换, 内存缓冲也不需要刷新, 等等. 这使得线程调度非常快.</p>
<p>User-level threads also have other advantages. They allow each process to have<br>its own customized scheduling algorithm. For some applications, for example,<br>those with a garbage-collector thread, not having to worry about a thread being<br>stopped at an inconvenient moment is a plus. They also scale better, since kernel<br>threads invariably require some table space and stack space in the kernel, which<br>can be a problem if there are a very large number of threads.</p>
<p>用户级线程还有其他优点. 它使每个进程都可以有自己的特定调度算法. 对于一些应用, 比如垃圾回收线程, 不用担心线程在不适当时候停下来, 这是一个优点. 他们拥有更好的伸缩性, 因为内核线程总是需要一些表空间和栈空间, 当线程逐渐增加时, 会造成麻烦.</p>
<p>Despite their better performance, user-level threads packages have some major<br>problems. First among these is the problem of how blocking system calls are im-<br>plemented. Suppose that a thread reads from the keyboard before any keys hav e<br>been hit. Letting the thread actually make the system call is unacceptable, since<br>this will stop all the threads. One of the main goals of having threads in the first<br>place was to allow each one to use blocking calls, but to prevent one blocked<br>thread from affecting the others. With blocking system calls, it is hard to see how<br>this goal can be achieved readily.</p>
<p>即使它们拥有更好的性能, 用户级线程包也有一些固有的问题. </p>
<p>首先, 如何实现阻塞的系统调用. 假如线程等待来自键盘的输入, 让这个线程准确执行系统调用是不允许的, 因为这会阻塞所有线程, 线程的首要目的之一是允许每个线程使用阻塞调用, 但是保证一个阻塞线程不会影响其他线程. 可以看出这很难实现.</p>
<p>The system calls could all be changed to be nonblocking (e.g., a read on the<br>keyboard would just return 0 bytes if no characters were already buffered), but re-<br>quiring changes to the operating system is unattractive. Besides, one argument for<br>user-level threads was precisely that they could run with existing operating sys-<br>tems. In addition, changing the semantics of read will require changes to many<br>user programs.</p>
<p>系统调用必须都变为非阻塞的(比如, 读取键盘输入应该在没有任何字符被缓存时返回0), 但是这对于操作系统而已不太友好. 次外(我真不知道怎么翻译这句…). 另外, 改变读取的语义将会影响到大量用户程序.</p>
<p>Another alternative is available in the event that it is possible to tell in advance<br>if a call will block. In most versions of UNIX, a system call, select , exists, which<br>allows the caller to tell whether a prospective read will block. When this call is<br>present, the library procedure read can be replaced with a new one that first does a<br>select call and then does the read call only if it is safe (i.e., will not block). If the<br>read call will block, the call is not made. Instead, another thread is run. The next<br>time the run-time system gets control, it can check again to see if the read is now<br>safe. This approach requires rewriting parts of the system call library, and is inef-<br>ficient and inelegant, but there is little choice. The code placed around the system<br>call to do the checking is called a jacket or wrapper.</p>
<p>在这种情况下还有另一个方法: 提前告知一个调用将会被阻塞是可行的(??? 啥意思啊 = =).</p>
<p>在多个 UNIX 版本中, 选择性地存在系统调用运行调用者判断未来的读操作将会阻塞. 当这样的调用存在时, 库程序读取替换成一个首先做判断, 然后当确定是安全的时候读取(比如, 非阻塞).不会执行会阻塞的读操作, 另一个线程将会运行. </p>
<p>在下次运行时系统获得控制时, 会再次检查读操作是否是安全的. 这个方法需要重写部分系统调用库. 不那么高效和优雅. 不过这是一个选择, 放置在系统函数周围的代码去检查的这种方法被称为 jacket 或 wrapper.</p>
<p>Somewhat analogous to the problem of blocking system calls is the problem of<br>page faults. We will study these in Chap. 3. For the moment, suffice it to say that<br>computers can be set up in such a way that not all of the program is in main memo-<br>ry at once. If the program calls or jumps to an instruction that is not in memory, a<br>page fault occurs and the operating system will go and get the missing instruction<br>(and its neighbors) from disk. This is called a page fault. The process is blocked<br>while the necessary instruction is being located and read in. If a thread causes a<br>page fault, the kernel, unaware of even the existence of threads, naturally blocks<br>the entire process until the disk I/O is complete, even though other threads might<br>be runnable.01</p>
<p>(简单来说, 这段说的是页错误, 主存和磁盘间虚拟空间内容的交换.)</p>
<p>Another problem with user-level thread packages is that if a thread starts run-<br>ning, no other thread in that process will ever run unless the first thread voluntarily<br>gives up the CPU. Within a single process, there are no clock interrupts, making it<br>impossible to schedule processes round-robin fashion (taking turns). Unless a<br>thread enters the run-time system of its own free will, the scheduler will never get a<br>chance.</p>
<p>用户级线程将面临的另一个问题是: 当线程开始执行时, 除非自愿放弃, 不然其他线程无法执行. </p>
<p>单线程程序, 不会产生时钟终端, 使用 round-robin 调度器管理进程是不可能的. 除非线程自愿进入运行时系统. 否则调度器将不会生效.</p>
<p>One possible solution to the problem of threads running forever is to have the<br>run-time system request a clock signal (interrupt) once a second to give it control,<br>but this, too, is crude and messy to program. Periodic clock interrupts at a higher<br>frequency are not always possible, and even if they are, the total overhead may be<br>substantial. Furthermore, a thread might also need a clock interrupt, interfering<br>with the run-time system’s use of the clock.</p>
<p>一个可能的方法是: 让运行时系统每秒请求一个时钟信号来控制它(总而言之这是一个馊主意).</p>
<p>Another, and really the most devastating, argument against user-level threads is<br>that programmers generally want threads precisely in applications where the<br>threads block often, as, for example, in a multithreaded Web server. These threads<br>are constantly making system calls. Once a trap has occurred to the kernel to carry<br>out the system call, it is hardly any more work for the kernel to switch threads if<br>the old one has blocked, and having the kernel do this eliminates the need for con-<br>stantly making select system calls that check to see if read system calls are safe.<br>For applications that are essentially entirely CPU bound and rarely block, what is<br>the point of having threads at all? No one would seriously propose computing the<br>first n prime numbers or playing chess using threads because there is nothing to be<br>gained by doing it that way.</p>
<p>另一个反对用户级线程的论证(也是最具破坏性的)是, 程序员通常希望线程在线程经常阻塞的应用中使用, 比如, 在一个多线程 web 服务器中. 线程不间断地使用系统调用, 一旦内核执行系统调用, 如果旧线程已被阻塞, 那么切换线程就几乎没有其他需要做的了. …(后面我翻不下去了, 大概意思是, 这样的话, 程序就没有必要使用多线程了)</p>
<p>(总结归纳一下: 大概意思是, 用户级线程最大的优点是在于其切换起来很快, 但是我们通常希望在频繁发生线程阻塞的应用中使用线程, 而在这种情况下, 线程切换所需的操作就会变少(如果旧线程已经被阻塞了的话), 那么 用户级线程存在的意义就不大了)</p>
<h3 id="2-2-5-Implementing-Threads-in-the-Kernel"><a href="#2-2-5-Implementing-Threads-in-the-Kernel" class="headerlink" title="2.2.5 Implementing Threads in the Kernel"></a>2.2.5 Implementing Threads in the Kernel</h3><p>Now let us consider having the kernel know about and manage the threads. No<br>run-time system is needed in each, as shown in Fig. 2-16(b). Also, there is no<br>thread table in each process. Instead, the kernel has a thread table that keeps track<br>of all the threads in the system. When a thread wants to create a new thread or<br>destroy an existing thread, it makes a kernel call, which then does the creation or<br>destruction by updating the kernel thread table.</p>
<p>现在, 让我们考虑让内核知道如何管理线程. 如图 2-16(b) 所示, 在进程中没有运行时系统, 也没有线程表. 内核有张线程表, 用于跟踪系统中的所有线程. 当线程想要创建或删除一个线程时, 使用一个内核调用, 然后通过更新内核线程表来创建或删除.</p>
<p>The kernel’s thread table holds each thread’s registers, state, and other infor-<br>mation. The information is the same as with user-level threads, but now kept in the<br>kernel instead of in user space (inside the run-time system). This information is a<br>subset of the information that traditional kernels maintain about their single-<br>threaded processes, that is, the process state. In addition, the kernel also maintains<br>the traditional process table to keep track of processes.</p>
<p>内核的线程表保存每个线程的寄存器, 状态, 以及其他信息. 与用户级线程保存的信息一致, 只是保存在内核中. </p>
<p>这些信息是传统内核管理的单线程进程信息的子集. 内核也同样管理传统的进程表, 以用于跟踪进程.</p>
<p>All calls that might block a thread are implemented as system calls, at consid-<br>erably greater cost than a call to a run-time system procedure. When a thread<br>blocks, the kernel, at its option, can run either another thread from the same proc-<br>ess (if one is ready) or a thread from a different process. With user-level threads,<br>the run-time system keeps running threads from its own process until the kernel<br>takes the CPU away from it (or there are no ready threads left to run).</p>
<p>所有可能阻塞线程的调用都被实现为系统调用, 相对运行时系统的调用, 明显有很大的额外消耗. 当线程阻塞时, 内核可以选择同进程下的线程运行, 也可以运行另一个进程的线程. 但用户级线程只会运行本进程的线程, 直到内核不让其使用 CPU 资源.</p>
<p>Due to the relatively greater cost of creating and destroying threads in the ker-<br>nel, some systems take an environmentally correct approach and recycle their<br>threads. When a thread is destroyed, it is marked as not runnable, but its kernel<br>data structures are not otherwise affected. Later, when a new thread must be creat-<br>ed, an old thread is reactivated, saving some overhead. Thread recycling is also<br>possible for user-level threads, but since the thread-management overhead is much<br>smaller, there is less incentive to do this.</p>
<p>因为在内核中创建和销毁线程操作相对更费力, 一些系统使用与环境相关的方法, 重利用它们的线程. </p>
<p>当线程销毁时, 将其标记为不可运行, 但是其内核数据结构不受影响, 随后, 当新线程需要创建时, 重新利用这些资源.  用户级线程也可以使用这个方法, 不过因为线程管理的消耗较小, 并不是很有必要这么做</p>
<p>Kernel threads do not require any new, nonblocking system calls. In addition,<br>if one thread in a process causes a page fault, the kernel can easily check to see if<br>the process has any other runnable threads, and if so, run one of them while wait-<br>ing for the required page to be brought in from the disk. Their main disadvantage is<br>that the cost of a system call is substantial, so if thread operations (creation, termi-<br>nation, etc.) a common, much more overhead will be incurred.</p>
<p>内核线程不需要任何新的, 非阻塞系统调用. 另外, 如果线程导致了页错误, 内核可以轻松地检查进程是否有其他线程可运行, 如果有, 在等待所需的页加载入内存中时, 执行该线程. 它们潜在的问题是: 系统调用比较耗时, 所以如果线程操作比较常见, 则会有更多的负载.</p>
<p>While kernel threads solve some problems, they do not solve all problems. For<br>example, what happens when a multithreaded process forks? Does the new proc-<br>ess have as many threads as the old one did, or does it have just one? In many<br>cases, the best choice depends on what the process is planning to do next. If it is<br>going to call exec to start a new program, probably one thread is the correct choice,<br>but if it continues to execute, reproducing all the threads is probably best.</p>
<p>内核线程依旧有一些未能解决的问题, 比如, 当多线程进程执行 fork 的时候, 会发生什么? 新的进程是否会像旧进程一样拥有同样多的线程呢? 还是只拥有一个呢? 在大多数情况下, 取决于进程将要做什么, 如果它将会调用 exec 执行一个新的程序, 当然只有一个好, 但是如果是继续运行的话, 则保留所有的线程则是最好的.</p>
<p>(PS: 在 linux posix 线程下, 默认是同样多的线程)</p>
<p>Another issue is signals. Remember that signals are sent to processes, not to<br>threads, at least in the classical model. When a signal comes in, which thread<br>should handle it? Possibly threads could register their interest in certain signals, so<br>when a signal came in it would be given to the thread that said it wants it. But what<br>happens if two or more threads register for the same signal? These are only two of<br>the problems threads introduce, and there are more.</p>
<p>另一个问题是信号. 信号是发给进程的, 而并非线程(至少在经典模型下). 当信号到达时, 那个线程来处理它呢? 可能线程会注册自己感兴趣的信号, 所以, 当信号到达, 会交由那个注册线程处理. 但是如果多个线程注册了同样的信号呢? 这仅仅是线程引入的其中两个问题.</p>
<h3 id="2-2-6-Hybrid-Implementations"><a href="#2-2-6-Hybrid-Implementations" class="headerlink" title="2.2.6 Hybrid Implementations"></a>2.2.6 Hybrid Implementations</h3><p>Various ways have been investigated to try to combine the advantages of user-<br>level threads with kernel-level threads. One way is use kernel-level threads and<br>then multiplex user-level threads onto some or all of them, as shown in Fig. 2-17.<br>When this approach is used, the programmer can determine how many kernel<br>threads to use and how many user-level threads to multiplex on each one. This<br>model gives the ultimate in flexibility.</p>
<p>已经有多种方法被研究出来, 用于融合用户级线程和内核级线程. 其中一种方法是使用内核级别线程, 然后每个内核线程使用多个用户级别线程. 如 2-17. </p>
<p>程序能够知晓多少内核线程, 多少用户线程被使用. 这种模型给予了很大的灵活性.</p>
<p><img src="https://imgur.com/Bcc4Uzh.png" alt=""></p>
<p>With this approach, the kernel is aware of only the kernel-level threads and<br>schedules those. Some of those threads may have multiple user-level threads multi-<br>plexed on top of them. These user-level threads are created, destroyed, and sched-<br>uled just like user-level threads in a process that runs on an operating system with-<br>out multithreading capability. In this model, each kernel-level thread has some set<br>of user-level threads that take turns using it.</p>
<p>在这种方法下, 内核只至少内核线程, 并调度它们. 其中一些内核线程上可能存在多个用户级线程. 这些用户线程将会在进程中管控. </p>
<p>内核线程和用户线程各有其优势, 用户线程效率更高, 但是操作系统不知情的情况下, 会产生许多逻辑上是多线程, 但物理上依旧是单线程才会产生的错误. 比如 信号, 中断. 而内核线程虽然相对效率低, 并且占用内核空间, 但是操作系统知晓是多线程, 与操作系统间有更多协作的空间.</p>
]]></content>
  </entry>
  <entry>
    <title>other/install vim8</title>
    <url>/2020/01/09/other/install%20vim8/</url>
    <content><![CDATA[<p>在和 master vim quickly 的作者邮件中 </p>
<p>发现了自己的vim版本还可以再更新, 于是有了这篇笔记</p>
<p>参考教程:</p>
<p><a href="https://www.tecmint.com/vim-8-0-install-in-ubuntu-linux-systems/" target="_blank" rel="noopener">https://www.tecmint.com/vim-8-0-install-in-ubuntu-linux-systems/</a></p>
<p><a href="https://www.systutorials.com/241762/how-to-upgrade-vim-to-version-8-on-centos-7/" target="_blank" rel="noopener">https://www.systutorials.com/241762/how-to-upgrade-vim-to-version-8-on-centos-7/</a></p>
<p>vim的git地址:</p>
<p><a href="https://github.com/vim/vim" target="_blank" rel="noopener">https://github.com/vim/vim</a></p>
<p>vim8安装指南:</p>
<p><a href="https://github.com/vim/vim/blob/master/src/INSTALL" target="_blank" rel="noopener">https://github.com/vim/vim/blob/master/src/INSTALL</a></p>
<h3 id="安装vim8"><a href="#安装vim8" class="headerlink" title="安装vim8"></a>安装vim8</h3><ol>
<li><p>首先需要源代码</p>
<p>git clone <a href="https://github.com/vim/vim.git" target="_blank" rel="noopener">https://github.com/vim/vim.git</a></p>
</li>
<li><p>编译</p>
<p>cd &lt;vim repo 路径&gt;/src</p>
<p>make</p>
<p>make install</p>
<p>现在应该就已经获得了新的vim可执行文件, 将他覆盖原来的vim就好</p>
</li>
</ol>
<p>@btw: 中途可能会遇到一些问题</p>
<ul>
<li>安装编译vim所需的API<ul>
<li>yum  -y install  ncurses-devel</li>
</ul>
</li>
<li>覆盖时提示出错<ul>
<li>因为可能vim还在其他地方被运行, 使用 losf 查看进程, kill 掉</li>
</ul>
</li>
</ul>
<p>具体的可以参考上面的教程链接, 这里只是简单概述</p>
<p>顺便给一份通常的vim设置</p>
<pre><code>&quot;General&quot;
set number    &quot;Show line numbers&quot;
set linebreak    &quot;Break lines at word (requires Wrap lines)&quot;
set showbreak=+++    &quot;Wrap-broken line prefix&quot;
set textwidth=100    &quot;Line wrap (number of cols)&quot;
set showmatch    &quot;Highlight matching brace&quot;
set visualbell    &quot;Use visual bell (no beeping)&quot;

set hlsearch    &quot;Highlight all search results&quot;
set smartcase    &quot;Enable smart-case search&quot;
set ignorecase    &quot;Always case-insensitive&quot;
set incsearch    &quot;Searches for strings incrementally&quot;

set autoindent    &quot;Auto-indent new lines&quot;
set shiftwidth=4    &quot;Number of auto-indent spaces&quot;
set smartindent    &quot;Enable smart-indent&quot;
set smarttab    &quot;Enable smart-tabs&quot;
set softtabstop=4    &quot;Number of spaces per Tab&quot;

&quot;Advanced&quot;
set ruler    &quot;Show row and column ruler information&quot;
​    
set undolevels=1000    &quot;Number of undo levels&quot;
set backspace=indent,eol,start    &quot;Backspace behaviour&quot;</code></pre>]]></content>
  </entry>
  <entry>
    <title>other/linux</title>
    <url>/2020/01/09/other/linux/</url>
    <content><![CDATA[<pre><code>mkdir 创建文件夹指令  
su 切换到管理员模式  
sudo 以管理员模式执行命令
sudo passwd 以用户密码更改管理员密码
rm -f * 删除当前目录下所有文件
clear 清空终端窗口(实际还存在, 只不过看不见了, 和cmd一样)

apt-get install [工具名] 安装工具  
CentOS下是使用yum

更改vim配色
1. 下载vim文件
2. 放到~/.vim/colors文件夹下(没有就创建)
3. 更改vimrc文件, 路径: /etc/vim/vimrc, 增加指令: colorscheme [配色方案名]
PS: 默认的colors文件夹路径: /usr/share/vim/vim80/colors
之后发现vimrc文件在/etc目录下, 而vim文件放在了~/.vim目录下
emmmmm, 已经想不起当时怎么弄的了... 就这样吧, 可能是版本问题...

更改tab间距
同样更改vimrc文件, 增加如下指令: 
set ts=4 // 设置table间距为4
set expandtab // 不清楚 - -</code></pre><p>以上环境为ubuntu 18<br>PS: 想起之前刚接触linux, 安装g++, gcc参照了错误的教程(那沙雕教程又是装插件又是下安装包)<br>好不容易装完之后又被vi的输入和命令行模式, 嘟嘟嘟嘟嘟, 气得半死<br>之后又好不容易写好一个测试代码, ctrl+s一保存, 直接TMD不响应了<br>(事后才得知这是关闭向终端输入的接口, 只需要ctrl+q就可以重新打开输入, 留下了属于无知者的泪水…)<br>一系列操作让我直接删除ubuntu… </p>
<p>vim查询字符串 <code>/字符串</code><br>PS: 但是之后被搜索的字符串会持续高亮显示, 使输入<code>noh</code>可还原  </p>
<p>vim注释多行<br>control + v<br>上下键/(j/k) 键选中操作的行<br>shift + i<br>输入<code>//</code> (视语言而定)<br>连续两次 ESC</p>
<p>取消多行注释<br>control + v<br>上下左右键 选中需要注释的符号<br>d</p>
]]></content>
  </entry>
  <entry>
    <title>other/permission</title>
    <url>/2020/01/09/other/permission/</url>
    <content><![CDATA[<h3 id="permission-denied"><a href="#permission-denied" class="headerlink" title="permission denied"></a>permission denied</h3><blockquote>
<p>有些时候, linux下执行/访问文件的时候, 都会报这个错</p>
<p>错误的原因是: 权限被拒绝, 那么linux的权限是怎么规定的?</p>
</blockquote>
<h3 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h3><blockquote>
<p>执行ll后, 显示的信息:</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-rwxrwxr-x 1 wd wd  8419 Nov  8 10:47 a.out</span><br><span class="line">-rw-rw-r-- 1 wd wd 60579 Oct 25 21:11 t</span><br><span class="line">-rw-rw-r-- 1 wd wd   272 Oct 25 21:11 t.cpp</span><br><span class="line">-rw-rw-r-- 1 wd wd   369 Nov  8 10:47 time.cpp</span><br><span class="line">-rw-rw-r-- 1 wd wd 71784 Oct 29 11:53 t.o</span><br><span class="line">-rw-rw-r-- 1 wd wd  5815 Oct 29 11:57 t.s</span><br></pre></td></tr></table></figure>
<p>其中 -rw-rw-r– 这一串代表的就是linux的文件权限, 一共有10个字符  </p>
<p>其中最开始的字符代表文件类型, 比如:  - 代表一般文件, l 代表链接文件</p>
<p>后面9个字符分为三部分, 分别代表: user(用户), group(组), other(其他)</p>
<p>每个部分有3个字符, 分别表示: r(read, 可读), w(write, 可写), x(execute 可执行)</p>
<p>如果某一部分没有这个权限, 则用 - 占位</p>
<p>因此可知 -rw-rw-r– 意为:</p>
<p>一般文件, 拥有者可读写, 同组用户可读写, 其他用户可读</p>
<h3 id="隐藏属性"><a href="#隐藏属性" class="headerlink" title="隐藏属性"></a>隐藏属性</h3><p>除此之外, linux的文件还有隐藏的属性</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[...]$ lsattr .</span><br><span class="line">-------------e- ./t.o</span><br><span class="line">-------------e- ./a.out</span><br><span class="line">-------------e- ./t.s</span><br><span class="line">-------------e- ./time.cpp</span><br><span class="line">-------------e- ./t</span><br><span class="line">-------------e- ./t.cpp</span><br></pre></td></tr></table></figure>
<p>通过lsattr(attribute), 可以查询文件的隐藏属性, 其中比较重要的属性有:</p>
<p>a: append, 只能添加, 不能更改和删除</p>
<p>i: 不能删除. 改名, 设置链接, 同时也无法写入和添加数据</p>
<p>属性的增加和删除, 可以通过chattr + - 来设置, 如果想直接赋予一个新的属性, 可以使用 = </p>
<h3 id="特殊权限"><a href="#特殊权限" class="headerlink" title="特殊权限"></a>特殊权限</h3><p>文件除此之外还有一些特殊的权限, SUID, SGID, SBIT</p>
<p>SUID位于user权限组: 拥有这个属性的文件, 最后一个字符位s, 例如: -rws——</p>
<p>​    SUID仅对二进制程序有效</p>
<p>​    SUID意为如果执行者拥有x权限, 当执行文件时, 执行者暂时拥有root权限</p>
<p>SGID位于group权限组: 拥有这个属性的文件, 最后一个字符位s, 例如: —-rws—</p>
<p>​    SGID意为如果执行者拥有x权限, 当执行文件时, 执行者暂时拥有用户组权限</p>
<p>SBIT位于other权限组:</p>
<p>​    SBIT仅对目录游泳: 拥有这个属性的文件, 最后一个字符位t, 例如: ——-rwt</p>
<p>​    SBIT意为: 当前面目录下, A仅仅只能删除(包括移动和重命名)A拥有的文件(文件持有者是A)</p>
<p>​        不能删除B的文件</p>
<p>以上来自鸟哥私房菜, 详细参照第二部分</p>
]]></content>
  </entry>
  <entry>
    <title>other/pointAndRefrence</title>
    <url>/2020/01/09/other/pointAndRefrence/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近看了&lt;现代操作系统&gt;, 从内存管理那一章中获得了一些东西: 分页和分段  </p>
<p>其中分页的概念让我对内存的管理有了更加清晰的认知</p>
<h3 id="什么是分页"><a href="#什么是分页" class="headerlink" title="什么是分页?"></a>什么是分页?</h3><p>就是将内存分为一个个小的页面(以4k为例). </p>
<p>在将磁盘数据加载进内存时, 以页为单位, 而将内存中的数据换出到磁盘中时, 也以页为单位. </p>
<p>对此, 一个具体的虚拟地址可以分为两部分:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">页号 + 地址</span><br></pre></td></tr></table></figure>

<p>其中, 页号会被替换, 而地址会被保留:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">真实的地址 + 地址</span><br></pre></td></tr></table></figure>

<p>真实的地址存放到进程虚拟地址映射表中  </p>
<p>emmm… 也就是说, <strong>虚拟地址中, 有部分的地址是真实的</strong></p>
<p>(如果我能知道那部分假的地址, 是否就有办法操作真实磁盘中的数据呢? 我突然有了不太好的想法 :) )</p>
<h3 id="指针中是否会保留原始变量的地址"><a href="#指针中是否会保留原始变量的地址" class="headerlink" title="指针中是否会保留原始变量的地址?"></a>指针中是否会保留原始变量的地址?</h3><p>指针中存放了数据, 而这样的数据能够找到指针所指向的变量  </p>
<p>那么, 这样的数据是什么呢? 最直接的, 那么应该是地址, 考虑以下程序:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="number">11</span>     <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="number">12</span>     <span class="keyword">int</span> *p = &amp;i;</span><br><span class="line"><span class="number">13</span>     <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, &amp;i);</span><br><span class="line"><span class="number">14</span>     <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, &amp;p);</span><br><span class="line"><span class="number">15</span>     <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *((<span class="keyword">int</span> *)&amp;p));</span><br><span class="line"><span class="number">16</span> </span><br><span class="line"><span class="number">17</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">18</span> &#125;</span><br></pre></td></tr></table></figure>

<p>15打印的是指针本身内存中所指向的东西, 将它与变量i的地址做以下对比, 会相同么?  以下是输出结果:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0x7fff12ca4efc</span><br><span class="line">0x7fff12ca4ef0</span><br><span class="line">315248380</span><br></pre></td></tr></table></figure>

<p>i的地址是 0x7fff12ca4efc, 而p中保存的值(我将它解释为整数)是: 315248380  </p>
<p>整型数字不怎么直观, 将它转为hex试试?  =&gt; 0x12ca4efc </p>
<p>有没有觉得熟悉?  0x7fff12ca4efc —– 0x12ca4efc   </p>
<p>除前面的 0x7fff, 后面的数字是一样的, 所以我们可以说指针保存了变量的地址, 但是并不准确  </p>
<p>那么 0x7fff 就是那个页号么? 指针中只会存放真是地址? 好像不那么对…</p>
<p>emmm… 好像可以继续尝试, 因为当前环境是32位的, 这个地址数字明显超出了32位的表现范围</p>
<p>(我居然忽略了这一点 = =…)</p>
<p>或许我能获得更多的数据? 在代码中加入了下面一行:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">16</span>     <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ((<span class="keyword">int</span> *)&amp;p)[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>

<p>得到了数据: 32767 =&gt; 0x7fff  </p>
<p>所以指针中直接保存了变量的地址(我们之前并没有拿到完全的数据, 地址超过了int的大小)  </p>
<p><strong>指针就是地址</strong></p>
<p>emmm… 好像这个笔记不是那么有意义做了…</p>
<p>我是不是太慢了? 这些东西应该是初学者就可以去钻研的内容</p>
<p>(@btw: 为什么是[1] 而不是 [-1])</p>
<h3 id="是否有办法知道哪些数据是与页号有关的"><a href="#是否有办法知道哪些数据是与页号有关的" class="headerlink" title="是否有办法知道哪些数据是与页号有关的?"></a>是否有办法知道哪些数据是与页号有关的?</h3><p>emmm… 那些东西与内核有关, 我现在没有办法获得</p>
<h3 id="其他的耦合知识-volatile"><a href="#其他的耦合知识-volatile" class="headerlink" title="其他的耦合知识: volatile"></a>其他的耦合知识: volatile</h3><p>在书中我还读到了一个非常有趣的知识, 那就是进程表项有一个<strong>是否缓存标志位</strong></p>
<p>这个标志位的意思是, 如果该位是1, 表示该页不被缓存  </p>
<p>意思是什么呢? 如果要访问的数据是在该页中的, 那么访问时会去访问磁盘  </p>
<p>而写入的时候, 也会直接往磁盘中写入, 因为内存中不缓存该页的数据</p>
<p>仔细想想和什么东西有关? 嗯, c++的 volatile 关键字</p>
<p>我打赌, volatile的实现一定与这东西有关(至少实现类似) 不过我现在的能力暂时无法证实</p>
<p>同时还有一个疑问, volatile 修饰一个变量, 而一个页是4k的, 如何将这两个东西分开呢? </p>
<h3 id="为什么是-1-而不是-1"><a href="#为什么是-1-而不是-1" class="headerlink" title="为什么是[1] 而不是 [-1]"></a>为什么是[1] 而不是 [-1]</h3><p>上面的例子中, 我继续访问数据, 使用的是 [1] 而不是 [-1]</p>
<p>我一开始是用 [-1], 因为栈是往下增长的, 之后发现 [1] 是正确的, 为什么?</p>
<p>的确实际上应该是 [1], 不然局部数组的访问就要乱套了 </p>
<p>但是栈的确是向下增长的, 从 fc 和 f0 中可以看出来 </p>
<p>那么底层到底对我的代码做了什么? 或许可以从汇编中得到答案</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">12 main:</span><br><span class="line">13 .LFB1079:</span><br><span class="line">14     .cfi_startproc</span><br><span class="line">15     .cfi_personality 0x3,__gxx_personality_v0</span><br><span class="line">16     pushq   %rbp</span><br><span class="line">17     .cfi_def_cfa_offset 16</span><br><span class="line">18     .cfi_offset 6, -16</span><br><span class="line">19     movq    %rsp, %rbp		&#x2F;&#x2F; 保存了栈底指针</span><br><span class="line">20     .cfi_def_cfa_register 6</span><br><span class="line">21     subq    $16, %rsp		&#x2F;&#x2F; 开拓栈帧, 16个字节</span><br><span class="line">22     movl    $1, -4(%rbp)		&#x2F;&#x2F; 嗯, 我们的数字1被放入内存了</span><br><span class="line">23     leaq    -4(%rbp), %rax	&#x2F;&#x2F; 将变量1的地址放入rax</span><br><span class="line">24     movq    %rax, -16(%rbp)	&#x2F;&#x2F; 将rax的值放入了栈... 栈顶?(因为这里是-16)</span><br><span class="line">25     leaq    -4(%rbp), %rax	&#x2F;&#x2F; 又将变量1的地址放入rax</span><br><span class="line">26     movq    %rax, %rsi		</span><br><span class="line">27     movl    $.LC0, %edi		&#x2F;&#x2F; .LC0:.string &quot;%p\n&quot;</span><br><span class="line">28     movl    $0, %eax			</span><br><span class="line">29     call    printf			&#x2F;&#x2F; rax存了变量1的地址, 这里应该对应: printf(&quot;%p\n&quot;, &amp;i);</span><br><span class="line">30     leaq    -16(%rbp), %rax	&#x2F;&#x2F; 将栈顶的地址放入了rax</span><br><span class="line">31     movq    %rax, %rsi		</span><br><span class="line">32     movl    $.LC0, %edi</span><br><span class="line">33     movl    $0, %eax</span><br><span class="line">34     call    printf			&#x2F;&#x2F; 现在rax是栈顶, 所以对应这一句: printf(&quot;%p\n&quot;, &amp;p);</span><br><span class="line">35     leaq    -16(%rbp), %rax	&#x2F;&#x2F; 把p的地址放入rax</span><br><span class="line">36     movl    (%rax), %eax		&#x2F;&#x2F; 又移动到eax</span><br><span class="line">37     movl    %eax, %esi		&#x2F;&#x2F; 还移动 &#x3D; &#x3D;</span><br><span class="line">38     movl    $.LC1, %edi		&#x2F;&#x2F; .LC1:.string &quot;%d\n&quot;</span><br><span class="line">39     movl    $0, %eax</span><br><span class="line">40     call    printf			&#x2F;&#x2F; 对应: printf(&quot;%d\n&quot;, ((int *)&amp;p)[0]);</span><br><span class="line">41     leaq    -16(%rbp), %rax	</span><br><span class="line">42     addq    $4, %rax			&#x2F;&#x2F; *将rax+4, 也就是往栈顶移动的</span><br><span class="line">43     movl    (%rax), %eax</span><br><span class="line">44     movl    %eax, %esi</span><br><span class="line">45     movl    $.LC1, %edi</span><br><span class="line">46     movl    $0, %eax</span><br><span class="line">47     call    printf			&#x2F;&#x2F; 对应: printf(&quot;%d\n&quot;, ((int *)&amp;p)[1]);</span><br><span class="line">48     movl    $0, %eax</span><br><span class="line">49     leave</span><br><span class="line">50     .cfi_def_cfa 7, 8</span><br><span class="line">51     ret</span><br><span class="line">52     .cfi_endproc</span><br></pre></td></tr></table></figure>

<p>那么了解了, 虽然栈是往下移动的, 分配栈帧时也是往下移动的  </p>
<p>但是 [1] 这种位移时, 是往上移动的, 也就是往高地址移动的</p>
<p>因为变量本身的地址开始是在栈的低地址, 是往上移动的  </p>
<p>没有问题, 是正常的 :)</p>
<p>但是我又发现一个问题, 这里指针所占用的空间为8字节!</p>
<p>不过又想了一下, 这好像也正常的, 毕竟64位嘛…</p>
<h3 id="引用呢-引用又是什么样子的呢"><a href="#引用呢-引用又是什么样子的呢" class="headerlink" title="引用呢? 引用又是什么样子的呢?"></a>引用呢? 引用又是什么样子的呢?</h3><p>时隔几天, 突然想到了这个东西, 引用又是什么样子的呢? 它和指针实质的区别?</p>
<p>参考以下代码:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;i2 = i;</span><br><span class="line"><span class="keyword">int</span> *pi = &amp;i;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p\n"</span>, &amp;i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p\n"</span>, &amp;i2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p\n"</span>, &amp;pi);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *pi);</span><br></pre></td></tr></table></figure>

<p>emmm… 这很简单, 分别打印地址和值</p>
<p>我们来看看汇编:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">main:</span><br><span class="line">.LFB1084:</span><br><span class="line">    .cfi_startproc</span><br><span class="line">    .cfi_personality 0x3,__gxx_personality_v0</span><br><span class="line">    pushq   %rbp</span><br><span class="line">    .cfi_def_cfa_offset 16</span><br><span class="line">    .cfi_offset 6, -16</span><br><span class="line">    movq    %rsp, %rbp</span><br><span class="line">    .cfi_def_cfa_register 6</span><br><span class="line">    subq    $32, %rsp			&#x2F;&#x2F; 32字节的栈帧</span><br><span class="line">    movl    $100, -12(%rbp)		&#x2F;&#x2F; i</span><br><span class="line">    leaq    -12(%rbp), %rax		&#x2F;&#x2F; i 的地址放入了rax</span><br><span class="line">    movq    %rax, -8(%rbp)		&#x2F;&#x2F; 直接将 rax 的值放入了 i2, 也就是说, 引用也保存了变量的地址</span><br><span class="line">    leaq    -12(%rbp), %rax		&#x2F;&#x2F; 这是一个完全可以优化掉的操作</span><br><span class="line">    movq    %rax, -24(%rbp)		&#x2F;&#x2F; pi </span><br><span class="line">    leaq    -12(%rbp), %rax		&#x2F;&#x2F; 你家 rax 都没变过, 你怎么还来 (눈_눈)</span><br><span class="line">    movq    %rax, %rsi</span><br><span class="line">    movl    $.LC0, %edi</span><br><span class="line">    movl    $0, %eax</span><br><span class="line">    call    printf				&#x2F;&#x2F; &amp;i</span><br><span class="line">    movq    -8(%rbp), %rax		&#x2F;&#x2F; 这里直接将栈中的值放进入了</span><br><span class="line">    movq    %rax, %rsi</span><br><span class="line">    movl    $.LC0, %edi</span><br><span class="line">    movl    $0, %eax</span><br><span class="line">    call    printf				&#x2F;&#x2F; &amp;i2</span><br><span class="line">    leaq    -24(%rbp), %rax		&#x2F;&#x2F; 注意, 这是 lea</span><br><span class="line">    movq    %rax, %rsi</span><br><span class="line">    movl    $.LC0, %edi</span><br><span class="line">    movl    $0, %eax</span><br><span class="line">    call    printf				&#x2F;&#x2F; &amp;pi</span><br><span class="line">    movl    -12(%rbp), %eax</span><br><span class="line">    movl    %eax, %esi</span><br><span class="line">    movl    $.LC1, %edi</span><br><span class="line">    movl    $0, %eax</span><br><span class="line">    call    printf				&#x2F;&#x2F; i</span><br><span class="line">    movq    -8(%rbp), %rax		&#x2F;&#x2F; 直接将地址放入 rax</span><br><span class="line">    movl    (%rax), %eax		&#x2F;&#x2F; 将这个地址中的值放入了(即 i 的地址) eax</span><br><span class="line">    movl    %eax, %esi</span><br><span class="line">    movl    $.LC1, %edi</span><br><span class="line">    movl    $0, %eax</span><br><span class="line">    call    printf				&#x2F;&#x2F; i2</span><br><span class="line">    movq    -24(%rbp), %rax</span><br><span class="line">    movl    (%rax), %eax</span><br><span class="line">    movl    %eax, %esi</span><br><span class="line">    movl    $.LC1, %edi</span><br><span class="line">    movl    $0, %eax</span><br><span class="line">    call    printf				&#x2F;&#x2F; pi</span><br><span class="line">    movl    $0, %eax</span><br><span class="line">    leave</span><br><span class="line">    .cfi_def_cfa 7, 8</span><br><span class="line">    ret</span><br><span class="line">    .cfi_endproc</span><br></pre></td></tr></table></figure>

<p>引用和指针并无关键性的区别, 引用也会占用内存(废话 (눈_눈), 不过我记得培训时有个沙雕老师说不占)</p>
<p>当使用引用的值时, 它是像指针一样使用</p>
<p>而当对引用取地址时, 它是直接拿存储的数据, 而并非用存储的数据去寻址</p>
<p>(这应当是编译器的规定, 它这么编译了引用)</p>
<p>唯一不同是, 引用占了8字节, 这很合理, 但是为什么指针是12字节</p>
<p>(这是一个我在之前忽视了的点, 我曾看过那4字节中是什么, 结果是 0 </p>
<p>(用指针的时候, 也用的是 movq, 这意味着只使用了 64 位, 即 8 字节, 为什么中空了 4 字节?)</p>
<p>或许我可以再试试赋值的时候, 引用和指针的不同之处</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">i2 = <span class="number">100</span>;</span><br><span class="line">*pi = <span class="number">111</span>;</span><br></pre></td></tr></table></figure>

<p>汇编:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">main:</span><br><span class="line">.LFB1078:</span><br><span class="line">    .cfi_startproc</span><br><span class="line">    .cfi_personality 0x3,__gxx_personality_v0</span><br><span class="line">    pushq   %rbp			&#x2F;&#x2F; 通过压栈的方式保存bp</span><br><span class="line">    .cfi_def_cfa_offset 16</span><br><span class="line">    .cfi_offset 6, -16</span><br><span class="line">    movq    %rsp, %rbp		&#x2F;&#x2F; 它没有显示说明栈帧有多大, 让我有点不习惯 ∑(￣□￣;)</span><br><span class="line">    .cfi_def_cfa_register 6</span><br><span class="line">    movl    $2147483647, -20(%rbp)</span><br><span class="line">    leaq    -20(%rbp), %rax</span><br><span class="line">    movq    %rax, -16(%rbp)</span><br><span class="line">    leaq    -20(%rbp), %rax</span><br><span class="line">    movq    %rax, -8(%rbp)</span><br><span class="line">    movq    -16(%rbp), %rax</span><br><span class="line">    movl    $100, (%rax)	&#x2F;&#x2F; 它是用寄存器寻址的方式来赋值的</span><br><span class="line">    movq    -8(%rbp), %rax</span><br><span class="line">    movl    $111, (%rax)</span><br><span class="line">    movl    $0, %eax</span><br><span class="line">    leave</span><br><span class="line">    .cfi_def_cfa 7, 8</span><br><span class="line">    ret</span><br><span class="line">    .cfi_endproc</span><br></pre></td></tr></table></figure>

<p>也就是说, 赋值是一样的, 嗯, 完全一样 </p>
<h3 id="指针和引用的安全性"><a href="#指针和引用的安全性" class="headerlink" title="指针和引用的安全性"></a>指针和引用的安全性</h3><p>还记得为什么引用比指针安全么? 因为对于引用是像值一样去使用它, 它仅仅是别名  </p>
<p>(其实不是别名, 如你所见, 有些时候访问引用其实还是访问的是引用所占的内存)  </p>
<p>它不会出现意外的 delete, 因为管理了它本身数据的访问, 也不会出现一些指针原有的错误(空指针,  野指针…)  </p>
<p>我更倾向于: <strong>引用是一个加了顶层const的非空, 不可用于delete的指针</strong></p>
<h3 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h3><p>引用和指针的本质都是地址</p>
<h3 id="题外话-尝试篡改引用指向的对象"><a href="#题外话-尝试篡改引用指向的对象" class="headerlink" title="题外话: 尝试篡改引用指向的对象"></a>题外话: 尝试篡改引用指向的对象</h3><p>等等, 引用的内存也是在栈中的, 虽然 c++ 不让我用光明正大的方式修改它</p>
<p>但是, 既然是在栈中的数据, 那么, 我应该是可以改的, 那么就来试一下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int i &#x3D; 100;</span><br><span class="line">int i2 &#x3D; 200;</span><br><span class="line">int &amp;ref_i &#x3D; i;</span><br><span class="line"></span><br><span class="line">long long *desc &#x3D; (long long *)(&amp;i) + 1;&#x2F;&#x2F; 经过计算, i 的地址往上 8 个字节就是引用对象的内存</span><br><span class="line">char arr[64];	</span><br><span class="line">sprintf(arr, &quot;%ld&quot;, &amp;i2);	&#x2F;&#x2F; 将 &amp;i2 解释为ld类型数据, 放入数组中</span><br><span class="line">string s(arr);				&#x2F;&#x2F; 构建string对象, 主要是为了能使用 stoll (눈_눈)</span><br><span class="line"></span><br><span class="line">printf(&quot;%d\n&quot;, ref_i);		&#x2F;&#x2F; 100</span><br><span class="line">*desc &#x3D; stoll(s);			&#x2F;&#x2F; 现在, 它里面存储的数据是 i2 的地址了</span><br><span class="line">printf(&quot;%d\n&quot;, ref_i);		&#x2F;&#x2F; 200  成功了, 它指向了 i2  (￣ˇ￣)</span><br><span class="line">i2 &#x3D; 300;</span><br><span class="line">printf(&quot;%d\n&quot;, ref_i);		&#x2F;&#x2F; 300 再次验证, 没错, 我们更改了引用指向的对象</span><br></pre></td></tr></table></figure>

<p>汇编就不用看了, 因为这个程序就是根据自己脑补汇编中的样子来编写的</p>
<p>同理, 常量, 常量指针, 这些东西只要绕过编译器设的障碍就可以修改 (突然感受到了指针的魅力)</p>
<p>注: 经测试, 代码在 4.4 版本下的编译器可以, 而 4.8 版本的就不行</p>
]]></content>
  </entry>
  <entry>
    <title>other/sed</title>
    <url>/2020/01/09/other/sed/</url>
    <content><![CDATA[<h1 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h1><p>sed常用于处理文件, 它会逐行执行</p>
<h3 id="基础选项"><a href="#基础选项" class="headerlink" title="基础选项"></a>基础选项</h3><h4 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h4><p>s选项用于替换</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed 's/text/val/' f.txt</span><br></pre></td></tr></table></figure>

<p>以上语句会将 f.txt 文本中的 text 替换成 val</p>
<p>@note: 但实际不会更改文件内容, 而仅仅是替换后打印出来</p>
<p>​    如果想作用于文件, 需要结合 -i 参数</p>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>d选项删除</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed '/text/d' f.txt</span><br></pre></td></tr></table></figure>

<p>以上语句会将f.txt 文本中出现 text 的行删除</p>
<p>@btw: 为什么这里的 d 在后面?</p>
<h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><p>c选项用于修改</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">sed <span class="string">'/text/c test2'</span> f.txt</span><br></pre></td></tr></table></figure>

<p>以上语句会将f.txt 文本中出现 text 的行修改成 test2</p>
<p>@note: 修改会修改整个一行</p>
<p>@btw: </p>
<p>​    从语义上来讲的话, 貌似理解成替换要合理一些. 因为是替换掉了整个一行</p>
<p>​    但是 c 选项的完整单词是 change(修改), 而 s 选项的完整单词是 substitute(替换)</p>
<p>​    所以, 遵从编写者的原意, 这里理解为修改整个一行</p>
<h4 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h4><p>y选项用于处理单个字符的转换</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed 'y/10/22/' f.txt</span><br></pre></td></tr></table></figure>

<p>以上语句会将f.txt 文本中出现的 1 转换成2, 同时 0 也会转换成 2 </p>
<p>@note: 可以将命令置于文件中, 然后使用 -f 选项指定文件</p>
<p>@btw: 替换类型的命令都是将选项置于行首, 其余均是置于行尾</p>
<h4 id="取反"><a href="#取反" class="headerlink" title="取反"></a>取反</h4><p>! 选项用于取反</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed '/text/!d' f.txt</span><br></pre></td></tr></table></figure>

<p>删除不包含 text 文本的行</p>
<p>@btw: 如果SQL也能直接取反结果集就好了 = =</p>
<h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><h4 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h4><p>n选项用于移动到下一行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed '/text val/&#123;n;d&#125;' f.txt</span><br></pre></td></tr></table></figure>

<p>当这条语句匹配到 text val 时, 会跳转到下一行, 然后删除行(删除的是匹配行的下一行)</p>
<h4 id="合并两行"><a href="#合并两行" class="headerlink" title="合并两行"></a>合并两行</h4><p>N选项用于将两行的数据视为一行来处理</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed '/text val/&#123;N;d&#125;' f.txt</span><br></pre></td></tr></table></figure>

<p>这条语句会将匹配行, 及匹配行的下一行, 当做一行处理(一起删掉)</p>
<p>@btw: 同样的格式还有</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed 'N; /text val/d' f.txt</span><br></pre></td></tr></table></figure>

<p>它会完成和上个指令一样的操作</p>
<h4 id="选择性删除"><a href="#选择性删除" class="headerlink" title="选择性删除"></a>选择性删除</h4><p>D选项… 怎么说呢 = = , 看实例吧</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed '/text val/&#123;N;/val text/D&#125;' f.txt</span><br></pre></td></tr></table></figure>

<p>当某一行有 text val 时, 并且下一行有 val text 时</p>
<p>D选项会删除前一个匹配行(也就是说 text val 所在的行会被删除)</p>
<h4 id="多行打印"><a href="#多行打印" class="headerlink" title="多行打印"></a>多行打印</h4><p>emmmm, 略(并不是说不会, 而是感觉没什么用)</p>
<p>(N和D其实运用上已经很少了, P就更少了…)</p>
<h3 id="保持空间"><a href="#保持空间" class="headerlink" title="保持空间"></a>保持空间</h3><p>emmmm, 略</p>
<p>(倒不是说保持空间没用, 相反, 保持空间在某些特定的场合)</p>
<p>(它能起到独一无二的作用, 但是现在对于我来说, 了解一下就好 = =)</p>
<h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>b选项用于跳过一些分支(b完整的单词是 branch, 但是我觉得 break 怎么更好 = =)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed '&#123;2, 3b; s/10/\\/&#125;' f.txt</span><br></pre></td></tr></table></figure>

<p>命令会将 10 替换成 \ , 但是会跳过 2 - 3 行</p>
<p>@btw: 分支可以指定标识符, 就像goto一样. 这里就直接给一个书上的例子</p>
<p><img src="https://i.imgur.com/aKj1l7Q.png" alt=""></p>
<p>emmmm, 将第一行标记(其实也只有第一行)</p>
<p>每次将一个逗号删除(其实是替换), 循环替换</p>
<p>@btw:</p>
<p>​    看似很厉害, 实则没啥用, 因为可以用 g </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">```shell</span><br><span class="line">'s/,//g'</span><br><span class="line">```</span><br></pre></td></tr></table></figure>

<p>​    上述选项将会做出同样的效果</p>
<p>​    emmm, 我是不是忘了说 g ?</p>
<p>​    g 代表修改会作用于一整行, 当然 也可以使用数字来指定</p>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>略</p>
<h3 id="模式替代"><a href="#模式替代" class="headerlink" title="模式替代"></a>模式替代</h3><h4 id="通配符-amp"><a href="#通配符-amp" class="headerlink" title="通配符 &amp;"></a>通配符 &amp;</h4><p>&amp; 用于匹配模式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed 's/.0/"&amp;"/g' f.txt</span><br></pre></td></tr></table></figure>

<p>&amp; 匹配整个模式, 以上语句将会用 “” 把所有 0 及 0前面 的支付括起来</p>
<p>也可以使用单个模式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed 's/\(.\)\(0\)/\1 32/g' f.txt</span><br></pre></td></tr></table></figure>

<p>() 括起来的部分视为一个模式, \1 引用一个模式</p>
<p>上述语句将会把所有以 .0 的语句替换为 . 32 </p>
<p>@note: </p>
<p>​    这个例子将会只保留 . 匹配的内容, 而 &amp; 将会保留所有内容</p>
<p>​    &amp; 模式匹配是我在进阶章里面看到的最有用的东西</p>
<p>emmm, 关于 sed 的内容还有一些, 不过现在就先到这里吧 = =</p>
<p>@supplement</p>
<p>​    模式匹配: 增/删/改中可以运用模式匹配</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed '/test/i\this is a test' t.txt</span><br></pre></td></tr></table></figure>

<p>​    这条语句将会在有 test 字符串的那一行, 执行插入操作</p>
]]></content>
  </entry>
  <entry>
    <title>other/some useful define</title>
    <url>/2020/01/09/other/some%20useful%20define/</url>
    <content><![CDATA[<h2 id="保留条件表达式的第一个值"><a href="#保留条件表达式的第一个值" class="headerlink" title="保留条件表达式的第一个值"></a>保留条件表达式的第一个值</h2><pre><code>// CE: condition expression, RETAIN: 保持
#define CE_RETAIN1(a, b) ((a) ? (a) : (b))</code></pre><p>考虑一个情况, 当一个值有效时, 使用它, 否则使用另外一个数<br>如果直接写的话, 不太容易理解  </p>
<pre><code>(exp) ? (exp) : -1;</code></pre><p>当exp非常长的时候(或许可以保存成变量, 但是某些情况下, 不知道该用什么名字<br>而自己比较常用变量名差不多用光了, 或者这只是个只用一次的值), 如  </p>
<pre><code>val = func(a) * i + 10 ? func(a) * i + 10 : -1;</code></pre><p>而如果用宏定义的话就比较清晰了</p>
<pre><code>val = CE_RETAIN1(func(a) * i + 10, -1);</code></pre><p>PS: 但是如果的确出现表达式过长的情况, 可能考虑优化代码是最好的解决方案</p>
<h2 id="直接面向结果的函数"><a href="#直接面向结果的函数" class="headerlink" title="直接面向结果的函数"></a>直接面向结果的函数</h2><pre><code>void show() { setvisible(true); }    
void hide() { setvisible(false); }</code></pre><p>使用show(), hide()的情况下, 一目了然, 而通过参数的话, 理解会稍麻烦一些</p>
<h2 id="getInstance"><a href="#getInstance" class="headerlink" title="getInstance"></a>getInstance</h2><p>getInstance多数情况下作为一个类的公有接口, 用于获得一个实例<br>普通的书写方案如下        </p>
<pre><code>class A{
    int i; // 不仅仅是数据, 也可能是一个类
public:
    int&amp; getInstance() { return i; }
};</code></pre><p>使用这种方式的情况会存在两个问题  </p>
<ol>
<li>即使我从不使用i, 也从未掉用过getInstance这个函数, 但依旧给i分配了空间  </li>
<li>i依旧能在其他接口中被访问  </li>
</ol>
<p>上述两种情况并不一定会造成影响, 但可以考虑排除这种隐藏问题  </p>
<pre><code>int&amp; getInstance() {
    static int i;

    return i;
}</code></pre><p>静态变量在未被访问过的情况下, 不会分配空间<br>并且只存在于当前作用域, 有良好的安全性</p>
]]></content>
  </entry>
  <entry>
    <title>other/some useful skill</title>
    <url>/2020/01/09/other/some%20useful%20skill/</url>
    <content><![CDATA[<h2 id="保留条件表达式的第一个值"><a href="#保留条件表达式的第一个值" class="headerlink" title="保留条件表达式的第一个值"></a>保留条件表达式的第一个值</h2><pre><code>// CE: condition expression, RETAIN: 保持
#define CE_RETAIN1(a, b) ((a) ? (a) : (b))</code></pre><p>考虑一个情况, 当一个值有效时, 使用它, 否则使用另外一个数<br>如果直接写的话, 不太容易理解  </p>
<pre><code>(exp) ? (exp) : -1;</code></pre><p>当exp非常长的时候(或许可以保存成变量, 但是某些情况下, 不知道该用什么名字<br>而自己比较常用变量名差不多用光了, 或者这只是个只用一次的值), 如  </p>
<pre><code>val = func(a) * i + 10 ? func(a) * i + 10 : -1;</code></pre><p>而如果用宏定义的话就比较清晰了</p>
<pre><code>val = CE_RETAIN1(func(a) * i + 10, -1);</code></pre><p>PS: 但是如果的确出现表达式过长的情况, 可能考虑优化代码是最好的解决方案</p>
<h2 id="直接面向结果的函数"><a href="#直接面向结果的函数" class="headerlink" title="直接面向结果的函数"></a>直接面向结果的函数</h2><pre><code>void show() { setvisible(true); }    
void hide() { setvisible(false); }</code></pre><p>使用show(), hide()的情况下, 一目了然, 而通过参数的话, 理解会稍麻烦一些</p>
<h2 id="getInstance"><a href="#getInstance" class="headerlink" title="getInstance"></a>getInstance</h2><p>getInstance多数情况下作为一个类的公有接口, 用于获得一个实例<br>普通的书写方案如下        </p>
<pre><code>class A{
    int i; // 不仅仅是数据, 也可能是一个类
public:
    int&amp; getInstance() { return i; }
};</code></pre><p>使用这种方式的情况会存在两个问题  </p>
<ol>
<li>即使我从不使用i, 也从未掉用过getInstance这个函数, 但依旧给i分配了空间  </li>
<li>i依旧能在其他接口中被访问  </li>
</ol>
<p>上述两种情况并不一定会造成影响, 但可以考虑排除这种隐藏问题  </p>
<pre><code>int&amp; getInstance() {
    static int i;

    return i;
}</code></pre><p>静态变量在未被访问过的情况下, 不会分配空间<br>并且只存在于当前作用域, 有良好的安全性</p>
<h2 id="保存变量"><a href="#保存变量" class="headerlink" title="保存变量"></a>保存变量</h2><p>局部变量速度优于函数调用, 类似如果频繁用到数组的长度, 可以使用变量保存.size()的值</p>
]]></content>
  </entry>
  <entry>
    <title>other/sort</title>
    <url>/2020/01/09/other/sort/</url>
    <content><![CDATA[<p><a href="https://www.hackerearth.com/zh/practice/algorithms/sorting/bubble-sort/tutorial/" target="_blank" rel="noopener">source link</a></p>
<h2 id="Sort"><a href="#Sort" class="headerlink" title="Sort"></a>Sort</h2><h3 id="Bubble-Sort"><a href="#Bubble-Sort" class="headerlink" title="Bubble Sort"></a>Bubble Sort</h3><p>Bubble is the most common algorithm to sort an array. It based on the idea of repeatedly comparing adjacent element and then swapping their  value if exist in the wrong order </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[j])</span><br><span class="line">                swap(nums[i], nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Selection-sort"><a href="#Selection-sort" class="headerlink" title="Selection sort"></a>Selection sort</h3><p>The selection sort is based on finding the minimum or maximum in an unsorted array and putting it to a sorted array</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">min</span> = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[<span class="built_in">min</span>] &gt; nums[j])</span><br><span class="line">                <span class="built_in">min</span> = j;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums[i], nums[<span class="built_in">min</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Insertion-sort"><a href="#Insertion-sort" class="headerlink" title="Insertion sort"></a>Insertion sort</h3><p>From left to right, find each element’s correct position</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = nums[i];</span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        <span class="keyword">while</span>(j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            nums[j] = nums[j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &lt;= v)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            --j;                            </span><br><span class="line">        &#125;</span><br><span class="line">        nums[j] = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Merge-sort"><a href="#Merge-sort" class="headerlink" title="Merge sort"></a>Merge sort</h3><p>Merge sort is a divide-and-conquer algorithm based on repeatedly breaking down an array to two sub-array and then merge them</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> b, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = (b + e) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> q = m + <span class="number">1</span>, p = b;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = b; i &lt;= e; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p &gt; m)</span><br><span class="line">            v.push_back(nums[q++]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (q &gt; e)</span><br><span class="line">            v.push_back(nums[p++]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[q] &gt; nums[p])</span><br><span class="line">            v.push_back(nums[p++]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            v.push_back(nums[q++]);              </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> val : v)</span><br><span class="line">        nums[b++] = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> b, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b &gt;= e) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    mergeSort(nums, b, (e + b) / <span class="number">2</span>);</span><br><span class="line">    mergeSort(nums, (e + b) / <span class="number">2</span> + <span class="number">1</span>, e);</span><br><span class="line">    merge(nums, b, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Quick-sort"><a href="#Quick-sort" class="headerlink" title="Quick sort"></a>Quick sort</h3><p>Quick sort is also a divide-and-conquer algorithm. But it reduces the space complexity and removes the use of auxiliary array that is used in merger sort<br>One of the most important factors to influence performance is the pivot.<br>I chose the pivot from the middle, front, and back of the array. Sometimes will improve performance</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partion</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> b, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = e;</span><br><span class="line">    <span class="keyword">int</span> m = (b + e) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (nums[b] &gt; nums[m])</span><br><span class="line">        swap(nums[b], nums[m]);</span><br><span class="line">    <span class="keyword">if</span> (nums[b] &gt; nums[e])</span><br><span class="line">        swap(nums[b], nums[e]);</span><br><span class="line">    <span class="keyword">if</span> (nums[m] &gt; nums[e])</span><br><span class="line">        swap(nums[m], nums[e]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> piv = nums[m];</span><br><span class="line">    swap(nums[e--], nums[m]);</span><br><span class="line">    <span class="keyword">while</span> (b &lt; e) &#123;</span><br><span class="line">        <span class="keyword">while</span> (b &lt; e &amp;&amp; nums[b] &lt; piv)</span><br><span class="line">            ++b;</span><br><span class="line">        <span class="keyword">while</span> (b &lt; e &amp;&amp; nums[e] &gt;= piv)</span><br><span class="line">            --e;</span><br><span class="line">        <span class="keyword">if</span> (b &gt;= e) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        swap(nums[b], nums[e]);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(nums[p], nums[b]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> b, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b &gt;= e) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> p = partion(nums, b, e);</span><br><span class="line">    quickSort(nums, b, p - <span class="number">1</span>);</span><br><span class="line">    quickSort(nums, p + <span class="number">1</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Heap-sort"><a href="#Heap-sort" class="headerlink" title="Heap sort"></a>Heap sort</h3><p>Heap sort uses a structure called heap to sort the array. Heap is a complete binary tree.<br>left sub-tree index = 2 * root index + 1<br>right sub-tree index = 2 * root index + 2</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> n, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> largest = i;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> r = l + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l &lt; n &amp;&amp; nums[l] &gt; nums[largest])</span><br><span class="line">        largest = l;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r &lt; n &amp;&amp; nums[r] &gt; nums[largest])</span><br><span class="line">        largest = r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">        swap(nums[i], nums[largest]);</span><br><span class="line">        heapify(nums, n, largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;                </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.<span class="built_in">size</span>() / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        heapify(nums, nums.<span class="built_in">size</span>(), i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        swap(nums[<span class="number">0</span>], nums[i]);</span><br><span class="line">        heapify(nums, i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>other/sort2</title>
    <url>/2020/01/09/other/sort2/</url>
    <content><![CDATA[<p>this is a follow-up to <a href="http://49.235.55.145/html_note/sort.html" target="_blank" rel="noopener">sort</a></p>
<p>these sort algorithms based on &lt;Algorithms, 4th&gt;</p>
<h2 id="shell-sort"><a href="#shell-sort" class="headerlink" title="shell sort"></a>shell sort</h2><p>shell sort is a better version sort algorithm based on insert sort.</p>
<p>when a[0] is the biggest number but head of array, for move the number to the end of the array, need swap length(a) elements. </p>
<p>shell sort 是基于插入排序的改良版本</p>
<p>当 a[0] 是整个数组最大的元素时, 为了移动这个元素到数组的尾端, 需要交换 length(a) 次元素. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (h &lt; v.<span class="built_in">size</span>() / <span class="number">3</span>) h = h * <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (h &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = h; j &lt; v.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = j; i &gt;= h &amp;&amp; v[i] &lt; v[i - h]; i -= h)</span><br><span class="line">                swap(v[i], v[i - h]);                         </span><br><span class="line">        &#125;</span><br><span class="line">        h /= <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="bottom-up-sort"><a href="#bottom-up-sort" class="headerlink" title="bottom-up sort"></a>bottom-up sort</h2><p>bottom-up sort is a down-top method based on merge sort.</p>
<p>bottom-up sort 基于合并排序, 是一种从底至上的方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v, <span class="keyword">int</span> b, <span class="keyword">int</span> m, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2 = v;</span><br><span class="line">    <span class="keyword">int</span> mid = m++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = b; i &lt;= e; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &gt; mid)</span><br><span class="line">            v[i] = v2[m++];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (m &gt; e)</span><br><span class="line">            v[i] = v2[b++];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (v2[b] &lt; v2[m])</span><br><span class="line">            v[i] = v2[b++];</span><br><span class="line">        <span class="keyword">else</span>·</span><br><span class="line">            v[i] = v2[m++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bottomupSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; v.<span class="built_in">size</span>(); i *= <span class="number">2</span>)&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; v.<span class="built_in">size</span>() - i; j = j + <span class="number">2</span> * i)</span><br><span class="line">			merge(v, j, j + i <span class="number">-1</span>, <span class="built_in">min</span>(<span class="keyword">int</span>(v.<span class="built_in">size</span>() - <span class="number">1</span>, j + <span class="number">2</span> * i - <span class="number">1</span>)));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="a-better-version-of-quick-sort"><a href="#a-better-version-of-quick-sort" class="headerlink" title="a better version of quick sort"></a>a better version of quick sort</h2><p>if an array with some duplicate numbers,  skip these numbers will be more effective</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QS_MIN_LENGTH 7</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> b, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b &gt;= e) <span class="keyword">return</span>;                          </span><br><span class="line"></span><br><span class="line">    <span class="comment">// if element too little, insertSort more effective than quickSort</span></span><br><span class="line">    <span class="keyword">if</span> (e - b &lt; QS_MIN_LENGTH)</span><br><span class="line">        insertSort(nums, b, e);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// meduim of three can get more effetive pivot</span></span><br><span class="line">    <span class="keyword">int</span> m = (b + e) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (nums[b] &gt; nums[m])</span><br><span class="line">        swap(nums[b], nums[m]);</span><br><span class="line">    <span class="keyword">if</span> (nums[b] &gt; nums[e])</span><br><span class="line">        swap(nums[b], nums[e]);</span><br><span class="line">    <span class="keyword">if</span> (nums[m] &gt; nums[e])</span><br><span class="line">        swap(nums[m], nums[e]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pivot = nums[m];</span><br><span class="line">    <span class="comment">// skip elements equal pivot</span></span><br><span class="line">    <span class="keyword">int</span> lt = b + <span class="number">1</span>, eq = lt, gt = e - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (eq &lt;= gt) &#123; </span><br><span class="line">        <span class="keyword">if</span> (nums[eq] &lt; pivot)</span><br><span class="line">            swap(nums[lt++], nums[eq++]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[eq] &gt; pivot)</span><br><span class="line">            swap(nums[eq], nums[gt--]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            eq++;</span><br><span class="line">    &#125;       </span><br><span class="line"></span><br><span class="line">    quickSort(nums, b, lt - <span class="number">1</span>);</span><br><span class="line">    quickSort(nums, gt + <span class="number">1</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="a-sort-algorithm-without-compare"><a href="#a-sort-algorithm-without-compare" class="headerlink" title="a sort algorithm without compare"></a>a sort algorithm without compare</h3><p>I saw a string sort algorithm without compare in &lt;algorithm 4th&gt;. so take some notes</p>
<p>I’m to lazy to write this code, please check the book…</p>
]]></content>
  </entry>
  <entry>
    <title>other/useful skill</title>
    <url>/2020/01/09/other/useful%20skill/</url>
    <content><![CDATA[<h4 id="vim中执行cmd"><a href="#vim中执行cmd" class="headerlink" title="vim中执行cmd"></a>vim中执行cmd</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">!cmd</span><br></pre></td></tr></table></figure>



<h4 id="vim中编写额外的文件"><a href="#vim中编写额外的文件" class="headerlink" title="vim中编写额外的文件"></a>vim中编写额外的文件</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">args filename</span><br></pre></td></tr></table></figure>



<h4 id="sed处理文件"><a href="#sed处理文件" class="headerlink" title="sed处理文件"></a>sed处理文件</h4><h4 id="at和crontab定时"><a href="#at和crontab定时" class="headerlink" title="at和crontab定时"></a>at和crontab定时</h4><h4 id="流重定向"><a href="#流重定向" class="headerlink" title="流重定向"></a>流重定向</h4><p>“&gt;”:  输出重定向, 这个操作符会覆盖已有文件的内容, 若文件不存在, 则创建</p>
<p>“&gt;&gt;”: 同样也是输出重定向, 这个操作符会将内容添加到文件尾部, 同样的, 若文件不存在, 则创建文件</p>
<p>@note:</p>
<p>​    比较特殊的是内联输入重定向: “&lt;&lt;”, 我现在也不太明白这东西的实质用法和含义</p>
<p>​    只知道它的行为: 它可以使用命令行的内容作为输入流, 并且可以指定一个”标识”来表示结束</p>
<h4 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h4><p>@brief: </p>
<p>​    将一个命令的输出作为另一个命令的输入. 例如:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat file | less</span><br></pre></td></tr></table></figure>

<p>cat仅仅只是查看文件, 但并不会增加一些控制功能(如翻页, 搜索…)  </p>
<p>less则提供了相关的更高级的功能, 将cat的输入(文件内容)作为less的输入</p>
<p>@note: </p>
<p>​    其实这个例子很没有必要, 现实中这么写, 可能会被diss到死. 因为可以直接使用 less file</p>
<h4 id="创建一个新文件"><a href="#创建一个新文件" class="headerlink" title="创建一个新文件"></a>创建一个新文件</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">touch file</span><br></pre></td></tr></table></figure>



<h4 id="置空文件内容"><a href="#置空文件内容" class="headerlink" title="置空文件内容"></a>置空文件内容</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /dev/null &gt; file</span><br></pre></td></tr></table></figure>

<p>@note: </p>
<p>​    更加简便的方式是 &gt; file</p>
<h4 id="单引号和双引号"><a href="#单引号和双引号" class="headerlink" title="单引号和双引号"></a>单引号和双引号</h4><p>需要注意的是, 单引号中, 双引号不需要转义.</p>
<p>同样的, 双引号中, 单引号不需要转义</p>
<p>这会在某些场合下, 让你的字符串更加简洁易懂, 同时还更好改, 更不容易写错</p>
<p>@ps:</p>
<p>​    我曾在一次 crontab 任务中遇到这种场合, 我使用了 crontab file 的形式来添加任务</p>
<p>​    同时使用 echo + 重定向 的形式往文件中添加内容, 而要执行的命令中就包含些许单引号和双引号</p>
<p>​    (不过我倒是没有在这里面用到这个技巧, 因为我第一次就写对了 :) )</p>
<h4 id="md5加密"><a href="#md5加密" class="headerlink" title="md5加密"></a>md5加密</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo "test" | md5sum</span><br></pre></td></tr></table></figure>



<h4 id="查看自己的公网信息"><a href="#查看自己的公网信息" class="headerlink" title="查看自己的公网信息"></a>查看自己的公网信息</h4><pre><code>curl cip.cc</code></pre><p>简析: curl 为一个在服务器中传递数据的攻击, 而 cip.cc 为一个查询网络信息的网站  </p>
<p>当你登录 cip.cc 时, 它应当会根据你访问网站时的信息, 查询你 IP 的相关信息, 并返还给你</p>
<h4 id="传递大量文件-远端和本地"><a href="#传递大量文件-远端和本地" class="headerlink" title="传递大量文件(远端和本地)"></a>传递大量文件(远端和本地)</h4><pre><code>rsync</code></pre><p>具体用法参照 man 手册</p>
<h4 id="查看本地IP端口信息"><a href="#查看本地IP端口信息" class="headerlink" title="查看本地IP端口信息"></a>查看本地IP端口信息</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat -tunlp</span><br></pre></td></tr></table></figure>

<p>t : TCP</p>
<p>u : UDP</p>
<p>n : 不经过域名服务器</p>
<p>l : 显示监控中服务器的socket</p>
<p>p : 显示监控中的程序识别码和名称    </p>
<p>@btw: 可以加入 -a 选项, 这会将所有(包括当前未监听)的端口信息都列出来</p>
<p>​    与之相关的命令还有 nmap, nc</p>
<h4 id="查看本机服务"><a href="#查看本机服务" class="headerlink" title="查看本机服务"></a>查看本机服务</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service --status-all | grep running</span><br></pre></td></tr></table></figure>

<p>这个命令可以查看本机现在运行的所有服务</p>
<p>@note: –status-all 之间不能空格.  “–status -all” 这是错误的写法</p>
]]></content>
  </entry>
  <entry>
    <title>other/virtualFunction</title>
    <url>/2020/01/09/other/virtualFunction/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>想深入了解一下(或者说验证)对象底层是如何工作的</p>
<p>重点是虚函数的调用, 虚指针的生成, 虚表中的数据</p>
<p>以及这些数据在多重继承, 虚继承, 多重虚继承环境下的表现</p>
<h3 id="虚指针-virtual-point"><a href="#虚指针-virtual-point" class="headerlink" title="虚指针(virtual point)"></a>虚指针(virtual point)</h3><p>考虑以下代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"A %d\n"</span>, _i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"A2 %d\n"</span>, _i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> _i = <span class="number">10</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"B %d\n"</span>, _i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> _i = <span class="number">20</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    A *pa = &amp;b;</span><br><span class="line">    </span><br><span class="line">    pa-&gt;func();		<span class="comment">// B 20</span></span><br><span class="line">    pa-&gt;func2();	<span class="comment">// A2 10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出和预期一致, 其中 func 是被 B 覆盖过的虚函数, 而 func2 则未被覆盖</p>
<p>以下是生成的汇编代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">main:</span><br><span class="line">.LFB1199:</span><br><span class="line">    pushq   %rbp</span><br><span class="line">    movq    %rsp, %rbp</span><br><span class="line">    subq    $32, %rsp</span><br><span class="line">    movq    $_ZTV1B+16, -32(%rbp)	&#x2F;&#x2F; 又是这个东西, 现在我怀疑它是 lippman 说的 thunk</span><br><span class="line">    							&#x2F;&#x2F; 后面知道了, **其实这就是虚指针, 它被放到了头部**</span><br><span class="line">    							&#x2F;&#x2F; 编译器非常聪明, 在即使有 vptr, nontrivial 的情况下</span><br><span class="line">    							&#x2F;&#x2F; 也并未生成构造函数</span><br><span class="line">    movl    $10, -24(%rbp)	</span><br><span class="line">    movl    $20, -20(%rbp)</span><br><span class="line">    leaq    -32(%rbp), %rax</span><br><span class="line">    movq    %rax, -8(%rbp)</span><br><span class="line">    movq    -8(%rbp), %rax</span><br><span class="line">    movq    (%rax), %rax	&#x2F;&#x2F; rax &#x3D; vptr	拿到虚指针地址</span><br><span class="line">    movq    (%rax), %rax	&#x2F;&#x2F; rax &#x3D; *vptr	获得虚指针中的地址(槽 0)</span><br><span class="line">    movq    -8(%rbp), %rdx	&#x2F;&#x2F; member data 是直接位移得到的</span><br><span class="line">    movq    %rdx, %rdi</span><br><span class="line">    call    *%rax		&#x2F;&#x2F; 调用slot0</span><br><span class="line">    movq    -8(%rbp), %rax</span><br><span class="line">    movq    (%rax), %rax</span><br><span class="line">    addq    $8, %rax	&#x2F;&#x2F; 虚指针地址 +8 位移(也就是下一个槽)</span><br><span class="line">    movq    (%rax), %rax	&#x2F;&#x2F; 获得 slot1 的地址</span><br><span class="line">    movq    -8(%rbp), %rdx</span><br><span class="line">    movq    %rdx, %rdi</span><br><span class="line">    call    *%rax	&#x2F;&#x2F; 调用slot1</span><br><span class="line">    movl    $0, %eax</span><br><span class="line">    leave</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>

<p>所以调用方式和书中一致, 从 vptr 索引虚表, 获得相应的 slot</p>
<p>这些信息全部都是在编译的时候由编译器生成</p>
<p>有一个点我忽略了: <strong>单一继承对象只有一个虚表</strong></p>
<p>后续我加上 C 对象后( C 继承自 A ), 让 B 继承 A, 这样A中就有 B C</p>
<p>但是依旧只有一个虚表, 仅当我让A再继承一个对象时, 这时产生了 2 个虚表</p>
<p>可能会问, 那么C对象是如何通过 pc-&gt;A::func() 这样的形式来调用 A 作用域的函数的呢?</p>
<p>答案是, 这会是一个单纯的函数调用, 并不会通过虚表或虚指针, 也没有任何的偏移</p>
<p>(emmm… 也就是说普通成员函数对于类来说, 可能更像是个陌生人, 即使它是成员)</p>
<p>(这也是为什么大多数情况下基类需要 virtual destruct 的原因)</p>
<h3 id="虚析构是如何被调用的"><a href="#虚析构是如何被调用的" class="headerlink" title="虚析构是如何被调用的"></a>虚析构是如何被调用的</h3><p>在写标题的时候大概猜到了, 其实虚析构就是一个在子类中占了一个不能被重写的虚表槽</p>
<p>应该就是通过简单的偏移来调用的, 来试一下</p>
<p>(重点在于虚析构是不可能被覆盖的, 因为子类中不可能存在同名的函数)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="number">5</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"> <span class="number">6</span> <span class="keyword">public</span>:</span><br><span class="line"> <span class="number">7</span>     <span class="keyword">virtual</span> ~A() &#123;</span><br><span class="line"> <span class="number">8</span>         <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, <span class="string">"A destruct"</span>);</span><br><span class="line"> <span class="number">9</span>     &#125;</span><br><span class="line"><span class="number">10</span> &#125;;</span><br><span class="line"><span class="number">11</span> </span><br><span class="line"><span class="number">12</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="number">13</span> <span class="keyword">public</span>:</span><br><span class="line"><span class="number">14</span>     <span class="keyword">virtual</span> ~B() &#123;</span><br><span class="line"><span class="number">15</span>         <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, <span class="string">"B destruct"</span>);</span><br><span class="line"><span class="number">16</span>     &#125;</span><br><span class="line"><span class="number">17</span> &#125;;</span><br><span class="line"><span class="number">18</span> </span><br><span class="line"><span class="number">19</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="number">20</span>     B a;</span><br><span class="line"><span class="number">21</span> </span><br><span class="line"><span class="number">22</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">23</span> &#125;</span><br></pre></td></tr></table></figure>

<p>汇编:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">161 main:</span><br><span class="line">162 .LFB1204:</span><br><span class="line">163     .cfi_startproc</span><br><span class="line">164     pushq   %rbp</span><br><span class="line">165     .cfi_def_cfa_offset 16</span><br><span class="line">166     .cfi_offset 6, -16</span><br><span class="line">167     movq    %rsp, %rbp</span><br><span class="line">168     .cfi_def_cfa_register 6</span><br><span class="line">169     pushq   %rbx</span><br><span class="line">170     subq    $24, %rsp</span><br><span class="line">171     .cfi_offset 3, -24</span><br><span class="line">172     movq    $_ZTV1B+16, -32(%rbp)</span><br><span class="line">173     movl    $0, %ebx</span><br><span class="line">174     leaq    -32(%rbp), %rax</span><br><span class="line">175     movq    %rax, %rdi</span><br><span class="line">176     call    _ZN1BD1Ev	&#x2F;&#x2F; 就是这里调用了析构函数</span><br><span class="line">177     movl    %ebx, %eax</span><br><span class="line">178     addq    $24, %rsp</span><br><span class="line">179     popq    %rbx</span><br><span class="line">180     popq    %rbp</span><br><span class="line">181     .cfi_def_cfa 7, 8</span><br><span class="line">182     ret</span><br><span class="line">183     .cfi_endproc</span><br></pre></td></tr></table></figure>

<p>B的析构:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 89 _ZN1BD2Ev:	&#x2F;&#x2F; 如果足够细心, 那么注意到了这里是 _ZN1BD2Ev 而并非 _ZN1BD1Ev</span><br><span class="line"> 				&#x2F;&#x2F; 对此, 我发现编译器类似有个中间层一样的东西(或者说会符号替换?)</span><br><span class="line"> 				&#x2F;&#x2F; 然后其实会跳转到这里来, 汇编中将这两个东西相关联</span><br><span class="line"> 90 .LFB1201:</span><br><span class="line"> 91     .cfi_startproc</span><br><span class="line"> 92     .cfi_personality 0x3,__gxx_personality_v0</span><br><span class="line"> 93     .cfi_lsda 0x3,.LLSDA1201</span><br><span class="line"> 94     pushq   %rbp</span><br><span class="line"> 95     .cfi_def_cfa_offset 16</span><br><span class="line"> 96     .cfi_offset 6, -16</span><br><span class="line"> 97     movq    %rsp, %rbp</span><br><span class="line"> 98     .cfi_def_cfa_register 6</span><br><span class="line"> 99     subq    $16, %rsp</span><br><span class="line">100     movq    %rdi, -8(%rbp)</span><br><span class="line">101     movq    -8(%rbp), %rax</span><br><span class="line">102     movq    $_ZTV1B+16, (%rax)</span><br><span class="line">103     movl    $.LC1, %edi</span><br><span class="line">104     call    puts	&#x2F;&#x2F; 编译器知道只是打印一个字符串, 所以调用的是 puts</span><br><span class="line">105     movq    -8(%rbp), %rax</span><br><span class="line">106     movq    %rax, %rdi</span><br><span class="line">107     call    _ZN1AD2Ev	&#x2F;&#x2F; 和我想的不一样, 又一样...</span><br><span class="line">108     movl    $0, %eax</span><br><span class="line">109     testl   %eax, %eax</span><br><span class="line">110     je  .L6	&#x2F;&#x2F; 这里我也不太懂, 这个不是必跳么?</span><br><span class="line">111     movq    -8(%rbp), %rax</span><br><span class="line">112     movq    %rax, %rdi</span><br><span class="line">113     call    _ZdlPv	&#x2F;&#x2F; 这个东西没有找到</span><br></pre></td></tr></table></figure>

<p>和预料中不同的是, A 的析构函数是直接调用的, 而并非偏移  </p>
<p>想了想这在意料之中, 因为编译器将它优化成了普通函数</p>
<p>至于 _ZdlPv, 没有在汇编中找到这个符号 … </p>
<p>(我试了一下, 没有什么好的方式让它像被虚函数一样调用, 很可惜…)</p>
<h3 id="虚继承的析构函数调用"><a href="#虚继承的析构函数调用" class="headerlink" title="虚继承的析构函数调用"></a>虚继承的析构函数调用</h3><p>感觉非常奇怪, 所以本来是打算看看就好的, 因为之前花功夫去看了看虚继承的内存布局</p>
<p>不过实在太奇怪了, 所以打算好好分析一下, 顺便我在之前分析的时候好像忘了看虚继承的虚函数调用了</p>
<p>因为那时候好像已经晕了… </p>
<p>它会怎么被调用呢? 最无趣的情况就是像上面那样硬编码</p>
<p>不过在虚继承这种比较复杂的环境下, 编译器可能会做出其他反应也说不定?</p>
<p>源码就单纯的E被CD虚继承, B继承CD, 这里直接汇编:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">main:</span><br><span class="line">.LFB1212:</span><br><span class="line">    .cfi_startproc</span><br><span class="line">    pushq   %rbp</span><br><span class="line">    .cfi_def_cfa_offset 16</span><br><span class="line">    .cfi_offset 6, -16</span><br><span class="line">    movq    %rsp, %rbp</span><br><span class="line">    .cfi_def_cfa_register 6</span><br><span class="line">    pushq   %rbx	&#x2F;&#x2F; 这里, 与前面的 pushq 无关</span><br><span class="line">    subq    $56, %rsp</span><br><span class="line">    .cfi_offset 3, -24</span><br><span class="line">    leaq    -64(%rbp), %rax	&#x2F;&#x2F; 前面有 pushq, 所以这里是 -64</span><br><span class="line">    movq    %rax, %rdi</span><br><span class="line">    call    _ZN1BC1Ev	&#x2F;&#x2F; 构造</span><br><span class="line">    movl    $0, %ebx</span><br><span class="line">    leaq    -64(%rbp), %rax</span><br><span class="line">    movq    %rax, %rdi</span><br><span class="line">    call    _ZN1BD1Ev	&#x2F;&#x2F; 析构</span><br><span class="line">    movl    %ebx, %eax</span><br><span class="line">    addq    $56, %rsp</span><br><span class="line">    popq    %rbx</span><br><span class="line">    popq    %rbp</span><br><span class="line">    .cfi_def_cfa 7, 8</span><br><span class="line">    ret</span><br><span class="line">    .cfi_endproc</span><br></pre></td></tr></table></figure>

<p>B的析构函数:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">457 _ZN1BD1Ev:</span><br><span class="line">458 .LFB1210:</span><br><span class="line">459     .cfi_startproc</span><br><span class="line">460     .cfi_personality 0x3,__gxx_personality_v0</span><br><span class="line">461     .cfi_lsda 0x3,.LLSDA1210</span><br><span class="line">462     pushq   %rbp</span><br><span class="line">463     .cfi_def_cfa_offset 16</span><br><span class="line">464     .cfi_offset 6, -16</span><br><span class="line">465     movq    %rsp, %rbp</span><br><span class="line">466     .cfi_def_cfa_register 6</span><br><span class="line">467     subq    $16, %rsp</span><br><span class="line">468     movq    %rdi, -8(%rbp)</span><br><span class="line">469     movl    $_ZTV1B+24, %edx</span><br><span class="line">470     movq    -8(%rbp), %rax</span><br><span class="line">471     movq    %rdx, (%rax)	&#x2F;&#x2F; 栈顶加入了虚指针 +24</span><br><span class="line">472     movl    $32, %edx</span><br><span class="line">473     movq    -8(%rbp), %rax</span><br><span class="line">474     addq    %rax, %rdx</span><br><span class="line">475     movl    $_ZTV1B+104, %eax</span><br><span class="line">476     movq    %rax, (%rdx)	&#x2F;&#x2F; 栈顶 -32 处加入了虚指针 +104</span><br><span class="line">477     movl    $_ZTV1B+64, %edx</span><br><span class="line">478     movq    -8(%rbp), %rax</span><br><span class="line">479     movq    %rdx, 16(%rax)	&#x2F;&#x2F; 栈顶 -16 处加入了虚指针 +64</span><br><span class="line">480     movq    -8(%rbp), %rax</span><br><span class="line">481     movl    28(%rax), %eax</span><br><span class="line">482     movl    %eax, %esi</span><br><span class="line">483     movl    $.LC3, %edi	&#x2F;&#x2F; .string &quot;B destruct: %d\n&quot;</span><br><span class="line">484     movl    $0, %eax</span><br><span class="line">485     call    printf</span><br><span class="line">486     movl    $_ZTT1B+24, %eax</span><br><span class="line">487     movq    -8(%rbp), %rdx</span><br><span class="line">488     addq    $16, %rdx</span><br><span class="line">489     movq    %rax, %rsi</span><br><span class="line">490     movq    %rdx, %rdi</span><br><span class="line">491     call    _ZN1CD2Ev	&#x2F;&#x2F; 硬编码...</span><br><span class="line">492     movl    $_ZTT1B+8, %edx</span><br><span class="line">493     movq    -8(%rbp), %rax</span><br><span class="line">494     movq    %rdx, %rsi</span><br><span class="line">495     movq    %rax, %rdi</span><br><span class="line">496     call    _ZN1AD2Ev</span><br><span class="line">497     movl    $2, %eax</span><br><span class="line">498     testl   %eax, %eax</span><br><span class="line">499     je  .L23</span><br><span class="line">500     movq    -8(%rbp), %rax</span><br><span class="line">501     addq    $32, %rax</span><br><span class="line">502     movq    %rax, %rdi</span><br><span class="line">503     call    _ZN1ED2Ev</span><br><span class="line">504     nop</span><br></pre></td></tr></table></figure>

<p>虚函数是通过硬编码来调用的  </p>
<p>不过有个非常不错的发现, 我在 _ZTT1B 中发现了 LTHUNK 的影子</p>
<p>在 _ZTT1B  中有 LTHUNK  相关的代码, 不过很可惜, 这些猜测无从证明…</p>
<p>来看看虚函数的调用吧:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">911 main:</span><br><span class="line">912 .LFB1216:</span><br><span class="line">913     .cfi_startproc</span><br><span class="line">914     .cfi_personality 0x3,__gxx_personality_v0</span><br><span class="line">915     .cfi_lsda 0x3,.LLSDA1216</span><br><span class="line">916     pushq   %rbp</span><br><span class="line">917     .cfi_def_cfa_offset 16</span><br><span class="line">918     .cfi_offset 6, -16</span><br><span class="line">919     movq    %rsp, %rbp</span><br><span class="line">920     .cfi_def_cfa_register 6</span><br><span class="line">921     pushq   %rbx</span><br><span class="line">922     subq    $88, %rsp</span><br><span class="line">923     .cfi_offset 3, -24</span><br><span class="line">924     leaq    -96(%rbp), %rax</span><br><span class="line">925     movq    %rax, %rdi</span><br><span class="line">926     call    _ZN1BC1Ev</span><br><span class="line">927     leaq    -96(%rbp), %rax</span><br><span class="line">928     movq    %rax, -24(%rbp)</span><br><span class="line">929     movq    -24(%rbp), %rax</span><br><span class="line">930     movq    (%rax), %rax	&#x2F;&#x2F; 解引用</span><br><span class="line">931     addq    $16, %rax		&#x2F;&#x2F; +16</span><br><span class="line">932     movq    (%rax), %rax	&#x2F;&#x2F; 取这个槽中的地址</span><br><span class="line">933     movq    -24(%rbp), %rdx</span><br><span class="line">934     movq    %rdx, %rdi</span><br><span class="line">935 .LEHB0:</span><br><span class="line">936     call    *%rax</span><br><span class="line">937     leaq    -96(%rbp), %rax</span><br><span class="line">938     movq    %rax, -32(%rbp)</span><br><span class="line">939     movq    -32(%rbp), %rax</span><br><span class="line">940     movq    (%rax), %rax</span><br><span class="line">941     addq    $16, %rax		&#x2F;&#x2F; +16</span><br><span class="line">942     movq    (%rax), %rax</span><br><span class="line">943     movq    -32(%rbp), %rdx</span><br><span class="line">944     movq    %rdx, %rdi</span><br><span class="line">945     call    *%rax			&#x2F;&#x2F; A, B使用了一样的虚表和槽, 仅仅是this指针不同</span><br><span class="line">946     leaq    -96(%rbp), %rax</span><br><span class="line">947     addq    $16, %rax		&#x2F;&#x2F; +16</span><br><span class="line">948     movq    %rax, -40(%rbp)</span><br><span class="line">949     movq    -40(%rbp), %rax</span><br><span class="line">950     movq    (%rax), %rax	</span><br><span class="line">951     addq    $16, %rax		&#x2F;&#x2F; +16</span><br><span class="line">952     movq    (%rax), %rax</span><br><span class="line">953     movq    -40(%rbp), %rdx</span><br><span class="line">954     movq    %rdx, %rdi</span><br><span class="line">955     call    *%rax			&#x2F;&#x2F; C 先是 +16 取到自己的虚表, 然后同样使用槽 1</span><br><span class="line">956 .LEHE0:</span><br><span class="line">957     movl    $0, %ebx</span><br><span class="line">958     leaq    -96(%rbp), %rax</span><br><span class="line">959     movq    %rax, %rdi</span><br><span class="line"> 960     call    _ZN1BD1Ev</span><br><span class="line">961     movl    %ebx, %eax</span><br><span class="line">962     jmp .L39</span><br><span class="line">963 .L38:</span><br><span class="line">964     movq    %rax, %rbx</span><br><span class="line">965     leaq    -96(%rbp), %rax</span><br><span class="line">966     movq    %rax, %rdi</span><br><span class="line">967     call    _ZN1BD1Ev</span><br><span class="line">968     movq    %rbx, %rax</span><br><span class="line">969     movq    %rax, %rdi</span><br><span class="line">970 .LEHB1:</span><br><span class="line">971     call    _Unwind_Resume</span><br><span class="line">972 .LEHE1:</span><br><span class="line">973 .L39:</span><br><span class="line">974     addq    $88, %rsp</span><br><span class="line">975     popq    %rbx</span><br><span class="line">976     popq    %rbp</span><br><span class="line">977     .cfi_def_cfa 7, 8</span><br><span class="line">978     ret</span><br><span class="line">979     .cfi_endproc</span><br></pre></td></tr></table></figure>

<p>普通虚函数的调用就是找到自己的虚表, 调用对应的槽</p>
<p>这个虚继承来的虚函数调用和普通继承的虚函数调用方式基本一致</p>
<p>多态是如何实现的呢?</p>
<p>每个构造函数, 都会覆写它的所有虚指针, 使他指向不同的地址(但是这些地址都不相同!!!)</p>
<p>如你所见, 当C指针去调用时, 发生了偏移, 虽然取到了同样的 slot, 但却不是同一张虚表</p>
<p>那么我能想到的就是有多张相同的虚表</p>
<p>(我只能如此猜测, 我想不到为什么这样的情况下还能调用同一个函数)</p>
<p>(但是为什么要有相同的呢? 这又是一个问题)</p>
<p>我尝试了看看这些虚表中是什么数据, 可惜失败了, 或者说看不懂</p>
<p>但是同一个类的虚表是完全相同的, 这可以肯定</p>
<p>不同的情况仅在于A类中C类和单独的C类, 这两个C类的虚表是不一样的</p>
<h3 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h3><p>虚函数机制和书中所说基本一致</p>
<ol>
<li>找到对应的虚表</li>
<li>调用槽中的函数</li>
</ol>
<h3 id="review"><a href="#review" class="headerlink" title="review"></a>review</h3><p>我在 objdump 的输出中发现, 诸如 _ZTI1C 这样的东西在链接的时候会转化成一个数字常量</p>
<p>有些可能会是基于某个位置的偏移(比如 %rip)</p>
<p>编译器会利用它进行直接寻址, 有些会利用它进行间接寻址</p>
]]></content>
  </entry>
  <entry>
    <title>other/virtualInherit</title>
    <url>/2020/01/09/other/virtualInherit/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>想要了解一下虚继承的内部数据结构</p>
<p>(语言: c++, 编译器: g++(4.8.5))</p>
<h3 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h3><p>考虑以下代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> _i = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> _i = <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> _i = <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B, <span class="keyword">public</span> C&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> _i = <span class="number">4</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>单纯的虚拟继承而已, 我使用了这种方式打印它们的内部数据</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">D a;</span><br><span class="line"><span class="keyword">void</span> *p = &amp;a;</span><br><span class="line"><span class="keyword">int</span> *pi = (<span class="keyword">int</span> *)p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(a) / <span class="number">4</span>; ++i)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, pi[i]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"val:%d\n"</span>, a._i);</span><br></pre></td></tr></table></figure>

<p>然后它们A, B, C, D内部数据情况如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">A: 	<span class="number">1</span></span><br><span class="line">B: 	<span class="number">4196632</span></span><br><span class="line">    <span class="number">0</span></span><br><span class="line">    <span class="number">2</span></span><br><span class="line">    <span class="number">1</span></span><br><span class="line">C: 	<span class="number">4196632</span></span><br><span class="line">    <span class="number">0</span></span><br><span class="line">    <span class="number">3</span></span><br><span class="line">    <span class="number">1</span></span><br><span class="line">D:	<span class="number">4196760</span></span><br><span class="line">    <span class="number">0</span></span><br><span class="line">    <span class="number">2</span></span><br><span class="line">    <span class="number">0</span></span><br><span class="line">    <span class="number">4196784</span></span><br><span class="line">    <span class="number">0</span></span><br><span class="line">    <span class="number">3</span></span><br><span class="line">    <span class="number">4</span></span><br><span class="line">    <span class="number">1</span></span><br><span class="line">    <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>emmm… </p>
<p>OK, 我可以把前两个 4 字节认为是虚指针(A没有) </p>
<p>那么A, B, C的内存分布就不用看了, 唯一比较特殊的是<strong>虚基类在内存的高地址</strong></p>
<p>然后D的内部分布… 这… emmm… 仔细一想, 还好, 重要的是(Q1: 为什么最后补了一个0 ??)</p>
<h3 id="存取方式"><a href="#存取方式" class="headerlink" title="存取方式"></a>存取方式</h3><p>我试着访问了一下数据</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">D a;</span><br><span class="line">A *pa = &amp;a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, pa-&gt;_i);</span><br><span class="line">B *pb = &amp;a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, pb-&gt;_i);</span><br><span class="line">C *pc = &amp;a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, pc-&gt;_i);</span><br><span class="line">D *pd = &amp;a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, pd-&gt;_i);</span><br></pre></td></tr></table></figure>

<p>来看一看汇编</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pushq   %rbp</span><br><span class="line">.cfi_def_cfa_offset 16</span><br><span class="line">.cfi_offset 6, -16</span><br><span class="line">movq    %rsp, %rbp</span><br><span class="line">.cfi_def_cfa_register 6</span><br><span class="line">subq    $80, %rsp		&#x2F;&#x2F; 80 栈帧</span><br><span class="line">leaq    -80(%rbp), %rax	</span><br><span class="line">movq    %rax, %rdi	</span><br><span class="line">call    _ZN1DC1Ev		&#x2F;&#x2F; 这里是构造函数, 稍后可能需要看看它的构造</span><br><span class="line">leaq    -80(%rbp), %rax</span><br><span class="line">addq    $32, %rax		&#x2F;&#x2F; +32, OK, 向上 32 字节的确是 1</span><br><span class="line">movq    %rax, -8(%rbp)	</span><br><span class="line">movq    -8(%rbp), %rax</span><br><span class="line">movl    (%rax), %eax</span><br><span class="line">movl    %eax, %esi</span><br><span class="line">movl    $.LC0, %edi</span><br><span class="line">movl    $0, %eax</span><br><span class="line">call    printf			&#x2F;&#x2F; 1 第一次printf</span><br><span class="line">leaq    -80(%rbp), %rax</span><br><span class="line">movq    %rax, -16(%rbp)</span><br><span class="line">movq    -16(%rbp), %rax	&#x2F;&#x2F; B 类型指针并没有经过偏移, 这和预料的一样</span><br><span class="line">movl    8(%rax), %eax	&#x2F;&#x2F; 这里+8, 跳过了虚指针</span><br><span class="line">movl    %eax, %esi</span><br><span class="line">movl    $.LC0, %edi</span><br><span class="line">movl    $0, %eax</span><br><span class="line">call    printf			&#x2F;&#x2F; 2 第二次printf</span><br><span class="line">leaq    -80(%rbp), %rax</span><br><span class="line">addq    $16, %rax		&#x2F;&#x2F; +16 C类型指针跳过了 B的内存, 这也没什么不对</span><br><span class="line">movq    %rax, -24(%rbp)</span><br><span class="line">movq    -24(%rbp), %rax	</span><br><span class="line">movl    8(%rax), %eax	&#x2F;&#x2F; 同理</span><br><span class="line">movl    %eax, %esi</span><br><span class="line">movl    $.LC0, %edi</span><br><span class="line">movl    $0, %eax</span><br><span class="line">call    printf			&#x2F;&#x2F; 3 第三次printf</span><br><span class="line">leaq    -80(%rbp), %rax</span><br><span class="line">movq    %rax, -32(%rbp)</span><br><span class="line">movq    -32(%rbp), %rax</span><br><span class="line">movl    28(%rax), %eax	&#x2F;&#x2F; +28 OK~</span><br><span class="line">movl    %eax, %esi</span><br><span class="line">movl    $.LC0, %edi</span><br><span class="line">movl    $0, %eax</span><br><span class="line">call    printf			&#x2F;&#x2F; 4 第四次printf</span><br><span class="line">movl    $0, %eax</span><br><span class="line">leave</span><br></pre></td></tr></table></figure>

<p>数据的访问在编译时就已经定好的, 不存在额外效率影响</p>
<p>A指针    偏移了 +32 字节     直接访问数据</p>
<p>B指针    未偏移             访问数据时跳过了虚指针(8字节)</p>
<p>C指针    偏移 +16 字节     访问数据时跳过了虚指针(8字节)</p>
<p>D指针    未偏移             访问数据时跳过了虚指针 + B, C类数据(共28字节)</p>
<p>或许看一下访问虚基类的数据会有所了解? </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pushq   %rbp</span><br><span class="line">.cfi_def_cfa_offset 16</span><br><span class="line">.cfi_offset 6, -16</span><br><span class="line">movq    %rsp, %rbp</span><br><span class="line">.cfi_def_cfa_register 6</span><br><span class="line">subq    $80, %rsp</span><br><span class="line">leaq    -80(%rbp), %rax</span><br><span class="line">movq    %rax, %rdi</span><br><span class="line">call    _ZN1DC1Ev</span><br><span class="line">leaq    -80(%rbp), %rax</span><br><span class="line">addq    $32, %rax</span><br><span class="line">movq    %rax, -8(%rbp)</span><br><span class="line">movq    -8(%rbp), %rax</span><br><span class="line">movl    (%rax), %eax</span><br><span class="line">movl    %eax, %esi</span><br><span class="line">movl    $.LC0, %edi</span><br><span class="line">movl    $0, %eax</span><br><span class="line">call    printf			&#x2F;&#x2F; 基类访问方式和上面的汇编并没有不同</span><br><span class="line">leaq    -80(%rbp), %rax</span><br><span class="line">movq    %rax, -16(%rbp)</span><br><span class="line">movq    -16(%rbp), %rax</span><br><span class="line">movq    (%rax), %rax	&#x2F;&#x2F; 取指针指向的值, 也就是D的地址</span><br><span class="line">subq    $24, %rax		&#x2F;&#x2F; D地址减去24字节 也就是说, 它前面还有东西</span><br><span class="line">movq    (%rax), %rax	&#x2F;&#x2F; 获得那个地址中的值</span><br><span class="line">movq    %rax, %rdx</span><br><span class="line">movq    -16(%rbp), %rax</span><br><span class="line">addq    %rdx, %rax		&#x2F;&#x2F; 增加了 rdx 大小, </span><br><span class="line">movl    (%rax), %eax</span><br><span class="line">movl    %eax, %esi</span><br><span class="line">movl    $.LC0, %edi</span><br><span class="line">movl    $0, %eax</span><br><span class="line">call    printf</span><br><span class="line">leaq    -80(%rbp), %rax</span><br><span class="line">addq    $16, %rax</span><br><span class="line">movq    %rax, -24(%rbp)</span><br><span class="line">movq    -24(%rbp), %rax</span><br><span class="line">movq    (%rax), %rax</span><br><span class="line">subq    $24, %rax</span><br><span class="line">movq    (%rax), %rax</span><br><span class="line">movq    %rax, %rdx</span><br><span class="line">movq    -24(%rbp), %rax</span><br><span class="line">addq    %rdx, %rax</span><br><span class="line">movl    (%rax), %eax</span><br><span class="line">movl    %eax, %esi</span><br><span class="line">movl    $.LC0, %edi</span><br><span class="line">movl    $0, %eax</span><br><span class="line">call    printf</span><br><span class="line">leaq    -80(%rbp), %rax</span><br><span class="line">movq    %rax, -32(%rbp)</span><br><span class="line">movq    -32(%rbp), %rax</span><br><span class="line">movq    (%rax), %rax</span><br><span class="line">subq    $24, %rax</span><br><span class="line">movq    (%rax), %rax</span><br><span class="line">movq    %rax, %rdx</span><br><span class="line">movq    -32(%rbp), %rax</span><br><span class="line">addq    %rdx, %rax</span><br><span class="line">movl    (%rax), %eax</span><br><span class="line">movl    %eax, %esi</span><br><span class="line">movl    $.LC0, %edi</span><br><span class="line">movl    $0, %eax</span><br><span class="line">call    printf</span><br><span class="line">movl    $0, %eax</span><br><span class="line">leave</span><br></pre></td></tr></table></figure>

<p>emmm… 有一个重大的发现就是, <strong>基类对象前面有数据</strong></p>
<p>这些数据应该是偏移, 这些偏移配合 + 指针本身的地址能够访问到正确的虚基类数据</p>
<p>也就是说, 这是 深入探索对象 中, 对于虚基类的两种实现方式中的第一种</p>
<p>即: 在每个基类中添加虚基类的偏移, 但是又不全对…</p>
<p>越来越糊涂了 (눈_눈), 深吸一口气, 想想自己要干嘛… emmmm….</p>
<p>这样吧, 完整地看一遍构造的过程, 这样应该就明白了</p>
<p>(如果还是晕, 那么就希望下次遇到这个问题的时候能够更从容一些)</p>
<p>(我已经再这个问题上花太多时间, 再这样下去反而不好, 这也不是一个很重要/常用的知识)</p>
<h3 id="完整的构造过程"><a href="#完整的构造过程" class="headerlink" title="完整的构造过程"></a>完整的构造过程</h3><p>首先是 main 区块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">main:</span><br><span class="line">.LFB1196:</span><br><span class="line">    pushq	%rbp</span><br><span class="line">    movq	%rsp, %rbp</span><br><span class="line">    subq	$48, %rsp	&#x2F;&#x2F; 48 字节栈帧, 为什么是 48 呢?</span><br><span class="line">    leaq	-48(%rbp), %rax</span><br><span class="line">    movq	%rax, %rdi</span><br><span class="line">    call	_ZN1DC1Ev	&#x2F;&#x2F; 调用构造函数</span><br><span class="line">    movl	$0, %eax</span><br><span class="line">    leave</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>
<p>然后是D的构造函数:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_ZN1DC1Ev:</span><br><span class="line">.LFB1208:</span><br><span class="line">    pushq	%rbp</span><br><span class="line">    movq	%rsp, %rbp</span><br><span class="line">    subq	$16, %rsp		&#x2F;&#x2F; 它再次开辟了 16 字节的栈帧</span><br><span class="line">    movq	%rdi, -8(%rbp)	&#x2F;&#x2F; 把原栈顶指针放入了栈中</span><br><span class="line">    movq	-8(%rbp), %rax	</span><br><span class="line">    addq	$32, %rax		&#x2F;&#x2F; 原栈顶指针 +32 偏移, 距栈底还有 16 字节</span><br><span class="line">    movq	%rax, %rdi</span><br><span class="line">    call	_ZN1AC2Ev		&#x2F;&#x2F; 这里留了 16 字节用于 A 的构造</span><br><span class="line">    movl	$_ZTT1D+8, %edx	&#x2F;&#x2F; 我很好奇地查了 $_ZTT1D 这东西是多少, 然而事实让我绝望...</span><br><span class="line">    						&#x2F;&#x2F; 它有非常多的耦合, 短时间内我根本无法计算出这东西是多少!!!</span><br><span class="line">    						&#x2F;&#x2F; 而且里面的代码是以.开头的, 这意味着是伪指令... (;´༎ຶД༎ຶ&#96;)</span><br><span class="line">    movq	-8(%rbp), %rax</span><br><span class="line">    movq	%rdx, %rsi		&#x2F;&#x2F; rdx 从未被赋值过, 我很好奇它将什么值给了 rsi</span><br><span class="line">    						&#x2F;&#x2F; 对了, 在上面一句用到了 edx, 这和 rdx 有关</span><br><span class="line">    						&#x2F;&#x2F; 暂且把它认为是一个, 编译器施加的魔法: magic</span><br><span class="line">    movq	%rax, %rdi		&#x2F;&#x2F; 原栈顶指针</span><br><span class="line">    call	_ZN1BC2Ev		&#x2F;&#x2F; 调用 B 构造函数</span><br><span class="line">    movl	$_ZTT1D+16, %eax</span><br><span class="line">    movq	-8(%rbp), %rdx	&#x2F;&#x2F; 拿出原栈顶指针</span><br><span class="line">    addq	$16, %rdx		&#x2F;&#x2F; +16 偏移</span><br><span class="line">    movq	%rax, %rsi</span><br><span class="line">    movq	%rdx, %rdi</span><br><span class="line">    call	_ZN1CC2Ev		&#x2F;&#x2F; 调用 C 构造函数</span><br><span class="line">    movl	$_ZTV1D+24, %edxl</span><br><span class="line">    movq	-8(%rbp), %rax</span><br><span class="line">    movq	%rdx, (%rax)	&#x2F;&#x2F; 这里与调用 B 时的步骤重复了 :), 覆写</span><br><span class="line">    movl	$_ZTV1D+48, %edx</span><br><span class="line">    movq	-8(%rbp), %rax</span><br><span class="line">    movq	%rdx, 16(%rax)	&#x2F;&#x2F; 这里与调用 C 时的步骤重复了 :), 覆写</span><br><span class="line">    movq	-8(%rbp), %rax</span><br><span class="line">    movl	$444, 28(%rax)	&#x2F;&#x2F; 写入值</span><br><span class="line">    leave</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>
<p>A的构造函数:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_ZN1AC2Ev:</span><br><span class="line">.LFB1199:</span><br><span class="line">    pushq	%rbp</span><br><span class="line">    movq	%rsp, %rbp</span><br><span class="line">    movq	%rdi, -8(%rbp)</span><br><span class="line">    movq	-8(%rbp), %rax</span><br><span class="line">    movl	$111, (%rax)	&#x2F;&#x2F; 将 $111 放入了参数 rdi 指向的内存中 movl: 4字节</span><br><span class="line">    popq	%rbp</span><br><span class="line">    ret		&#x2F;&#x2F; 嗯, 没了, 所以编译器仅仅对这 4 字节赋值</span><br><span class="line">    		&#x2F;&#x2F; 剩下的 12 字节呢?</span><br><span class="line">    		&#x2F;&#x2F; 其中8字节没用过, 或者不在 D 的内存中, 因为 sizeof d 是40, 而非48</span><br></pre></td></tr></table></figure>
<p>B的构造函数:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_ZN1BC2Ev:</span><br><span class="line">.LFB1202:</span><br><span class="line">    pushq	%rbp</span><br><span class="line">    movq	%rsp, %rbp</span><br><span class="line">    movq	%rdi, -8(%rbp)	&#x2F;&#x2F; 原栈顶指针</span><br><span class="line">    movq	%rsi, -16(%rbp)	&#x2F;&#x2F; 未知的原 rdx(magic)</span><br><span class="line">    movq	-16(%rbp), %rax</span><br><span class="line">    movq	(%rax), %rdx	&#x2F;&#x2F; magic的地址 -16 中的值放入 rdx</span><br><span class="line">    movq	-8(%rbp), %rax</span><br><span class="line">    movq	%rdx, (%rax)	&#x2F;&#x2F; 将 rdx 中的值放入了栈顶, 这里是q, 占了 8 字节</span><br><span class="line">    movq	-8(%rbp), %rax</span><br><span class="line">    movl	$222, 8(%rax)	&#x2F;&#x2F; 栈顶 +8 偏移中, 放入了 $222</span><br><span class="line">    popq	%rbp</span><br><span class="line">    ret				&#x2F;&#x2F; 共写入了 12 字节</span><br></pre></td></tr></table></figure>
<p>C的构造函数:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_ZN1CC2Ev:</span><br><span class="line">.LFB1205:</span><br><span class="line">    pushq	%rbp</span><br><span class="line">    movq	%rsp, %rbp</span><br><span class="line">    movq	%rdi, -8(%rbp)</span><br><span class="line">    movq	%rsi, -16(%rbp)</span><br><span class="line">    movq	-16(%rbp), %rax</span><br><span class="line">    movq	(%rax), %rdx</span><br><span class="line">    movq	-8(%rbp), %rax</span><br><span class="line">    movq	%rdx, (%rax)</span><br><span class="line">    movq	-8(%rbp), %rax</span><br><span class="line">    movl	$333, 8(%rax)</span><br><span class="line">    popq	%rbp		&#x2F;&#x2F; 步骤与 B 基本相同</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>
<p>也就是说, 在D的构造中, ABC的构造都被调用了</p>
<p>要注意的一点是, BC都未调用A的构造, A的构造仅在D中调用了一次</p>
<p>同时要注意的是, BC会用那个编译器给的数字往自身的内存布局中写值</p>
<p>但是如果其上有D, D会将那个值覆写一次, 假设其值恒定不变, 位移分别为:</p>
<p>8 16 24 48</p>
<p>这是一组有规律的数字, 以 8 为开始, 每个数字是前面数字之和(这个就是偏移)</p>
<p>剩下来最重要的是, D覆写了什么?</p>
<p>再次来看看是如何访问虚基类数据的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">D a;</span><br><span class="line">C *pd = &amp;a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, pd-&gt;A::_i);</span><br></pre></td></tr></table></figure>


<p>汇编:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.LFB1196:</span><br><span class="line">    pushq   %rbp</span><br><span class="line">    movq    %rsp, %rbp</span><br><span class="line">    subq    $48, %rsp</span><br><span class="line">    leaq    -48(%rbp), %rax</span><br><span class="line">    movq    %rax, %rdi</span><br><span class="line">    call    _ZN1DC1Ev</span><br><span class="line">    leaq    -48(%rbp), %rax</span><br><span class="line">    addq    $16, %rax		&#x2F;&#x2F; 因为是 C 类型指针, 所以做了 +16 偏移</span><br><span class="line">    movq    %rax, -8(%rbp)	&#x2F;&#x2F; C *pd &#x3D; &amp;a;</span><br><span class="line">    movq    -8(%rbp), %rax</span><br><span class="line">    movq    (%rax), %rax	&#x2F;&#x2F; 获得了指针中的值</span><br><span class="line">    subq    $24, %rax		&#x2F;&#x2F; 该值减去 24 </span><br><span class="line">    movq    (%rax), %rax	&#x2F;&#x2F; 再以该值间接寻址</span><br><span class="line">    movq    %rax, %rdx</span><br><span class="line">    movq    -8(%rbp), %rax</span><br><span class="line">    addq    %rdx, %rax		&#x2F;&#x2F; rdx 本身的值 + 指针的值</span><br><span class="line">    movl    (%rax), %eax	&#x2F;&#x2F; 间接寻址得到的值就是虚基类的值</span><br><span class="line">    movl    %eax, %esi</span><br><span class="line">    movl    $.LC0, %edi</span><br><span class="line">    movl    $0, %eax</span><br><span class="line">    call    printf</span><br><span class="line">    movl    $0, %eax</span><br><span class="line">    leave</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>

<p>这次要清晰得多了, 我们以上面D的内存布局为例:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">4196760</span>	<span class="comment">// 2. 它减去 24 到了这里 </span></span><br><span class="line">    	<span class="comment">// 3. 用这里的值寻址得到了某个数 x </span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">4196784</span>	<span class="comment">// 1. 这是一开始 C 指针指向的内存</span></span><br><span class="line">    	<span class="comment">// 4. 用这个指针 + x 得到了虚基类数据的地址</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>那么在代码中试一下, 如果没有错误的话, 那个 x 应该是 4</p>
<p>(这个地址明显非常低, 它甚至没达到 8 字节, 这应该是编译的时候准备好的数据)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">D a;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> *pl = (<span class="keyword">long</span> <span class="keyword">long</span> *)&amp;a;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> *pl2 = (<span class="keyword">long</span> <span class="keyword">long</span> *)&amp;pl;</span><br><span class="line">*pl2 = *pl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%ld\n"</span>, *pl);	<span class="comment">// 16</span></span><br></pre></td></tr></table></figure>


<p>取出来了 16, emmm… 嗯, 没错, 4 个 4字节 4 x 4 = 16 !!!!!!! </p>
<p>PS: 有没有思考过为什么通过双间接才能去到虚基类呢?</p>
<p>这里明显的一个问题是, 虚基类的数据是通过 C 的某个地址索引到 D 的某个地址</p>
<p>然后再用 C 的地址索引到虚基类数据, 有两次的跳转 </p>
<p>我再次试了一下有继承三个虚基类的情况(就是D再继承了一个类似 BC的类)</p>
<p>发现它的访问方式是一样的, 也就是说, 每一个自身都会往前寻找固定的字节(编译后固定)</p>
<p>然后用那个地址的数据 + 指针本身的地址(我不知道我又没有表达清楚, 不过我感觉我没有 :) )</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> _i = <span class="number">555</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B, <span class="keyword">public</span> C, <span class="keyword">public</span> E&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> _i = <span class="number">444</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    D a;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> *pl = (<span class="keyword">long</span> <span class="keyword">long</span> *)&amp;a;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> *pl2 = (<span class="keyword">long</span> <span class="keyword">long</span> *)&amp;pl;</span><br><span class="line">    *pl2 = *pl;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%ld\n"</span>, *pl);   <span class="comment">// 32</span></span><br><span class="line"></span><br><span class="line">    pl = (<span class="keyword">long</span> <span class="keyword">long</span> *)&amp;a + <span class="number">2</span>;</span><br><span class="line">    pl2 = (<span class="keyword">long</span> <span class="keyword">long</span> *)&amp;pl;</span><br><span class="line">    *pl2 = *pl;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%ld\n"</span>, *pl);   <span class="comment">// 16</span></span><br><span class="line"></span><br><span class="line">    pl = (<span class="keyword">long</span> <span class="keyword">long</span> *)&amp;a + <span class="number">4</span>;</span><br><span class="line">    pl2 = (<span class="keyword">long</span> <span class="keyword">long</span> *)&amp;pl;</span><br><span class="line">    *pl2 = *pl;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%ld\n"</span>, *pl);   <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>内存布局:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">4196856</span>	(<span class="number">32</span>)<span class="comment">// 2. 通过这个地址拿到偏移</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">222</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">4196880</span>	(<span class="number">16</span>)<span class="comment">// 1. C对象, 当我要找虚基类对象时, 我先往上移动固定字节</span></span><br><span class="line">    		<span class="comment">// 这些移动的大小都是在编译时就写死了的常量(编译器自动计算)</span></span><br><span class="line">    		<span class="comment">// 往上移动的字节会随着数据大小而改变, 但是数据中的地址是不变的</span></span><br><span class="line">    		<span class="comment">// 比如我这里是4196880, 那么无论往上移动多少</span></span><br><span class="line">    		<span class="comment">// 上一个地址中存的值恒定为 当前值 - 24 (4196856)</span></span><br><span class="line">    	<span class="comment">// 3. 根据拿到的偏移 + 地址获取虚基类数据</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">333</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">4196904</span> (<span class="number">0</span>)<span class="comment">// E对象, 它如果想拿到虚基类数据, 执行和 C 对象一样的操作就好</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">555</span></span><br><span class="line"><span class="number">444</span></span><br><span class="line"><span class="number">111</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>这样的内存布局在其他方面可能还会有用</p>
<p>那么为什么会有 0 呢? 我估计是因为要实现这种内存布局, 或者说什么其他原因</p>
<h3 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h3><p> 我很怀疑下次我看笔记时, 我自己看不看得懂我在说什么…</p>
]]></content>
  </entry>
  <entry>
    <title>leetcode/160IntersectionofTwoLinkedList</title>
    <url>/2020/01/09/leetcode/160IntersectionofTwoLinkedList/</url>
    <content><![CDATA[<h2 id="Intersection-of-two-linked-list"><a href="#Intersection-of-two-linked-list" class="headerlink" title="Intersection of two linked list"></a>Intersection of two linked list</h2><p><img src="https://imgur.com/nhmAc0h.png" alt=""></p>
<p>获得两条链表的连接点</p>
<h3 id="my-solution-36ms-100"><a href="#my-solution-36ms-100" class="headerlink" title="my solution (36ms, 100%)"></a>my solution (36ms, 100%)</h3><p>(虽然效率看起来是最好的, 但是其实比起最好的算法要差不少)</p>
<p>核心难点在于两条链表的长度不一定相等, 这样就不能遍历节点用等于的形式来判断  </p>
<p>那么拿到两条链表的长度, 让较长的链表前进若干次, 以达到长度相等的情形, 那么就可以遍历了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> deep_A = <span class="number">0</span>, deep_B = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode *temp_head = headA;</span><br><span class="line">        <span class="keyword">while</span> (temp_head) &#123;</span><br><span class="line">            temp_head = temp_head-&gt;next;</span><br><span class="line">            ++deep_A;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        temp_head = headB;</span><br><span class="line">        <span class="keyword">while</span> (temp_head) &#123;</span><br><span class="line">            temp_head = temp_head-&gt;next;</span><br><span class="line">            ++deep_B;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> distance = <span class="built_in">abs</span>(deep_A - deep_B);</span><br><span class="line">        <span class="keyword">if</span> (deep_A &gt; deep_B) &#123;</span><br><span class="line">            <span class="keyword">while</span> (distance) &#123;</span><br><span class="line">                headA = headA-&gt;next;</span><br><span class="line">                --distance;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (distance) &#123;</span><br><span class="line">                headB = headB-&gt;next;</span><br><span class="line">                --distance;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (headA &amp;&amp; headB &amp;&amp; headA != headB) &#123;</span><br><span class="line">            headA = headA-&gt;next;</span><br><span class="line">            headB = headB-&gt;next;    </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> headA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>代码如下, 会产生 3 次遍历, 两次完整的遍历 O(3n) =&gt; O(n)</p>
<h3 id="the-best-solution"><a href="#the-best-solution" class="headerlink" title="the best solution"></a>the best solution</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode *p = headA;</span><br><span class="line">        ListNode *q = headB;</span><br><span class="line">        <span class="keyword">while</span> (p != q) &#123;</span><br><span class="line">            p = (p ? p-&gt;next: headB);</span><br><span class="line">            q = (q ? q-&gt;next: headA);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>原来还可以这么做!!!</p>
<p>算法的核心思想在于, A + B = B + A</p>
<p>假设有两条链表, 长度不等</p>
<pre><code>0 0 0 2 1 1    // A
0 0 2 1 1    // B</code></pre><p>其中将他们的链接点标为 2</p>
<p>那么有以下组合链表</p>
<pre><code>0 0 0 2 1 1 0 0 2 1 1    // A + B
0 0 2 1 1 0 0 0 2 1 1    // B + A</code></pre><p>他们如果有链接点, 那么在第二次循环时必然相等  </p>
<p>我是用求深度差来解决这个问题, 这个算法更加巧妙地用组合链表的形式规避了这个深度差</p>
]]></content>
  </entry>
  <entry>
    <title>leetcode/152MaximumProductSubarray</title>
    <url>/2020/01/09/leetcode/152MaximumProductSubarray/</url>
    <content><![CDATA[<h2 id="152-Maximum-Product-Subarray"><a href="#152-Maximum-Product-Subarray" class="headerlink" title="152 Maximum Product Subarray"></a>152 Maximum Product Subarray</h2><p><img src="https://imgur.com/soCfHk6.png" alt=""></p>
<p>找到数组中最大的连续乘积</p>
<h3 id="my-solution-8ms-100"><a href="#my-solution-8ms-100" class="headerlink" title="my solution (8ms, 100%)"></a>my solution (8ms, 100%)</h3><p>先将乘积以 0 为分界线分开, 这样得到的就是一段段最大的乘积(暂时无视正负)</p>
<p>而如果得到的数是负数, 那么分为 4 种情况 </p>
<ol>
<li>从左到右, 找到第一个负数, 用当前乘积除以它</li>
<li>从左到右, 找到第一个负数, 以该负数为界限, 获取左边的乘积</li>
<li>从右到左, 找到第一个负数, 用当前乘积除以它</li>
<li>从右到左,, 找到第一个负数, 以该负数为界限, 获取右边的乘积</li>
</ol>
<p>这四种情况最大者, 视为这一段的最大值, 而所有这些段再做比较, 就得到了整个数组连续乘积的最大值</p>
<p>代码如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> _ = [] () &#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; ();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">size_t</span> <span class="built_in">size</span> = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> ( !<span class="built_in">size</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> e = <span class="built_in">size</span>;</span><br><span class="line">        <span class="keyword">int</span> ret = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">while</span> (b &lt; e) &#123;</span><br><span class="line">            <span class="keyword">int</span> tb = b;</span><br><span class="line">            <span class="keyword">while</span> (b &lt; e &amp;&amp; nums[b] != <span class="number">0</span>) ++b;</span><br><span class="line">            <span class="keyword">if</span> (b - tb &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                ret = <span class="built_in">max</span>(ret, nums[tb]);</span><br><span class="line">                <span class="keyword">if</span> (b &lt; e)</span><br><span class="line">                    ret = <span class="built_in">max</span>(ret, nums[b]);</span><br><span class="line">                b += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> tb2 = tb;</span><br><span class="line">            <span class="keyword">while</span> (tb2 &lt; b) sum *= nums[tb2++];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> sumneg1 = <span class="number">1</span>;</span><br><span class="line">                tb2 = tb;</span><br><span class="line">                <span class="keyword">while</span> (tb2 &lt; b) &#123; </span><br><span class="line">                    sumneg1 *= nums[tb2];</span><br><span class="line">                    <span class="keyword">if</span> (nums[tb2] &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">                    ++tb2;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> sum1 = sumneg1 / nums[tb2] == <span class="number">1</span> ? sumneg1 : </span><br><span class="line">                    sumneg1 / nums[tb2];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> sumneg2 = <span class="number">1</span>;</span><br><span class="line">                tb2 = b - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (tb2 &gt;= tb) &#123;</span><br><span class="line">                    sumneg2 *= nums[tb2];</span><br><span class="line">                    <span class="keyword">if</span> (nums[tb2] &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">                    --tb2;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> sum2 = sumneg2 / nums[tb2] == <span class="number">1</span> ? sumneg2 : </span><br><span class="line">                    sumneg2 / nums[tb2];</span><br><span class="line"></span><br><span class="line">                sum /= <span class="built_in">max</span>(sumneg1, sumneg2);</span><br><span class="line">                sum = <span class="built_in">max</span>(sum, sum1);</span><br><span class="line">                sum = <span class="built_in">max</span>(sum, sum2);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ret = <span class="built_in">max</span>(ret, sum);</span><br><span class="line">            b += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>不太满意, 代码有点过长了…</p>
<p><img src="https://imgur.com/KGRgySn.png" alt=""></p>
<h3 id="best-solution"><a href="#best-solution" class="headerlink" title="best solution"></a>best solution</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> max_num[len] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> min_num[len] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">max</span> = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">min</span> = nums[<span class="number">0</span>];</span><br><span class="line">        max_num[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        min_num[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp1 = max_num[i<span class="number">-1</span>] * nums[i];</span><br><span class="line">            <span class="keyword">int</span> tmp2 = min_num[i<span class="number">-1</span>] * nums[i];</span><br><span class="line">            <span class="keyword">int</span> cur_max_num = tmp1 &gt; tmp2 ? tmp1 : tmp2;</span><br><span class="line">            <span class="keyword">int</span> cur_min_num = tmp1 &lt; tmp2 ? tmp1 : tmp2;</span><br><span class="line">            max_num[i] = cur_max_num &gt;= nums[i] ? cur_max_num : nums[i];</span><br><span class="line">            min_num[i] = cur_min_num &lt;= nums[i] ? cur_min_num : nums[i];</span><br><span class="line">            <span class="built_in">max</span> = <span class="built_in">max</span> &gt; max_num[i] ? <span class="built_in">max</span> : max_num[i];</span><br><span class="line">            <span class="built_in">min</span> = <span class="built_in">min</span> &lt; min_num[i] ? <span class="built_in">min</span> : min_num[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>啊. 简洁的小东西</p>
<p>不过, 我不是太懂这个代码的含义…  </p>
<p>不过我觉得我的想法会好点, 虽然代码实现起来有点困难  </p>
<p>但是它能一次性跳过很大一片区域, 对于连续整数很多的情况, 能够很快地计算出来  </p>
<p>而这种的话会完完整整的遍历一次</p>
<p>emmm. 是的, 我觉得我的想法会好一点 :)</p>
]]></content>
  </entry>
  <entry>
    <title>leetcode/135Candy</title>
    <url>/2020/01/09/leetcode/135Candy/</url>
    <content><![CDATA[<h2 id="Candy"><a href="#Candy" class="headerlink" title="Candy"></a>Candy</h2><p><img src="https://imgur.com/x5xFxEL.png" alt=""></p>
<p>按照规则给每个小孩发糖果</p>
<ol>
<li>每个小孩的糖果数至少为 1</li>
<li>每个小孩获得的糖果数比他临近的, 并且权重比他小的小孩获得的要多</li>
</ol>
<h3 id="my-solution-12ms-100-00"><a href="#my-solution-12ms-100-00" class="headerlink" title="my solution(12ms, 100.00%)"></a>my solution(12ms, 100.00%)</h3><p>虽然做出来了, 但是并不高兴 = =, 因为代码太过复杂</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> _ = [] () &#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; ();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">candy</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; ratings)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">size_t</span> <span class="built_in">size</span> = ratings.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">size</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">size</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; candys(<span class="built_in">size</span>, <span class="number">0</span>);  </span><br><span class="line"></span><br><span class="line">		<span class="comment">// 填充所有可以直接确定的数</span></span><br><span class="line">        <span class="keyword">if</span> (ratings[<span class="number">0</span>] &lt;= ratings[<span class="number">1</span>]) </span><br><span class="line">            candys[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (ratings[<span class="built_in">size</span> - <span class="number">1</span>] &lt;= ratings[<span class="built_in">size</span> - <span class="number">2</span>]) </span><br><span class="line">            candys[<span class="built_in">size</span> - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + <span class="number">1</span> &lt; <span class="built_in">size</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> minn = <span class="built_in">min</span>(ratings[i], ratings[i - <span class="number">1</span>]);</span><br><span class="line">            minn = <span class="built_in">min</span>(minn, ratings[i + <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ratings[i] == minn)</span><br><span class="line">                candys[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 正向遍历</span></span><br><span class="line">        <span class="keyword">if</span> (ratings[<span class="number">0</span>] &gt; ratings[<span class="number">1</span>] &amp;&amp; candys[<span class="number">1</span>]) </span><br><span class="line">            candys[<span class="number">0</span>] = candys[<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (ratings[<span class="built_in">size</span> - <span class="number">1</span>] &gt; ratings[<span class="built_in">size</span> - <span class="number">2</span>] &amp;&amp; candys[<span class="built_in">size</span> - <span class="number">2</span>]) </span><br><span class="line">            candys[<span class="built_in">size</span> - <span class="number">1</span>] = candys[<span class="built_in">size</span> - <span class="number">2</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + <span class="number">1</span> &lt; <span class="built_in">size</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (candys[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> minn, maxn;</span><br><span class="line">                <span class="comment">// 当他是临近的人中权重最大的人时, 他的糖果数是</span></span><br><span class="line">         		<span class="comment">// max(left, right) + 1</span></span><br><span class="line">                <span class="keyword">if</span> (ratings[i + <span class="number">1</span>] == ratings[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (candys[i + <span class="number">1</span>] &amp;&amp; candys[i - <span class="number">1</span>])</span><br><span class="line">                        candys[i] = <span class="built_in">max</span>(candys[i + <span class="number">1</span>], candys[i - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ratings[i + <span class="number">1</span>] &gt; ratings[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                    minn = i - <span class="number">1</span>;</span><br><span class="line">                    maxn = i + <span class="number">1</span>;</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    minn = i + <span class="number">1</span>;</span><br><span class="line">                    maxn = i - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">				</span><br><span class="line">				<span class="comment">// 当他只比其中一个大时, 他的糖果数是 min + 1</span></span><br><span class="line">                <span class="keyword">if</span> (ratings[i] &lt;= ratings[maxn] &amp;&amp; candys[minn])</span><br><span class="line">                    candys[i] = candys[minn] + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 这里和第一处的判断是相同的, 第一处只是为了减少一些操作</span></span><br><span class="line">                <span class="keyword">if</span> (ratings[i] &gt; ratings[maxn] &amp;&amp; candys[maxn] &amp;&amp; candys[minn])</span><br><span class="line">                    candys[i] = <span class="built_in">max</span>(candys[maxn], candys[minn]) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 反向遍历, 逻辑相同</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">size</span> - <span class="number">2</span>; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (candys[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> minn, maxn;</span><br><span class="line">                <span class="keyword">if</span> (ratings[i + <span class="number">1</span>] == ratings[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (candys[i + <span class="number">1</span>] &amp;&amp; candys[i - <span class="number">1</span>])</span><br><span class="line">                        candys[i] = <span class="built_in">max</span>(candys[i + <span class="number">1</span>], candys[i - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ratings[i + <span class="number">1</span>] &gt; ratings[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                    minn = i - <span class="number">1</span>;</span><br><span class="line">                    maxn = i + <span class="number">1</span>;</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    minn = i + <span class="number">1</span>;</span><br><span class="line">                    maxn = i - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (ratings[i] &lt;= ratings[maxn] &amp;&amp; candys[minn])</span><br><span class="line">                    candys[i] = candys[minn] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (ratings[i] &gt; ratings[maxn] &amp;&amp; candys[maxn] &amp;&amp; candys[minn])</span><br><span class="line">                    candys[i] = <span class="built_in">max</span>(candys[maxn], candys[minn]) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ratings[<span class="number">0</span>] &gt; ratings[<span class="number">1</span>] &amp;&amp; candys[<span class="number">1</span>]) </span><br><span class="line">            candys[<span class="number">0</span>] = candys[<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (ratings[<span class="built_in">size</span> - <span class="number">1</span>] &gt; ratings[<span class="built_in">size</span> - <span class="number">2</span>] &amp;&amp; candys[<span class="built_in">size</span> - <span class="number">2</span>]) </span><br><span class="line">            candys[<span class="built_in">size</span> - <span class="number">1</span>] = candys[<span class="built_in">size</span> - <span class="number">2</span>] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; ++i)</span><br><span class="line">            ret += candys[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>整体代码会有 3 次遍历, 但是代码太多, 太复杂了…</p>
<p><img src="https://imgur.com/BFwX292.png" alt=""></p>
<p>如果没有看到最好算法的简洁程度, 我可能还能再高兴一下…</p>
<h3 id="best-solution"><a href="#best-solution" class="headerlink" title="best solution"></a>best solution</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">candy</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; ratings)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; num(ratings.<span class="built_in">size</span>(), <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; ratings.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (ratings[i] &gt; ratings[i<span class="number">-1</span>]) &#123;</span><br><span class="line">        num[i] = num[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = ratings.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (ratings[i] &gt; ratings[i+<span class="number">1</span>] &amp;&amp; num[i] &lt;= num[i+<span class="number">1</span>]) &#123;</span><br><span class="line">        num[i] = num[i+<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">      sum += num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> x = []() &#123;</span><br><span class="line">  ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">  <span class="built_in">cin</span>.tie(<span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">cout</span>.tie(<span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>
<p>(做完题的喜悦被冲刷得干干净净…, 啊… 真的是羞愧难当啊…)</p>
<p>(我为什么总是把问题复杂化了呢…)</p>
<p>逻辑上大致相同, 只不过他只需要一次 反向遍历, 一次 正向遍历</p>
<p>其中每次遍历所需要判断的条件都十分简单并且清晰</p>
]]></content>
  </entry>
  <entry>
    <title>leetcode/16Z3Sum_Closest</title>
    <url>/2020/01/09/leetcode/16Z3Sum_Closest/</url>
    <content><![CDATA[<h2 id="3Sum-Closest"><a href="#3Sum-Closest" class="headerlink" title="3Sum Closest"></a>3Sum Closest</h2><p><img src="https://i.imgur.com/7Q0hVY2.png" alt=""></p>
<p>给一个包含多个整数的数组 nums, 以及一个整数 target, 在 nums 中找一个三整数, 满足和最接近 target</p>
<p>返回这个和, 你可以假定每一个输入都只有一个解法</p>
<h3 id="my-code"><a href="#my-code" class="headerlink" title="my code"></a>my code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// nums.size() return value is size_t !!!!</span></span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">3</span>) <span class="keyword">return</span> nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[<span class="number">2</span>];</span><br><span class="line">        cut(nums);</span><br><span class="line">        <span class="keyword">int</span> length = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        minn = nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[<span class="number">2</span>];</span><br><span class="line">        targetp = target;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= length; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i2 = <span class="number">0</span>; i2 &lt;= length; ++i2) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i2 != i) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i3 = <span class="number">0</span>; i3 &lt;= length; ++i3) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (i3 != i2 &amp;&amp; i3 != i) &#123;</span><br><span class="line">                            <span class="keyword">if</span> ( !isMin(nums[i] + nums[i2] + nums[i3]) )</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        &#125; <span class="comment">// 3 if</span></span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">                    &#125; <span class="comment">// 3</span></span><br><span class="line">                &#125; <span class="comment">// 2 if</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="comment">// 2</span></span><br><span class="line">        &#125; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> minn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cut</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMin</span><span class="params">(<span class="keyword">int</span> newn)</span> </span>&#123;</span><br><span class="line">        minn = <span class="built_in">abs</span>(newn - targetp) &gt; <span class="built_in">abs</span>(targetp - minn) ? minn : newn;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> newn &lt; targetp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> minn;</span><br><span class="line">    <span class="keyword">int</span> targetp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>非常愚蠢地选择了丑陋的forforfor…</p>
<p>比较主要的是重新排序了集合, 这样在循环中的值就会越来越大, </p>
<p>那么当超过一定数值的时候, 就可以break出去, 减少更多的无用计算</p>
<p>不过依旧差不多是 o3 的复杂度</p>
<h4 id="memery-and-speed"><a href="#memery-and-speed" class="headerlink" title="memery and speed"></a>memery and speed</h4><p><img src="https://imgur.com/BFPPahz.png" alt=""></p>
<p>速度在统计图之外, 内存使用倒是挺少的 (算法就是要空间换时间啊, MU少有什么用 = =)</p>
<h3 id="dalao‘s-code"><a href="#dalao‘s-code" class="headerlink" title="dalao‘s code"></a>dalao‘s code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rnum = nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[<span class="number">2</span>];</span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (n - <span class="number">2</span>); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> lb = i + <span class="number">1</span>, ub = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (lb &lt; ub) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmpsum = nums[i] + nums[lb] + nums[ub];</span><br><span class="line">                <span class="keyword">if</span> (tmpsum == target) <span class="keyword">return</span> target;</span><br><span class="line">                <span class="keyword">if</span> (tmpsum &gt; target) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((tmpsum - target) &lt; <span class="built_in">abs</span>(rnum - target)) rnum = tmpsum;</span><br><span class="line">                    --ub;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((target - tmpsum) &lt; <span class="built_in">abs</span>(rnum - target)) rnum = tmpsum;</span><br><span class="line">                    ++lb;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rnum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>他的思路也是排序后, 根据有顺序的元素进行优化  </p>
<p>不过是按照首位逼近的方式来优化, 并且没有丑陋的forforfor (diediedie!!!)</p>
<p>代码少了很多, 但是也更加简洁和清晰了</p>
]]></content>
  </entry>
  <entry>
    <title>leetcode/17ZLetter_Combinations_of_a_phone_Number</title>
    <url>/2020/01/09/leetcode/17ZLetter_Combinations_of_a_phone_Number/</url>
    <content><![CDATA[<h3 id="Letter-combinations-of-a-phone-number"><a href="#Letter-combinations-of-a-phone-number" class="headerlink" title="Letter combinations of a phone number"></a>Letter combinations of a phone number</h3><p><img src="https://i.imgur.com/VLZKo4s.png" alt=""></p>
<p>给一个包含 2-9 整数的字符串, 返回所有可能的数字能代表的字母组合  </p>
<h3 id="my-code"><a href="#my-code" class="headerlink" title="my code"></a>my code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; letterCombinations(<span class="built_in">string</span> digits) &#123;</span><br><span class="line">        <span class="keyword">if</span> (digits.empty()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        doit(digits, &#123;&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doit</span><span class="params">(<span class="built_in">string</span> digits, <span class="built_in">string</span> <span class="keyword">const</span>&amp; str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (digits.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            ret.emplace_back(str);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; charset = dict[<span class="keyword">int</span>(digits[<span class="number">0</span>]) - <span class="number">48</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; charset.<span class="built_in">size</span>(); ++i) &#123;          </span><br><span class="line">            doit(&#123;digits.<span class="built_in">begin</span>() + <span class="number">1</span>, digits.<span class="built_in">end</span>()&#125;, str + charset[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; dict = &#123;</span><br><span class="line">        &#123;<span class="number">2</span>, &#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="number">3</span>, &#123;<span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="number">4</span>, &#123;<span class="string">'g'</span>, <span class="string">'h'</span>, <span class="string">'i'</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="number">5</span>, &#123;<span class="string">'j'</span>, <span class="string">'k'</span>, <span class="string">'l'</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="number">6</span>, &#123;<span class="string">'m'</span>, <span class="string">'n'</span>, <span class="string">'o'</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="number">7</span>, &#123;<span class="string">'p'</span>, <span class="string">'q'</span>, <span class="string">'r'</span>, <span class="string">'s'</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="number">8</span>, &#123;<span class="string">'t'</span>, <span class="string">'u'</span>, <span class="string">'v'</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="number">9</span>, &#123;<span class="string">'w'</span>, <span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'z'</span>&#125;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ret;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>简单地存储一个映射, 然后循环调用, 每次获取一个字符  </p>
<p>因为循环深度不可控, 以及为了简单易懂, 所以选择了递归, 不过这会带来额外的栈帧</p>
<p><img src="https://imgur.com/FnyQQQ1.png" alt=""></p>
<p>内存开销上会多不少, 速度上差别倒是不大  </p>
<h3 id="dalao’s-code"><a href="#dalao’s-code" class="headerlink" title="dalao’s code"></a>dalao’s code</h3><p>简单看了一下, 是用 for 循环实现的  </p>
<p>因为时间上并没有什么差距, 原理也很好懂, 这次就不具体贴出来了</p>
]]></content>
  </entry>
  <entry>
    <title>leetcode/190EReverseBits</title>
    <url>/2020/01/09/leetcode/190EReverseBits/</url>
    <content><![CDATA[<p><img src="https://imgur.com/194AzQQ.png" alt=""></p>
<p>反转二进制</p>
<h3 id="my-solution"><a href="#my-solution" class="headerlink" title="my solution"></a>my solution</h3><p>我选的方法是直接调用 bits.Reverse 函数来解决, 如果自己写的话, 应该会循环获取每一位, 重新构造一个数字</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseBits</span><span class="params">(num <span class="keyword">uint32</span>)</span> <span class="title">uint32</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> bits.Reverse32(num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="best-solution"><a href="#best-solution" class="headerlink" title="best solution"></a>best solution</h3><p>这也是为什么一道 easy 的题会单独做笔记的原因, 因为这道题的解法很有意思</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseBits</span><span class="params">(num <span class="keyword">uint32</span>)</span> <span class="title">uint32</span></span> &#123;</span><br><span class="line">    constNums := []<span class="keyword">uint32</span>&#123;<span class="number">0xAAAAAAAA</span>, <span class="number">0x55555555</span>, <span class="number">0xCCCCCCCC</span>, <span class="number">0x33333333</span>, <span class="number">0xF0F0F0F0</span>, <span class="number">0x0F0F0F0F</span>, <span class="number">0xFF00FF00</span>, <span class="number">0x00FF00FF</span>, <span class="number">0xFFFF0000</span>, <span class="number">0x0000FFFF</span>&#125;</span><br><span class="line">    <span class="keyword">var</span> index, power <span class="keyword">uint32</span></span><br><span class="line">    <span class="keyword">for</span> index, power = <span class="number">0</span>, <span class="number">0</span>; index &lt;= <span class="number">8</span>; index, power = index+<span class="number">2</span>, power+<span class="number">1</span> &#123;</span><br><span class="line">        num = ((num &amp; constNums[index]) &gt;&gt; (<span class="number">1</span> &lt;&lt; power)) | ((num &amp; constNums[index+<span class="number">1</span>]) &lt;&lt; (<span class="number">1</span> &lt;&lt; power))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>乍看之下理解不了, 特别是循环中的那句代码, 先给个例子来展示一下 :</p>
<pre><code>原二进制:       00000010100101000001111010011100
第一次循环后:       00000001011010000010110101101100
第二次循环后:       00000100100100101000011110010011
第三次循环后:       01000000001010010111100000111001
第四次循环后:       00101001010000000011100101111000
第五次循环后:       00111001011110000010100101000000</code></pre><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">((num &amp; constNums[index]) &gt;&gt; (<span class="number">1</span> &lt;&lt; power)) | ((num &amp; constNums[index+<span class="number">1</span>]) &lt;&lt; (<span class="number">1</span> &lt;&lt; power))</span><br></pre></td></tr></table></figure>

<p>代码的含义是这样的(诶… 我想想怎么解释一下 = =)</p>
<p>emmm, 先看一个最简单的例子, 那么就能理解了, 首先, 取二进制 01, 只执行一次循环, 看看效果</p>
<p>num &amp; constNums[index]  = 0, (num &amp; constNums[index+1]) = 1, power = 0, 所以结果是 10, 我们得到了反转字符串</p>
<p>那么再来难点的例子, 1101, 这样需要执行两次循环</p>
<p>num &amp; constNums[index]  = 1000,  (num &amp; constNums[index+1]) = 0101, power = 0, 所以第一次循环的结果是 0100 | 1010 = 1110</p>
<p>num &amp; constNums[index]  = 1100, (num &amp; constNums[index+1]) = 0010, power = 1, 所以结果是 0011 | 1000 = 1011</p>
<p>这样大概就能了解了吧, 第一次循环是两位为一组交换位置, 第二次循环是四位为一组交换位置, 所以第一次的二进制是 0xAAAAAAAA, 0x55555555 类似与 101010… 010101… 这样的, 他们的二进制位是相反的, 同理直到达到足够的位数为止, 这道题的复杂度是 O(logn) 级别的, 其中 s = 数字的位数, s = 2 的 n 次方</p>
<p>真是个不错的算法 :)</p>
<p>这个算法能见到 二分 和 递归 的影子, 理解了就会非常简单</p>
<p>看了 go 对于该算法的实现, 也是这样的</p>
<p>顺便, 看了 go 的源码, 其实句子可以更简单 </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">constNums[index] &amp; num &gt;&gt; (<span class="number">1</span> &lt;&lt; power) | constNums[index+<span class="number">1</span>] &amp; num &lt;&lt; (<span class="number">1</span> &lt;&lt; power)</span><br></pre></td></tr></table></figure>

<p>整个代码也可以重构</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseBits</span><span class="params">(n <span class="keyword">uint32</span>)</span> <span class="title">uint32</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> m0 <span class="keyword">uint32</span> = <span class="number">0x55555555</span></span><br><span class="line">    <span class="keyword">var</span> m1 <span class="keyword">uint32</span> = <span class="number">0x33333333</span></span><br><span class="line">    <span class="keyword">var</span> m2 <span class="keyword">uint32</span> = <span class="number">0x0F0F0F0F</span></span><br><span class="line">    <span class="keyword">var</span> m3 <span class="keyword">uint32</span> = <span class="number">0x00FF00FF</span></span><br><span class="line"></span><br><span class="line">    n = n &gt;&gt; <span class="number">1</span> &amp; m0 | n &amp; m0 &lt;&lt; <span class="number">1</span></span><br><span class="line">    n = n &gt;&gt; <span class="number">2</span> &amp; m1 | n &amp; m1 &lt;&lt; <span class="number">2</span></span><br><span class="line">    n = n &gt;&gt; <span class="number">4</span> &amp; m2 | n &amp; m2 &lt;&lt; <span class="number">4</span></span><br><span class="line">    n = n &gt;&gt; <span class="number">8</span> &amp; m3 | n &amp; m3 &lt;&lt; <span class="number">8</span></span><br><span class="line">    <span class="keyword">return</span> n &gt;&gt; <span class="number">16</span> | n &lt;&lt; <span class="number">16</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这基本与 go 的 reverse32 源码一致, 不愧是源码啊…  </p>
<p>这个版本的代码进一步减少了变量和常量, 其中那 index 所代表的一对本就可以用移位来代替</p>
]]></content>
  </entry>
  <entry>
    <title>leetcode/209MininumSizeSubarraySum</title>
    <url>/2020/01/09/leetcode/209MininumSizeSubarraySum/</url>
    <content><![CDATA[<h2 id="Minimun-Size-Subarray-Sum"><a href="#Minimun-Size-Subarray-Sum" class="headerlink" title="Minimun Size Subarray Sum"></a>Minimun Size Subarray Sum</h2><p><img src="https://imgur.com/HJmyh7Q.png" alt=""></p>
<p>不想解释…</p>
<h3 id="my-solution"><a href="#my-solution" class="headerlink" title="my solution"></a>my solution</h3><p>简单思考了一下, 以每个元素为起点, 循环往右找到满足条件的数 </p>
<p>最终做比较, 就可以得出答案</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minSubArrayLen</span><span class="params">(s <span class="keyword">int</span>, nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    size := <span class="built_in">len</span>(nums)</span><br><span class="line">    ret := size</span><br><span class="line">    <span class="keyword">var</span> sum <span class="keyword">int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span>(nums) &#123;</span><br><span class="line">        sum += v</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum &lt; s) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span>(nums) &#123;</span><br><span class="line">        sum = v</span><br><span class="line">        counter := <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i2 := i + <span class="number">1</span>; i2 &lt; size &amp;&amp; sum &lt; s; i2++ &#123;</span><br><span class="line">            sum += nums[i2]</span><br><span class="line">            counter++</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> sum &gt;= s &amp;&amp; counter &lt; ret &#123;</span><br><span class="line">            ret = counter</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的复杂度大概是 O(n2), 同时为了区别特殊情况, 还做了一次… </p>
<h3 id="the-best-solution"><a href="#the-best-solution" class="headerlink" title="the best solution"></a>the best solution</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minSubArrayLen</span><span class="params">(s <span class="keyword">int</span>, nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    size := <span class="built_in">len</span>(nums)</span><br><span class="line">    ret := size + <span class="number">1</span></span><br><span class="line">    start := <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> sum <span class="keyword">int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span>(nums) &#123;</span><br><span class="line">        sum += v</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> sum &gt;= s &amp;&amp; sum - nums[start] &gt;= s &#123;</span><br><span class="line">            sum -= nums[start]</span><br><span class="line">            start++</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> sum &gt;= s &amp;&amp; i - start + <span class="number">1</span> &lt; ret &#123;</span><br><span class="line">            ret = i - start + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ret == size + <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实这是我将算法思想重写后的代码…</p>
<p>简单来说, 就是先找到匹配的 sum, 然后没加一次, 就尝试减少前面的数  </p>
<p>这样遍历之后, 得到的数同样也是最短的</p>
<p>(我很好奇没有是否没有人对数级的解决方案…)</p>
]]></content>
  </entry>
  <entry>
    <title>leetcode/222CountCompleteTreeNodes</title>
    <url>/2020/01/09/leetcode/222CountCompleteTreeNodes/</url>
    <content><![CDATA[<h2 id="222-Count-Complete-Tree-Nodes"><a href="#222-Count-Complete-Tree-Nodes" class="headerlink" title="222. Count Complete Tree Nodes"></a>222. Count Complete Tree Nodes</h2><p><img src="https://imgur.com/7DA2TjB.png" alt=""></p>
<p>统计 complete tree 节点数量</p>
<h3 id="my-solution"><a href="#my-solution" class="headerlink" title="my solution"></a>my solution</h3><p>首先说说我的做法, 我首先想到的是用栈来保存其数据结构, 跟踪路径, 从右至左, 直到找到一条能到达底层的路</p>
<p>first.  my idea  is use stack to save the data structure, trace the route, from right to left, until find a way to bottom node</p>
<p>(前些天被一个 13 说我 leetcode 从不写注释, 我怨念到了现在 = =)</p>
<p>(I was told by a 13 the other day that i never write comments in leetcode. I remember it till now :(  )</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;pair&lt;TreeNode*, <span class="keyword">bool</span>&gt;&gt; nodes;</span><br><span class="line">        </span><br><span class="line">        TreeNode* <span class="built_in">cursor</span> = root;</span><br><span class="line">        <span class="keyword">int</span> ldeep = <span class="number">0</span>, rdeep = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">cursor</span>) &#123;</span><br><span class="line">            <span class="built_in">cursor</span> = <span class="built_in">cursor</span>-&gt;left;</span><br><span class="line">            ++ldeep;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cursor</span> = root;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">cursor</span>) &#123;</span><br><span class="line">            <span class="comment">// 1 means next is a right node</span></span><br><span class="line">            nodes.push(make_pair(<span class="built_in">cursor</span>, <span class="number">1</span>));</span><br><span class="line">            <span class="built_in">cursor</span> = <span class="built_in">cursor</span>-&gt;right;</span><br><span class="line">            ++rdeep;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ret = (<span class="number">1</span> &lt;&lt; ldeep) - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// is a full binary tree</span></span><br><span class="line">        <span class="keyword">if</span> (ldeep == rdeep) </span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!nodes.empty()) &#123;</span><br><span class="line">            <span class="built_in">cursor</span> = nodes.top().first;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">cursor</span>-&gt;right) --ret;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">cursor</span>-&gt;left) --ret;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">cursor</span>-&gt;left || <span class="built_in">cursor</span>-&gt;right)</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            </span><br><span class="line">            nodes.pop();</span><br><span class="line">            --rdeep;</span><br><span class="line">            <span class="comment">// current node is right node, so next node is left node</span></span><br><span class="line">            <span class="keyword">if</span> (!nodes.empty() &amp;&amp; nodes.top().second) &#123;</span><br><span class="line">                nodes.top().second = <span class="number">0</span>;</span><br><span class="line">                nodes.push(make_pair(nodes.top().first-&gt;left, <span class="number">1</span>));</span><br><span class="line">                ++rdeep;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// find next node with next node is right node</span></span><br><span class="line">            <span class="keyword">while</span> (!nodes.empty() &amp;&amp; !nodes.top().second) &#123;</span><br><span class="line">                nodes.pop();</span><br><span class="line">                --rdeep;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// means some errors occur</span></span><br><span class="line">            <span class="keyword">if</span> (nodes.empty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            nodes.top().second = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">cursor</span> = nodes.top().first-&gt;left;</span><br><span class="line">            <span class="keyword">while</span> (<span class="built_in">cursor</span>) &#123;</span><br><span class="line">                nodes.push(make_pair(<span class="built_in">cursor</span>, <span class="number">1</span>));</span><br><span class="line">                <span class="built_in">cursor</span> = <span class="built_in">cursor</span>-&gt;right;</span><br><span class="line">                ++rdeep;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// get the bottom element</span></span><br><span class="line">            <span class="keyword">if</span> (ldeep == rdeep) <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// means some errors occur</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>最不理想的情况下, 最左边只有一个节点, 会遍历掉所有节点 = =. stack 容量应该不会超过 31 个元素. </p>
<p>代码不够整洁, 不够易懂. 勉强算个解法.</p>
<p><img src="https://imgur.com/ST4TQfP.png" alt=""></p>
<h3 id="best-solution"><a href="#best-solution" class="headerlink" title="best solution"></a>best solution</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">is_high</span> <span class="params">(TreeNode* root, <span class="keyword">int</span> path, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    high--;</span><br><span class="line">    <span class="keyword">while</span> (high &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = path &amp; (<span class="number">1</span> &lt;&lt; high);</span><br><span class="line">        <span class="keyword">if</span> (flag &amp;&amp; root-&gt;right) &#123;</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!flag &amp;&amp; root-&gt;left) &#123;</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        high--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countNodes</span> <span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> high = <span class="number">0</span>;</span><br><span class="line">        TreeNode* node = root-&gt;left;</span><br><span class="line">        <span class="keyword">while</span> (node) &#123;</span><br><span class="line">            high++;</span><br><span class="line">            node = node-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> first = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> last = <span class="number">1</span> &lt;&lt; high;</span><br><span class="line">        <span class="keyword">while</span> (first &lt; last) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (first + last) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (is_high(root, mid, high)) &#123;</span><br><span class="line">                first = mid + <span class="number">1</span>;        </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                last = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; high) - <span class="number">1</span> + last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>最后的 return 里面, 用 first 和 last 都可以, 我觉得 last 语义可能更好, 所以换成了 last.</p>
<p>on the end of return, use both first and last. i think ‘last’ more make sence, so i use ‘last’</p>
<p>他的计算是 full tree 节点数 + 底层节点数. 从这个算法中我学到了一些东西, 二进制和 binary tree, 真的有很大可操作空间.</p>
<p>the algorithm is a number of full tree nodes plus bottom nodes. I study something from the algorithm. it’s a lot of skill can use between binary system and binary tree.</p>
<p>在分析算法前, 我先总结一下我从这个算法中看到的规律. </p>
<p>before profiling this algorithm, summarize  some rules of complete tree that I saw in this algorithm</p>
<p>首先, 将树节点排序, root 为 1, 从左到右, 从上到下,  依次递进. 得到类似的图 : </p>
<p>first, sort tree nodes. root is number 1, from left to right, up to down, get this map:</p>
<pre><code>                            1
            2                                3
    4                5                6                7
8(1)    9(2)    10(3)    11(4)    12(5)    13(6)    14(7)    15(8)</code></pre><p>假设一个数, 5, 其二进制为 101, 已知是 binary tree, 所以每个节点的 2 倍就是当前数字右移 1 位, 右尾置 0. 所以 0 代表向左下前进, 1 则代表向右下前进. 分为两种情况.</p>
<p>assume a number, for example 5, it’s binary expression is 101.</p>
<ol>
<li><p>将首位看做无效位, 则 101 = 01, 代表从根向左-&gt;向右, 则得到了数字 5.</p>
<p>treat the first digit as an invalid bit. 101 means left -&gt; right. get the number 5.</p>
</li>
<li><p>将首位看做有效位, 则 101 = 101, 代表从根向右-&gt;向左-&gt;向右, 得到数字 13, 而这个数字, 刚好是底部从左往右的第 5 个数字 + 1 = 第 6 个数字. </p>
<p>treat the first digit as an valid bit. 101 means right -&gt; left -&gt; right. get the number 13. the number sorted by bottom level is the the original number plus one. </p>
<p>(为什么呢? 为什么刚好是 + 1? 因为恒定的, 因为这是 complete tree, 每一层到下一层的相对应那个数的步数都是恒定的. 都是 (2 &lt;&lt; n) - 1, 而 + 1 就刚好是 2 &lt;&lt; n, 这和刚才将首位看做有效位对应上了, 其实将首位看做有效位也就是增加了 2 &lt;&lt; n 而已.)</p>
</li>
</ol>
<p>将一些规律总结后, 就变简单了许多</p>
<p>after summarize some rules, things more simple. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (first &lt; last) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (first + last) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (is_high(root, mid, high)) &#123;</span><br><span class="line">        first = mid + <span class="number">1</span>;        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        last = mid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码就是在首位间不断逼近, 求得的最大的数字, 也就是最后一排. </p>
<p>this code just get more close between ‘first’ and ‘last’. get biggest number, also is the result.</p>
<p>is_high(root, mid, high) 实则是在判断, 最后一排有没有 mid + 1 这个数字, 如果有, 则 first = mid + 1, 意味着这个数字是存在的, 继续不断逼近. 直到最后 last == first, 因为 first = mid + 1, 而 mid = (first + last) / 2, 所以 first 最大不会超过 last. </p>
<p>‘is_higt’ judge is there a number ‘mid + 1’. if is, then ‘first = mid + 1’. means this number is exist.</p>
<p>所以这个解法是利用了 complete tree 的特性. 相当简洁, 也没有使用额外的空间, 时间复杂度是 O(logn), 很不错的解法.</p>
<p>I’m tired… :(     </p>
<p>thanks for browsing :)</p>
]]></content>
  </entry>
  <entry>
    <title>leetcode/230KthSmallestElementInaBST</title>
    <url>/2020/01/09/leetcode/230KthSmallestElementInaBST/</url>
    <content><![CDATA[<h2 id="Kth-Smallest-Element-In-a-BST"><a href="#Kth-Smallest-Element-In-a-BST" class="headerlink" title="Kth Smallest Element In a BST"></a>Kth Smallest Element In a BST</h2><p><img src="https://imgur.com/bstQOJh.png" alt=""></p>
<p>找到二叉树中, 第 n 个最小的节点</p>
<h3 id="my-solution"><a href="#my-solution" class="headerlink" title="my solution"></a>my solution</h3><p>可以一步一步找它的最小节点, 追踪的问题, 可以交给 stack</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">kthSmallest</span><span class="params">(root *TreeNode, k <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">// if root == nil &#123;</span></span><br><span class="line">    <span class="comment">//     return 0</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    stack := []*TreeNode&#123;root&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> root.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">        stack = <span class="built_in">append</span>(stack, root.Left)</span><br><span class="line">        root = root.Left</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pos := <span class="built_in">len</span>(stack) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> foot := <span class="number">1</span>; foot != k; foot++ &#123;</span><br><span class="line">        <span class="comment">// if cur.Right != nil then next is cur.Right.Left(bottom)</span></span><br><span class="line">        <span class="keyword">if</span> stack[pos].Right != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// i really need stack...</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(stack) &gt; pos + <span class="number">1</span> &#123;</span><br><span class="line">                stack[pos + <span class="number">1</span>] = stack[pos].Right</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack = <span class="built_in">append</span>(stack, stack[pos].Right)</span><br><span class="line">            &#125;</span><br><span class="line">            pos++</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> stack[pos].Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(stack) &gt; pos + <span class="number">1</span> &#123;</span><br><span class="line">                    stack[pos + <span class="number">1</span>] = stack[pos].Left</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    stack = <span class="built_in">append</span>(stack, stack[pos].Left)</span><br><span class="line">                &#125;</span><br><span class="line">                pos++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// if cur.Right == nil then next is last biger value</span></span><br><span class="line">            old := stack[pos].Val</span><br><span class="line"></span><br><span class="line">            <span class="comment">// hope BST don't have repetitive value... </span></span><br><span class="line">            <span class="keyword">for</span> stack[pos].Val &lt;= old &#123;</span><br><span class="line">                pos--</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> stack[pos].Val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查找下一节点 (next) 可以这么描述:</p>
<p>如果当前节点 (cur) 有右子节点, 则 next 为右子节点的左根节点</p>
<p>否则, next 为上一个大于当前节点值的节点</p>
<p>这是用递归来实现的, 为了追踪, 使用了 stack </p>
<p>(我好希望 go 能提供一个标准的 stack, 这样代码可以更加简洁. 或许是提供了, 但我不知道?)</p>
<p><img src="https://imgur.com/2mIMNZl.png" alt=""></p>
<p>一次成功, 真好</p>
<h3 id="the-best-solution"><a href="#the-best-solution" class="headerlink" title="the best solution"></a>the best solution</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">kthSmallest</span><span class="params">(root *TreeNode, k <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    helper(root,k,<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> res <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helper</span><span class="params">(root *TreeNode, k <span class="keyword">int</span>, i <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    cur := <span class="number">0</span> </span><br><span class="line">    <span class="keyword">if</span> root.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">        prev := helper(root.Left, k, i)</span><br><span class="line">        cur = prev + <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cur = i</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> cur == k &#123;</span><br><span class="line">        res = root.Val</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> root.Right != <span class="literal">nil</span> &amp;&amp; cur &lt; k &#123;</span><br><span class="line">        <span class="keyword">return</span> helper(root.Right, k, cur+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>emm, 他使用了递归, 用递归来追踪, 可以不用显式追踪数据了, 挺好</p>
]]></content>
  </entry>
  <entry>
    <title>leetcode/25ZReverse_Nodes_in_k-Group</title>
    <url>/2020/01/09/leetcode/25ZReverse_Nodes_in_k-Group/</url>
    <content><![CDATA[<h3 id="25-Reverse-Nodes-in-k-Group"><a href="#25-Reverse-Nodes-in-k-Group" class="headerlink" title="25. Reverse Nodes in k-Group"></a>25. Reverse Nodes in k-Group</h3><p><img src="https://imgur.com/sancVDL.png" alt=""></p>
<p>给定一个链表, 每次反转链表数量为k的节点, 然后返回更改后的链表</p>
<p>k是一个正整数, 小于等于链表的长度, 如果链表的长度不是k的整数倍, 最后遗漏的节点保持原样</p>
<h3 id="my-code"><a href="#my-code" class="headerlink" title="my code"></a>my code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        ListNode* ret = head;</span><br><span class="line">        <span class="keyword">while</span> (head &amp;&amp; head-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">int</span> kt = k;</span><br><span class="line">            ListNode* headt = head;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"></span><br><span class="line">            vec.push_back(headt-&gt;val);</span><br><span class="line">            <span class="keyword">while</span> (--kt &amp;&amp; head-&gt;next) &#123;</span><br><span class="line">                head = head-&gt;next;</span><br><span class="line">                vec.push_back(head-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (kt) <span class="keyword">break</span>;</span><br><span class="line">            reverse(headt, vec);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(ListNode* head, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::reverse_iterator it = vec.rbegin(); it != vec.rend(); ++it) &#123;</span><br><span class="line">            head-&gt;val = *it;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这道题的思路很清晰, 感觉不应该是hard难度的题  </p>
<p>简单地将链表每一部分分开, 然后调用反序函数就可以了</p>
<p>可以优化的点是 while 那里, 以及我可以不用在 while 中判断, reverse 应该能够正常处理元素数量不同的情况  </p>
<p>那么我在最后做一次判断, 将最后一次不用修改的还原就可以了, 这样可以省去 while 中的判断逻辑</p>
<p><img src="https://imgur.com/8QPzS1D.png" alt=""></p>
<p>速度上来说还算不错, 但是资源使用率上就很堪忧了</p>
<h3 id="dalao’s-code"><a href="#dalao’s-code" class="headerlink" title="dalao’s code"></a>dalao’s code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* first, ListNode* last)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode* prev = last;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ( first != last )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> tmp = first-&gt;next;</span><br><span class="line">            first-&gt;next = prev;</span><br><span class="line">            prev = first;</span><br><span class="line">            first = tmp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> node=head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; k; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ( ! node  )</span><br><span class="line">                <span class="keyword">return</span> head; <span class="comment">// nothing to do list too sort</span></span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> new_head = reverse( head, node);</span><br><span class="line">        head-&gt;next = reverseKGroup( node, k);</span><br><span class="line">        <span class="keyword">return</span> new_head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个做法和我的想法基本相同, 但是在细节上的处理很好</p>
<p>首先, 他采用的递归, 这样代码更加简洁易懂</p>
<p>其次循环中是更改链表的指向, 而不是赋值, 这样功能性更强</p>
]]></content>
  </entry>
  <entry>
    <title>leetcode/300LongestIncreasingSubsequence</title>
    <url>/2020/01/09/leetcode/300LongestIncreasingSubsequence/</url>
    <content><![CDATA[<h2 id="300-Longest-Increasing-Subsequence"><a href="#300-Longest-Increasing-Subsequence" class="headerlink" title="300 Longest Increasing Subsequence"></a>300 Longest Increasing Subsequence</h2><p><img src="https://imgur.com/Pn1zsFZ.png" alt=""></p>
<p>找出数组中最大的增长数量</p>
<h3 id="my-solution-8ms-66-89"><a href="#my-solution-8ms-66-89" class="headerlink" title="my solution (8ms, 66.89%)"></a>my solution (8ms, 66.89%)</h3><p>emm… 考虑将每一个下降的 slice 视为一个数组, 因为这些数组只可能产生一个值  </p>
<p>而再将这些 slice 循环, 每次从当前节点选择最小的数字, 每次前进时选择一个最小的比上一个节点大的数字  </p>
<p>然后计数, 一次遍历下来就得到了最大增长序列的长度</p>
<p>复杂度是一次 O(n) 的遍历  + 切片之后数组长度的遍历, 接近 O(n2)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLIS</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stairs := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    temp := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    prev := <span class="number">0x7fffffff</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> v &lt; prev &#123;</span><br><span class="line">            temp = <span class="built_in">append</span>(temp, v)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sort.Ints(temp)</span><br><span class="line">            stairs = <span class="built_in">append</span>(stairs, temp)</span><br><span class="line">            temp = []<span class="keyword">int</span>&#123;v&#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        prev = v</span><br><span class="line">    &#125;</span><br><span class="line">    sort.Ints(temp)</span><br><span class="line">    stairs = <span class="built_in">append</span>(stairs, temp)</span><br><span class="line"></span><br><span class="line">    size := <span class="built_in">len</span>(stairs)</span><br><span class="line">    count, ret := <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; size; i++ &#123;</span><br><span class="line">        prev = stairs[i][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i2 := i + <span class="number">1</span>; i2 &lt; size; i2++ &#123;</span><br><span class="line">            ind, size2 := <span class="number">0</span>, <span class="built_in">len</span>(stairs[i2])</span><br><span class="line">            <span class="keyword">for</span> ind &lt; size2 &amp;&amp; stairs[i2][ind] &lt;= prev &#123;</span><br><span class="line">                ind++</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ind &gt;= size2 || stairs[i2][ind] &lt;= prev &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            count++</span><br><span class="line">            prev = stairs[i2][ind]</span><br><span class="line">        &#125;</span><br><span class="line">        ret = max(ret, count)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ret &gt;= size - i &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        count = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>emm… 代码有点长</p>
<p><img src="https://imgur.com/AqBweht.png" alt=""></p>
<p>8ms 那个是我做的, 0 不是</p>
<h3 id="best-solution"><a href="#best-solution" class="headerlink" title="best solution"></a>best solution</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">binsearch</span><span class="params">(stack []<span class="keyword">int</span>, x <span class="keyword">int</span>)</span> <span class="params">(r <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    l, r := <span class="number">0</span>, <span class="built_in">len</span>(stack)</span><br><span class="line">    <span class="keyword">for</span> l &lt; r &#123;</span><br><span class="line">        m := l + (r - l) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> stack[m] &gt;= x &#123;</span><br><span class="line">            r = m</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l = m + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLIS</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="params">(r <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    stack := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        r := binsearch(stack, num)</span><br><span class="line">        <span class="keyword">if</span> r &lt; <span class="number">0</span> &#123;</span><br><span class="line">            stack[<span class="number">0</span>] = num</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> r == <span class="built_in">len</span>(stack) &#123;</span><br><span class="line">            stack = <span class="built_in">append</span>(stack, num)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stack[r] = num</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(stack)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单来说就是通过不断将数组按照升序添加到 slice 里面  (我将其称作 slice, 因为它的行为不太像 stack)</p>
<p>slice 的元素只有两种情况会变更:  </p>
<p>要么有更小的元素覆盖, 要么比 slice 中所有元素都大, 然后 append</p>
<p>因为题目要求的只要长度, 所以即使 slice 里面元素可能是错误的, 也没关系, 长度是对的</p>
<p>这样的复杂度是 O(n), 其实原理还是挺容易理解的, 为什么我就没想到呢 = =</p>
]]></content>
  </entry>
  <entry>
    <title>leetcode/31ZNextPermutation</title>
    <url>/2020/01/09/leetcode/31ZNextPermutation/</url>
    <content><![CDATA[<h3 id="31-Next-Permutation"><a href="#31-Next-Permutation" class="headerlink" title="31 Next Permutation"></a>31 Next Permutation</h3><p><img src="https://imgur.com/bSdV2cb.png" alt=""></p>
<p>简单来说就是找下一个比当前数字更大的数, 如果没有, 就重新排序</p>
<h3 id="my-code"><a href="#my-code" class="headerlink" title="my code"></a>my code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">size_t</span> <span class="built_in">size</span> = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">size</span> - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> i2 = nums[i - <span class="number">1</span>];</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = nums.<span class="built_in">end</span>();</span><br><span class="line">                <span class="keyword">while</span> ( ++i2 &lt; <span class="built_in">size</span> ) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ( ( it = <span class="built_in">find</span>(nums.<span class="built_in">begin</span>() + i + <span class="number">1</span>, nums.<span class="built_in">end</span>(), i2) ) != nums.<span class="built_in">end</span>() )</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> ( it != nums.<span class="built_in">end</span>() ) &#123;</span><br><span class="line">                    *it ^= nums[i - <span class="number">1</span>];</span><br><span class="line">                    nums[i - <span class="number">1</span>] ^= *it;</span><br><span class="line">                    *it ^= nums[i - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    nums[i] ^= nums[i - <span class="number">1</span>];</span><br><span class="line">                    nums[i - <span class="number">1</span>] ^= nums[i];</span><br><span class="line">                    nums[i] ^= nums[i - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                sort(nums.<span class="built_in">begin</span>() + i, nums.<span class="built_in">end</span>());</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>思路很简单, 从右到左找到第一个”不和谐”的点B (该点数字比前面的数字A大)  </p>
<p>然后拿A, 从这个不和谐的点B往右找下一个比A大的数, 交换  </p>
<p>之后重排序B右边的数字(包括B)</p>
<p><img src="https://imgur.com/rdDSHLJ.png" alt=""></p>
<p>emmmm… 结果不太好呢… </p>
<h3 id="dalao’s-code"><a href="#dalao’s-code" class="headerlink" title="dalao’s code"></a>dalao’s code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> _ = []() &#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="comment">// 很 6 啊, 这里实际是一个值, 全局的 static 变量, 他的执行会在 main 之前 </span></span><br><span class="line"><span class="comment">// 会求值 lambda 表达式中的内容, 而值并不是主要的目的, 甚至不是目的  </span></span><br><span class="line"><span class="comment">// 他是想调用其中的加速流操作的函数, 所以lambda最后有个()运算符, 果然我是条咸鱼...</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        next_permutation(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()); <span class="comment">// emm. 这是标准库函数...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>里面有一些我看不懂的东西, 涉及到 c++ 的流</p>
<pre><code>ios::sync_with_stdio(false);    // 是否兼容printf
cin.tie(nullptr);        // 在每一次输入之前, 不要让他调用 cout 的 flushing</code></pre><p>网上查了一下, 加速流的输入输出…</p>
<p><a href="http://www.hankcs.com/program/cpp/cin-tie-with-sync_with_stdio-acceleration-input-and-output.html" target="_blank" rel="noopener">http://www.hankcs.com/program/cpp/cin-tie-with-sync_with_stdio-acceleration-input-and-output.html</a></p>
<p><a href="https://www.geeksforgeeks.org/fast-io-for-competitive-programming/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/fast-io-for-competitive-programming/</a></p>
<p>dalao 就是 dalao… </p>
<p>我是怎么在不知道这一对函数的情况下活到今天的<img src="http://img.baidu.com/hi/jx2/j_0012.gif" alt="img"></p>
]]></content>
  </entry>
  <entry>
    <title>leetcode/334IncreasingTripletSubsequence</title>
    <url>/2020/01/09/leetcode/334IncreasingTripletSubsequence/</url>
    <content><![CDATA[<h2 id="334-Increasing-Triplet-Subsequence"><a href="#334-Increasing-Triplet-Subsequence" class="headerlink" title="334 Increasing Triplet Subsequence"></a>334 Increasing Triplet Subsequence</h2><p><img src="https://imgur.com/InKKTPj.png" alt=""></p>
<p>找出数组中是否存在n个连续增长数列</p>
<h3 id="my-solution-0ms-100"><a href="#my-solution-0ms-100" class="headerlink" title="my solution (0ms, 100%)"></a>my solution (0ms, 100%)</h3><p>这道题的解法来自于在做完另一道题后, 观察最佳算法时获得的技巧</p>
<p>简单来说, 这可以用一个可覆写的数组来实现</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">increasingTriplet</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    vec := []<span class="keyword">int</span>&#123;<span class="number">1</span> &lt;&lt; <span class="number">63</span> - <span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> v &gt; vec[<span class="built_in">len</span>(vec) - <span class="number">1</span>] &#123;</span><br><span class="line">            vec = <span class="built_in">append</span>(vec, v)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(vec) &gt; <span class="number">2</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, v2 := <span class="keyword">range</span> vec &#123;</span><br><span class="line">            <span class="keyword">if</span> v &lt;= v2 &#123;</span><br><span class="line">                vec[i] = v</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为答案仅仅需要一个 bool 值, 所以可以这么做  </p>
<p>不过, 有时候, vec 的值会是错误的, 同时这个解可以用于 n 个数字, 也可用于递减数组</p>
<p>(同时, 如果我在讨论中, 没有看到相应语言完全比我好的解法, 我会开始分享自己的解法)</p>
<p>(<a href="https://leetcode.com/problems/increasing-triplet-subsequence/discuss/298228/go-simple-solution-O(n)-100" target="_blank" rel="noopener">https://leetcode.com/problems/increasing-triplet-subsequence/discuss/298228/go-simple-solution-O(n)-100</a>)</p>
<p><img src="https://imgur.com/jg6NqJV.png" alt=""></p>
<p>开始没想到, 尝试了几次之后想到的</p>
<h3 id="best-solution"><a href="#best-solution" class="headerlink" title="best solution"></a>best solution</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">increasingTriplet</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    min1,min2:= <span class="number">2</span>&lt;&lt;<span class="number">32</span><span class="number">-1</span>,<span class="number">2</span>&lt;&lt;<span class="number">32</span><span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> _,v:=<span class="keyword">range</span> nums&#123;</span><br><span class="line">        <span class="keyword">if</span> v&lt;=min1&#123;</span><br><span class="line">            min1=v</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> v&lt;=min2&#123;</span><br><span class="line">            min2=v</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>EHM… 我好像又把问题复杂化了…  </p>
<p>不过没关系, 我的解可以用于 n 个序列 (我如此安慰自己)</p>
]]></content>
  </entry>
  <entry>
    <title>leetcode/338CountingBits</title>
    <url>/2020/01/09/leetcode/338CountingBits/</url>
    <content><![CDATA[<h2 id="338-Counting-Bits"><a href="#338-Counting-Bits" class="headerlink" title="338 Counting Bits"></a>338 Counting Bits</h2><p><img src="https://imgur.com/319pMc1.png" alt=""></p>
<p>不想解释</p>
<h3 id="my-solution-没脸说…"><a href="#my-solution-没脸说…" class="headerlink" title="my solution  (没脸说…)"></a>my solution  (没脸说…)</h3><p>这样的东西必定有规律, 找出来就好了</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countBits</span><span class="params">(num <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    ret := []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">    last := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, size := <span class="number">3</span>, <span class="number">16</span>; size &lt;= num; i++ &#123;</span><br><span class="line">        beg := size - size / <span class="number">4</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> beg + <span class="number">4</span> &lt;= size &#123;</span><br><span class="line">            last = <span class="built_in">append</span>(last[:], ret[beg:]...)</span><br><span class="line">            beg = beg + (size - beg) / <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        last = <span class="built_in">append</span>(last[:], []<span class="keyword">int</span>&#123;i, i + <span class="number">1</span>, i + <span class="number">1</span>, i + <span class="number">2</span>&#125;...)</span><br><span class="line">        ret = <span class="built_in">append</span>(ret[:], last[:]...)</span><br><span class="line">        size *= <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = ret[:num + <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>规律如下, 每次的增加都是上次的一半的递归 (我不知道怎么解释这种规律, 感觉语言很苍白…)</p>
<pre><code>0,1,1,2,
1,2,2,3,
1,2,2,3, 2,3,3,4,
1,2,2,3, 2,3,3,4, 2,3,3,4, 3,4,4,5,
1,2,2,3, 2,3,3,4, 2,3,3,4, 3,4,4,5, 2,3,3,4, 3,4,4,5, 3,4,4,5, 2,3,3,4, 3,4,4,5, 4,5,5,6</code></pre><p>仔细观察一下就发现了</p>
<p>我本来以为我的解法很不错, 计算次数很少, 几乎没有, 大部分的运算都是 append, 应该会很快, 然而…</p>
<p><img src="https://imgur.com/DpNioZ0.png" alt=""></p>
<p>那个几十毫秒的不是我的, 800/900 的才是 = =</p>
<h3 id="best-solution"><a href="#best-solution" class="headerlink" title="best solution"></a>best solution</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countBits</span><span class="params">(num <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    result := <span class="built_in">make</span>([]<span class="keyword">int</span>, num+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= num; i++ &#123;</span><br><span class="line">        result[i] = result[i &amp; (i<span class="number">-1</span>)] + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>他是通过计算出来的, 比我好在于, 他不会计算多余的, 然后需要裁剪</p>
<p>(BTW 这个算法与我原算法的速度相差无几, 但是等价的 C++ 代码却只需要几十毫秒)</p>
<p>(加上 tie 和 sync_with_stdio, 可能速度能更快, 我不禁陷入了沉思…)</p>
]]></content>
  </entry>
  <entry>
    <title>leetcode/377CombinationSumIV</title>
    <url>/2020/01/09/leetcode/377CombinationSumIV/</url>
    <content><![CDATA[<h2 id="Combination-Sum-IV"><a href="#Combination-Sum-IV" class="headerlink" title="Combination Sum IV"></a>Combination Sum IV</h2><p><img src="https://imgur.com/9bn22To.png" alt=""></p>
<p>找出满足条件组合的次数</p>
<h3 id="my-solution"><a href="#my-solution" class="headerlink" title="my solution"></a>my solution</h3><p>没脸写出来 </p>
<h3 id="best-solution"><a href="#best-solution" class="headerlink" title="best solution"></a>best solution</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combinationSum4</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> target &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, target+<span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= target; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">            <span class="keyword">if</span> i-num &gt;= <span class="number">0</span> &#123;</span><br><span class="line">                dp[i] += dp[i-num]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[target]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>0 1 = 1
1 1 = 1
2 1 1 = 2
3 2 1 1 = 4
4 4 2 1 = 7</code></pre><p>不太好描述这个规律, 有点类似于 “万丈高楼平地起”, 简单来说就是一个迭代/包含的过程</p>
<p>比较关键的地方在于循环中的 if (感觉是废话 = = )</p>
<p>我想过, 是否会出现一种情况, 这种情况通过了判断, 但是实际上不正确  </p>
<p>比如 当 i = 3 的时候, num = 2, 通过了判断, 但是此时没有 1 那么就无法组成 4 </p>
<p>这种情况成立么? 答案是否定的, 因为 2 中的次数就包含了有 1, 如果没有 1, 2 也将会是 0 </p>
<p>假设 P(x) 为 x 所包含的次数, 上述解法就是 P(x) = P(x - 1) + … + P(1) (等式右侧每项参数都位于nums中)</p>
<p>(感觉越描越黑了 - - )  </p>
]]></content>
  </entry>
  <entry>
    <title>leetcode/32ZLongestValidParentheses</title>
    <url>/2020/01/09/leetcode/32ZLongestValidParentheses/</url>
    <content><![CDATA[<h3 id="Longest-Valid-Parentheses"><a href="#Longest-Valid-Parentheses" class="headerlink" title="Longest Valid Parentheses"></a>Longest Valid Parentheses</h3><p><img src="https://imgur.com/ErQh0hJ.png" alt=""></p>
<p>一个只包含字符 ‘(‘ 和字符 ‘)’ 的字符串, 找到最长的有效括号层数</p>
<h3 id="my-solution"><a href="#my-solution" class="headerlink" title="my solution"></a>my solution</h3><p>这个问题的核心是如何知道, 哪个 ‘)’ 和哪个 ‘(‘ 匹配  </p>
<p>这种情况, 如果用栈来解决的话会简单很多</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> _ = []() &#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">size</span> = s.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vecc;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">'('</span>) &#123;</span><br><span class="line">                vecc.push_back(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;    <span class="comment">// asume is )</span></span><br><span class="line">                <span class="keyword">if</span> (vecc.<span class="built_in">size</span>() &amp;&amp; s[vecc.back()] == <span class="string">'('</span>) &#123;</span><br><span class="line">                    s[i] = <span class="string">'0'</span>;</span><br><span class="line">                    s[vecc.back()] = <span class="string">'0'</span>;</span><br><span class="line">                    vecc.pop_back();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;  <span class="comment">// asume if (vecc.back() != '(') </span></span><br><span class="line">                    vecc.<span class="built_in">clear</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>, now = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">'0'</span>)</span><br><span class="line">                ++now;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ret = <span class="built_in">max</span>(now, ret);</span><br><span class="line">                now = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(now, ret);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我并没有想到一次循环并找到最大长度的办法  </p>
<p>采用的是一次循环将所有能够合并的括号全部替换, 再用一次循环来找到其中最长的序列  </p>
<p><img src="https://imgur.com/8VYDL2H.png" alt=""></p>
<p>效果比想象中的要好, 可能是归功于快速IO  </p>
<h3 id="the-best-solution-4ms"><a href="#the-best-solution-4ms" class="headerlink" title="the best solution (4ms)"></a>the best solution (4ms)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> _= []()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();	<span class="comment">// 在 hard 难度的题里面, 这个东西频繁出现</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxLength = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(s.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 只处理当前值是 ')' 的情况</span></span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">')'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果上一个值是 '('</span></span><br><span class="line">                <span class="keyword">if</span> (s[i - <span class="number">1</span>] == <span class="string">'('</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 如果当前下标超出了 2, 意味着可以加上之前的宽度</span></span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">2</span>)</span><br><span class="line">                        dp[i] = dp[i - <span class="number">2</span>] + <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="comment">// 否则宽度直接为 2 </span></span><br><span class="line">                        dp[i] = <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果上一个值是 ')'</span></span><br><span class="line">                <span class="keyword">else</span> <span class="comment">// s[i-1] == ')'</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 暂时保存上一个下标所记录的步数</span></span><br><span class="line">                    <span class="keyword">int</span> prev = dp[i - <span class="number">1</span>];</span><br><span class="line">                    <span class="comment">// 先判断下标是否有效, s[i - prev - 1] 的含义是</span></span><br><span class="line">                    <span class="comment">// 当前下标 减去 上一个下标记录的宽度, 那么就来到了这个宽度的起始位置</span></span><br><span class="line">                    <span class="comment">// 再减去 1, 就得到了这个宽度的上一个字符, 如果是 '(' 则代表宽度可以继续增加2</span></span><br><span class="line">                    <span class="keyword">if</span> (i - prev - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; s[i - prev - <span class="number">1</span>] == <span class="string">'('</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 宽度增加了 2</span></span><br><span class="line">                        dp[i] = dp[i - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">                        <span class="comment">// 再判断上一个区间的索引值是否合法</span></span><br><span class="line">                        <span class="keyword">if</span> (i - prev - <span class="number">2</span> &gt;= <span class="number">0</span>)</span><br><span class="line">                            <span class="comment">// 合法的话就再加上上一个区间的宽度</span></span><br><span class="line">                            dp[i] += dp[i - prev - <span class="number">2</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : dp)</span><br><span class="line">            maxLength = <span class="built_in">max</span>(maxLength, n);</span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>算法给人的第一感觉是”脚印”, 如果上一个”脚印”有效, 就加上他, 这样慢慢增加</p>
<p>他也是由两次循环组成, 第一个循环计算每次的步数, 第二次循环找到最大值</p>
<p>规律总结在代码注释, 假设字符串是 “()))()))()”, 那么他的 dp 可能是 0 2 0 0 0 2 0 0 0 2 </p>
<p>“())(())()()()))” dp 可能是 0 2 0 0 0 2 4 0 6 0 8 0 [10] 0 0</p>
<p>(眼睛有点花… 不过应该没错)</p>
<p>大抵来说:</p>
<ol>
<li>跳过了 ‘(‘ 的判断, 这会使需要处理的情况少 1/2</li>
<li>赋值少了 1/2, 他不对 ‘(‘ 的索引进行计算</li>
</ol>
<p>emmm… 学到了很多  </p>
<p>感觉”脚印”这个概念在很多算法里面都看到过, 一个个累加将复杂的计算分为了很多的小计算</p>
]]></content>
  </entry>
  <entry>
    <title>leetcode/45ZJumpGameII</title>
    <url>/2020/01/09/leetcode/45ZJumpGameII/</url>
    <content><![CDATA[<h3 id="45-Jump-Game-II"><a href="#45-Jump-Game-II" class="headerlink" title="45. Jump Game II"></a>45. Jump Game II</h3><p><img src="https://imgur.com/i8ucDdk.png" alt=""></p>
<p>给定一个非负整数的数字, 你开始在数组的第一个索引处</p>
<p>每一个在数组中的元素代表你能够跳跃的最大距离  </p>
<p>你的目标是找到到达最后一个索引的最小跳跃数</p>
<h3 id="my-code"><a href="#my-code" class="headerlink" title="my code"></a>my code</h3><p>要达到最小跳跃数的话, 那么只要保证每次跳跃的距离是最大的就可以了</p>
<p>每个节点的跳跃距离是 节点距离起始节点的距离 + 节点自身值</p>
<p>感觉比上一个 jump 简单</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">size_t</span> <span class="built_in">size</span> = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">size</span> &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> route = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i + nums[i] &gt;= <span class="built_in">size</span> - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> ++route;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> maxn = nums[i] + nums[i + nums[i]];</span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">step</span> = nums[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i2 = i + <span class="number">1</span>; i2 &lt;= (i + nums[i]); ++i2) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i2 - i + nums[i2] &gt; maxn) &#123;</span><br><span class="line">                    maxn = i2 - i + nums[i2];</span><br><span class="line">                    <span class="built_in">step</span> = i2 - i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            i += <span class="built_in">step</span>;</span><br><span class="line">            ++route;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://imgur.com/psf3MTs.png" alt=""></p>
<p>结果还行, 看一下最好的算法</p>
<h3 id="the-best-solution"><a href="#the-best-solution" class="headerlink" title="the best solution"></a>the best solution</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> fast_io = []() &#123;</span><br><span class="line"><span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;();	<span class="comment">// 我已经不会见到这个会觉得奇怪了!</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans(n, n);</span><br><span class="line">        ans[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]+i &gt;= n<span class="number">-1</span>) ans[n<span class="number">-1</span>] = <span class="built_in">min</span>(ans[n<span class="number">-1</span>], ans[i]+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">                <span class="keyword">while</span> (temp &gt; <span class="number">0</span> &amp;&amp; ans[i+temp] &gt; ans[i]+<span class="number">1</span>) ans[i+(temp--)] = ans[i]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>大致想法上好像差不多</p>
<p>看不太懂, 但是我感觉好像差不多  </p>
<p>它多了一个长度为 n 的数组, 并且循环是线性 n </p>
<p>(我没有使用数组, 并且循环是以 step 为距离, 唯一会在速度上决胜负的应该是我for 中的 for 和他for中的while对比, 他的while可以提前退出的, 综合来说, 我觉得这次我的算法不输他! (有点膨胀 :) … ) )</p>
<p>我将前面的 fast_io 添加进我的代码后, 也达到了最好的速度</p>
<p><img src="https://imgur.com/s4fSkM2.png" alt=""></p>
<p>emmm, 那就不花时间研究他的算法了~</p>
]]></content>
  </entry>
  <entry>
    <title>leetcode/46ZPermutations</title>
    <url>/2020/01/09/leetcode/46ZPermutations/</url>
    <content><![CDATA[<h3 id="46ZPermutations"><a href="#46ZPermutations" class="headerlink" title="46ZPermutations"></a>46ZPermutations</h3><p><img src="https://imgur.com/qKQUxju.png" alt=""></p>
<p>给定一个整数数组集合, 返回所有的数组排列可能</p>
<h3 id="my-solution-16ms"><a href="#my-solution-16ms" class="headerlink" title="my solution (16ms)"></a>my solution (16ms)</h3><p>如果单纯想要做出来, 很简单, 递归就完事了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> _ = []() &#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permute(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v) &#123;</span><br><span class="line">        <span class="keyword">size_t</span> <span class="built_in">size</span> = v.<span class="built_in">size</span>(); </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">size</span> == <span class="number">1</span>) <span class="keyword">return</span> &#123;v&#125;;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">size</span> == <span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// asume size &gt;= 2;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; ++i) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp = v;</span><br><span class="line">            temp.erase(temp.<span class="built_in">begin</span>() + i);</span><br><span class="line"></span><br><span class="line">            permute_do(&#123;v[i]&#125;, temp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">permute_do</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; curv, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">size_t</span> <span class="built_in">size</span> = v.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">size</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            ret.push_back(curv);</span><br><span class="line">            ret.back().push_back(v.front());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; ++i) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tempV = v;</span><br><span class="line">            tempV.erase(tempV.<span class="built_in">begin</span>() + i);</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tempCurv = curv;</span><br><span class="line">            tempCurv.push_back(v[i]);</span><br><span class="line"></span><br><span class="line">            permute_do(tempCurv, tempV);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>内存使用率应该很高, 因为每一次递归都会重新创建临时对象  </p>
<p>但是想不到什么好的方式在不影响速度的情况下解决这个问题…</p>
<p><img src="https://imgur.com/pu5YhhK.png" alt=""></p>
<p>emmm, 内存使用果然很高…  </p>
<p>(这个问题是几个月之前尝试过的, 试了 3 次没有成功, 今天一次就成功了, </p>
<p>而且解题的时间也挺短的, 看来进步还不错)</p>
<h3 id="the-best-solution-14ms"><a href="#the-best-solution-14ms" class="headerlink" title="the best solution (14ms)"></a>the best solution (14ms)</h3><p>看一下最好的算法是怎么解决这个问题的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; permute(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;num) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; result;</span><br><span class="line"></span><br><span class="line">        permuteRecursive(num, <span class="number">0</span>, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// permute num[begin..end]</span></span><br><span class="line">    <span class="comment">// invariant: num[0..begin-1] have been fixed/permuted</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">permuteRecursive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;num, <span class="keyword">int</span> <span class="built_in">begin</span>, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;result)</span>	</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">begin</span> &gt;= num.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="comment">// one permutation instance</span></span><br><span class="line">            result.push_back(num);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">begin</span>; i &lt; num.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            swap(num[<span class="built_in">begin</span>], num[i]);</span><br><span class="line">            permuteRecursive(num, <span class="built_in">begin</span> + <span class="number">1</span>, result);</span><br><span class="line">            <span class="comment">// reset</span></span><br><span class="line">            swap(num[<span class="built_in">begin</span>], num[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>他将 permute 中的循环合并到了 permuteRecursive 里面  </p>
<p>核心在于 swap, 通过交换, 这样 result 就始终只有一个, 取而代之的是多了一个 int 参数传递</p>
]]></content>
  </entry>
  <entry>
    <title>leetcode/47ZPermutaionsII</title>
    <url>/2020/01/09/leetcode/47ZPermutaionsII/</url>
    <content><![CDATA[<h3 id="Permutaions-II"><a href="#Permutaions-II" class="headerlink" title="Permutaions II"></a>Permutaions II</h3><p><img src="https://imgur.com/afcpZbV.png" alt=""></p>
<p>给定一个数组, 返回数组中所有不重复的序列</p>
<h3 id="my-solutions-108-gt-24ms"><a href="#my-solutions-108-gt-24ms" class="headerlink" title="my solutions (108 -&gt; 24ms)"></a>my solutions (108 -&gt; 24ms)</h3><p>一开始我的想法是, 按照 46 题的解法, 然后用 set 自动去重</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> _ = []() &#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permuteUnique(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v) &#123;</span><br><span class="line">        <span class="built_in">size</span> = v.<span class="built_in">size</span>(); </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">size</span> == <span class="number">1</span>) <span class="keyword">return</span> &#123;v&#125;;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">size</span> == <span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        permuteUnique_do(v, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123; ret.<span class="built_in">begin</span>(), ret.<span class="built_in">end</span>() &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">permuteUnique_do</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; curv, <span class="keyword">int</span> <span class="built_in">begin</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">begin</span> &gt;= <span class="built_in">size</span>) &#123;</span><br><span class="line">            ret.insert(ret.<span class="built_in">begin</span>(), curv);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">begin</span>; i &lt; <span class="built_in">size</span>; ++i) &#123;</span><br><span class="line">            swap(curv[i], curv[<span class="built_in">begin</span>]);</span><br><span class="line">            permuteUnique_do(curv, <span class="built_in">begin</span> + <span class="number">1</span>);</span><br><span class="line">            swap(curv[i], curv[<span class="built_in">begin</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">    <span class="keyword">size_t</span> <span class="built_in">size</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>但是这得到了 108 ms 的答案, 我思索了一下, 速度的瓶颈在于: </p>
<p>我对多个数做了同样的操作, 但最后将他们其中的大部分都抛弃了  </p>
<p>要结局这种问题, 需要从源头入手, 在操作之前, 就将这些数据跳过  </p>
<p>不过我暂时没有什么好的想法, 看了一下最好的答案  </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> _ = []() &#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permuteUnique(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            res.push_back(nums);</span><br><span class="line">        &#125;<span class="keyword">while</span>(next_permutation(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()));</span><br><span class="line">        res.erase(unique(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>()),res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>emmm, 他又用了标准库  </p>
<p>本来想着这道题就这样算了, 但是突然想到, 这好像和 31 题很类似…  </p>
<p>然后我改良了一下算法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> _ = []() &#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permuteUnique(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v) &#123;</span><br><span class="line">        <span class="keyword">size_t</span> <span class="built_in">size</span> = v.<span class="built_in">size</span>(); </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">size</span> == <span class="number">1</span>) <span class="keyword">return</span> &#123;v&#125;;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">size</span> == <span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        sort( v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>() );</span><br><span class="line">        ret.push_back(v);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ( nextPermutation(v) ) &#123;</span><br><span class="line">            ret.push_back(v);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">size_t</span> <span class="built_in">size</span> = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">size</span> - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> i2 = nums[i - <span class="number">1</span>];</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = nums.<span class="built_in">end</span>();</span><br><span class="line">                <span class="keyword">while</span> ( ++i2 &lt; <span class="built_in">size</span> ) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ( ( it = <span class="built_in">find</span>(nums.<span class="built_in">begin</span>() + i + <span class="number">1</span>, nums.<span class="built_in">end</span>(), i2) ) != nums.<span class="built_in">end</span>() )</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> ( it != nums.<span class="built_in">end</span>() ) &#123;</span><br><span class="line">                    *it ^= nums[i - <span class="number">1</span>];</span><br><span class="line">                    nums[i - <span class="number">1</span>] ^= *it;</span><br><span class="line">                    *it ^= nums[i - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    nums[i] ^= nums[i - <span class="number">1</span>];</span><br><span class="line">                    nums[i - <span class="number">1</span>] ^= nums[i];</span><br><span class="line">                    nums[i] ^= nums[i - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                sort(nums.<span class="built_in">begin</span>() + i, nums.<span class="built_in">end</span>());</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>形状和 the best solution 类似, 但是过程我自己实现了, 换成了我在 31 题中的解法  </p>
<p><img src="https://imgur.com/O8YEq7O.png" alt=""></p>
<p>最后, 我得到了仅次于最好答案的速度</p>
<p>(标准库还是没办法比得过的, 我什么时候能写出标准库一样漂亮的代码呢?)</p>
<p>(PS: 我是不是改抽一部分时间去分析一下标准库的东西?)</p>
<p>(一开始的 236 是我未将参数以引用传递)</p>
<p>(后面的 32 是我将 size 换成了类变量, 但是时间增加了, 看来对于经常访问的变量, 还是局部变量好)  </p>
<p>(PS: 我不是分析过这些东西么, 为什么会犯这种错…)</p>
]]></content>
  </entry>
  <entry>
    <title>leetcode/59ZSpiralMatrixII</title>
    <url>/2020/01/09/leetcode/59ZSpiralMatrixII/</url>
    <content><![CDATA[<h3 id="Spiral-Matrix-II"><a href="#Spiral-Matrix-II" class="headerlink" title="Spiral Matrix II"></a>Spiral Matrix II</h3><p><img src="https://imgur.com/6FsdN4f.png" alt=""></p>
<p>没什么好说的, 旋转填充N宫格</p>
<h3 id="my-solution-4ms"><a href="#my-solution-4ms" class="headerlink" title="my solution (4ms)"></a>my solution (4ms)</h3><p>可以用一个 while + 4个for 来做, 这样是最直观, 最好理解的  </p>
<p>但是不太想这样, 感觉太丑陋了… 所以想了一下办法在一个循环中实现它</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; generateMatrix(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret( n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>) );</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">step</span> &#123; &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125; &#125;;</span><br><span class="line">        <span class="keyword">int</span> type = <span class="number">0</span>, count = <span class="number">0</span>, xstep = <span class="number">0</span>, ystep = <span class="number">0</span>;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> nums = <span class="number">1</span>, <span class="built_in">end</span> = n * n; nums &lt;= <span class="built_in">end</span>; ) &#123;</span><br><span class="line">            ret[ystep][xstep] = nums++;</span><br><span class="line"></span><br><span class="line">            xstep += <span class="built_in">step</span>[type][<span class="number">0</span>];</span><br><span class="line">            ystep += <span class="built_in">step</span>[type][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            count = ++count &gt;= (n - <span class="number">1</span>) ? count - n + <span class="number">1</span> : count;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                type = ++type % <span class="number">4</span>;</span><br><span class="line">                <span class="keyword">if</span> (type == <span class="number">0</span>) &#123;</span><br><span class="line">                    n -= <span class="number">2</span>;</span><br><span class="line">                    xstep += <span class="number">1</span>;</span><br><span class="line">                    ystep += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>前进有4个方向, 每次的位移是一定的, 而且是按照循环来做位移  </p>
<p>所以用了取余和数组来确定每一次的位移是正确的</p>
<p>然后是将每个方向的步数看做同一个值, 所以求取步数在之前  </p>
<p>比如 n = 3: </p>
<pre><code>[ 1, 2, 3 ],
[ 8, 9, 4 ],
[ 7, 6, 5 ]</code></pre><p>则是按照 1, 2   3, 4 … ( (4 * n - 1) )这样的概念来前进, 但是问题在于</p>
<p>如果将计算步数的操作放到了最后, 那么 3 就会被错误计算, 所以保存了一下最后一次越界前的值</p>
<p>(我隐约感觉这里应该能够优化, 毕竟这样写出来的代码不易理解)</p>
<p><img src="https://imgur.com/IJDHb1y.png" alt=""></p>
<p>结果没什么好说的</p>
<h3 id="the-best-solution-4ms"><a href="#the-best-solution-4ms" class="headerlink" title="the best solution (4ms)"></a>the best solution (4ms)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; generateMatrix(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; result(n,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            result[<span class="number">0</span>][<span class="number">0</span>] = n;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> bottom = n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = n<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> index = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(top&lt;=bottom)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=left;i&lt;=right;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                result[top][i]=index;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=top+<span class="number">1</span>;i&lt;bottom;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                result[i][right]=index;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(top&lt;bottom)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=right;i&gt;=left;i--)</span><br><span class="line">                &#123;</span><br><span class="line">                   result[bottom][i]=index;</span><br><span class="line">                    index++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(left&lt;right)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=bottom<span class="number">-1</span>;i&gt;top;i--)</span><br><span class="line">                &#123;</span><br><span class="line">                    result[i][left]=index;</span><br><span class="line">                    index++;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">            top++;</span><br><span class="line">            bottom--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我不喜欢丑陋的 while for for for for :(  , 就不分析了</p>
]]></content>
  </entry>
  <entry>
    <title>leetcode/56ZMergeIntervals</title>
    <url>/2020/01/09/leetcode/56ZMergeIntervals/</url>
    <content><![CDATA[<h3 id="Merge-Intervals"><a href="#Merge-Intervals" class="headerlink" title="Merge Intervals"></a>Merge Intervals</h3><p><img src="https://imgur.com/EpONkBi.png" alt=""></p>
<p>给定一个区间的集合, 合并所有重复的区间</p>
<h3 id="my-solution-12ms"><a href="#my-solution-12ms" class="headerlink" title="my solution (12ms)"></a>my solution (12ms)</h3><p>可以通过重新排序的形式来一步步合并, 比如:</p>
<p>start:     1 2 8  15</p>
<p>end:      3 6 10 18</p>
<p>其中 start 和 end 是经排序后的数组  </p>
<p>从 1 开始, 如果接下来的开始下标小于当前的结束下标 (2 &lt; 3)  </p>
<p>那么, 就可以合并, 继续对比下一个. (8 &lt; 6) 不成立, 那么第一个区间就出现了, 1-6  </p>
<p>接下来从 8 开始, 继续以上步骤, 直至数组尾部, 这样算法的复杂度就是 O(n)  </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for an interval.</span></span><br><span class="line"><span class="comment"> * struct Interval &#123;</span></span><br><span class="line"><span class="comment"> *     int start;</span></span><br><span class="line"><span class="comment"> *     int end;</span></span><br><span class="line"><span class="comment"> *     Interval() : start(0), end(0) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     Interval(int s, int e) : start(s), end(e) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> _ = []() &#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;Interval&gt; merge(<span class="built_in">vector</span>&lt;Interval&gt;&amp; intervals) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; start;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">end</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Interval&gt; ret;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; it : intervals) &#123;</span><br><span class="line">            start.push_back(it.start);</span><br><span class="line">            <span class="built_in">end</span>.push_back(it.<span class="built_in">end</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sort(start.<span class="built_in">begin</span>(), start.<span class="built_in">end</span>());</span><br><span class="line">        sort(<span class="built_in">end</span>.<span class="built_in">begin</span>(), <span class="built_in">end</span>.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">size_t</span> <span class="built_in">size</span> = start.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; ) &#123;</span><br><span class="line">            <span class="keyword">int</span> ti = i;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i++; ;) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= <span class="built_in">size</span> || i &gt;= <span class="built_in">size</span>) &#123;	<span class="comment">// 这里应该可以少判断 j 的值</span></span><br><span class="line">                    ret.push_back( &#123;start[ti], <span class="built_in">end</span>.back()&#125; );</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (start[i] &lt;= <span class="built_in">end</span>[j]) &#123;</span><br><span class="line">                    ++i, ++j;</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    ret.push_back( &#123;start[ti], <span class="built_in">end</span>[j]&#125; );</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>代码如上, 应该还有可以优化的地方 (比如说外围 for 循环, 他仅仅就是一个保留 i 的作用)</p>
<p><img src="https://imgur.com/57NGf4L.png" alt=""></p>
<p>结果还不错</p>
<h3 id="the-best-solution-8ms"><a href="#the-best-solution-8ms" class="headerlink" title="the best solution (8ms)"></a>the best solution (8ms)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> _ = []()&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Interval&gt; merge(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Interval&gt;&amp; Intervals) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> IntervalNum = Intervals.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (IntervalNum &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> Intervals;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::sort(Intervals.<span class="built_in">begin</span>(), Intervals.<span class="built_in">end</span>(), </span><br><span class="line">                  [](<span class="keyword">const</span> Interval &amp;A, <span class="keyword">const</span> Interval &amp;B) &#123;</span><br><span class="line">                      <span class="keyword">return</span> A.start &lt; B.start;</span><br><span class="line">                  &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Interval&gt; Merged &#123;Intervals[<span class="number">0</span>]&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; IntervalNum; ++i) &#123;</span><br><span class="line">            <span class="keyword">const</span> Interval &amp;Curr = Intervals[i];</span><br><span class="line">            Interval &amp;LastMerged = Merged.back();</span><br><span class="line">            <span class="comment">// 完全被内含的区间会被跳过</span></span><br><span class="line">            <span class="keyword">if</span> (Curr.<span class="built_in">end</span> &lt;= LastMerged.<span class="built_in">end</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">			<span class="comment">// 更新区间的最大值</span></span><br><span class="line">            <span class="keyword">if</span> (Curr.start &lt;= LastMerged.<span class="built_in">end</span>)</span><br><span class="line">                LastMerged.<span class="built_in">end</span> = Curr.<span class="built_in">end</span>;</span><br><span class="line">            <span class="keyword">else</span>	<span class="comment">// 下一个区间完全不在当前区间内, 不能合并. 压入当前区间, 继续执行</span></span><br><span class="line">                Merged.push_back(Curr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Merged;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>他的排序是直接在 Intervals 进行, 并且只比对 start  (也是, 我好像做了多余的比对)</p>
<p>想法大致是一样的, 但是细节不够好</p>
]]></content>
  </entry>
  <entry>
    <title>leetcode/62ZUnuquePaths</title>
    <url>/2020/01/09/leetcode/62ZUnuquePaths/</url>
    <content><![CDATA[<h3 id="Unique-Paths"><a href="#Unique-Paths" class="headerlink" title="Unique Paths"></a>Unique Paths</h3><p><img src="https://imgur.com/GNf4ByW.png" alt=""></p>
<p>找到不重复的能到达目标的路径数</p>
<h3 id="my-solution-8ms"><a href="#my-solution-8ms" class="headerlink" title="my solution (8ms)"></a>my solution (8ms)</h3><p>典型的可以用递归解决的问题</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        _m = m;</span><br><span class="line">        _n = n;</span><br><span class="line">        _cx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        uniquePaths_do(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> _cx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">uniquePaths_do</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m == _m &amp;&amp; n == _n) &#123;</span><br><span class="line">            ++_cx;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m + <span class="number">1</span> &lt;= _m)</span><br><span class="line">            uniquePaths_do(m + <span class="number">1</span>, n);</span><br><span class="line">        <span class="keyword">if</span> (n + <span class="number">1</span> &lt;= _n)</span><br><span class="line">            uniquePaths_do(m, n + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> _m;</span><br><span class="line">    <span class="keyword">int</span> _n;</span><br><span class="line">    <span class="keyword">int</span> _cx;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>结果超时了, 想了一下:</p>
<pre><code>            11
     21            12
  31   22        22   13
41 32 32 23    32 23 23 14</code></pre><p>这样子的话, 大多数的迭代都会重复</p>
<p>所以更改了一下代码:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        _m = m;</span><br><span class="line">        _n = n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> uniquePaths_do(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePaths_do</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> p = make_pair(m, n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (road[p] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> road[p];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (m == _m &amp;&amp; n == _n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (m + <span class="number">1</span> &lt;= _m)</span><br><span class="line">            l = uniquePaths_do(m + <span class="number">1</span>, n);</span><br><span class="line">        <span class="keyword">if</span> (n + <span class="number">1</span> &lt;= _n)</span><br><span class="line">            r = uniquePaths_do(m, n + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (road[p] == <span class="number">0</span>) &#123;</span><br><span class="line">            road[p] = l + r;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> l + r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> _m;</span><br><span class="line">    <span class="keyword">int</span> _n;</span><br><span class="line">    <span class="built_in">map</span> &lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; road;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过保存的形式来去掉一些可以重用的计算, 虽然过了, 但是效果不理想</p>
<p><img src="https://imgur.com/jVV30Mn.png" alt=""></p>
<p>emm… 我没有再从树中能总结出什么好的规律…</p>
<h3 id="the-best-solution"><a href="#the-best-solution" class="headerlink" title="the best solution"></a>the best solution</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; path(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = m - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = n - <span class="number">2</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">                path[i][j] = path[i + <span class="number">1</span>][j] + path[i][j + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> path[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>简洁又高效, 真是个漂亮的小东西</p>
<p>思路是这样的:</p>
<pre><code>1 1 1
3 2 1

1 1 1
3 2 1
6 3 1</code></pre><p>上述分别是 3, 2 和 3, 3 的情况, 假设 rebot 在左下角, star 在右上角(本质上不会有什么改变, 只是换了方向)</p>
<p>从 star 开始往后退, 每一个节点的次数都是他的 上节点次数 + 右节点次数 直到循环结束  </p>
<p>最后的左下角就是 rebot 的次数  </p>
<p>这样的算法复杂度是 O(n)</p>
]]></content>
  </entry>
  <entry>
    <title>leetcode/820SortEncodingofWords</title>
    <url>/2020/01/09/leetcode/820SortEncodingofWords/</url>
    <content><![CDATA[<h2 id="820-Short-Encoding-of-Words"><a href="#820-Short-Encoding-of-Words" class="headerlink" title="820 Short Encoding of Words"></a>820 Short Encoding of Words</h2><p><img src="https://imgur.com/ycGcntf.png" alt=""></p>
<h3 id="my-solution"><a href="#my-solution" class="headerlink" title="my solution = ="></a>my solution = =</h3><p>一开始先试着用 O(n2) 的方法, 之后用 O(n), 但是时间依旧很长</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumLengthEncoding</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        sort(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), [](<span class="built_in">string</span> &amp;str1, <span class="built_in">string</span> &amp;str2) &#123;</span><br><span class="line">            <span class="keyword">return</span> str1.<span class="built_in">size</span>() &gt; str2.<span class="built_in">size</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">           </span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( str.<span class="built_in">find</span>(words[i] + <span class="string">'#'</span>) == <span class="built_in">string</span>::npos ) &#123;</span><br><span class="line">                str.append(words[i] + <span class="string">'#'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> str.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>并且这个代码之前还踩了个坑 : <a href="https://www.boost.org/sgi/stl/StrictWeakOrdering.html" target="_blank" rel="noopener">https://www.boost.org/sgi/stl/StrictWeakOrdering.html</a></p>
<h3 id="best-solution"><a href="#best-solution" class="headerlink" title="best solution"></a>best solution</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumLengthEncoding</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">string</span>&amp; s : words) &#123;</span><br><span class="line">            reverse(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        sort(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((i + <span class="number">1</span>) &gt;= words.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                length += words[i].length() + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (words[i+<span class="number">1</span>].compare(<span class="number">0</span>, words[i].length(), words[i]) != <span class="number">0</span>) &#123;</span><br><span class="line">                length += words[i].length() + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>em… 逻辑挺简单的 </p>
<p>反序字符串, 字典序排序, 后再直接 compare</p>
]]></content>
  </entry>
  <entry>
    <title>leetcode/77ZCombinations</title>
    <url>/2020/01/09/leetcode/77ZCombinations/</url>
    <content><![CDATA[<h3 id="Combinations"><a href="#Combinations" class="headerlink" title="Combinations"></a>Combinations</h3><p><img src="https://imgur.com/UHtnUvF.png" alt=""></p>
<p>找到 n 中所有 长度为 k 的不重复的组合</p>
<h3 id="my-solution-60ms-top-99-97"><a href="#my-solution-60ms-top-99-97" class="headerlink" title="my solution (60ms, top 99.97%)"></a>my solution (60ms, top 99.97%)</h3><p>通过问题代换, 可以转换成一种很好理解并易于编写的问题  </p>
<p>将问题看做 <strong>找出范围 n 中所有满足 p(x) 的整数 x</strong></p>
<p>(和 31. Next Permutation 类似, 我是从中得到的启发)</p>
<p>其中 x 一开始为  ∑k &lt;&lt; (n - k); [k=1], 即 n = 4, x = 1234</p>
<pre><code>n = 4, k = 2
1 2 3 4
[1,2],
[1,3],
[1,4],
[2,3],
[2,4],
[3,4],

n = 4, k = 3
1 2 3 4
[1,2,3],
[1,2,4],
[1,3,4],
[2,3,4]</code></pre><p>他们都按照一定规律, 满足下一个数比上一个数大</p>
<p>这个规则 p(x) 用语言描述, 就是:</p>
<pre><code>从后往前找一个当前下标小于当前下标的最大值的数
如果找到了, 当前下标存储的值自增, 后续下标以当前下标为基准, 顺序 +1
如果没找到, 返回所有已找到的</code></pre><p>代码描述如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; n) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        _n = n, _k = k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">            _cur.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">        ret.emplace_back(_cur);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            getNextNums();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (_cur.<span class="built_in">size</span>() != <span class="number">0</span>)</span><br><span class="line">                ret.emplace_back(_cur);</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getNextNums</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = _k - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( _cur[i] &lt; _n - _k + i + <span class="number">1</span> ) &#123;</span><br><span class="line">                _cur[i] += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>, s = _cur[i] + <span class="number">1</span>; j &lt; _k; ++j) </span><br><span class="line">                    _cur[j] = s++;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _cur.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; _cur;</span><br><span class="line">    <span class="keyword">int</span> _n, _k;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>combine 和 getNextNums 的逻辑都相当简单, 写起来很容易</p>
<p><img src="https://imgur.com/rQ2ZGIM.png" alt=""></p>
<h3 id="best-solution-56ms"><a href="#best-solution-56ms" class="headerlink" title="best solution (56ms)"></a>best solution (56ms)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">combine</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;result, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;item, <span class="keyword">int</span> beg, <span class="keyword">int</span> <span class="built_in">end</span>, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = item.<span class="built_in">size</span>() - index;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">            result.push_back(item);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = beg; i &lt;= <span class="built_in">end</span> - k + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            item[index] = i;</span><br><span class="line">            combine(result, item, i + <span class="number">1</span>, <span class="built_in">end</span>, index + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span> || k &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; item(k);</span><br><span class="line">        item[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        combine(result, item, <span class="number">1</span>, n, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>emmm, 好奇怪啊, 逻辑上来说想的都是一样的, 为什么他少 4ms 呢… ( 或许是因为通过 this 指针获取变量的锅? )</p>
<p>他用递归的形式来实现, 每次递归中会从当前起始索引循环到结束索引</p>
<p>当数组的长度到达 k 的时候, 就返回  </p>
<p>值得一提的是, 他用索引的形式避免了那个会被多次修改的 item 以值形式传递  </p>
<p>(我放弃使用递归的一部分原因就是因为暂时想不到什么方法避免那个临时的数组, 原来还可以这样…)</p>
]]></content>
  </entry>
  <entry>
    <title>leetcode/92ReverseLinkedListII</title>
    <url>/2020/01/09/leetcode/92ReverseLinkedListII/</url>
    <content><![CDATA[<h2 id="Reverse-Linked-List-II"><a href="#Reverse-Linked-List-II" class="headerlink" title="Reverse Linked List II"></a>Reverse Linked List II</h2><p><img src="https://imgur.com/qHJVvfn.png" alt=""></p>
<p>给定一个单向链表, 按照距离 m, n 旋转单向链表</p>
<h3 id="my-solution-4ms-100"><a href="#my-solution-4ms-100" class="headerlink" title="my solution (4ms, 100%)"></a>my solution (4ms, 100%)</h3><p>其实这个题没什么好写的, 主要是这个题之前做过.</p>
<p>当时的代码量很大不说, 最后还没做出来…  </p>
<h4 id="old-solution"><a href="#old-solution" class="headerlink" title="old solution"></a>old solution</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">moth</span><span class="params">(ListNode* head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m == n)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// don't need replace</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">replace_far</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        pmptrv-&gt;next = pn;</span><br><span class="line">        pm-&gt;next = pnnext;</span><br><span class="line">        pnptrv-&gt;next = pm;</span><br><span class="line">        pn-&gt;next = pmnext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">replace_close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        pmptrv ? pmptrv-&gt;next = pn : <span class="literal">nullptr</span>;</span><br><span class="line">        pm-&gt;next = pnnext;</span><br><span class="line">        pn-&gt;next = pm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setpoint</span><span class="params">(ListNode* pcursor, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; ; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == m - <span class="number">1</span>) </span><br><span class="line">                pmptrv = pcursor;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i == m) </span><br><span class="line">                pm = pcursor;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i == m + <span class="number">1</span>) &#123;</span><br><span class="line">                pmnext = pcursor;</span><br><span class="line">                <span class="keyword">if</span> (i == n - <span class="number">1</span>)</span><br><span class="line">                    pnptrv = pcursor;</span><br><span class="line">                <span class="keyword">if</span> (i == n)</span><br><span class="line">                    pn = pcursor;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i == n - <span class="number">1</span>)</span><br><span class="line">                pnptrv = pcursor;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i == n) </span><br><span class="line">                pn = pcursor;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i == n + <span class="number">1</span>) </span><br><span class="line">                pnnext = pcursor;</span><br><span class="line"></span><br><span class="line">            pcursor = pcursor-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (!pcursor)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (moth(head, m, n)) </span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ListNode* pcursor = head;</span></span><br><span class="line">        setpoint(head, m, n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n - m &gt;= <span class="number">2</span>)</span><br><span class="line">            replace_far();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n - m == <span class="number">1</span>)</span><br><span class="line">            replace_close();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> pn;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ListNode* pm = <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode* pn = <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode* pmptrv = <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode* pmnext = <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode* pnptrv = <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode* pnnext = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>…  天知道我 4 个月前脑子里面装的是什么, 会写出这样的代码. </p>
<p>关键是错了十几次, 然后还是没做出来…</p>
<h4 id="new-solution"><a href="#new-solution" class="headerlink" title="new solution"></a>new solution</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m == n || head == <span class="literal">nullptr</span>) </span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="function">ListNode <span class="title">temp</span><span class="params">(<span class="number">-1</span>)</span></span>;</span><br><span class="line">        temp.next = head;</span><br><span class="line">        ListNode* p1 = &amp;temp;</span><br><span class="line">        ListNode* sta;</span><br><span class="line">        <span class="keyword">int</span> ax = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (++ax &gt;= m) &#123;</span><br><span class="line">                sta = p1;</span><br><span class="line">                p1 = p1-&gt;next;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode* prev = p1;</span><br><span class="line">        ListNode* cur = p1-&gt;next;</span><br><span class="line">        ListNode* <span class="built_in">end</span> = p1;</span><br><span class="line">        <span class="keyword">while</span> (ax++ &lt; n) &#123;</span><br><span class="line">            ListNode* sav = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = prev;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = sav;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sta-&gt;next = prev;</span><br><span class="line">        <span class="built_in">end</span>-&gt;next = cur;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我采用了多放置一个头结点的方式来处理头结点也会被旋转的情况</p>
<p>先找到 m 的位置, 然后顺序旋转至 n 的位置, 最后将头尾衔接一下</p>
<p><img src="https://imgur.com/SgupRQT.png" alt=""></p>
<p>最后的几次是我的尝试, 一开始的时候是 8ms, 但是我观察了 best solution, 发现区别不大  </p>
<p>遂又尝试了一下, 然后是 4ms, 但是有时候不稳定, 总之在 4ms - 8ms 之间跳 (= =…)</p>
]]></content>
  </entry>
  <entry>
    <title>leetcode/94BinaryTreeInorderTraversal</title>
    <url>/2020/01/09/leetcode/94BinaryTreeInorderTraversal/</url>
    <content><![CDATA[<h2 id="Binary-Tree-Inorder-Traversal"><a href="#Binary-Tree-Inorder-Traversal" class="headerlink" title="Binary Tree Inorder Traversal"></a>Binary Tree Inorder Traversal</h2><p><img src="https://imgur.com/vlChItp.png" alt=""></p>
<p>这个问题用递归非常好解决, 但是作者要求使用迭代</p>
<p>这是一个以迭代实现子树遍历的做法, 值得做一下笔记</p>
<h3 id="my-solution"><a href="#my-solution" class="headerlink" title="my solution"></a>my solution</h3><p>一开始我没看到 follow up, 然后用递归解决了  </p>
<p>之后看到的时候没什么好的思路</p>
<p>(有部分是受了答案的影响, 因为这时候我已经解决了, 可以看别人的答案了)</p>
<p>(不得不说答案真是害人啊…  如果我独立思考的话, 花一部分时间也能想通的)</p>
<p>后面借鉴了答案的思想, 自己实现了, 所以这里就不贴出来了</p>
<h3 id="best-solution-4ms"><a href="#best-solution-4ms" class="headerlink" title="best solution (4ms)"></a>best solution (4ms)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        TreeNode *curr; </span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; st; </span><br><span class="line">        curr = root;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ( !st.empty() || curr )&#123;</span><br><span class="line">            <span class="keyword">while</span> ( curr ) &#123; st.push(curr); curr = curr-&gt;left; &#125;</span><br><span class="line">            curr = st.top();</span><br><span class="line">            st.pop();</span><br><span class="line">            res.push_back(curr-&gt;val);</span><br><span class="line">            curr=curr-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>简单来说</p>
<ol>
<li>遍历所有左子树</li>
<li>获得栈顶, 存值, 然后以其右子树继续遍历</li>
</ol>
<p>重复以上步骤, 很简单吧 (但是我当时为什么没有想出来呢 ? …)</p>
<p>以同样的逻辑, 可以实现 leftorder, rightorder </p>
<p>(如果没记错的话, 应该是这么叫的, 而且如果没估计错的话, 应该可以)</p>
]]></content>
  </entry>
  <entry>
    <title>leetcode/116PopulatingNextRightPointersInEachNode</title>
    <url>/2020/01/09/leetcode/116PopulatingNextRightPointersInEachNode/</url>
    <content><![CDATA[<h2 id="Populating-Next-Right-Pointers-in-Each-Node"><a href="#Populating-Next-Right-Pointers-in-Each-Node" class="headerlink" title="Populating Next Right Pointers in Each Node"></a>Populating Next Right Pointers in Each Node</h2><p><img src="https://imgur.com/db5dxSr.png" alt=""></p>
<p>给了一个完美的二叉树, 填充其next节点</p>
<h3 id="my-solution-60ms-90-37"><a href="#my-solution-60ms-90-37" class="headerlink" title="my solution (60ms, 90.37%)"></a>my solution (60ms, 90.37%)</h3><p>这道题我给出了两种方案, 递归和迭代  </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> _ = [] () &#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; ();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Node* connect(Node* root) &#123;</span></span><br><span class="line">    <span class="comment">//     if (!root)</span></span><br><span class="line">    <span class="comment">//         return root;</span></span><br><span class="line">    <span class="comment">//     </span></span><br><span class="line">    <span class="comment">//     vector&lt;Node*&gt; lev;</span></span><br><span class="line">    <span class="comment">//     lev.push_back(root);</span></span><br><span class="line">    <span class="comment">//     </span></span><br><span class="line">    <span class="comment">//     while ( !lev.empty() ) &#123;</span></span><br><span class="line">    <span class="comment">//         vector&lt;Node*&gt; nlev;</span></span><br><span class="line">    <span class="comment">//         int size = lev.size();</span></span><br><span class="line">    <span class="comment">//         </span></span><br><span class="line">    <span class="comment">//         int i = 0, i2 = 1;</span></span><br><span class="line">    <span class="comment">//         for (; i2 &lt; size; ++i, ++i2) &#123;</span></span><br><span class="line">    <span class="comment">//             lev[i]-&gt;next = lev[i2];</span></span><br><span class="line">    <span class="comment">//             if ( lev[i]-&gt;left ) &#123;</span></span><br><span class="line">    <span class="comment">//                 nlev.push_back( lev[i]-&gt;left );</span></span><br><span class="line">    <span class="comment">//                 nlev.push_back( lev[i]-&gt;right );</span></span><br><span class="line">    <span class="comment">//             &#125;</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//         lev[i]-&gt;next = nullptr;</span></span><br><span class="line">    <span class="comment">//         if ( lev[i]-&gt;left ) &#123;</span></span><br><span class="line">    <span class="comment">//             nlev.push_back( lev[i]-&gt;left );</span></span><br><span class="line">    <span class="comment">//             nlev.push_back( lev[i]-&gt;right );</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//         </span></span><br><span class="line">    <span class="comment">//         swap(lev, nlev);</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     </span></span><br><span class="line">    <span class="comment">//     return root;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        connect_two(root-&gt;left, root-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connect_two</span><span class="params">(Node* left, Node* right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!left) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        left-&gt;next = right;</span><br><span class="line">        <span class="keyword">if</span> (left-&gt;left)</span><br><span class="line">            connect_two(left-&gt;left, left-&gt;right);</span><br><span class="line">            connect_two(left-&gt;right, right-&gt;left);</span><br><span class="line">            connect_two(right-&gt;left, right-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于迭代, 我将每一级的元素都保留, 然后用作下一次迭代 </p>
<p>递归的话, 因为如果只是单节点传参, 始终会面临有缝隙的情况, 所以用双节点传参</p>
<p>递归的代码更加简洁, 我推荐使用递归</p>
<p><img src="https://imgur.com/DbsUtql.png" alt=""></p>
<p>emmmm… 速度上还好, 但是内存上就很不能接受了</p>
<p>(我很好奇, 代码量已经很少了, 而且递归中也不会产生多余的操作)</p>
<p>(难道是在 perfect binary tree 上能有什么绚丽的操作么?)</p>
<h3 id="best-solution"><a href="#best-solution" class="headerlink" title="best solution"></a>best solution</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(TreeLinkNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeLinkNode*&gt; q;</span><br><span class="line">    <span class="keyword">if</span> (!root)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    q.push(root);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">size</span> = q.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">size</span>--)&#123;</span><br><span class="line">            TreeLinkNode* c = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">size</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                c-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                c-&gt;next = q.front();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (c-&gt;left)&#123;</span><br><span class="line">                q.push(c-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (c-&gt;right)&#123;</span><br><span class="line">                q.push(c-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>哦哦哦, 用的是迭代的方式, 只不过他用了队列</p>
<p>而且用了size, 这样也就不需要一个新的容器了, 很不错 -v-  </p>
<p>不过既然题说了是 perfect binary tree, 而且next默认为空, 那么可以稍微改良一下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">queue</span>&lt;Node*&gt; q;</span><br><span class="line">    q.push(root);</span><br><span class="line">    <span class="keyword">while</span>( !q.empty() ) &#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">size</span> = q.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">size</span>--) &#123;</span><br><span class="line">            Node* cur = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">size</span>)</span><br><span class="line">                cur-&gt;next = q.front();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;left) &#123;</span><br><span class="line">                q.push(cur-&gt;left);</span><br><span class="line">                q.push(cur-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>细节在于:</p>
<ol>
<li>如果是空节点, 少了一个空 queue 的分配时间</li>
<li>不用再去赋值 nullptr 了</li>
<li>少了一个 cur-&gt;right 的判断, 因为题目说了是 perfect binary tree</li>
</ol>
<p>PS: 我最后用这个答案再试了一次, 发现结果和我用递归的结果相差无几…</p>
<p>可能这是增加了测试用例或者改了题的结果? 毕竟 TreeLinkNode 变为了 Node</p>
]]></content>
  </entry>
</search>
