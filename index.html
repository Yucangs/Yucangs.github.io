<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Muse',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="cas&#39;s website">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="cas&#39;s website">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="cas">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>cas's website</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">cas's website</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">casyup.me@outlook.com</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/16/read/routingAlgorithms/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cas">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cas's website">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/16/read/routingAlgorithms/" class="post-title-link" itemprop="url">read/routingAlgorithms</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-16 19:46:54 / Modified: 19:46:12" itemprop="dateCreated datePublished" datetime="2020-01-16T19:46:54+08:00">2020-01-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="routing-algorithms"><a href="#routing-algorithms" class="headerlink" title="routing algorithms"></a>routing algorithms</h2><p>​    • A centralized routing algorithm computes the least-cost path between a source<br>and destination using complete, global knowledge about the network. That is, the<br>algorithm takes the connectivity between all nodes and all link costs as inputs.<br>This then requires that the algorithm somehow obtain this information before<br>actually performing the calculation. The calculation itself can be run at one site<br>(e.g., a logically centralized controller as in Figure 5.2) or could be replicated in<br>the routing component of each and every router (e.g., as in Figure 5.1). The key<br>distinguishing feature here, however, is that the algorithm has complete informa-<br>tion about connectivity and link costs. Algorithms with global state information<br>are often referred to as link-state (LS) algorithms, since the algorithm must<br>be aware of the cost of each link in the network. We’ll study LS algorithms in<br>Section 5.2.1.</p>
<p>​    集中式的路由算法计算从起点到终点的最少成本时, 知晓整个网络的成本情况. 意思是, 这个算法需要所有相连节点的成本作为输入. 这需要在实际执行计算前, 在某处获取这些信息. 这个计算本身可以在某个站点, 也可以在每个路由中. 基于全局状态信息的算法经常被成为 link-state(LS) 算法. 因为算法需要注意整个网络, 每个节点的成本情况. </p>
<p>​    • In a decentralized routing algorithm, the calculation of the least-cost path is<br>carried out in an iterative, distributed manner by the routers. No node has com-<br>plete information about the costs of all network links. Instead, each node begins<br>with only the knowledge of the costs of its own directly attached links. Then,<br>through an iterative process of calculation and exchange of information with its<br>neighboring nodes, a node gradually calculates the least-cost path to a destination<br>or set of destinations. The decentralized routing algorithm we’ll study below in<br>Section 5.2.2 is called a distance-vector (DV) algorithm, because each node main-<br>tains a vector of estimates of the costs (distances) to all other nodes in the net-<br>work. Such decentralized algorithms, with interactive message exchange between<br>neighboring routers is perhaps more naturally suited to control planes where the<br>routers interact directly with each other, as in Figure 5.1.</p>
<p>​    分散式的路由算法, 其计算最小成本路径的计算通过路由以迭代, 分布的方式计算. 没有节点知晓整个网络节点成本信息. 每个节点在仅知晓自身直连的节点信息的状态下开始, 然后通过列点的方式计算, 并与邻近节点交换细信息, 逐步计算一个/多个节点的最小成本路径. 分散式路由算法进程被成为 distance-vector(DV) 算法, 因为每个节点管理一个保存连接节点成本的向量. 这样的分散算法, 需要在邻近节点交换信息, 或许更加适合和其他节点交互的路由.</p>
<p>​    A second broad way to classify routing algorithms is according to whether they<br>are static or dynamic. In static routing algorithms, routes change very slowly over<br>time, often as a result of human intervention (for example, a human manually editing<br>a link costs). Dynamic routing algorithms change the routing paths as the network<br>traffic loads or topology change. A dynamic algorithm can be run either periodically<br>or in direct response to topology or link cost changes. While dynamic algorithms<br>are more responsive to network changes, they are also more susceptible to problems<br>such as routing loops and route oscillation.</p>
<p>​    第二个区分路由算法的方式是根据其是静态/动态的. 在静态路由算法中, 路由变化十分缓慢, 通常是由于人为干涉. 动态路由算法随着网络流量负载/拓扑变化时更改路由路径. 动态路由算法可以是周期性的, 也可以是直接由拓扑响应/链接成本变化改变. 当动态路由越积极响应网络变化, 也就越容器出现问题, 比如路由循环/路由振荡.</p>
<p>​    A third way to classify routing algorithms is according to whether they are load-<br>sensitive or load-insensitive. In a load-sensitive algorithm, link costs vary dynami-<br>cally to reflect the current level of congestion in the underlying link. If a high cost<br>is associated with a link that is currently congested, a routing algorithm will tend<br>to choose routes around such a congested link. While early ARPAnet routing algo-<br>rithms were load-sensitive [McQuillan 1980], a number of difficulties were encoun-<br>tered [Huitema 1998]. Today’s Internet routing algorithms (such as RIP, OSPF, and<br>BGP) are load-insensitive, as a link’s cost does not explicitly reflect its current (or<br>recent past) level of congestion.</p>
<p>​    第三种区分路由算法的方式是根据其是负载敏感的/负载不敏感的. 在负载敏感的算法中, 连接成本变化反应了当前底层的堵塞状态. 如果链接有高负载, 那么当前链接堵塞. 路由算法将会重新选择路由以然后这个堵塞节点. 早先 ARPAnet的路由算法就是负载敏感的, 今天 Internet 路由算法是负载不敏感的, 当前链接的负载不反应底层的堵塞情况.</p>
<h3 id="5-2-1-The-Link-State-LS-Routing-Algorithm"><a href="#5-2-1-The-Link-State-LS-Routing-Algorithm" class="headerlink" title="5.2.1 The Link-State (LS) Routing Algorithm"></a>5.2.1 The Link-State (LS) Routing Algorithm</h3><p>Recall that in a link-state algorithm, the network topology and all link costs are<br>known, that is, available as input to the LS algorithm. In practice this is accom-<br>plished by having each node broadcast link-state packets to all other nodes in<br>the network, with each link-state packet containing the identities and costs of<br>its attached links. In practice (for example, with the Internet’s OSPF routing<br>protocol, discussed in Section 5.3) this is often accomplished by a link-state<br>broadcast algorithm [Perlman 1999]. The result of the nodes’ broadcast is that<br>all nodes have an identical and complete view of the network. Each node can<br>then run the LS algorithm and compute the same set of least-cost paths as every<br>other node.</p>
<p>回想一下, 在 LS 算法知晓网络的拓扑和链接成本. 实际上是由每个节点广播自身的 link-state 包给网络上其他所有节点来实现的, 每个 link-state 包包含了身份验证和其已附加的链接的负载. 经常由 link-state 广播算法实现. 节点广播的结果是: 所有节点都有统一, 完成的关于整个网络的视图. 每个节点可以运行 LS 算法, 计算得到和其他节点相同的最小负载路径.</p>
<p>The link-state routing algorithm we present below is known as Dijkstra’s<br>algorithm, named after its inventor. A closely related algorithm is Prim’s algo-<br>rithm; see [Cormen 2001] for a general discussion of graph algorithms. Dijkstra’s<br>algorithm computes the least-cost path from one node (the source, which we will<br>refer to as u) to all other nodes in the network. Dijkstra’s algorithm is iterative and<br>has the property that after the kth iteration of the algorithm, the least-cost paths<br>are known to k destination nodes, and among the least-cost paths to all destination<br>nodes, these k paths will have the k smallest costs. Let us define the following<br>notation:</p>
<p>下面将要提出的路由算法名为 Dijkstra 算法. 这个算法从一个节点到网络中的所有其他节点开始, 计算最小负载路径. Dijkstra 算法是迭代的, 在 k 次迭代后依旧有这样的性质. </p>
<p>• D(v): cost of the least-cost path from the source node to destination v as of this<br>iteration of the algorithm.</p>
<p>从起点到重点的最小负载路径负载.</p>
<p>• p(v): previous node (neighbor of v) along the current least-cost path from the<br>source to v.</p>
<p>最小负载路径的上一个节点.</p>
<p>• N′: subset of nodes; v is in N′ if the least-cost path from the source to v is defini-<br>tively known.</p>
<p>节点子集</p>
<p>The centralized routing algorithm consists of an initialization step followed by<br>a loop. The number of times the loop is executed is equal to the number of nodes in<br>the network. Upon termination, the algorithm will have calculated the shortest paths<br>from the source node u to every other node in the network.</p>
<p>集中路由算法由一个初始化步骤和一个循环组成. 循环执行次数与网络中的节点数一致. 运算结束后, 算法将会得出从源节点 u 到网络中每个节点的最小负载路径. </p>
<pre><code>Link-State (LS) Algorithm for Source Node u
1 Initialization:
2 N’ = {u}
3 for all nodes v
4 if v is a neighbor of u
5 then D(v) = c(u,v)
6 else D(v) = ∞
7
8 Loop
9 find w not in N’ such that D(w) is a minimum
10 add w to N’
11 update D(v) for each neighbor v of w and not in N’:
12 D(v) = min(D(v), D(w)+ c(w,v) )
13 /* new cost to v is either old cost to v or known
14 least path cost to w plus cost from w to v */
15 until N’= N</code></pre><p><img src="https://imgur.com/aYU2AT9.png" alt=""></p>
<p><img src="https://imgur.com/w1FDgP2.png" alt=""></p>
<p>As an example, let’s consider the network in Figure 5.3 and compute the least-<br>cost paths from u to all possible destinations. A tabular summary of the algorithm’s<br>computation is shown in Table 5.1, where each line in the table gives the values of<br>the algorithm’s variables at the end of the iteration. Let’s consider the few first steps<br>in detail.</p>
<p>参考图 5.3, 思考以下细节.</p>
<p>• In the initialization step, the currently known least-cost paths from u to its directly<br>attached neighbors, v, x, and w, are initialized to 2, 1, and 5, respectively. Note in<br>particular that the cost to w is set to 5 (even though we will soon see that a lesser-cost<br>path does indeed exist) since this is the cost of the direct (one hop) link from u to<br>w. The costs to y and z are set to infinity because they are not directly connected<br>to u.</p>
<p>在初始化步骤, 当前从 u 到其直连节点 v, x, w 初始化为 2, 1, 5. 因为 y 和 z 没有直连节点, 所以初始化为无穷大.</p>
<p>• In the first iteration, we look among those nodes not yet added to the set N′ and<br>find that node with the least cost as of the end of the previous iteration. That node<br>is x, with a cost of 1, and thus x is added to the set N′. Line 12 of the LS algorithm<br>is then performed to update D(v) for all nodes v, yielding the results shown in the<br>second line (Step 1) in Table 5.1. The cost of the path to v is unchanged. The cost<br>of the path to w (which was 5 at the end of the initialization) through node x is<br>found to have a cost of 4. Hence this lower-cost path is selected and w’s predeces-<br>sor along the shortest path from u is set to x. Similarly, the cost to y (through x) is<br>computed to be 2, and the table is updated accordingly.</p>
<p>第一次迭代, 查找还未添加进 N’ 集合的节点, 获取上一次迭代得到的最小负载节点. 在此例中为 x, 负载 1. 随后 x 加入 N’ 集合. LS 算法第 12 行执行更新 D(v) 运算. 得到的返回在表 5.1 的第二行. 到节点 v 的负载并未改变, w 路径的负载变为了 4. </p>
<p>• In the second iteration, nodes v and y are found to have the least-cost paths (2),<br>and we break the tie arbitrarily and add y to the set N′ so that N′ now contains u,<br>x, and y. The cost to the remaining nodes not yet in N′, that is, nodes v, w, and z,<br>are updated via line 12 of the LS algorithm, yielding the results shown in the third<br>row in Table 5.1.</p>
<p>在第二次迭代中, v 和 y 节点找到了最小负载路径, 并且增加 y 节点到 N’ 中. </p>
<p>• And so on . . .</p>
<p>以此类推…</p>
<p>(LS 算法需要知晓所有节点信息, 其算法复杂度为 O(n * n), 因为每个节点都有可能会改变其他所有节点, 其本质是将已有的节点距离(根据比较获得/最初的无穷大)和新得到的拼接距离做比较, 经过 (n * n) 次循环, 得到的距离就是最短距离)</p>
<h3 id="5-2-2-The-Distance-Vector-DV-Routing-Algorithm"><a href="#5-2-2-The-Distance-Vector-DV-Routing-Algorithm" class="headerlink" title="5.2.2 The Distance-Vector (DV) Routing Algorithm"></a>5.2.2 The Distance-Vector (DV) Routing Algorithm</h3><p>Whereas the LS algorithm is an algorithm using global information, the distance-<br>vector (DV) algorithm is iterative, asynchronous, and distributed. It is distributed in<br>that each node receives some information from one or more of its directly attached<br>neighbors, performs a calculation, and then distributes the results of its calculation<br>back to its neighbors. It is iterative in that this process continues on until no more<br>information is exchanged between neighbors. (Interestingly, the algorithm is also<br>self-terminating—there is no signal that the computation should stop; it just stops.)<br>The algorithm is asynchronous in that it does not require all of the nodes to operate in<br>lockstep with each other. We’ll see that an asynchronous, iterative, self-terminating,<br>distributed algorithm is much more interesting and fun than a centralized algorithm!<br>Before we present the DV algorithm, it will prove beneficial to discuss an impor-<br>tant relationship that exists among the costs of the least-cost paths. Let d x (y) be the<br>cost of the least-cost path from node x to node y. Then the least costs are related by<br>the celebrated Bellman-Ford equation, namely,</p>
<p>不同于 LS 算法使用全局信息, distance-vector(DV) 算法是迭代, 异步, 分布的. </p>
<p>其分布在各个节点上, 接收来自直连节点的信息, 计算, 然后返回其计算结果. 直至没有节点需要交换信息. </p>
<p>这个算法还是异步算法, 不需要所有节点彼此间同步运算. 我们将会见到, 一个异步, 迭代, 自销毁, 的分布算法比集中算法有趣的多. </p>
<pre><code>Distance-Vector (DV) Algorithm
At each node, x:
1 Initialization:
2 for all destinations y in N:
3 D x (y)= c(x,y)/* if y is not a neighbor then c(x,y)= ∞ */
4 for each neighbor w
5 D w (y) = ? for all destinations y in N
6 for each neighbor w
7 send distance vector D x = [D x (y): y in N] to w
8
9 loop
10 wait (until I see a link cost change to some neighbor w or
11 until I receive a distance vector from some neighbor w)
12
13 for each y in N:
14 D x (y) = min v {c(x,v) + D v (y)}
15
16 if Dx(y) changed for any destination y
17 send distance vector D x = [D x (y): y in N] to all neighbors
18
19 forever</code></pre><p>In the DV algorithm, a node x updates its distance-vector estimate when it either<br>sees a cost change in one of its directly attached links or receives a distance-vector<br>update from some neighbor. But to update its own forwarding table for a given des-<br>tination y, what node x really needs to know is not the shortest-path distance to y but<br>instead the neighboring node v<em>(y) that is the next-hop router along the shortest path<br>to y. As you might expect, the next-hop router v</em>(y) is the neighbor v that achieves<br>the minimum in Line 14 of the DV algorithm. (If there are multiple neighbors v that<br>achieve the minimum, then v<em>(y) can be any of the minimizing neighbors.) Thus,<br>in Lines 13–14, for each destination y, node x also determines v</em>(y) and updates its<br>forwarding table for destination y.</p>
<p>在 DV 算法中, 当邻近节点的负载发生变化, 或接收到一个来自邻近节点的 distance-vector 更新时, 会更新自身的 distance-vector 估计. 但是为了更新自身某个节点 y 的转发表, x 实际需要知道的并不是到 y 的最短路径, 而是邻近节点到 y 的最短路径. 如你所料, 邻近节点的最短路径来自 DV 算法第 14 行. </p>
<p>Recall that the LS algorithm is a centralized algorithm in the sense that it<br>requires each node to first obtain a complete map of the network before running the<br>Dijkstra algorithm. The DV algorithm is decentralized and does not use such global<br>information. Indeed, the only information a node will have is the costs of the links<br>to its directly attached neighbors and information it receives from these neighbors.<br>Each node waits for an update from any neighbor (Lines 10–11), calculates its new<br>distance vector when receiving an update (Line 14), and distributes its new distance<br>vector to its neighbors (Lines 16–17). DV-like algorithms are used in many routing<br>protocols in practice, including the Internet’s RIP and BGP, ISO IDRP, Novell IPX,<br>and the original ARPAnet.</p>
<p>LS 算法是集中算法, 其需要先获取所有网络节点信息. 而 DV 算法是分布的, 不需要. 实际上需要的仅仅是邻近节点的信息. 类 DV 算法在现实中应用广泛, 包括 internet 的 RIP, BGP, IOS IDRP, Novell IPX 已经最初的 ARPAnet. (以上我都不知道 :( … )</p>
<p><img src="https://imgur.com/E4wSJ2o.png" alt=""></p>
<p>Figure 5.6 illustrates the operation of the DV algorithm for the simple three-<br>node network shown at the top of the figure. The operation of the algorithm is illus-<br>trated in a synchronous manner, where all nodes simultaneously receive distance<br>vectors from their neighbors, compute their new distance vectors, and inform their<br>neighbors if their distance vectors have changed. After studying this example, you<br>should convince yourself that the algorithm operates correctly in an asynchronous<br>manner as well, with node computations and update generation/reception occurring<br>at any time.</p>
<p>图 5.6 阐释了 DV 算法在简单的三节点网络上的的操作. 算法以异步形式体现. 所有节点同时接收来自邻近节点的 distance-vector. 计算其新 distance vectors, 然后同时其邻近节点(如果有改变的话). </p>
<p>The leftmost column of the figure displays three initial routing tables for each<br>of the three nodes. For example, the table in the upper-left corner is node x’s ini-<br>tial routing table. Within a specific routing table, each row is a distance vector—<br>specifically, each node’s routing table includes its own distance vector and that<br>of each of its neighbors. Thus, the first row in node x’s initial routing table is<br>D x = [D x (x), D x (y), D x (z)] = [0, 2, 7]. The second and third rows in this table are<br>the most recently received distance vectors from nodes y and z, respectively. Because<br>at initialization node x has not received anything from node y or z, the entries in<br>the second and third rows are initialized to infinity.</p>
<p>After initialization, each node sends its distance vector to each of its two neigh-<br>bors. This is illustrated in Figure 5.6 by the arrows from the first column of tables<br>to the second column of tables. For example, node x sends its distance vector D x =<br>[0, 2, 7] to both nodes y and z. After receiving the updates, each node recomputes its<br>own distance vector. For example, node x computes<br>The second column therefore displays, for each node, the node’s new distance vector<br>along with distance vectors just received from its neighbors. Note, for example, that</p>
<p>初始化后, 每个节点将自身的 distance-vector 发生给其邻近节点. 通过图 5.6 的箭头表示. </p>
<p>(应该只会发送变化的节点吧? 不然处理起来应该不太方便)</p>
<p>node x’s estimate for the least cost to node z, D x (z), has changed from 7 to 3. Also<br>note that for node x, neighboring node y achieves the minimum in line 14 of the DV<br>algorithm; thus at this stage of the algorithm, we have at node x that v<em>(y) = y and<br>v</em>(z) = y.<br>After the nodes recompute their distance vectors, they again send their updated<br>distance vectors to their neighbors (if there has been a change). This is illustrated in<br>Figure 5.6 by the arrows from the second column of tables to the third column of<br>tables. Note that only nodes x and z send updates: node y’s distance vector didn’t<br>change so node y doesn’t send an update. After receiving the updates, the nodes then<br>recompute their distance vectors and update their routing tables, which are shown in<br>the third column.</p>
<p>在节点重计算 distance vectors 后, 再重新发送他们已更新的 distance vectors 给其邻近节点</p>
<p>The process of receiving updated distance vectors from neighbors, recomputing<br>routing table entries, and informing neighbors of changed costs of the least-cost path<br>to a destination continues until no update messages are sent. At this point, since no<br>update messages are sent, no further routing table calculations will occur and the<br>algorithm will enter a quiescent state; that is, all nodes will be performing the wait in<br>Lines 10–11 of the DV algorithm. The algorithm remains in the quiescent state until<br>a link cost changes, as discussed next.</p>
<p>(DV 算法是分布的, 它只需要知道其邻近节点信息, 也只需要与邻近节点交互)</p>
<h2 id="A-Comparison-of-LS-and-DV-Routing-Algorithms"><a href="#A-Comparison-of-LS-and-DV-Routing-Algorithms" class="headerlink" title="A Comparison of LS and DV Routing Algorithms"></a>A Comparison of LS and DV Routing Algorithms</h2><p>The DV and LS algorithms take complementary approaches toward computing rout-<br>ing. In the DV algorithm, each node talks to only its directly connected neighbors,<br>but it provides its neighbors with least-cost estimates from itself to all the nodes<br>(that it knows about) in the network. The LS algorithm requires global information.<br>Consequently, when implemented in each and every router, e.g., as in Figure 4.2 and<br>5.1, each node would need to communicate with all other nodes (via broadcast), but<br>it tells them only the costs of its directly connected links. Let’s conclude our study<br>of LS and DV algorithms with a quick comparison of some of their attributes. Recall<br>that N is the set of nodes (routers) and E is the set of edges (links).</p>
<p>DV 和 LS 是两个互补的算法. DV 只需要和其邻近节点交互. 但是其需要交互自身到其他所有节点的最小负载估计. LS 算法需要全局信息, 因此, 在路由上实现时, 每个节点需要和其他所有节点交互(通过广播). 但是只会发送直连节点的信息. 让我们通过一个快速的对比来总结一下 LS 和 DV 算法(N 代表节点结合, E 代表边集合) </p>
<p>• Message complexity. We have seen that LS requires each node to know the cost<br>of each link in the network. This requires O(|N| |E|) messages to be sent. Also,<br>whenever a link cost changes, the new link cost must be sent to all nodes. The DV<br>algorithm requires message exchanges between directly connected neighbors at<br>each iteration. We have seen that the time needed for the algorithm to converge<br>can depend on many factors. When link costs change, the DV algorithm will<br>propagate the results of the changed link cost only if the new link cost results in a<br>changed least-cost path for one of the nodes attached to that link.</p>
<p>信息复杂度: LS 需要每个节点都知道网络中的链接负载. 无论何时链接负载变化, 都必须发送给其余节点. DV 算法需要邻近节点间的信息交换. 这个算法所需时间基于很多因素. 当链接负载发生变化, 信息仅在最小负载路径发生变化时才传播给邻近节点.</p>
<p>• Speed of convergence. We have seen that our implementation of LS is an O(|N| 2 )<br>algorithm requiring O(|N| |E|)) messages. The DV algorithm can converge slowly<br>and can have routing loops while the algorithm is converging. DV also suffers<br>from the count-to-infinity problem.</p>
<p>收敛速度(???): </p>
<p>• Robustness. What can happen if a router fails, misbehaves, or is sabotaged?<br>Under LS, a router could broadcast an incorrect cost for one of its attached links<br>(but no others). A node could also corrupt or drop any packets it received as part<br>of an LS broadcast. But an LS node is computing only its own forwarding tables;<br>other nodes are performing similar calculations for themselves. This means route<br>calculations are somewhat separated under LS, providing a degree of robustness.<br>Under DV, a node can advertise incorrect least-cost paths to any or all destina-<br>tions. (Indeed, in 1997, a malfunctioning router in a small ISP provided national<br>backbone routers with erroneous routing information. This caused other routers<br>to flood the malfunctioning router with traffic and caused large portions of the<br>Internet to become disconnected for up to several hours [Neumann 1997].) More<br>generally, we note that, at each iteration, a node’s calculation in DV is passed on<br>to its neighbor and then indirectly to its neighbor’s neighbor on the next iteration.<br>In this sense, an incorrect node calculation can be diffused through the entire<br>network under DV.</p>
<p>稳定性: 当路由失败, 错误行为, 或者被蓄意破坏时会发生什么? 在 LS 算法中, 路由会广播错误的负载给每个连接的路由(不是其他所有). 节点也可能丢失接收到的广播. 但是 LS 算法仅在只是路由上计算(也就只影响自身). 这意为着节点计算是分离的. 增强了一定的稳定性. 而在 DV 算法中, 节点可能会通知错误的最小负载给邻近节点. 周而复始, 一个节点的计算会影响到其他所有节点.</p>
<p>In the end, neither algorithm is an obvious winner over the other; indeed, both algo-<br>rithms are used in the Internet.</p>
<p>所以, 两种算法各有其优. 都在 Internet 中有使用到.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/15/read/newFeaturesInC++14/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cas">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cas's website">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/15/read/newFeaturesInC++14/" class="post-title-link" itemprop="url">read/newFeaturesInC++14</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-15 09:37:20" itemprop="dateCreated datePublished" datetime="2020-01-15T09:37:20+08:00">2020-01-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-01-14 11:22:10" itemprop="dateModified" datetime="2020-01-14T11:22:10+08:00">2020-01-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="new-features-in-c-14"><a href="#new-features-in-c-14" class="headerlink" title="new features in c++14"></a>new features in c++14</h2><p>From : <a href="https://en.wikipedia.org/wiki/C%2B%2B14" target="_blank" rel="noopener">wiki</a></p>
<h2 id="New-language-features-edit"><a href="#New-language-features-edit" class="headerlink" title="New language features[edit]"></a>New language features[<a href="https://en.wikipedia.org/w/index.php?title=C%2B%2B14&action=edit&section=1" target="_blank" rel="noopener">edit</a>]</h2><p>These are the features added to the core language of C++14.</p>
<h3 id="Function-return-type-deduction-edit"><a href="#Function-return-type-deduction-edit" class="headerlink" title="Function return type deduction[edit]"></a>Function return type deduction[<a href="https://en.wikipedia.org/w/index.php?title=C%2B%2B14&action=edit&section=2" target="_blank" rel="noopener">edit</a>]</h3><p>C++11 allowed <a href="https://en.wikipedia.org/wiki/Lambda_function_(computer_programming)" target="_blank" rel="noopener">lambda functions</a> to deduce the return type based on the type of the expression given to the return statement. C++14 provides this ability to all functions. It also extends these facilities to lambda functions, allowing return type deduction for functions that are not of the form <code>return expression;</code>.<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-wong1-3" target="_blank" rel="noopener">[3]</a></p>
<p>c++允许 lambda 表达式根据返回值表达式推测返回值类型, c++14将其范围提升到了所有函数. </p>
<p>(后面这句我不明白它是什么意思)</p>
<p>In order to induce return type deduction, the function must be declared with <code>auto</code> as the return type, but without the trailing return type specifier in C++11:</p>
<p>为了引进返回值推测, 需要在声明时在返回值类型上带上 auto 关键字. 而不需要尾随返回值说明符.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto DeduceReturnType();   &#x2F;&#x2F; Return type to be determined.</span><br></pre></td></tr></table></figure>

<p>If multiple return expressions are used in the function’s implementation, then they must all deduce the same type.<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-deduce-4" target="_blank" rel="noopener">[4]</a></p>
<p>如果函数实现中存在多个返回值表达式, 它们必须被能被推测为一种类型. </p>
<p>Functions that deduce their return types can be forward declared, but they cannot be used until they have been defined. Their definitions must be available to the translation unit that uses them.</p>
<p>返回值类型推导可以前向声明. 但是直到被定义时才能使用. 定义必须能被翻译单元使用.</p>
<p><a href="https://en.wikipedia.org/wiki/Recursion" target="_blank" rel="noopener">Recursion</a> can be used with a function of this type, but the recursive call must happen after at least one return statement in the definition of the function:<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-deduce-4" target="_blank" rel="noopener">[4]</a></p>
<p>递归函数也可以使用返回值推导, 但是必须在至少一个返回语句之后使用.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">auto Correct(int i)</span><br><span class="line">&#123;</span><br><span class="line">  if (i &#x3D;&#x3D; 1)</span><br><span class="line">    return i;             &#x2F;&#x2F; return type deduced as int</span><br><span class="line"></span><br><span class="line">  return Correct(i-1)+i;  &#x2F;&#x2F; ok to call it now</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">auto Wrong(int i)</span><br><span class="line">&#123;</span><br><span class="line">  if (i !&#x3D; 1)</span><br><span class="line">    return Wrong(i-1)+i;  &#x2F;&#x2F; Too soon to call this. No prior return statement.</span><br><span class="line"></span><br><span class="line">  return i;               &#x2F;&#x2F; return type deduced as int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Alternate-type-deduction-on-declaration-5"><a href="#Alternate-type-deduction-on-declaration-5" class="headerlink" title="Alternate type deduction on declaration[5]"></a>Alternate type deduction on declaration<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-5" target="_blank" rel="noopener">[5]</a></h3><p>In C++11, two methods of type deduction were added. <code>auto</code> was a way to create a variable of the appropriate type, based on a given expression. <code>decltype</code> was a way to compute the type of a given expression. However, <code>decltype</code> and <code>auto</code> deduce types in different ways. In particular, <code>auto</code> always deduces a non-reference type, as though by using <code>std::decay</code>, while <code>auto&amp;&amp;</code> always deduces a reference type. However, <code>decltype</code> can be prodded into deducing a reference or non-reference type, based on the value category of the expression and the nature of the expression it is deducing:<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-wong1-3" target="_blank" rel="noopener">[3]</a></p>
<p>在 c++11, 引进了两种类型推导. <code>auto</code> 和 <code>decltype</code> <code>auto</code> 总是推导出非引用类型, <code>decltype</code> 则推导出完整的类型.  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int   i;</span><br><span class="line">int&amp;&amp; f();</span><br><span class="line">auto          x3a &#x3D; i;     &#x2F;&#x2F; decltype(x3a) is int</span><br><span class="line">decltype(i)   x3d &#x3D; i;     &#x2F;&#x2F; decltype(x3d) is int</span><br><span class="line">auto          x4a &#x3D; (i);   &#x2F;&#x2F; decltype(x4a) is int</span><br><span class="line">decltype((i)) x4d &#x3D; (i);   &#x2F;&#x2F; decltype(x4d) is int&amp;</span><br><span class="line">auto          x5a &#x3D; f();   &#x2F;&#x2F; decltype(x5a) is int</span><br><span class="line">decltype(f()) x5d &#x3D; f();   &#x2F;&#x2F; decltype(x5d) is int&amp;&amp;</span><br></pre></td></tr></table></figure>

<p>C++14 adds the <code>decltype(auto)</code> syntax. This allows <code>auto</code> declarations to use the <code>decltype</code> rules on the given expression.</p>
<p>c++ 增加了 <code>decltype(auto)</code> 语法, 这使 <code>auto</code> 声明可以在指定表达式上使用 <code>decltype</code> 规则.</p>
<p>The <code>decltype(auto)</code> syntax can also be used with <a href="https://en.wikipedia.org/wiki/C%2B%2B14#Function_return_type_deduction" target="_blank" rel="noopener">return type deduction</a>, by using <code>decltype(auto)</code> syntax instead of <code>auto</code> for the function’s return type deduction.<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-deduce-4" target="_blank" rel="noopener">[4]</a></p>
<p><code>decltype(auto)</code> 语法还可以在返回值类型推导上使用.</p>
<h3 id="Relaxed-constexpr-restrictions-edit"><a href="#Relaxed-constexpr-restrictions-edit" class="headerlink" title="Relaxed constexpr restrictions[edit]"></a>Relaxed constexpr restrictions[<a href="https://en.wikipedia.org/w/index.php?title=C%2B%2B14&action=edit&section=4" target="_blank" rel="noopener">edit</a>]</h3><p><a href="https://en.wikipedia.org/wiki/C%2B%2B11" target="_blank" rel="noopener">C++11</a> introduced the concept of a constexpr-declared function; a function which could be executed at compile time. Their return values could be consumed by operations that require constant expressions, such as an integer template argument. However, C++11 constexpr functions could only contain a single expression that is returned (as well as <code>static_assert</code>s and a small number of other declarations).</p>
<p>c++引进了常量声明函数(一个可以在编译期执行的函数). 他么的返回值可以被常量表达式使用. 然而, c++11 常量表达式函数只能包含单个返回的表达式</p>
<p>C++14 relaxes these restrictions. Constexpr-declared functions may now contain the following:<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-wong1-3" target="_blank" rel="noopener">[3]</a></p>
<p>c++14 取消了这些限制, 常量表达式函数可以包含以下: </p>
<ul>
<li><p>Any declarations except:</p>
<ul>
<li><p><code>static</code> or <code>thread_local</code> variables.</p>
<p><code>staic</code> 或 <code>thread_local</code> 变量.</p>
</li>
<li><p>Variable declarations without initializers.</p>
<p>没有初始化的变量声明(???)</p>
</li>
</ul>
</li>
<li><p>The conditional branching statements <code>if</code> and <code>switch</code>.</p>
<p>if 和 switch 条件语句</p>
</li>
<li><p>Any looping statement, including range-based <code>for</code>.</p>
<p>任何循环语句, 包括基于循环的 for</p>
</li>
<li><p>Expressions which change the value of an object if the lifetime of that object began within the constant expression function. This includes calls to any non-<code>const</code> <code>constexpr</code>-declared non-static member functions.</p>
<p>可更改开始于常量表达式函数的对象的值. 这包括任何对非常属性, 常量表达式定义, 非静态成员函数的调用.</p>
</li>
</ul>
<p><code>goto</code> statements are forbidden in C++14 relaxed constexpr-declared functions.</p>
<p>Also, C++11 stated that all non-static member functions that were declared <code>constexpr</code> were also implicitly declared <code>const</code>, with respect to <code>this</code>. That has since been removed; non-static member functions may be non-<code>const</code>.<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-6" target="_blank" rel="noopener">[6]</a> However, per the restrictions above, a non-<code>const</code> <code>constexpr</code> member function can only modify a class member if that object’s lifetime began within the constant expression evaluation.</p>
<p>C++11规定所有非静态, 被 <code>constexpr</code> 声明的成员函数是隐式声明为 <code>const</code> 的. 这同样也被移除了, 非静态成员函数可以是 <code>non-const</code> 的. 然而, 根据上面的限制, 一个 <code>non-const</code> <code>constexpr</code> 的成员函数只能更改对象生命周期随常量表达式求值开始的对象的成员(???) </p>
<p>(我在其他文档中并未看到具体的关于更改值的介绍, 我简单理解的话, constexpr 现已可以支持循环和分支语句, 并且可以包含 static 和 thread_local 变量)</p>
<h3 id="Variable-templates-edit"><a href="#Variable-templates-edit" class="headerlink" title="Variable templates[edit]"></a>Variable templates[<a href="https://en.wikipedia.org/w/index.php?title=C%2B%2B14&action=edit&section=5" target="_blank" rel="noopener">edit</a>]</h3><p>In prior versions of <a href="https://en.wikipedia.org/wiki/C%2B%2B" target="_blank" rel="noopener">C++</a>, only functions, classes or type aliases could be templated. C++14 now allows the creation of variables that are templated. An example given in the proposal is a variable <code>pi</code> that can be read to get the value of <a href="https://en.wikipedia.org/wiki/Pi" target="_blank" rel="noopener">pi</a> for various types (e.g., <code>3</code> when read as an integral type; the closest value possible with <code>float</code>, <code>double</code> or <code>long double</code> precision when read as <code>float</code>, <code>double</code> or <code>long double</code>, respectively; etc.).</p>
<p>在之前版本的 C++ 中, 类/类型别名可以模板化, C++14 允许创建变量模板. </p>
<p>The usual rules of templates apply to such declarations and definitions, including specialization.<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-isocpp-7" target="_blank" rel="noopener">[7]</a><a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-8" target="_blank" rel="noopener">[8]</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">constexpr T pi &#x3D; T(3.141592653589793238462643383);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Usual specialization rules apply:</span><br><span class="line">template&lt;&gt;</span><br><span class="line">constexpr const char* pi&lt;const char*&gt; &#x3D; &quot;pi&quot;;</span><br></pre></td></tr></table></figure>



<h3 id="Aggregate-member-initialization-edit"><a href="#Aggregate-member-initialization-edit" class="headerlink" title="Aggregate member initialization[edit]"></a>Aggregate member initialization[<a href="https://en.wikipedia.org/w/index.php?title=C%2B%2B14&action=edit&section=6" target="_blank" rel="noopener">edit</a>]</h3><p><a href="https://en.wikipedia.org/wiki/C%2B%2B11" target="_blank" rel="noopener">C++11</a> added member initializers, expressions to be applied to members at class scope if a constructor did not initialize the member itself. The definition of aggregates was changed to explicitly exclude any class with member initializers; therefore, they are not allowed to use aggregate initialization.</p>
<p>C++14 relaxes this restriction,<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-wong1-3" target="_blank" rel="noopener">[3]</a> allowing aggregate initialization on such types. If the braced init list does not provide a value for that argument, the member initializer takes care of it.<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-9" target="_blank" rel="noopener">[9]</a></p>
<p>(我不明白说的什么, 成员初始化不是 C++11 就有的么?)</p>
<h3 id="Binary-literals-edit"><a href="#Binary-literals-edit" class="headerlink" title="Binary literals[edit]"></a>Binary literals[<a href="https://en.wikipedia.org/w/index.php?title=C%2B%2B14&action=edit&section=7" target="_blank" rel="noopener">edit</a>]</h3><p>Numeric literals in C++14 can be specified in <a href="https://en.wikipedia.org/wiki/Binary_number" target="_blank" rel="noopener">binary form</a>.<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-wong1-3" target="_blank" rel="noopener">[3]</a> The syntax uses the prefixes <code>0b</code> or <code>0B</code>. The syntax is also used in other languages e.g. <a href="https://en.wikipedia.org/wiki/Java_(programming_language)" target="_blank" rel="noopener">Java</a>, <a href="https://en.wikipedia.org/wiki/C_Sharp_(programming_language)" target="_blank" rel="noopener">C#</a>, <a href="https://en.wikipedia.org/wiki/Swift_(programming_language)" target="_blank" rel="noopener">Swift</a>, <a href="https://en.wikipedia.org/wiki/Go_(programming_language)" target="_blank" rel="noopener">Go</a>, <a href="https://en.wikipedia.org/wiki/Scala_(programming_language)" target="_blank" rel="noopener">Scala</a>, <a href="https://en.wikipedia.org/wiki/Ruby_(programming_language)" target="_blank" rel="noopener">Ruby</a>, <a href="https://en.wikipedia.org/wiki/Python_(programming_language)" target="_blank" rel="noopener">Python</a>, <a href="https://en.wikipedia.org/wiki/OCaml" target="_blank" rel="noopener">OCaml</a>, and as an unofficial extension in some C compilers since at least 2007.<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-gccbinaryliteralbugreport-10" target="_blank" rel="noopener">[10]</a></p>
<h3 id="Digit-separators-edit"><a href="#Digit-separators-edit" class="headerlink" title="Digit separators[edit]"></a>Digit separators[<a href="https://en.wikipedia.org/w/index.php?title=C%2B%2B14&action=edit&section=8" target="_blank" rel="noopener">edit</a>]</h3><p>In C++14, the single-quote character may be used arbitrarily as a <a href="https://en.wikipedia.org/wiki/Integer_literal#Digit_separators" target="_blank" rel="noopener">digit separator</a> in numeric literals, both <a href="https://en.wikipedia.org/wiki/Integer_literal" target="_blank" rel="noopener">integer literals</a> and floating point literals.<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-11" target="_blank" rel="noopener">[11]</a> This can make it easier for human readers to parse large numbers through <a href="https://en.wikipedia.org/wiki/Subitizing" target="_blank" rel="noopener">subitizing</a>.</p>
<p>auto integer_literal = 1’000’000;<br> auto floating_point_literal = 0.000’015’3;<br> auto binary_literal = 0b0100’1100’0110;<br> auto silly_example = 1’0’0’000’00;</p>
<p>C++14中, 单引号专用于整数/浮点数表示, 使人看起来可以更加清晰(woo, 真是个人性化的功能)</p>
<h3 id="Generic-lambdas-edit"><a href="#Generic-lambdas-edit" class="headerlink" title="Generic lambdas[edit]"></a>Generic lambdas[<a href="https://en.wikipedia.org/w/index.php?title=C%2B%2B14&action=edit&section=9" target="_blank" rel="noopener">edit</a>]</h3><p>In C++11, <a href="https://en.wikipedia.org/wiki/Anonymous_function" target="_blank" rel="noopener">lambda function</a> parameters need to be declared with concrete types. C++14 relaxes this requirement, allowing lambda function parameters to be declared with the <code>auto</code> type specifier.<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-isocpp-7" target="_blank" rel="noopener">[7]</a></p>
<p>在 C++11 中, lambda 函数参数声明必须具有具体的类型, C++14 放松了这个要求, 允许 lambda 函数参数使用 auto 关键字声明, 如下: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto lambda &#x3D; [](auto x, auto y) &#123;return x + y;&#125;;</span><br></pre></td></tr></table></figure>

<p>Concerning <code>auto</code> type deduction, generic lambdas follow the rules of template argument deduction (which are similar, but not identical in all respects[*<a href="https://en.wikipedia.org/wiki/Wikipedia:Please_clarify" target="_blank" rel="noopener">clarification needed</a>*]). The code above is equivalent to this:<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-12" target="_blank" rel="noopener">[12]</a></p>
<p>关于 auto 类型推导, 泛型 lambdas 遵循模板参数推导原则. 上述代码等同于以下:</p>
<p>(其实也证实了, 与其说是匿名函数, 不如说是带 () 重载的匿名类)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct</span><br><span class="line">&#123;</span><br><span class="line">  template&lt;typename T, typename U&gt;</span><br><span class="line">    auto operator()(T x, U y) const &#123;return x + y;&#125;</span><br><span class="line">&#125; lambda&#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>Generic lambdas are essentially templated functor lambdas.</p>
<p>泛型 lambdas 是更高效的函数模板</p>
<h3 id="Lambda-capture-expressions-edit"><a href="#Lambda-capture-expressions-edit" class="headerlink" title="Lambda capture expressions[edit]"></a>Lambda capture expressions[<a href="https://en.wikipedia.org/w/index.php?title=C%2B%2B14&action=edit&section=10" target="_blank" rel="noopener">edit</a>]</h3><p>C++11 lambda functions capture variables declared in their outer scope by value-copy or by reference. This means that value members of a lambda cannot be move-only types.<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-13" target="_blank" rel="noopener">[13]</a> C++14 allows captured members to be initialized with arbitrary expressions. This allows both capture by value-move and declaring arbitrary members of the lambda, without having a correspondingly named variable in an outer scope.<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-isocpp-7" target="_blank" rel="noopener">[7]</a></p>
<p>C++11 在其所在作用域中按值/引用捕获变量, 这意味着 lambda 成员的值不能是 move-only 类型. C++14 循序被捕获变量以任意形式初始化. 这使所有捕获可以值/移动, 以及声明任意的 lambda 成员, 而不需要在外层作用域中有对应的已命名成员.</p>
<p>This is done via the use of an initializer expression:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto lambda &#x3D; [value &#x3D; 1] &#123;return value;&#125;;</span><br></pre></td></tr></table></figure>

<p>The lambda function <code>lambda</code> returns 1, which is what <code>value</code> was initialized with. The declared capture deduces the type from the initializer expression as if by <code>auto</code>.</p>
<p>声明捕获像 auto 一样推导初始化表达式.</p>
<p>This can be used to capture by move, via the use of the standard <code>std::move</code> function:</p>
<p>还可以用于捕获移动语义(赞啊 -v- )</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;int&gt; ptr(new int(10));</span><br><span class="line">auto lambda &#x3D; [value &#x3D; std::move(ptr)] &#123;return *value;&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="The-attribute-deprecated-edit"><a href="#The-attribute-deprecated-edit" class="headerlink" title="The attribute [[deprecated]][edit]"></a>The attribute <code>[[deprecated]]</code>[<a href="https://en.wikipedia.org/w/index.php?title=C%2B%2B14&action=edit&section=11" target="_blank" rel="noopener">edit</a>]</h3><p>The <code>deprecated</code> attribute allows marking an entity <a href="https://en.wikipedia.org/wiki/Deprecated" target="_blank" rel="noopener">deprecated</a>, which makes it still legal to use but puts users on notice that use is discouraged and may cause a warning message to be printed during compilation. An optional <a href="https://en.wikipedia.org/wiki/String_literal" target="_blank" rel="noopener">string literal</a> can appear as the argument of <code>deprecated</code>, to explain the rationale for deprecation and/or to suggest a replacement.</p>
<p>deprecated 属性可以标记一个整体为’废弃的’, 继续使用这个整体是合法的, 但是用户会在编译时收到一个警告. </p>
<p>deprecated 可以增加字符串文本, 用作警示语.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[[deprecated]] int f();</span><br><span class="line"></span><br><span class="line">[[deprecated(&quot;g() is thread-unsafe. Use h() instead&quot;)]]</span><br><span class="line">void g( int&amp; x );</span><br><span class="line"></span><br><span class="line">void h( int&amp; x );</span><br><span class="line"></span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">  int a &#x3D; f(); &#x2F;&#x2F; warning: &#39;f&#39; is deprecated</span><br><span class="line">  g(a); &#x2F;&#x2F; warning: &#39;g&#39; is deprecated: g() is thread-unsafe. Use h() instead</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(在 gcc (Debian 6.3.0-18+deb9u1) 6.3.0 20170516 版本下, 对于类的支持有所不足)</p>
<h2 id="New-standard-library-features-edit"><a href="#New-standard-library-features-edit" class="headerlink" title="New standard library features[edit]"></a>New standard library features[<a href="https://en.wikipedia.org/w/index.php?title=C%2B%2B14&action=edit&section=12" target="_blank" rel="noopener">edit</a>]</h2><h3 id="Shared-mutexes-and-locking-edit"><a href="#Shared-mutexes-and-locking-edit" class="headerlink" title="Shared mutexes and locking[edit]"></a>Shared mutexes and locking[<a href="https://en.wikipedia.org/w/index.php?title=C%2B%2B14&action=edit&section=13" target="_blank" rel="noopener">edit</a>]</h3><p>C++14 adds a shared timed mutex and a companion shared lock type.<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-wong3-14" target="_blank" rel="noopener">[14]</a><a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-15" target="_blank" rel="noopener">[15]</a></p>
<p>C++14 增加了共享互斥锁, 以及他的’伴侣’共享锁类型.</p>
<p>(这里有点不好说, mutex 本身是一把锁, 而 lock 也是锁的意思, 不过是加锁, lock(mutex), emm, 应该是这意思)</p>
<h3 id="Heterogeneous-lookup-in-associative-containers-edit"><a href="#Heterogeneous-lookup-in-associative-containers-edit" class="headerlink" title="Heterogeneous lookup in associative containers[edit]"></a>Heterogeneous lookup in associative containers[<a href="https://en.wikipedia.org/w/index.php?title=C%2B%2B14&action=edit&section=14" target="_blank" rel="noopener">edit</a>]</h3><p>The <a href="https://en.wikipedia.org/wiki/C%2B%2B_Standard_Library" target="_blank" rel="noopener">C++ Standard Library</a> defines four associative container classes. These classes allow the user to look up a value based on a value of that type. The map containers allow the user to specify a key and a value, where lookup is done by key and returns a value. However, the lookup is always done by the specific key type, whether it is the key as in maps or the value itself as in sets.</p>
<p>C++ 标准库定义了四种关联的容器类, 这些类型使用户可以检查基于该值类型的值. 然而, 检查总是需要指定类型来完成 (??? 卧槽 你想干嘛???)</p>
<p>C++14 allows the lookup to be done via an arbitrary type, so long as the comparison operator can compare that type with the actual key type.<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-wong2-16" target="_blank" rel="noopener">[16]</a> This would allow a map from <code>std::string</code> to some value to compare against a <code>const char*</code> or any other type for which an <code>operator&lt;</code>overload is available. It is also useful for indexing composite objects in a <code>std::set</code> by the value of a single member without forcing the user of <code>find</code> to create a dummy object (for example creating an entire <code>struct Person</code> to find a person by name).</p>
<p>C++14 允许检查可以经由任意类型完成, 只要对比操作可以和正确的键类型对比. 这使 map&lt;std::string&gt;可以和 const char* 类型的值或其他有有效 &lt; 重载的操作符的类型(为什么一定是 <code>&lt;</code> ?  <code>&gt;</code> 它不香么?) </p>
<p>当要检查一个集合中的复合类型时, 不需要创建一个复杂的复合类型也可以检索 (比如: 检索 struct person, 可以使用他的名字, 而并不需要创建一个 person 对象)</p>
<p>To preserve backwards compatibility, heterogeneous lookup is only allowed when the comparator given to the associative container allows it. The standard library classes <code>std::less&lt;&gt;</code> and <code>std::greater&lt;&gt;</code> are augmented to allow heterogeneous lookup.<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-17" target="_blank" rel="noopener">[17]</a></p>
<p>为了保持向后兼容性, heterogeneous 检查只在关联的容器允许对比器时才适用. 标准库 std::less&lt;&gt;, std::greater&lt;&gt; 被 heterogeneous 检查接纳 (诶, 我不知道这该怎么写…)</p>
<p>(这是我在网上找到的代码, 其中两个包含 thread::id 的重载缺一不可, 也就是说编译器都会用到)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ThreadCmp</span> &#123;</span></span><br><span class="line">  <span class="keyword">using</span> is_transparent = <span class="keyword">void</span>;</span><br><span class="line">  <span class="comment">// Regular overload.</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::thread&amp; a, <span class="keyword">const</span> <span class="built_in">std</span>::thread&amp; b)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.get_id() &lt; b.get_id();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Transparent overloads</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::thread&amp; a, <span class="built_in">std</span>::thread::id b)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.get_id() &lt; b;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="built_in">std</span>::thread::id a, <span class="keyword">const</span> <span class="built_in">std</span>::thread&amp; b)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &lt; b.get_id();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//bool operator()(std::thread::id a, std::thread::id b) const &#123;</span></span><br><span class="line">  <span class="comment">//  return a &lt; b;</span></span><br><span class="line">  <span class="comment">//&#125;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::thread, ThreadCmp&gt; threads;</span><br><span class="line">    <span class="comment">// Can't construct an instance of `std::thread` with the same id, just to do the lookup.</span></span><br><span class="line">    <span class="comment">// But we can look up by id instead.</span></span><br><span class="line">    <span class="built_in">std</span>::thread::id id = this_thread::get_id();;</span><br><span class="line">    <span class="keyword">auto</span> it = threads.<span class="built_in">find</span>(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h3 id="Standard-user-defined-literals-edit"><a href="#Standard-user-defined-literals-edit" class="headerlink" title="Standard user-defined literals[edit]"></a>Standard user-defined literals[<a href="https://en.wikipedia.org/w/index.php?title=C%2B%2B14&action=edit&section=15" target="_blank" rel="noopener">edit</a>]</h3><p>C++11 defined the syntax for user-defined literal suffixes, but the standard library did not use any of them. C++14 adds the following standard literals:<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-wong2-16" target="_blank" rel="noopener">[16]</a></p>
<p>C++14 增加了以下标准字面量</p>
<ul>
<li><p>“s”, for creating the various <code>std::basic_string</code> types.</p>
<p>“s”, 创建各种 <code>std::basic_string</code> 类型</p>
</li>
<li><p>“h”, “min”, “s”, “ms”, “us”, “ns”, for creating the corresponding <code>std::chrono::duration</code> time intervals.</p>
<p>“h”, “min”, “s”, “ms”, “us”, “ns”, 创建对应的 <code>std::chrono::duration</code> 时间间隔</p>
</li>
<li><p>“if”, “i”, “il”, for creating the corresponding <code>std::complex</code>, <code>std::complex</code> and <code>std::complex</code> imaginary numbers.</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto str &#x3D; &quot;hello world&quot;s; &#x2F;&#x2F; auto deduces string</span><br><span class="line">auto dur &#x3D; 60s;            &#x2F;&#x2F; auto deduces chrono::seconds</span><br><span class="line">auto z   &#x3D; 1i;             &#x2F;&#x2F; auto deduces complex&lt;double&gt;</span><br></pre></td></tr></table></figure>

<p>The two “s” literals do not interact, as the string one only operates on <a href="https://en.wikipedia.org/wiki/String_literal" target="_blank" rel="noopener">string literals</a>, and the one for seconds operates only on numbers.<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-18" target="_blank" rel="noopener">[18]</a></p>
<h3 id="Tuple-addressing-via-type-edit"><a href="#Tuple-addressing-via-type-edit" class="headerlink" title="Tuple addressing via type[edit]"></a>Tuple addressing via type[<a href="https://en.wikipedia.org/w/index.php?title=C%2B%2B14&action=edit&section=16" target="_blank" rel="noopener">edit</a>]</h3><p>The <code>std::tuple</code> type introduced in C++11 allows an aggregate of typed values to be indexed by a compile-time constant integer. C++14 extends this to allow fetching from a tuple by type instead of by index.<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-wong2-16" target="_blank" rel="noopener">[16]</a> If the tuple has more than one element of the type, a compile-time error results:<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-19" target="_blank" rel="noopener">[19]</a></p>
<p>C++14 扩展了 <code>std::tuple</code> , 可以通过类型来获取元素, 如果 tuple 有多个相同类型, 则会出错.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tuple&lt;string, string, int&gt; t(&quot;foo&quot;, &quot;bar&quot;, 7);</span><br><span class="line">int i &#x3D; get&lt;int&gt;(t);        &#x2F;&#x2F; i &#x3D;&#x3D; 7</span><br><span class="line">int j &#x3D; get&lt;2&gt;(t);          &#x2F;&#x2F; Same as before: j &#x3D;&#x3D; 7</span><br><span class="line">string s &#x3D; get&lt;string&gt;(t);  &#x2F;&#x2F; Compile-time error due to ambiguity</span><br></pre></td></tr></table></figure>



<h3 id="Smaller-library-features-edit"><a href="#Smaller-library-features-edit" class="headerlink" title="Smaller library features[edit]"></a>Smaller library features[<a href="https://en.wikipedia.org/w/index.php?title=C%2B%2B14&action=edit&section=17" target="_blank" rel="noopener">edit</a>]</h3><p><code>std::make_unique</code> can be used like <code>std::make_shared</code> for <code>std::unique_ptr</code> objects.<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-isocpp-7" target="_blank" rel="noopener">[7]</a></p>
<p><code>std::integral_constant</code> gained an <code>operator()</code> overload to return the constant value.<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-wong2-16" target="_blank" rel="noopener">[16]</a></p>
<p>The class template <code>std::integer_sequence</code> and related alias templates were added for representing compile-time integer sequences, such as the indices of elements in a parameter pack.<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-intseqs-20" target="_blank" rel="noopener">[20]</a></p>
<p>The global <code>std::begin</code>/<code>std::end</code> functions were augmented with <code>std::cbegin</code>/<code>std::cend</code> functions, which return constant iterators, and <code>std::rbegin</code>/<code>std::rend</code> and <code>std::crbegin</code>/<code>std::crend</code> which return reverse iterators.</p>
<p>The <code>std::exchange</code> function template assigns a new value to a variable and returns the old value.<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-exchange-21" target="_blank" rel="noopener">[21]</a></p>
<p>New overloads of <code>std::equal</code>, <code>std::mismatch</code>, and <code>std::is_permutation</code> take a pair of iterators for the second range, so that the caller does not need to separately check that the two ranges are of the same length.<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-robustseqs-22" target="_blank" rel="noopener">[22]</a></p>
<p>The <code>std::is_final</code> type trait detects if a class is marked <code>final</code>.</p>
<p>The <code>std::quoted</code> stream I/O manipulator allows inserting and extracting strings with embedded spaces, by placing delimiters (defaulting to double-quotes) on output and stripping them on input, and escaping any embedded delimiters.<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-quoted-23" target="_blank" rel="noopener">[23]</a></p>
<h2 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h2><ol>
<li><p>类型推导, type deduce</p>
<p>以 <code>auto</code> 为主, 可以推导返回值而不需返回值后置语法. 同时 <code>decltype</code> 可以用于推导 auto 的原类型</p>
</li>
<li><p>常量表达式加强 <code>constexpr</code></p>
<p><code>constexpr</code> 中可以有静态变量, thread_local 变量, 可以有分支和循环语句</p>
</li>
<li><p>值模板 variable template</p>
<p>不仅类, 现在值也可以模板化</p>
</li>
<li><p>数字分隔符 digit separators</p>
<p>使数字更加易读</p>
</li>
<li><p>加强 lambda</p>
<p>lambda 的参数可以是 auto 推导的了, 同时 lambda 的捕获增加了移动语义, 还可以不是外部成员(也就是自建变量)</p>
</li>
<li><p>关键字 [[deprecated]]</p>
<p>用于警示用户</p>
</li>
<li><p>新的字面量, “s”, “h”, “min” … </p>
<p>新的字面量, 用于快捷创建变量, 而不需显式转换类型</p>
</li>
<li><p>新的 tuple 元素索引方式</p>
<p>可以用类型来检索了呢 :)</p>
</li>
</ol>
<p>以上是我从 C++14 中印象比较深刻的新特性</p>
<p>these are my impressive new features in c++14 </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/10/other/memoryAndCache/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cas">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cas's website">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/10/other/memoryAndCache/" class="post-title-link" itemprop="url">other/memoryAndCache</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-10 19:14:59" itemprop="dateCreated datePublished" datetime="2020-01-10T19:14:59+08:00">2020-01-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-01-09 17:12:35" itemprop="dateModified" datetime="2020-01-09T17:12:35+08:00">2020-01-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>#内层对齐补齐与分支目标缓冲器<br>    出自《C++反汇编技术分析与揭秘》<br>    此书我并没有读完，收获是对于底层更加了解，有2个点更加清楚了</p>
<h2 id="内存对齐与补齐，为什么是4字节"><a href="#内存对齐与补齐，为什么是4字节" class="headerlink" title="内存对齐与补齐，为什么是4字节"></a>内存对齐与补齐，为什么是4字节</h2><ul>
<li><p>CPU运算的第二梯队是cache（高速缓冲区），它的访问速度仅次于寄存器</p>
</li>
<li><p>cache中有虚拟地址映射，当运算时会从中拿到地址进行寻址操作</p>
</li>
<li><p>同时32位机的寄存器位数为32位，我们常用的数据整形int和指针的大小也为4字节</p>
</li>
<li><p>思考2个问题：</p>
<ul>
<li><p>一般常用的数据类型基本是4字节以上（除单个的char和short）</p>
</li>
<li><p>cache的内存十分宝贵，里面保存的地址是否有必要精确到1位  </p>
<p>对于cache进行了优化，其中保存的内存地址会丢弃后两位，丢弃之后，寻址操作只能基于4字节的倍数<br>所以对齐补齐是以4字节为基础的</p>
</li>
</ul>
</li>
</ul>
<h2 id="对于循环的优化"><a href="#对于循环的优化" class="headerlink" title="对于循环的优化"></a>对于循环的优化</h2><ul>
<li><p>先考虑流水线优化，其原理很简单：<br>  A B C D四个工人，当一个任务来的时候，顺序是A-&gt;B-&gt;C-&gt;D<br>  当A做完了，继续来了第2个任务，在此时，B在做第一个任务的第二步，参考如图：</p>
<ol>
<li><p>A B C D</p>
</li>
<li><p>&emsp;A B C D    </p>
</li>
<li><p>&emsp; &emsp;A B C D</p>
</li>
<li><p>……  </p>
<p>其核心是，如果只有一个任务，那么就需要花费一整段工作时间<br>而如果是多个任务，例如2个任务，那么就是5/4的时间，以此类推</p>
</li>
</ol>
</li>
<li><p>分支目标缓冲器，考虑下面的循环：  </p>
<pre><code>/**
*@brief 外层循环做10次
*/
for (int i = 0; i &lt; 10; ++i)
{
    /**
    *@brief 内层做1000次循环，第一次不预测，预测成功999次，第1001次预测失败
    */
    for (int j = 0; j &lt; 1000; ++j)
    {
        //...
    }
}</code></pre><p>  分支目标缓冲器要结合流水线优化来理解<br>  当第一个分支启动时，分支目标缓冲器不进行预测，当第二次循环进行时，进行预测，预测成功，直到失败<br>  分支目标缓冲器是经验主义，预测越多，优化更好，如果多次失败，则会刷新<br>  （intel的CPU是这样的，当进行一个分支时，下一个分支已经在进行预测了，它对true/false的情况进行预测<br>  ，也就是在这次分支执行时，下一次分支已经准备好了（其中的同步这些则是更底层的知识了）如果预测失败则会回流，<br>  如果预测成功，将会节省时间以达到提升性能的目的）</p>
<p>  如果外层分支进行10次，内层分支进行1000次，那么1次不预测，999次成功，最后一次失败，这样的操作重复10次<br>  则 10 x 999 = 9990 次<br>  如果外层分支进行1000次，内层分支进行10次，那么1次不预测，9次成功，最后一次失败，这样的操作重复1000次<br>  则 9 x 1000 = 9000 次<br>  分支预测是经验主义，预测越多，优化也就更好，所以：<br>  <strong>多重循环，内层循环次数应大于外层循环次数</strong><br>  PS：这需要结合CPU来考虑，intel的CPU是这样的，AMD就不知道了</p>
</li>
</ul>
<p>至于switch，if，等等，都有优化，具体以后再补，分支的结构类似于函数调用，都会发生跳转（inline例外）<br>PS：强推程序应当了解底层知识，编译器优化和汇编，如果了解了底层，很多知识点都能迎刃而解<br>当然，前提是有那耐心，一个简单的除法编译器都可能会优化成一堆计算机处理比较简单，而人理解起来就很头疼的代码<br>那涉及到数学方面的知识，并且不简单…</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/10/other/encode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cas">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cas's website">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/10/other/encode/" class="post-title-link" itemprop="url">other/encode</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-10 19:14:41" itemprop="dateCreated datePublished" datetime="2020-01-10T19:14:41+08:00">2020-01-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-01-09 17:12:35" itemprop="dateModified" datetime="2020-01-09T17:12:35+08:00">2020-01-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>#为什么是-128<del>127?<br>我们常说char类型数据占1个字节,范围是-128</del>127<br>OK,1字节八位,1位为符号为,7位存储数据,但是为什么负数要比正数多一个呢?</p>
<p>这涉及到补码和反码的概念,8位能表示2^8+1种变化(我更偏向于称它为变化,因为计算机中的二进制是我们赋予他的意义,这里+1指的是0)<br>也就是0<del>255,256个数字,所以-128</del>127是正确的<br>考虑一下0会如何被表示:</p>
<pre><code>在符号位为正的情况下为 0000 0000  
在符号位为负的情况下为 1000 0000  </code></pre><p>同样的数,他们表示方式重叠了,这显然不好<br>所以CPU采用了正数和负数表示方式不同的方法来解决这个问题<br>负数的表现方式为 补码: 反码 + 1</p>
<p>##反码<br>就和它的名字一样,它的意义是除符号位外,其他所有位取反<br>例如 0000 0000 取反为 0111 1111</p>
<p>##补码<br>补码即为反码 + 1</p>
<p>有了以上知识,那么可以得知以下二进制表示多少(假设为1 byte):</p>
<pre><code>1111 1111 反码:1000 0000 补码:1000 0001 表示 -1
1000 0000 反码:1111 1111 补码:(这里不好表示o(*￣▽￣*)ブ) 表示:-128</code></pre><p>所以,为什么负数比正数多了一个呢?<br>因为计算机内部结构(补码)造成了负数比正数能多表达一个(这一个是来自于-0这个概念,因为我们更加偏向于+0而不是-0,<br>所以就让正数吃亏了,也不仅仅是这样,在很多我无法举例但的确存在的某些”骚操作”里面,这种方式给予了很大的支持)</p>
<p>这里也映射了很多概念,比如一个数已经表示最大了(比如char的127)我将它+1 为什么他表示了-128?</p>
<pre><code>127二进制 0111 1111
+1之后 1000 0000(很熟悉吧,就在上面,这表示了负最大)</code></pre><p>PS:底层的东西很有趣,不然为什么编译原理和操作系统凭什么被认为是程序三大浪漫(还有一个是图形学,<br>emmm 三大浪漫有很多争议,有些认为应当包含数据库和算法,新的三大浪漫还有人工智能和机器视觉等等)</p>
<p>PS:关于符号位扩展</p>
<p>思考下面代码<br>    (x &lt;&lt; 1) &gt;&gt; 1<br>x左移一位后又右移一位, 乍一看并没有什么改变, 这涉及到符号位的扩展问题  </p>
<p>对于移位操作, 左移都补0, 而右移因为反码的关系:正数移位补0, 而负数移位补1, 所以当x左移改变了符号位时,再右移,它的值将会发生改变<br>具体改变的规律是符号位发生改变, 而数值上的体现涉及到负数会补码, 所以改变前后可能是两个看起来完全不同但其实有规律的值</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/10/other/overFlowAndCarry/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cas">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cas's website">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/10/other/overFlowAndCarry/" class="post-title-link" itemprop="url">other/overFlowAndCarry</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-10 19:12:57" itemprop="dateCreated datePublished" datetime="2020-01-10T19:12:57+08:00">2020-01-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-01-09 17:12:35" itemprop="dateModified" datetime="2020-01-09T17:12:35+08:00">2020-01-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>##对于溢出和越界的理解(overflow/outside range)</p>
<p>x86汇编flag寄存器有两个表示位, 分别位OF/CF, 溢出标志位/进位标志位<br>其中OF只对有符号数有效, 例如:<br>当两个1字节大小的数字相加时, A: 0111 1111 (127), B: 0000 0001 (1)<br>A + B = 128, 对应二进制位是 1000 0000, 但是对于有符号数来说, 这是负数, 计算结果是错误的<br>这里错误的原因是计算结果<strong>占用了一个不该它占有的有效位</strong><br>不该它占有: 它占有了符号位, 这个位错误地被计算结果改变<br>有效: 这个符号位是被合理分配的, 并不是未定义的</p>
<p>CF只对无符号数有效, 例如:<br>当两个1字节大小的数字相加时, A: 1111 1111 (255), B: 0000 0001 (1)<br>A + B = 256, 对应二进制位是 1 0000 0000, 1字节大小存不下9bit, 计算结果无法保存, 产生错误<br>错误原因是: 计算结果<strong>超出了合理的范围, 这个位未被定义</strong><br>同样不该它占有, 但是同时这是个<strong>未被定义的空间</strong>  </p>
<p>那么就可以简单看出, 从寄存器角度, 溢出/越界的区分了, <strong>那个位是否有效</strong><br>(但是也不一定…)</p>
<pre><code>vector&lt;int&gt; veci{1, 2, 3};
vector&lt;int&gt;::iterator it1 = veci.begin();
vector&lt;int&gt;::iterator it2 = veci.begin() + 1; 

veci.erase(it1);
// @note 这里的erase会报错, 因为在上一句代码中, begin迭代器所指向的数据被删除了, 
//     删除之后, begin迭代器之后的元素重新排序(往前移), 此时的it2已经不指向它原先希望指向的位置了  
//     可能它指向了新的begin迭代器之后的位置, 也可能指向begin了, 直接的结果是: 它失效了  
veci.erase(it2);</code></pre><p>在上段代码中, it2实际可能还是指向一个元素的, (实际VS debug中, it2指向了第三个元素, 也就是3)<br>it2并未失效, 它依旧指向一块内存,(至少在VS debug中这样) 但是这是块<strong>不该它占有的内存</strong><br>按照上述我们对溢出/越界的定义, 这种问题属于溢出  </p>
<p>但是很可惜, 报错信息是:<br>“vector erase iterator outside range”<br>emmmmmmmmmm, 也就是说, 它认为这是越界…<br>所以我的理解可能是错的, 但是我还是认为这样子理解没有什么问题(大概… :) )</p>
<p>或许这样说更好, 有符号数, 只有7位数值, 两个7位数值无论如何计算也不会超过8位<br>而无符号数, 8位数值, 计算是可能超过8位的</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/10/other/CreatesoFileinLinux/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cas">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cas's website">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/10/other/CreatesoFileinLinux/" class="post-title-link" itemprop="url">other/CreatesoFileinLinux</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-10 19:12:23" itemprop="dateCreated datePublished" datetime="2020-01-10T19:12:23+08:00">2020-01-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-01-09 17:13:54" itemprop="dateModified" datetime="2020-01-09T17:13:54+08:00">2020-01-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Step"><a href="#Step" class="headerlink" title="Step"></a>Step</h3><ol>
<li>编写动态库源文件  </li>
<li>将动态库源文件编译链接生成动态库文件  </li>
<li>在执行源文件中添加头文件声明  </li>
<li>使用动态库文件  </li>
</ol>
<hr>
<h4 id="Step1"><a href="#Step1" class="headerlink" title="Step1:"></a>Step1:</h4><p>…</p>
<h4 id="Step2"><a href="#Step2" class="headerlink" title="Step2:"></a>Step2:</h4><pre><code>gcc/g++ -fPIC -shared -o [libname].so [sourcefile]</code></pre><p>example:  </p>
<pre><code>gcc -fPIC -shared -o tlib.so tlib.c</code></pre><p>这样就会生成一个<code>tlib.so</code>的动态库文件<br>其中<code>-fPIC</code>的含义是: Position Independent Code (位置无关代码)</p>
<h4 id="Step3"><a href="#Step3" class="headerlink" title="Step3:"></a>Step3:</h4><p>添加声明可以在单独的头文件中添加, 也可以直接在使用的源文件内添加  </p>
<h4 id="Step4"><a href="#Step4" class="headerlink" title="Step4:"></a>Step4:</h4><pre><code>gcc t.c -L. tlib.so  </code></pre><p>会生成一个默认的<code>a.out</code>可执行文件  </p>
<p>此时还有一个问题就是直接运行的话会报错:<br>应用程序找不到<code>.so</code>文件<br>解决方法有两种, 一种是改系统文件, 另外一种是临时告诉shell动态库的路径<br>因为这个是测试用例, 介绍第二种  </p>
<pre><code>LD_LIBRARY_PATH=. ./a.out  </code></pre><p>执行此命令可以解决报错问题, 其中<code>LD_LIBRARY_PATH=.</code>的含义是:<br>告诉shell, 库的路径在当前路径下(如果库放在别的路径, 将<code>.</code>替换即可)  </p>
<p>以上经验来自<a href="https://www.cnblogs.com/jiqingwu/p/linux_dynamic_lib_create.html" target="_blank" rel="noopener">博客园</a>  </p>
<hr>
<p>顺便: 第一次写了<code>makefile</code>, 用作上述的动态库管理  </p>
<blockquote>
<p>make build: 生成动态库, 可执行文件<br>make doit: 执行程序(如果文件并不存在, 先生成文件)<br>make clean: 清除生成的文件</p>
</blockquote>
<pre><code> 1 build: tlib.so a.out
 2 
 3 tlib.so: tlib.c
 4           gcc -fPIC -shared -o $@ $&lt;
 5 
 6 a.out: t1.c
 7           gcc $&lt; -L. tlib.so
 8 
 9 doit: build 
10           LD_LIBRARY_PATH=. ./a.out
11 
12 file = tlib.so a.out
13 clean: 
14           rm $(file)</code></pre><p>书写makedile和核心就是搞清楚依赖关系<br>其中<code>build</code>为创建动态库和可执行文件, 所以依赖于<code>tlib.so</code>和<code>a.out</code><br>而<code>tlib.so</code>依赖于<code>tlib.c</code>, <code>a.out</code>依赖于<code>t1.c</code><br>…</p>
<p>有一份<a href="https://www.kancloud.cn/kancloud/make-command/45593" target="_blank" rel="noopener">make教程</a></p>
<p>上述所用到的基础makefile规则并不难理解, 这里不做赘述  </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/10/leetcode/234PalindromeLinkedList/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cas">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cas's website">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/10/leetcode/234PalindromeLinkedList/" class="post-title-link" itemprop="url">leetcode/234PalindromeLinkedList</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-10 19:07:52 / Modified: 17:44:00" itemprop="dateCreated datePublished" datetime="2020-01-10T19:07:52+08:00">2020-01-10</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="234-Palindrome-Linked-List"><a href="#234-Palindrome-Linked-List" class="headerlink" title="234 Palindrome Linked List"></a>234 Palindrome Linked List</h2><p><img src="https://imgur.com/NFvwG9E.png" alt=""></p>
<p>判断链表是否是回文链表, 可以的话, O(n)时间复杂度, O(1)空间复杂度.</p>
<p>Determine whether the given single-linked list is a palindrome linked list.</p>
<p>Flow up: O(n) time and O(1) space.</p>
<h3 id="my-solution"><a href="#my-solution" class="headerlink" title="my solution"></a>my solution</h3><p>单链表, 时间O(n), 空间O(1), 同时满足有点难啊 = = … </p>
<p>It’s a little difficult to solve this question with both O(n) time and O(1) space.</p>
<p>我能相出的办法仅在知道链表长度/链表尾节点的情况下适用.</p>
<p>I can solve this if I know the length of the linked list</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">            ListNode* <span class="built_in">cursor</span> = head;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">cursor</span>) &#123;</span><br><span class="line">                ++n;</span><br><span class="line">                <span class="built_in">cursor</span> = <span class="built_in">cursor</span>-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            ListNode *prev = head;</span><br><span class="line">            LisTNode *next = prev-&gt;next;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">                ListNode *tmp = next-&gt;next;</span><br><span class="line">                next-&gt;next = prev;</span><br><span class="line"></span><br><span class="line">                prev = next;</span><br><span class="line">                next = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// // this methond redirect two nodes in one cycle</span></span><br><span class="line">            <span class="comment">// cursor = head;</span></span><br><span class="line">            <span class="comment">// ListNode *prev = nullptr;</span></span><br><span class="line">            <span class="comment">// LisTNode *next = cursor-&gt;next;</span></span><br><span class="line">            <span class="comment">// for (int i = 1; i &lt; n / 2; ++i) &#123;</span></span><br><span class="line">            <span class="comment">//     cursor-&gt;next = prev;</span></span><br><span class="line">            <span class="comment">//     ListNode *tmp = next-&gt;next;</span></span><br><span class="line">            <span class="comment">//     next-&gt;next = cursor;</span></span><br><span class="line">            <span class="comment">//     </span></span><br><span class="line">            <span class="comment">//     prev = next;</span></span><br><span class="line">            <span class="comment">//     cursor = tmp;</span></span><br><span class="line">            <span class="comment">//     next = cursor-&gt;next;</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (n &amp; <span class="number">1</span>)</span><br><span class="line">                next = next-&gt;next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (next-&gt;val != prev-&gt;val)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                next = next-&gt;next;</span><br><span class="line">                prev = prev-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>知道了节点长度的话, 不断反向节点, 直到到达中间节点, 然后从中间节点向两端对比就好了, 两次循环各遍历一半的节点. 所以还算 O(1), 空间只需要必须的用于遍历的节点, O(1)也满足. 但问题就是这是节点长度的情况下. 所以很好奇什么算法可以满足这两个需求. (其实看了之后感觉 = = , emmm… 没有很惊艳)</p>
<p>If know the length of the linked list, reverse nodes until the center of the linked list, then compare elements between the center node. </p>
<h3 id="best-solution"><a href="#best-solution" class="headerlink" title="best solution"></a>best solution</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow-&gt;next = reverseList(slow-&gt;next);</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (slow) &#123;</span><br><span class="line">            <span class="keyword">if</span> (head-&gt;val != slow-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* currentHead = head;</span><br><span class="line">        <span class="keyword">while</span> (head-&gt;next) &#123;</span><br><span class="line">            ListNode* p = head-&gt;next;</span><br><span class="line">            head-&gt;next = p-&gt;next;</span><br><span class="line">            p-&gt;next = currentHead;</span><br><span class="line">            currentHead = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> currentHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>办法几乎和我相同, 核心就是那个中间节点, 结果是用这种方法来解决的… 怎么没想到呢 = =, 学到了学到了… </p>
<p>还有就是, 我在奇偶长度上花了些心思, 所以从 1 开始循环, 并且对两种情况做了处理. </p>
<p>但是这种方法的话, 因为并不是由内向外, 所以奇偶不重要, 也不需要额外的代码来处理了. </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/09/other/gdb/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cas">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cas's website">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/09/other/gdb/" class="post-title-link" itemprop="url">other/gdb</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-09 17:44:16" itemprop="dateCreated datePublished" datetime="2020-01-09T17:44:16+08:00">2020-01-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h3><p>gdb是一个 c/c++ debug 工具</p>
<p>没有一个教程和文档比 gdb 官方手册更加详细和准确</p>
<p>这个文件只是简单地介绍其中一小部分频繁使用的功能, 具体需要结合 gdb<br>的官方文档使用</p>
<p>(gdb非常强大, 其文档有400多页, 完全是一本参考书的规格)</p>
<p>( 同时gdb也做到了透明, 大多数时候你使用它只需掌握极少的几条指令(基础功能中的指令) )</p>
<h3 id="基础功能"><a href="#基础功能" class="headerlink" title="基础功能"></a>基础功能</h3><h4 id="n-next"><a href="#n-next" class="headerlink" title="n : next"></a>n : next</h4><p>用于跳转到下一条语句, 同时会先执行当前语句, 可配合 number 跳转多行</p>
<h4 id="s-step"><a href="#s-step" class="headerlink" title="s : step"></a>s : step</h4><p>进入函数调用</p>
<h4 id="b-break"><a href="#b-break" class="headerlink" title="b : break"></a>b : break</h4><p>断点</p>
<h4 id="c-continue"><a href="#c-continue" class="headerlink" title="c : continue"></a>c : continue</h4><p>继续执行</p>
<h4 id="p-print"><a href="#p-print" class="headerlink" title="p : print"></a>p : print</h4><p>打印变量信息, ptype 可以打印类型信息(用于类, 它会将类的所有成员都打印出来)</p>
<h4 id="l-：list"><a href="#l-：list" class="headerlink" title="l ：list"></a>l ：list</h4><p>查看当前行附近的代码信息, 可以指定行号和函数, 可以用于跳转到指定文件</p>
<h4 id="bt-backtrace"><a href="#bt-backtrace" class="headerlink" title="bt : backtrace"></a>bt : backtrace</h4><p>调用回溯, 查看当前调用栈</p>
<h4 id="f-frame"><a href="#f-frame" class="headerlink" title="f : frame"></a>f : frame</h4><p>与 bt 的信息配合, 使用 number 指定跳转到某条函数调用之前</p>
<h4 id="info"><a href="#info" class="headerlink" title="info"></a>info</h4><p>这条指令用于观察gdb指令的当前信息  </p>
<p>例如: info breakpoints, info frame, info watchpoints, info record… </p>
<h4 id="u-until"><a href="#u-until" class="headerlink" title="u : until"></a>u : until</h4><p>跳出当前循环, 或者配合 number 指定执行到何处</p>
<h4 id="finish"><a href="#finish" class="headerlink" title="finish"></a>finish</h4><p>完成当前函数调用, 跳转到函数调用的最后一条语句</p>
<h3 id="中级功能"><a href="#中级功能" class="headerlink" title="中级功能"></a>中级功能</h3><h4 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h4><p>观察点, 可以用来观察一个变量或者表达式的变化</p>
<h4 id="checkpoint"><a href="#checkpoint" class="headerlink" title="checkpoint"></a>checkpoint</h4><p>检查点用来保存当前进度, 可以在执行若干语句之后回到当前检查点</p>
<h4 id="record"><a href="#record" class="headerlink" title="record"></a>record</h4><p>记录命令的使用信息, 实用之处在于: 使用其中的 full 模式, 可以实现 reverse 操作</p>
<p>比如 reverse-next, 这将会反向执行到上一个语句</p>
<h4 id="forward-search-search"><a href="#forward-search-search" class="headerlink" title="forward-search/search"></a>forward-search/search</h4><p>前向搜索/搜索</p>
<h4 id="inferior"><a href="#inferior" class="headerlink" title="inferior"></a>inferior</h4><p>gdb支持debug多个进程</p>
<h4 id="thread"><a href="#thread" class="headerlink" title="thread"></a>thread</h4><p>gdb支持debug多线程程序</p>
<h4 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h4><p>捕获一个事件</p>
<h4 id="singal"><a href="#singal" class="headerlink" title="singal"></a>singal</h4><p>捕获一个信号</p>
<h4 id="win-winheight"><a href="#win-winheight" class="headerlink" title="win  : winheight"></a>win  : winheight</h4><p>进入可视化模式, 简单来说就是代码界面拥有了窗口, 同时一系列信息也会显示在上面</p>
<p>(不过这个模式实际上会出现会显示错误, 比如会显示删除符号, 显示tab键之类的问题, 我不知道这算不算bug…)</p>
<p>(或许我使用方式不对? )</p>
<h4 id="e-edit"><a href="#e-edit" class="headerlink" title="e : edit"></a>e : edit</h4><p>你可以在 gdb 中直接更改源文件, 不过这好像有点鸡肋…</p>
<h4 id="disassemble"><a href="#disassemble" class="headerlink" title="disassemble"></a>disassemble</h4><p>反编译代码, 显示 machine code</p>
<h4 id="diaplay"><a href="#diaplay" class="headerlink" title="diaplay"></a>diaplay</h4><p>自动显示变量</p>
<h4 id="set-convenience-variable"><a href="#set-convenience-variable" class="headerlink" title="set (convenience variable)"></a>set (convenience variable)</h4><p>使用该指令可以保存变量, 之后你可以用在任何命令的表达式里面, 记得前面加美元($)前缀</p>
<pre><code>(gdb) set {int}0x604010 = 4
(gdb) p v[0]
$16 = (__gnu_cxx::__alloc_traits&lt;std::allocator&lt;int&gt; &gt;::value_type &amp;) @0x604010: 4
(gdb) set {int}0x604010 = 5
(gdb) p v[0]
$17 = (__gnu_cxx::__alloc_traits&lt;std::allocator&lt;int&gt; &gt;::value_type &amp;) @0x604010: 5</code></pre><p>它可以用于对内存赋值!!!</p>
<pre><code>(gdb) p $rbx
$18 = 1
(gdb) set $rbx = 200
(gdb) p $rbx
$19 = 200</code></pre><p>也可以用于对寄存器赋值!!!</p>
<h4 id="convenience-function-10-12"><a href="#convenience-function-10-12" class="headerlink" title="convenience function (10.12)"></a>convenience function (10.12)</h4><p>gdb提供了一系列的函数以供使用, 例如:</p>
<pre><code>$_strlen(str)     $_streq(str1, str2)      $_regex(str, regex) </code></pre><p>前面依旧要加 ‘$’ 符号</p>
<h4 id="register-这个我超喜欢的-10-13"><a href="#register-这个我超喜欢的-10-13" class="headerlink" title="register (这个我超喜欢的) (10.13)"></a>register (这个我超喜欢的) (10.13)</h4><p>这个指令支持你查看寄存器的内容, 使用方法是</p>
<pre><code>p $register</code></pre><p>(这个或许应该放在 p 中, 不过我觉得这应该放在高级内容中)</p>
<p>我依稀记得之前我曾经因为无法在运行时看内存内容而苦恼  </p>
<p>现在这个问题随着gdb的深入学习而解决了, 以后我分析汇编的时候, 可以更加深入了</p>
<p>并且支持使用 set 来改变内容!!</p>
<h4 id="info-os-args"><a href="#info-os-args" class="headerlink" title="info os [args]"></a>info os [args]</h4><p>查看系统相关信息, 比如:</p>
<pre><code>info os files</code></pre><p>将会查看系统使用文件描述符的信息</p>
<h4 id="trace-13"><a href="#trace-13" class="headerlink" title="trace (13)"></a>trace (13)</h4><p>按照 gdb 官方文档的描述, 这个指令是用来调试那些对于实时性有要求的程序  </p>
<p>但是我也没能理解这个指令是如何使用的, 同时有这么一句话</p>
<pre><code>The tracepoint facility is currently available only for remote targets
追溯点当前只对远程目标有效</code></pre><p>这个指令的内容占了整个 13 章节, 应该相当重要. 所以这里仅仅记录一下, 或许以后会用到</p>
<pre><code>14 Debugging Programs That Use Overlays</code></pre><p>=========</p>
<p>后续内容(从 13 章往后)是一些高级内容(以置于我不得不将这段主题的标题改成中级功能…)</p>
<p>比如大型程序, 远程调试 … </p>
<p>暂不研究</p>
<h3 id="other"><a href="#other" class="headerlink" title="other"></a>other</h3><p>源自<a href="http://www.waider.ie/music/lyrics/gdb.html" target="_blank" rel="noopener">http://www.waider.ie/music/lyrics/gdb.html</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">GDB!</span><br><span class="line">based on _Tragedy_ by Barry, Robin <span class="keyword">and</span> Maurice Gibb</span><br><span class="line"></span><br><span class="line">Here<span class="number">'</span>s vi</span><br><span class="line">In a lost <span class="keyword">and</span> lonely part of code</span><br><span class="line">Held in time</span><br><span class="line">In a world of bugs my head explodes</span><br><span class="line">Goin<span class="number">'</span> <span class="built_in">home</span></span><br><span class="line">I just can<span class="number">'</span>t make it all alone</span><br><span class="line">I really should be coding you, coding you</span><br><span class="line"><span class="built_in">running</span> you, <span class="built_in">running</span> you</span><br><span class="line"></span><br><span class="line">CHORUS:</span><br><span class="line">GDB when the program<span class="number">'</span>s wrong <span class="keyword">and</span> the debug<span class="number">'</span>s on</span><br><span class="line">It<span class="number">'</span>s GDB when the system dies <span class="keyword">and</span> you don<span class="number">'</span>t know why</span><br><span class="line">It<span class="number">'</span>s hard to bear</span><br><span class="line">With no one to help you</span><br><span class="line">You're going nowhere</span><br><span class="line">GDB when you <span class="built_in">press</span> control <span class="keyword">and</span> the box just rolls</span><br><span class="line">It<span class="number">'</span>s GDB when the system dies <span class="keyword">and</span> you don<span class="number">'</span>t know why</span><br><span class="line">It<span class="number">'</span>s hard to bear</span><br><span class="line">With no one beside you</span><br><span class="line">You're going nowhere</span><br><span class="line"></span><br><span class="line">Night <span class="keyword">and</span> Day</span><br><span class="line">There<span class="number">'</span>s a burning down inside of me</span><br><span class="line">Burning code</span><br><span class="line">And a kernel that won<span class="number">'</span>t let me be</span><br><span class="line">Down it goes</span><br><span class="line"><span class="keyword">and</span> I just can<span class="number">'</span>t take it all alone</span><br><span class="line">I really should be coding you, coding you</span><br><span class="line">Running you, <span class="built_in">running</span> you</span><br><span class="line"></span><br><span class="line">REPEAT CHORUS</span><br><span class="line"></span><br><span class="line"><span class="function">REPEAT <span class="title">CHORUS</span><span class="params">(fade)</span></span></span><br></pre></td></tr></table></figure>
<p>源自<a href="https://www.gnu.org/music/gdb-song.html" target="_blank" rel="noopener">https://www.gnu.org/music/gdb-song.html</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Let<span class="number">'</span>s start at the very beginning, a very good place to start,</span><br><span class="line">When you're learning to sing, its Do, Re, Mi; </span><br><span class="line">When you're learning to code, its G, D, B. </span><br><span class="line">(<span class="built_in">background</span>) G, D, B.</span><br><span class="line"></span><br><span class="line">The first three letters just happen to be, G, D, B.</span><br><span class="line"></span><br><span class="line">(<span class="built_in">background</span>) G, D, B.</span><br><span class="line"></span><br><span class="line">(Chorus)</span><br><span class="line"></span><br><span class="line">G!,</span><br><span class="line">GNU!, it<span class="number">'</span>s Stallman<span class="number">'</span>s hope,</span><br><span class="line">D,</span><br><span class="line">a <span class="keyword">break</span> I <span class="built_in">set</span> myself.</span><br><span class="line">B,</span><br><span class="line">debug that rotten code,</span><br><span class="line">Run,</span><br><span class="line">a far, far way to go.</span><br><span class="line">Print,</span><br><span class="line">to see what you have done,</span><br><span class="line">Set,</span><br><span class="line">a patch that follows <span class="built_in">print</span>.</span><br><span class="line">Quit,</span><br><span class="line"><span class="keyword">and</span> recompile your code - - -</span><br><span class="line">That will bring it back to G,</span><br><span class="line">                              D,</span><br><span class="line">                                 B,</span><br><span class="line">                                    &lt;link&gt;</span><br><span class="line">(Resume from the Chorus)</span><br></pre></td></tr></table></figure>
<p>感觉, 嗯, 很有气势</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/09/leetcode/48RotateImage/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cas">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cas's website">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/09/leetcode/48RotateImage/" class="post-title-link" itemprop="url">leetcode/48RotateImage</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-09 17:20:51 / Modified: 17:07:59" itemprop="dateCreated datePublished" datetime="2020-01-09T17:20:51+08:00">2020-01-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Rotate-Image"><a href="#Rotate-Image" class="headerlink" title="Rotate Image"></a>Rotate Image</h1><p><img src="https://i.imgur.com/7hLPAwu.png" alt="">  </p>
<blockquote>
<p>顺时针90度旋转矩阵<br>要求就地更改(不能创建另外一个矩阵)</p>
</blockquote>
<h2 id="我的做法"><a href="#我的做法" class="headerlink" title="我的做法"></a>我的做法</h2><p>思路:  </p>
<blockquote>
<p>使用下标来获取元素更方便<br>从外层到内层, 一层层旋转, 每次旋转n个, 每层旋转4次<br>不可避免需要保存一组数值  </p>
</blockquote>
<p>具体代码:  </p>
<pre><code>class Solution {
public:
    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
        int n = matrix.size();

        for (int i = 0; i &lt; n / 2; ++i){
            // backup first stream
            vector&lt;int&gt; backup ((matrix.begin() + i)-&gt;begin() + i + 1, 
                (matrix.begin() + i)-&gt;end() - i);

                for (int col = i + 1, row = n - i - 2; col &lt; n - i; ++col, --row)
                    matrix[i][col] = matrix[row][i];

                for (int row = i, col = i; row &lt; n - i - 1; ++row, ++col)
                    matrix[row][i] = matrix[n - 1 - i][col];

                for (int col = i, row = n - i - 1; col &lt; n - i - 1; ++col, --row)
                    matrix[n - 1 - i][col] = matrix[row][n - i - 1];

                for (int row = n - 1 - i, t = backup.size() - 1; t &gt;= 0; --row, --t)
                    matrix[row][n - i - 1] = backup[t];
        }
    }
};</code></pre><p>最后结果:  </p>
<p><img src="https://i.imgur.com/IgjHagZ.png" alt="">  </p>
<h2 id="dalao的做法"><a href="#dalao的做法" class="headerlink" title="dalao的做法"></a>dalao的做法</h2><pre><code>class Solution {
public:
    void swapLR(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
        int n = matrix.size();
        for (int i = 0; i &lt; n; i++) {
            int l = 0;
            int r = n-1;
            while(l&lt;r) {
                int temp = matrix[i][l];
                matrix[i][l++] = matrix[i][r];
                matrix[i][r--] = temp;
            }
        }
    }

    void swapdig(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
        int n = matrix.size();
        for (int i = 0; i &lt; n-1; i++) {
            for (int j = 0; j &lt; n-1-i; j++) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[n-1-j][n-1-i];
                matrix[n-1-j][n-1-i] = temp;
            }
        }
    }

    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
        swapLR(matrix);
        swapdig(matrix);
    }
};</code></pre><p>首先分析 swapLR 函数:  </p>
<blockquote>
<p>emmmm, 它好像将左右的数据对换了<br><img src="https://i.imgur.com/6uc80iU.png" alt=""><br>emmm, 还是看不懂有什么规律, </p>
</blockquote>
<p><img src="https://i.imgur.com/fjWYKBX.png" alt="">  </p>
<p>6啊…, 更改后的行就是最终结果的列, 只要遍历倒叙一遍就可以了<br>这种思路是如何得出的? 需要哪方面的知识么?<br>思路这种东西好难弥补, 我自认为不出意外的话, 是无法想到这一点的</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/09/leetcode/42TrappingRainWater/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cas">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cas's website">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/09/leetcode/42TrappingRainWater/" class="post-title-link" itemprop="url">leetcode/42TrappingRainWater</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-09 17:20:38 / Modified: 17:07:59" itemprop="dateCreated datePublished" datetime="2020-01-09T17:20:38+08:00">2020-01-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Trapping-Rain-Water"><a href="#Trapping-Rain-Water" class="headerlink" title="Trapping Rain Water"></a>Trapping Rain Water</h2><p><a href="https://leetcode.com/problems/trapping-rain-water/description/" target="_blank" rel="noopener">原地址</a></p>
<p><img src="https://i.imgur.com/o9Cwc3k.png" alt=""></p>
<p>大致描述: 给出一个数组, 按如上所述, 求出蓝色方块的数量<br>(就像一个山脉一样, 看这样的山脉降雨后能留下多少水)</p>
<h3 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路:"></a>我的思路:</h3><p>排错:  </p>
<ol>
<li>必须有3个以上的山脉才有可能有积水, 所以数组长度必定大于3  </li>
<li>左右为平地的数组下标截断, 直到有山脉为止</li>
</ol>
<p>做法:  </p>
<ol>
<li>从左到右依次拿到符合条件的格子下标(比如第一次是(1, 3) )  </li>
<li>计算改区域的雨水  </li>
<li>重复第一步, 直到结束</li>
</ol>
<p>// 具体代码在42_.txt中  </p>
<h3 id="dalao的思路"><a href="#dalao的思路" class="headerlink" title="dalao的思路"></a>dalao的思路</h3><p>// 具体代码在42_2.txt中</p>
<p><img src="https://i.imgur.com/ZIGTZ9P.png" alt=""></p>
<p><img src="https://i.imgur.com/psX9onj.png" alt="">  </p>
<p>分析:<br>一个格子中能不能存水取决于左右格子的高度<br>算法从左到右一次, 从有到左一次.<br>每次假设该格子以左/右单方面最大能放多少水<br>将同一格的两次数据求最小, 这就是该下标实际能存多少水<br>最后减去本身的实体格子, 也就得到了空下的格子  </p>
<p>算法复杂度为O(n)</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">cas</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">80</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">cas</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
