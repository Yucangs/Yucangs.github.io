<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Muse',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="cas&#39;s website">
<meta property="og:url" content="http://yoursite.com/page/7/index.html">
<meta property="og:site_name" content="cas&#39;s website">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="cas">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/7/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>cas's website</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">cas's website</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">casyup.me@outlook.com</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="Searching..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/09/other/aQuestionAboutStaticKeyword/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cas">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cas's website">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/09/other/aQuestionAboutStaticKeyword/" class="post-title-link" itemprop="url">other/aQuestionAboutStaticKeyword</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-09 17:14:50" itemprop="dateCreated datePublished" datetime="2020-01-09T17:14:50+08:00">2020-01-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="一个关于-static-的问题"><a href="#一个关于-static-的问题" class="headerlink" title="一个关于 static 的问题"></a>一个关于 static 的问题</h3><p>2019年4月22日19:42:18  </p>
<p>日常的一天, 做做 leetcode, 但是突然发现了关于 leetcode 代码优化的问题 </p>
<p><img src="https://imgur.com/cH0JYBG.png" alt=""></p>
<p>题目大概是要你中序遍历树</p>
<p>(看到题目的时候愣了一下, 怀疑自己是不是眼花了, 直到看到了 Follow up…  emmm, 好吧, 迭代)</p>
<p>总之我先用递归试了一下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left)</span><br><span class="line">            inorderTraversal(root-&gt;left);</span><br><span class="line"></span><br><span class="line">        ret.push_back(root-&gt;val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right)</span><br><span class="line">            inorderTraversal(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://imgur.com/NMNndgq.png" alt=""></p>
<p>但是它总是给我报这个错</p>
<p>这是没有理由的! 我代码中不可能无中生有</p>
<p>我怀疑这是 leetcode 平台对于用户所做的一种优化  </p>
<p>而这种优化与我使用 static 关键字相冲突</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/09/other/O(n)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cas">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cas's website">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/09/other/O(n)/" class="post-title-link" itemprop="url">other/O(n)</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-09 17:14:16 / Modified: 17:13:31" itemprop="dateCreated datePublished" datetime="2020-01-09T17:14:16+08:00">2020-01-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度用于描述算法的效率, 是衡量算法优劣的重要指标  </p>
<h3 id="O-1"><a href="#O-1" class="headerlink" title="O(1)"></a>O(1)</h3><pre><code>void func(int n){
    std::cout &lt;&lt; n &lt;&lt; std::cout;
}</code></pre><p>将自变量视作n, n在此情景下为传入的参数<br>将因变量视作t, t在此情景下为函数执行的指令次数(这个就是时间复杂度)<br>上述算法中, 无论n是多少, t都为1, 则此算法复杂度记做: O(1)</p>
<p>O(1)复杂度的算法效率不因外界因素而改变  </p>
<p>PS: 也称作常量级复杂度, 是最理想的复杂度  </p>
<h3 id="O-2n"><a href="#O-2n" class="headerlink" title="O(2n)"></a>O(2n)</h3><p>略</p>
<p>PS: 其中O(2n)就是呈2倍复杂度增加, 而O(nn)则意为n倍增加  </p>
<h3 id="O-n"><a href="#O-n" class="headerlink" title="O(n)"></a>O(n)</h3><pre><code>void func(int n){
    for(int i = 0; i &lt; n; ++i){
        std::cout &lt;&lt; i &lt;&lt; std::endl;
    }
}</code></pre><p>上述算法中 t = n + 1(其中的1为最后一次的失败), 算法复杂度为O(n)</p>
<p>O(n)复杂度的算法效率会因外界因素而改变, 其规律为: 复杂度呈1:1形式增加    </p>
<p>PS: O(n)是比较常见的复杂度, 效率一般  </p>
<h3 id="O-n-2-O-n-n"><a href="#O-n-2-O-n-n" class="headerlink" title="O(n^2)/O(n^n)"></a>O(n^2)/O(n^n)</h3><pre><code>void func(int n){
    for(int i = 0; i &lt; n; ++i){
        for(int j = 0; j &lt; n; ++i){
            std::cout &lt;&lt; i &lt;&lt; std::endl;
        }
    }
}</code></pre><p>上述算法中 t = n * n + 1, 记做: O(n^2)  </p>
<p>O(n^2)复杂度的算法效率会随外界的影响平方倍变化<br>同理, 则O(n^n)复杂度的算法效率会随外界的影响呈n次方倍增加 </p>
<p>PS: 出现这种复杂度的代码, 则需要考虑优化</p>
<h3 id="O-log-n"><a href="#O-log-n" class="headerlink" title="O(log n)"></a>O(log n)</h3><p>要想明白O(log n)时间复杂度, 则先得复习<a href="https://zh.wikipedia.org/wiki/%E5%AF%B9%E6%95%B0" target="_blank" rel="noopener">对数</a><br>(如果你还没把数学还给数学老师的话, 就不必了)</p>
<p>这东西我也不大说得清楚, 就直接粘贴网上的案例了:</p>
<p><img src="https://i.imgur.com/JGXST7I.png" alt=""></p>
<p>PS: O(log n)的复杂度计算好像不太容易, 一般人还不一定计算得出来… </p>
<p>RET: 总的来说时间复杂度就是一个随着计算数据增加, 算法效率呈何种形式增加的一种规律<br>了解一下时间复杂度是很有必要的<br>以后别人问你 你的算法效率如何的时候. 就可以回答: 我的算法时间复杂度是O(1)!  </p>
<p>以上经验参照自<a href="https://www.jianshu.com/p/f4cca5ce055a" target="_blank" rel="noopener">简书</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/09/other/crontab/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cas">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cas's website">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/09/other/crontab/" class="post-title-link" itemprop="url">other/crontab</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-09 17:14:16 / Modified: 17:13:54" itemprop="dateCreated datePublished" datetime="2020-01-09T17:14:16+08:00">2020-01-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="需求描述"><a href="#需求描述" class="headerlink" title="需求描述"></a>需求描述</h3><p>设计一个定时关机的工具  </p>
<p>该工具使用lua语言, 通过PLINK链接服务器  </p>
<p>接收用户输入, 使用crontab/at设置定时器</p>
<h3 id="详细代码"><a href="#详细代码" class="headerlink" title="详细代码"></a>详细代码</h3><h4 id="timer-table"><a href="#timer-table" class="headerlink" title="timer table"></a>timer table</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">package</span>.<span class="built_in">path</span> = <span class="built_in">package</span>.<span class="built_in">path</span> .. <span class="string">";../../script/?.lua"</span></span><br><span class="line"><span class="comment">-- inc是工具类</span></span><br><span class="line"><span class="keyword">local</span> inc = <span class="built_in">require</span>(<span class="string">"inc"</span>)</span><br><span class="line"><span class="comment">-- config记录了服务器的配置信息</span></span><br><span class="line"><span class="keyword">local</span> <span class="built_in">config</span> = <span class="built_in">require</span>(<span class="string">"config"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- timer用于处理整个定时任务</span></span><br><span class="line"><span class="keyword">local</span> timer = &#123;&#125;</span><br><span class="line">timer.file = <span class="string">"crontabtask.sh"</span>			<span class="comment">-- 文件名, 因为使用 crontab [file]形式添加任务</span></span><br><span class="line">timer.<span class="built_in">path</span> = <span class="string">"/tmp/"</span>					<span class="comment">-- 文件位于服务器那个路径下</span></span><br><span class="line">timer.fullName = timer.<span class="built_in">path</span>..timer.file	<span class="comment">-- 路径+文件名, 当前为: /tmp/crontabtask.sh</span></span><br><span class="line">timer.filenamemask = <span class="string">"CRONTAB_TASK_"</span>	<span class="comment">-- 掩码, 用于区分任务</span></span><br><span class="line">timer.servername = <span class="literal">nil</span>					<span class="comment">-- 服务器名称, 这里仅仅占位, 会在之后设置</span></span><br></pre></td></tr></table></figure>

<p>timer是任务处理表(类), 因为bash下, 没有办法直接使用vim编辑(或者说我不知道有什么办法能这么做)  </p>
<p>所以 crontab -e 的方式被舍弃了, 使用 crontab [filename] 的形式来添加任务 </p>
<p>(这样的好处是统一使用某一文件作为任务文件,  后续可以使用某种手段(比如修改配置), 来重新定义crontab -e)</p>
<p>(坏处就是动到了系统的东西, 这并不一定是好事)</p>
<h4 id="lobby"><a href="#lobby" class="headerlink" title="lobby"></a>lobby</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 大厅</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timer.lobby</span><span class="params">()</span></span></span><br><span class="line">    inc.p(<span class="string">"请输入要操作的服务器ID"</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">local</span> serverID = <span class="built_in">tonumber</span>(<span class="built_in">io</span>.<span class="built_in">stdin</span>:<span class="built_in">read</span>())</span><br><span class="line">    <span class="keyword">local</span> scfg, servercfg = inc.getserverinfo(serverID)</span><br><span class="line"></span><br><span class="line">    inc.confirm_oper_server(scfg, &#123;servercfg&#125;, <span class="string">"即将操作该服务器"</span>)</span><br><span class="line">    <span class="comment">-- 检查文件是否存在</span></span><br><span class="line">    timer.checkFileExists(scfg, servercfg)</span><br><span class="line">    <span class="keyword">local</span> sFolder = <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">"%s%d.p%d"</span>, </span><br><span class="line">        <span class="built_in">config</span>.gamename, servercfg.id, servercfg.port)</span><br><span class="line">    timer.servername = sFolder</span><br><span class="line">    <span class="comment">-- 根据用户的选项, 我们重新设置了文件掩码, 加上了当前服务器名</span></span><br><span class="line">    <span class="comment">-- 这样更加安全, 也可以筛选统一主机下, 不同服务器任务了</span></span><br><span class="line">    timer.filenamemask = timer.filenamemask..timer.servername</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">        inc.p(<span class="string">"\n选择操作类型[1: 增加, 2: 删除, 4:查询]"</span>, <span class="number">10</span>)</span><br><span class="line">        <span class="keyword">local</span> operatetype = <span class="built_in">io</span>.<span class="built_in">stdin</span>:<span class="built_in">read</span>()</span><br><span class="line">        <span class="keyword">if</span> operatetype == <span class="string">'1'</span> <span class="keyword">then</span></span><br><span class="line">            <span class="comment">-- 增加定时器</span></span><br><span class="line">            timer.addTimerTask(scfg, servercfg)</span><br><span class="line">            <span class="comment">-- 判断是否增加成功</span></span><br><span class="line">            timer.isAddSuccess(scfg, servercfg)</span><br><span class="line">            <span class="comment">-- 自动刷新定时器列表</span></span><br><span class="line">            timer.searchTimerTask(scfg, servercfg)</span><br><span class="line">        <span class="keyword">elseif</span> operatetype == <span class="string">'2'</span> <span class="keyword">then</span></span><br><span class="line">            <span class="comment">-- 删除定时器</span></span><br><span class="line">            timer.deleteTimerTask(scfg, servercfg)</span><br><span class="line">            <span class="comment">-- 自动刷新定时器列表</span></span><br><span class="line">            timer.searchTimerTask(scfg, servercfg)</span><br><span class="line">        <span class="keyword">elseif</span> operatetype == <span class="string">'3'</span> <span class="keyword">then</span></span><br><span class="line">            <span class="comment">-- 预留</span></span><br><span class="line">        <span class="keyword">elseif</span> operatetype == <span class="string">'4'</span> <span class="keyword">then</span></span><br><span class="line">            <span class="comment">-- 刷新定时器列表</span></span><br><span class="line">            timer.searchTimerTask(scfg, servercfg)</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            inc.p(<span class="string">"操作码异常"</span>, <span class="number">14</span>)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>大厅界面, 先让用户选择一个操作的服务器, 设置相应的参数, 然后让用户一直操作该服务器</p>
<h4 id="checkFileExists"><a href="#checkFileExists" class="headerlink" title="checkFileExists"></a>checkFileExists</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 检查文件是否存在</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timer.checkFileExists</span><span class="params">(scfg, servercfg)</span></span></span><br><span class="line">    <span class="comment">-- 看一下目录下是否存配置文件</span></span><br><span class="line">    <span class="keyword">local</span> cmds = &#123;&#125;</span><br><span class="line">    <span class="built_in">table</span>.<span class="built_in">insert</span>(cmds, <span class="string">"cd "</span>..timer.<span class="built_in">path</span>)</span><br><span class="line">    <span class="built_in">table</span>.<span class="built_in">insert</span>(cmds, <span class="string">"ls crontab*"</span>);</span><br><span class="line">    <span class="keyword">local</span> filename;</span><br><span class="line">    inc.popen_server_cmds(scfg, cmds, <span class="function"><span class="keyword">function</span> <span class="params">(res)</span></span></span><br><span class="line">        <span class="comment">-- 因为某些原因, 不用在意这行代码. 它的作用是获取文件名</span></span><br><span class="line">        filename = res[<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">end</span>, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">string</span>.<span class="built_in">find</span>(filename, <span class="string">"crontab"</span>) == <span class="literal">nil</span>) <span class="keyword">then</span></span><br><span class="line">        <span class="comment">-- 没找到配置文件, 就新建一个</span></span><br><span class="line">        inc.p(<span class="string">"未找到文件, 即将创建空文件: "</span>, <span class="number">10</span>)</span><br><span class="line">        <span class="keyword">local</span> cmds = &#123;&#125;</span><br><span class="line">        <span class="built_in">table</span>.<span class="built_in">insert</span>(cmds, <span class="string">"touch "</span>..timer.fullName)</span><br><span class="line">        inc.popen_server_cmds(scfg, cmds, <span class="literal">nil</span>, <span class="literal">true</span>)</span><br><span class="line">        inc.p(<span class="string">"创建成功: "</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="comment">-- 如果配置文件已经存在了, 那么就直接使用当前文件</span></span><br><span class="line">        inc.p(<span class="string">"已找到文件: "</span>..filename, <span class="number">10</span>)</span><br><span class="line">        timer.file = filename</span><br><span class="line">        timer.fullName = timer.<span class="built_in">path</span>..timer.file</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>检查配置文件是否已存在, 存在则世界使用它, 不存在, 则创建一个</p>
<h4 id="addTimerTask"><a href="#addTimerTask" class="headerlink" title="addTimerTask"></a>addTimerTask</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 增加定时器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timer.addTimerTask</span><span class="params">(scfg, servercfg)</span></span></span><br><span class="line">    <span class="comment">-- 设置时间</span></span><br><span class="line">    <span class="keyword">local</span> timetab = &#123;&#125;</span><br><span class="line">    inc.p(<span class="string">"请输入任务名"</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">local</span> taskname = <span class="built_in">io</span>.<span class="built_in">stdin</span>:<span class="built_in">read</span>()</span><br><span class="line">    <span class="keyword">local</span> ttaskname = taskname..timer.filenamemask</span><br><span class="line">    <span class="comment">-- 检测任务名是否存在, 任务名用于删, 查任务</span></span><br><span class="line">    <span class="keyword">while</span> (timer.checkTaskName(scfg, servercfg, ttaskname) == <span class="literal">true</span>) <span class="keyword">do</span></span><br><span class="line">        inc.p(<span class="string">"任务重名, 请重新输入"</span>, <span class="number">14</span>)</span><br><span class="line">        taskname = <span class="built_in">io</span>.<span class="built_in">stdin</span>:<span class="built_in">read</span>()</span><br><span class="line">        ttaskname = taskname..timer.filenamemask</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 设置定时器触发时间</span></span><br><span class="line">    inc.p(<span class="string">"请输入服务器关闭时间(月)"</span>, <span class="number">10</span>)</span><br><span class="line">    timetab.month = <span class="built_in">io</span>.<span class="built_in">stdin</span>:<span class="built_in">read</span>()</span><br><span class="line">    inc.p(<span class="string">"请输入服务器关闭时间(日)"</span>, <span class="number">10</span>)</span><br><span class="line">    timetab.day = <span class="built_in">io</span>.<span class="built_in">stdin</span>:<span class="built_in">read</span>()</span><br><span class="line">    inc.p(<span class="string">"请输入服务器关闭时间(时)"</span>, <span class="number">10</span>)</span><br><span class="line">    timetab.hour = <span class="built_in">io</span>.<span class="built_in">stdin</span>:<span class="built_in">read</span>()</span><br><span class="line">    inc.p(<span class="string">"请输入服务器关闭时间(分)"</span>, <span class="number">10</span>)</span><br><span class="line">    timetab.minute = <span class="built_in">io</span>.<span class="built_in">stdin</span>:<span class="built_in">read</span>()</span><br><span class="line">    inc.p(<span class="string">"服务器将计划于 "</span>..timetab.month..<span class="string">"月"</span>..timetab.day..<span class="string">"日"</span>..</span><br><span class="line">        timetab.hour..<span class="string">"时"</span>..timetab.minute..<span class="string">"分 关闭, 确定? [输入y继续]"</span>, <span class="number">12</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">io</span>.<span class="built_in">stdin</span>:<span class="built_in">read</span>() ~= <span class="string">'y'</span> <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 这里构造了一条命令, 这条命令实现了添加一个定时器</span></span><br><span class="line">    <span class="comment">-- 这个定时器会到指定的服务器下, 调用 kill.net 来关闭服务器</span></span><br><span class="line">    <span class="comment">-- 关闭之后, 再使用 sed 命令, 将定时器删除, 然后重置定时器</span></span><br><span class="line">    <span class="keyword">local</span> cmds = &#123;&#125;;</span><br><span class="line">    <span class="keyword">local</span> dir = timer.getFullPath(servercfg)</span><br><span class="line">    <span class="keyword">local</span> timestamp = timetab.minute..<span class="string">' '</span>..timetab.hour..<span class="string">' '</span>..timetab.day..<span class="string">' '</span>..</span><br><span class="line">        timetab.month..<span class="string">' '</span>..<span class="string">'*'</span></span><br><span class="line">    <span class="built_in">table</span>.<span class="built_in">insert</span>(cmds, <span class="string">"echo \""</span>..timestamp..<span class="string">" echo \""</span>..ttaskname..<span class="string">"\""</span></span><br><span class="line">        ..<span class="string">';cd '</span>..dir..<span class="string">';./kill.net'</span>..</span><br><span class="line">        <span class="string">";sed -i \"/"</span>..ttaskname..<span class="string">"/d\" "</span>..timer.fullName..</span><br><span class="line">        <span class="string">";crontab "</span>..timer.fullName..<span class="string">"\" &gt;&gt; "</span>..timer.fullName)</span><br><span class="line">    <span class="built_in">print</span> (cmds[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">-- 这是一个外部工具类中的函数, 主要是使用PLINK携带用户信息和验证, 链接服务器</span></span><br><span class="line">    <span class="comment">-- 然后执行 cmds 中保存的命令</span></span><br><span class="line">    inc.popen_server_cmds(scfg, cmds, <span class="literal">nil</span>, <span class="literal">true</span>)</span><br><span class="line">    <span class="comment">-- 保存当前任务名, 用于判断任务是否成功</span></span><br><span class="line">    timer.lastTask = ttaskname;</span><br><span class="line">    timer.syncTask(scfg, servercfg)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h4 id="checkTaskName"><a href="#checkTaskName" class="headerlink" title="checkTaskName"></a>checkTaskName</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 检查文件名</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timer.checkTaskName</span><span class="params">(scfg, servercfg, ttaskname)</span></span></span><br><span class="line">    <span class="keyword">local</span> cmds = &#123;&#125;</span><br><span class="line">    <span class="built_in">table</span>.<span class="built_in">insert</span>(cmds, <span class="string">"crontab -l"</span>)</span><br><span class="line">    <span class="keyword">local</span> dupname = <span class="literal">false</span></span><br><span class="line">    <span class="comment">-- 第三个参数是回调函数, res中存储了执行 cmds 后, 服务器的输出</span></span><br><span class="line">    <span class="comment">-- 使用 crontab -l 查看了当前已有的任务, 如果找到了任务名, 则说明任务名重复</span></span><br><span class="line">    inc.popen_server_cmds(scfg, cmds, <span class="function"><span class="keyword">function</span> <span class="params">(res)</span></span></span><br><span class="line">        <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">pairs</span>(res) <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">string</span>.<span class="built_in">find</span>(v, ttaskname)) <span class="keyword">then</span></span><br><span class="line">                dupname = <span class="literal">true</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span>, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dupname</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h4 id="syncTask"><a href="#syncTask" class="headerlink" title="syncTask"></a>syncTask</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 同步任务</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timer.syncTask</span><span class="params">(scfg, servercfg)</span></span></span><br><span class="line">    <span class="keyword">local</span> cmds = &#123;&#125;</span><br><span class="line">    <span class="built_in">table</span>.<span class="built_in">insert</span>(cmds, <span class="string">"cd "</span>..timer.<span class="built_in">path</span>)</span><br><span class="line">    <span class="built_in">table</span>.<span class="built_in">insert</span>(cmds, <span class="string">"crontab "</span>..<span class="string">'./'</span>..timer.file);</span><br><span class="line">    <span class="comment">-- 其实就是执行 crontab [filename], 这里可以合为一句的</span></span><br><span class="line">    inc.popen_server_cmds(scfg, cmds, <span class="literal">nil</span>, <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h4 id="isAddSuccess"><a href="#isAddSuccess" class="headerlink" title="isAddSuccess"></a>isAddSuccess</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 是否增加成功</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timer.isAddSuccess</span><span class="params">(scfg, servercfg)</span></span></span><br><span class="line">    <span class="keyword">local</span> cmds = &#123;&#125;</span><br><span class="line">    <span class="built_in">table</span>.<span class="built_in">insert</span>(cmds, <span class="string">"cat "</span>..timer.fullName);</span><br><span class="line">    <span class="keyword">local</span> size1 = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">-- 获取文件中的行数</span></span><br><span class="line">    inc.popen_server_cmds(scfg, cmds, <span class="function"><span class="keyword">function</span> <span class="params">(res)</span></span></span><br><span class="line">        size1 = #res</span><br><span class="line">    <span class="keyword">end</span>, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> cmds = &#123;&#125;</span><br><span class="line">    <span class="built_in">table</span>.<span class="built_in">insert</span>(cmds, <span class="string">"crontab -l"</span>);</span><br><span class="line">    <span class="keyword">local</span> size2 = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">-- 获取实际 crontab 任务的行数</span></span><br><span class="line">    inc.popen_server_cmds(scfg, cmds, <span class="function"><span class="keyword">function</span> <span class="params">(res)</span></span></span><br><span class="line">        size2 = #res</span><br><span class="line">    <span class="keyword">end</span>, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 如果行数不一致, 那么就说明加入失败</span></span><br><span class="line">    <span class="comment">-- 加入失败一般只有一种原因: 时间格式错误</span></span><br><span class="line">    <span class="comment">-- 我们也可以编写代码在执行加入前就判断, 但是判断时间的话, 涉及到平年和润年, 还涉及大小月</span></span><br><span class="line">    <span class="comment">-- 并且是服务器的时间, 所以也不能直接在windows上调用函数处理</span></span><br><span class="line">    <span class="comment">-- 考虑到这些原因, 就让linux帮我们做了这件事(反正行数不一致, 肯定是失败了)</span></span><br><span class="line">    <span class="keyword">if</span> size1 ~= size2 <span class="keyword">then</span> </span><br><span class="line">        <span class="comment">-- 添加失败就回滚一次任务</span></span><br><span class="line">        timer.rollBack(scfg, servercfg)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        inc.p(<span class="string">"添加定时任务成功"</span>, <span class="number">14</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h4 id="rollBack"><a href="#rollBack" class="headerlink" title="rollBack"></a>rollBack</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 回滚一次任务</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timer.rollBack</span><span class="params">(scfg, servercfg)</span></span></span><br><span class="line">    <span class="keyword">local</span> cmds = &#123;&#125;</span><br><span class="line">    <span class="comment">-- 这里使用了 sed 来处理, 其中用到了我们之前记录的 lastTask</span></span><br><span class="line">    <span class="built_in">table</span>.<span class="built_in">insert</span>(cmds, <span class="string">"sed -i "</span>..<span class="string">'/'</span>..timer.lastTask..<span class="string">"/d"</span>..</span><br><span class="line">        <span class="string">' '</span>..timer.fullName);</span><br><span class="line">    inc.popen_server_cmds(scfg, cmds, <span class="literal">nil</span>, <span class="literal">true</span>)</span><br><span class="line">    inc.p(<span class="string">"时间格式错误, 已回滚"</span>, <span class="number">12</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h4 id="searchTimerTask"><a href="#searchTimerTask" class="headerlink" title="searchTimerTask"></a>searchTimerTask</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询定时器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timer.searchTimerTask</span><span class="params">(scfg, servercfg)</span></span></span><br><span class="line">    <span class="keyword">local</span> cmds = &#123;&#125;</span><br><span class="line">    <span class="built_in">table</span>.<span class="built_in">insert</span>(cmds, <span class="string">"crontab -l"</span>)</span><br><span class="line">    inc.p(<span class="string">"\n当前已有任务: "</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">local</span> orisrc = &#123;&#125;</span><br><span class="line">    <span class="comment">-- 查看当前已有的任务</span></span><br><span class="line">    inc.popen_server_cmds(scfg, cmds, <span class="function"><span class="keyword">function</span> <span class="params">(res)</span></span></span><br><span class="line">        orisrc = res</span><br><span class="line">    <span class="keyword">end</span>, <span class="literal">true</span>)</span><br><span class="line">	</span><br><span class="line">    <span class="comment">-- 这里是为了将数据格式化成方便看懂的格式</span></span><br><span class="line">    timer.regex(orisrc, servercfg)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h4 id="regex"><a href="#regex" class="headerlink" title="regex"></a>regex</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 检测记录, 筛选信息</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timer.regex</span><span class="params">(orisrc, servercfg)</span></span></span><br><span class="line">    <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">pairs</span>(orisrc) <span class="keyword">do</span></span><br><span class="line">        <span class="comment">-- 获取任务时间戳</span></span><br><span class="line">        <span class="keyword">local</span> taskstamp;</span><br><span class="line">        <span class="keyword">for</span> v2 <span class="keyword">in</span> <span class="built_in">string</span>.<span class="built_in">gmatch</span>(v, <span class="string">"%d+%s%d+%s%d+%s%d+"</span>) <span class="keyword">do</span> </span><br><span class="line">            taskstamp = v2</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">-- 获取任务名</span></span><br><span class="line">        <span class="keyword">local</span> taskname;</span><br><span class="line">        <span class="keyword">for</span> v3 <span class="keyword">in</span> <span class="built_in">string</span>.<span class="built_in">gmatch</span>(v, <span class="string">"echo.*"</span>..timer.filenamemask..<span class="string">';'</span>) <span class="keyword">do</span> </span><br><span class="line">            v3 = <span class="built_in">string</span>.<span class="built_in">sub</span>(v3, <span class="number">6</span>, #v3 - #timer.filenamemask - <span class="number">1</span>)</span><br><span class="line">            taskname = v3 </span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">-- 获取服务器名</span></span><br><span class="line">        <span class="keyword">local</span> hostname;</span><br><span class="line">        <span class="keyword">for</span> v4 <span class="keyword">in</span> <span class="built_in">string</span>.<span class="built_in">gmatch</span>(v, <span class="string">"CRONTAB_TASK.*;cd%s/data/server/"</span>) <span class="keyword">do</span> </span><br><span class="line">            v4 = <span class="built_in">string</span>.<span class="built_in">sub</span>(v4, <span class="number">14</span>, #v4 - <span class="number">17</span>)</span><br><span class="line">            hostname = v4 </span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">-- 如果这条信息是任务信息, 格式化打印出来</span></span><br><span class="line">        <span class="keyword">if</span> (taskstamp ~= <span class="literal">nil</span> <span class="keyword">and</span> taskname ~= <span class="literal">nil</span> <span class="keyword">and</span> hostname == timer.servername) <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">local</span> timetab = &#123;&#125;</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">string</span>.<span class="built_in">gmatch</span>(taskstamp, <span class="string">"%d+"</span>) <span class="keyword">do</span></span><br><span class="line">                <span class="built_in">table</span>.<span class="built_in">insert</span>(timetab, i);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">            inc.p(<span class="string">"服务器: "</span>..hostname..<span class="string">"  ========  任务名: "</span>..taskname..</span><br><span class="line">                <span class="string">"  ========  时间: "</span>..</span><br><span class="line">                timetab[<span class="number">4</span>]..<span class="string">"月"</span>..timetab[<span class="number">3</span>]..<span class="string">"日"</span>..</span><br><span class="line">                timetab[<span class="number">2</span>]..<span class="string">"时"</span>..timetab[<span class="number">1</span>]..<span class="string">"分"</span>, <span class="number">14</span>)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h4 id="deleteTimerTask"><a href="#deleteTimerTask" class="headerlink" title="deleteTimerTask"></a>deleteTimerTask</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除定时器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timer.deleteTimerTask</span><span class="params">(scfg, servercfg)</span></span></span><br><span class="line">    inc.p(<span class="string">"请输入任务名(暂不支持中文)"</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">local</span> taskname = <span class="built_in">io</span>.<span class="built_in">stdin</span>:<span class="built_in">read</span>()</span><br><span class="line">    <span class="keyword">local</span> dir = timer.getFullPath(servercfg)</span><br><span class="line">    <span class="keyword">local</span> cmds = &#123;&#125;</span><br><span class="line">    <span class="built_in">table</span>.<span class="built_in">insert</span>(cmds, <span class="string">"cd "</span>..dir)</span><br><span class="line">    <span class="keyword">local</span> ttaskname = taskname..timer.filenamemask</span><br><span class="line">    <span class="comment">-- 执行一条 sed 命令, 删除一个任务</span></span><br><span class="line">    <span class="built_in">table</span>.<span class="built_in">insert</span>(cmds, <span class="string">"sed -i "</span>..<span class="string">'/'</span>..ttaskname..<span class="string">"/d"</span>..</span><br><span class="line">        <span class="string">' '</span>..timer.fullName);</span><br><span class="line">    inc.popen_server_cmds(scfg, cmds, <span class="literal">nil</span>, <span class="literal">true</span>)</span><br><span class="line">    <span class="comment">-- 同步一次</span></span><br><span class="line">    timer.syncTask(scfg, servercfg)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>


<h3 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h3><p>那么代码就这些了, 其中主要就是使用lua编写程序, 通过PLINK传递命令行信息</p>
<p>以此达到远程控制服务器定时器的效果</p>
<p>其中最主要的技术是: </p>
<p>lua语言基础, lua正则表达式  </p>
<p>{ crontab, sed } 命令行, 数据流重定向  </p>
<p>(emmmmmm… 看起来好像没什么厉害的…)</p>
<p>以及从&lt;重构&gt;中学到的代码技术  </p>
<p>(一开始看重构这本书的时候, 本来对里面一些降低效率的做法不太满意)</p>
<p>(但是真的使用了之后, 发现代码的确好多了, 无论是易读, 编写, 调试, 增加/删除方面, 都有明显提升)</p>
<p>(不过可惜没有运用到&lt;设计模式&gt;中的东西(或许我用到了, 只是没注意到?) )</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/09/other/firstClassValue/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cas">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cas's website">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/09/other/firstClassValue/" class="post-title-link" itemprop="url">other/firstClassValue</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-09 17:14:16 / Modified: 17:12:51" itemprop="dateCreated datePublished" datetime="2020-01-09T17:14:16+08:00">2020-01-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="第一级值"><a href="#第一级值" class="headerlink" title="第一级值"></a>第一级值</h4><p>长久以来一直不太明白之前在 lua 一本书中提到的 “第一类值”   </p>
<p>直到今天在一本书上看到类似的解释:</p>
<pre><code>一般而言, 程序设计语言总会对计算元素的可能使用方式强加上某些限制  
带有最少限制的元素具有&quot;第一级&quot;的状态, 第一级元素的某些特权包括:
* 可以用变量命名
* 可以提供给过程作为参数
* 可以由过程作为结果返回
* 可以包含在数据结构中</code></pre><p>上述说的是第一级值, 猜想应该是第一类值拥有第一级特权</p>
<h4 id="第一类函数"><a href="#第一类函数" class="headerlink" title="第一类函数"></a>第一类函数</h4><p>以下摘自 wiki 对第一类函数(first-class function)的解释</p>
<pre><code>In computer science, a programming language is said to have first-    class functions if it treats functions as first-class citizens. This means the language supports passing functions as arguments to other functions, returning them as the values from other functions, and assigning them to variables or storing them in data structures
在计算机科学中, 一个编程语言如果对他函数就像第一类公民(??)一样, 那么就说他有第一类函数
这意味着语言支持将函数作为参数传递给其他函数
从其他函数中将其作为值返回
将其复制给变量, 或者保存到数据结构中</code></pre><h4 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h4><p>顺便 wiki 说了一下什么是高阶函数</p>
<pre><code>First-class functions are a necessity for the functional programming style, in which the use of higher-order functions is a standard practice. A simple example of a higher-ordered function is the map function, which takes, as its arguments, a function and a list, and returns the list formed by applying the function to each member of the list. For a language to support map, it must support passing a function as an argument.
第一类函数对于函数化编程是必要的
其中使用高阶函数就是一个标准的实践
一个高阶函数的简单案例就是map函数
(...能意会, 但没法翻译...)
它必须支持传递函数作为参数</code></pre><h4 id="lambda-是如何工作的"><a href="#lambda-是如何工作的" class="headerlink" title="lambda 是如何工作的"></a>lambda 是如何工作的</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;                                    </span><br><span class="line">    auto f &#x3D; [](int x, int y) &#123; return x + y; &#125;;</span><br><span class="line">    printf(&quot;%d\n&quot;,  f(1, 2) );                                                        </span><br><span class="line">    return 0;                                   </span><br><span class="line">&#125;                                               </span><br><span class="line">...</span><br><span class="line">_ZZ4mainENKUliiE_clEii:         </span><br><span class="line">.LFB3999:                       </span><br><span class="line">▹   .cfi_startproc              </span><br><span class="line">▹   pushq▹  %rbp                </span><br><span class="line">▹   .cfi_def_cfa_offset 16      </span><br><span class="line">▹   .cfi_offset 6, -16          </span><br><span class="line">▹   movq▹   %rsp, %rbp          </span><br><span class="line">▹   .cfi_def_cfa_register 6     </span><br><span class="line">▹   movq▹   %rdi, -8(%rbp)      &#x2F;&#x2F; 唯一的区别在于, 多传了一个&quot;this&quot;</span><br><span class="line">▹   movl▹   %esi, -12(%rbp)     </span><br><span class="line">▹   movl▹   %edx, -16(%rbp)     </span><br><span class="line">▹   movl▹   -16(%rbp), %eax     </span><br><span class="line">▹   movl▹   -12(%rbp), %edx     </span><br><span class="line">▹   addl▹   %edx, %eax          </span><br><span class="line">▹   popq▹   %rbp                </span><br><span class="line">▹   .cfi_def_cfa 7, 8           </span><br><span class="line">▹   ret                         </span><br><span class="line">...</span><br><span class="line">▹   subq▹   $16, %rsp</span><br><span class="line">▹   leaq▹   -1(%rbp), %rax	&#x2F;&#x2F; 这个 this 指向了当前栈帧, 但是这里为什么要 -1 ?</span><br><span class="line">▹   movl▹   $2, %edx</span><br><span class="line">▹   movl▹   $1, %esi</span><br><span class="line">▹   movq▹   %rax, %rdi            </span><br><span class="line">▹   call▹   _ZZ4mainENKUliiE_clEii</span><br></pre></td></tr></table></figure>

<p>在上面基础上, 让 lambda 捕获局部变量和全局变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">int gi &#x3D; 11;</span><br><span class="line">int main() &#123;</span><br><span class="line">    int i &#x3D; 10;</span><br><span class="line">    auto f &#x3D; [i, gi](int x, int y) &#123; return i + gi + x + y; &#125;;</span><br><span class="line">    printf(&quot;%d\n&quot;,  f(1, 2) );</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">_ZZ4mainENKUliiE_clEii:     </span><br><span class="line">.LFB3999:                   </span><br><span class="line">▹   .cfi_startproc          </span><br><span class="line">▹   pushq▹  %rbp            </span><br><span class="line">▹   .cfi_def_cfa_offset 16  </span><br><span class="line">▹   .cfi_offset 6, -16      </span><br><span class="line">▹   movq▹   %rsp, %rbp      </span><br><span class="line">▹   .cfi_def_cfa_register 6 </span><br><span class="line">▹   movq▹   %rdi, -8(%rbp)  </span><br><span class="line">▹   movl▹   %esi, -12(%rbp) </span><br><span class="line">▹   movl▹   %edx, -16(%rbp) </span><br><span class="line">▹   movq▹   -8(%rbp), %rax  </span><br><span class="line">▹   movl▹   (%rax), %edx    </span><br><span class="line">▹   movl▹   gi(%rip), %eax  	&#x2F;&#x2F; @warning 即使是按值捕获, 全局变量也并未产生复制</span><br><span class="line">▹   addl▹   %eax, %edx      </span><br><span class="line">▹   movl▹   -12(%rbp), %eax </span><br><span class="line">▹   addl▹   %eax, %edx      </span><br><span class="line">▹   movl▹   -16(%rbp), %eax </span><br><span class="line">▹   addl▹   %edx, %eax      </span><br><span class="line">▹   popq▹   %rbp            </span><br><span class="line">▹   .cfi_def_cfa 7, 8       </span><br><span class="line">▹   ret                    </span><br><span class="line">...</span><br><span class="line">▹   subq▹   $16, %rsp             </span><br><span class="line">▹   movl▹   $10, -4(%rbp)         </span><br><span class="line">▹   movl▹   -4(%rbp), %eax        </span><br><span class="line">▹   movl▹   %eax, -16(%rbp)       &#x2F;&#x2F; 复制了一份 i</span><br><span class="line">▹   leaq▹   -16(%rbp), %rax       </span><br><span class="line">▹   movl▹   $2, %edx              </span><br><span class="line">▹   movl▹   $1, %esi              </span><br><span class="line">▹   movq▹   %rax, %rdi            </span><br><span class="line">▹   call▹   _ZZ4mainENKUliiE_clEii</span><br></pre></td></tr></table></figure>

<p>其中关键之处在于对待全局变量的方式, 这有可能产生错误, 事实也的确错了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,  f(<span class="number">1</span>, <span class="number">2</span>) );</span><br><span class="line">gi = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,  f(<span class="number">1</span>, <span class="number">2</span>) );</span><br><span class="line">...</span><br><span class="line"><span class="number">24</span></span><br><span class="line"><span class="number">113</span> <span class="comment">// gi 的值改变后, 输出结果也随之改变, 这不应该是按值捕获的结果</span></span><br></pre></td></tr></table></figure>

<p>那么如果我加上 mutable 去更改这个 gi 呢?</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [i, gi](<span class="keyword">int</span> x, <span class="keyword">int</span> y) <span class="keyword">mutable</span> &#123; gi = <span class="number">110</span>; <span class="keyword">return</span> i + gi + x + y; &#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,  gi);      </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,  f(<span class="number">1</span>, <span class="number">2</span>) );</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,  gi);</span><br><span class="line">...</span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="number">110</span>	<span class="comment">// 改变了! 这可是很重要的细节</span></span><br></pre></td></tr></table></figure>

<p>上述结果, 编译器(gcc 4.8.5)只有一个警告</p>
<p>但是如果不注意这个细节, 去捕获全局变量, 可能会有很严重的错误</p>
<p>接下来专注一下类类型变量, 他会如何捕获 (这里的代码就有点头疼了)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;                                   </span><br><span class="line">    vector&lt;int&gt; v &#123;1, 2, 3, 4&#125;;                </span><br><span class="line">    int i &#x3D; 10;                                </span><br><span class="line">    auto f &#x3D; [i, gi, v](int x, int y) mutable &#123;</span><br><span class="line">        v[2] &#x3D; 10; gi &#x3D; 110;·                  </span><br><span class="line">        return i + gi + x + y; &#125;;              </span><br><span class="line">    printf(&quot;%d\n&quot;,  gi);                       </span><br><span class="line">    printf(&quot;%d\n&quot;,  f(1, 2) );                 </span><br><span class="line">    printf(&quot;%d\n&quot;,  v[2]);                     </span><br><span class="line"></span><br><span class="line">    return 0;                                  </span><br><span class="line">&#125;                                           </span><br><span class="line">...</span><br><span class="line">main:                                                          </span><br><span class="line">.LFB3998:          </span><br><span class="line">▹   pushq▹  %rbp                                                                       </span><br><span class="line">▹   movq▹   %rsp, %rbp                                         </span><br><span class="line">▹   pushq▹  %r13                                               </span><br><span class="line">▹   pushq▹  %r12                                               </span><br><span class="line">▹   pushq▹  %rbx                                               </span><br><span class="line">▹   subq▹   $72, %rsp                                          </span><br><span class="line">▹   leaq▹   -37(%rbp), %rax                                    </span><br><span class="line">▹   movq▹   %rax, %rdi                                         </span><br><span class="line">▹   call▹   _ZNSaIiEC1Ev                                       </span><br><span class="line">▹   movl▹   $._91, %r12d                                       </span><br><span class="line">▹   movl▹   $4, %r13d           &#x2F;&#x2F; 这里的 4 是告诉 vector, 有 4 个元素 (猜的)</span><br><span class="line">▹   leaq▹   -37(%rbp), %rdi                                    </span><br><span class="line">▹   movq▹   %r12, %rcx                                         </span><br><span class="line">▹   movq▹   %r13, %rbx                                         </span><br><span class="line">▹   movq▹   %r12, %rax                                         </span><br><span class="line">▹   movq▹   %r13, %rdx                                         </span><br><span class="line">▹   movq▹   %rcx, %rsi                                         </span><br><span class="line">▹   leaq▹   -64(%rbp), %rax     &#x2F;&#x2F; 按照上下文理解, 这应该就是 vector 的 this 指针   </span><br><span class="line">▹   movq▹   %rdi, %rcx                                         </span><br><span class="line">▹   movq▹   %rax, %rdi                                         </span><br><span class="line">.LEHB0:                                                        </span><br><span class="line">▹   call▹   _ZNSt6vectorIiSaIiEEC1ESt16initializer_listIiERKS0_ &#x2F;&#x2F; 真是个丑陋的小东西 &#x3D; &#x3D; </span><br><span class="line">.LEHE0:                                                        </span><br><span class="line">▹   leaq▹   -37(%rbp), %rax                                    </span><br><span class="line">▹   movq▹   %rax, %rdi                                         </span><br><span class="line">▹   call▹   _ZNSaIiED1Ev                                       </span><br><span class="line">▹   movl▹   $10, -36(%rbp)                                     </span><br><span class="line">▹   movl▹   -36(%rbp), %eax                                    </span><br><span class="line">▹   movl▹   %eax, -96(%rbp)       &#x2F;&#x2F; 上面的 10 是路标, 这个应该就是 lambda 的 this 指针</span><br><span class="line">▹   leaq▹   -64(%rbp), %rax       </span><br><span class="line">▹   leaq▹   -96(%rbp), %rdx</span><br><span class="line">▹   addq▹   $8, %rdx                                           </span><br><span class="line">▹   movq▹   %rax, %rsi                                         </span><br><span class="line">▹   movq▹   %rdx, %rdi                                         </span><br><span class="line">.LEHB1:                                                        </span><br><span class="line">▹   call▹   _ZNSt6vectorIiSaIiEEC1ERKS1_      &#x2F;&#x2F; 上面那句最长的应该是列表初始化, 而这一句                 								&#x2F;&#x2F; 可能是拷贝或者构造? </span><br><span class="line">.LEHE1:                               </span><br><span class="line">▹   movl▹   gi(%rip), %eax       </span><br><span class="line">▹   movl▹   %eax, %esi</span><br><span class="line">▹   movl▹   $.LC0, %edi</span><br><span class="line">▹   movl▹   $0, %eax</span><br><span class="line">.LEHB2:</span><br><span class="line">▹   call▹   printf</span><br><span class="line">▹   leaq▹   -96(%rbp), %rax</span><br><span class="line">▹   movl▹   $2, %edx</span><br><span class="line">▹   movl▹   $1, %esi</span><br><span class="line">▹   movq▹   %rax, %rdi</span><br><span class="line">▹   call▹   _ZZ4mainENUliiE_clEii</span><br><span class="line">...</span><br><span class="line">_ZZ4mainENUliiE_clEii:              </span><br><span class="line">.LFB4000:                           </span><br><span class="line">▹   .cfi_startproc                  </span><br><span class="line">▹   pushq▹  %rbp                    </span><br><span class="line">▹   .cfi_def_cfa_offset 16          </span><br><span class="line">▹   .cfi_offset 6, -16              </span><br><span class="line">▹   movq▹   %rsp, %rbp              </span><br><span class="line">▹   .cfi_def_cfa_register 6         </span><br><span class="line">▹   subq▹   $16, %rsp               </span><br><span class="line">▹   movq▹   %rdi, -8(%rbp)        &#x2F;&#x2F; this 指针  </span><br><span class="line">▹   movl▹   %esi, -12(%rbp)         </span><br><span class="line">▹   movl▹   %edx, -16(%rbp)         </span><br><span class="line">▹   movq▹   -8(%rbp), %rax          </span><br><span class="line">▹   addq▹   $8, %rax                </span><br><span class="line">▹   movl▹   $2, %esi                </span><br><span class="line">▹   movq▹   %rax, %rdi</span><br><span class="line">▹   call▹   _ZNSt6vectorIiSaIiEEixEm</span><br><span class="line">▹   movl▹   $10, (%rax)             &#x2F;&#x2F; 赋值</span><br><span class="line">▹   movl▹   $110, gi(%rip)</span><br><span class="line">▹   movq▹   -8(%rbp), %rax</span><br><span class="line">▹   movl▹   (%rax), %edx</span><br><span class="line">▹   movl▹   gi(%rip), %eax</span><br><span class="line">▹   addl▹   %eax, %edx</span><br><span class="line">▹   movl▹   -12(%rbp), %eax</span><br><span class="line">▹   addl▹   %eax, %edx</span><br><span class="line">▹   movl▹   -16(%rbp), %eax</span><br><span class="line">▹   addl▹   %edx, %eax</span><br><span class="line">▹   leave</span><br><span class="line">▹   .cfi_def_cfa 7, 8</span><br><span class="line">▹   ret</span><br></pre></td></tr></table></figure>
<p>值拷贝类的时候, 会将整个类拷贝一次, 并没有什么特殊的</p>
<p><strong>匿名函数与其说是函数, 不如说是类</strong> 他就像一个重载了调用运算符的类一样</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/09/other/float/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cas">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cas's website">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/09/other/float/" class="post-title-link" itemprop="url">other/float</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-09 17:14:16 / Modified: 17:12:51" itemprop="dateCreated datePublished" datetime="2020-01-09T17:14:16+08:00">2020-01-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在看到&lt;深入理解计算机系统&gt;的浮点数时, 第一想法是:</p>
<ul>
<li>无法精确保存大多数浮点数</li>
<li>精度上的缺失</li>
</ul>
<h3 id="零值的比较"><a href="#零值的比较" class="headerlink" title="零值的比较"></a>零值的比较</h3><p>很多面试题都会考一道浮点数零值比较的题(一般是单精度, 双精度太长了)</p>
<p>我觉得答案应该是:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f &gt; <span class="number">-0.000001f</span> &amp;&amp; f &lt; <span class="number">0.000001f</span></span><br></pre></td></tr></table></figure>

<p>这个题的核心在于 float 什么时候缺失精度</p>
<p>这里我没有使用等于, 因为我认为 0.000001f 和 -0.000001f 并不算缺失了精度 </p>
<p>(百度上的答案是有等于的, 我很怀疑这个答案, 甚至有人还用的是 0.00001 (눈_눈) )</p>
<p>(而google上我好像没有找到类似的答案, 再根据编译器给我的结果, 我只能如此推断)</p>
<p>下面是我推断的依据:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%f\n"</span>, <span class="number">0.000001f</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%f\n"</span>, <span class="number">0.0000006f</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%f\n"</span>, <span class="number">0.0000005f</span>);</span><br></pre></td></tr></table></figure>
<p>你觉得上面会打印什么呢?  输出结果是:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.000001</span></span><br><span class="line"><span class="number">0.000001</span></span><br><span class="line"><span class="number">0.000000</span></span><br></pre></td></tr></table></figure>
<p>这也就是我认为 0.000001 它并未损失精度的原因, 既然未损失, 那么就不能当做 0 值来对待</p>
<p>(再次看不起百度上的解答(눈_눈), 不过… 万一是cas错了呢?)</p>
<p>(损失精度还有更精确的 0.00000055f, 这个数字也被认为是 0.000001)</p>
<h3 id="数字的精度取决于有多少位表示"><a href="#数字的精度取决于有多少位表示" class="headerlink" title="数字的精度取决于有多少位表示"></a>数字的精度取决于有多少位表示</h3><p>上面看到了6为精度的情况, 他准确表示了0.1 (虽然它把 0.0000006f 当做了0.1…)</p>
<p>我们来看看其他的结果, 比如:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%f\n"</span>, <span class="number">255.1f</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="number">254.2f</span> == <span class="number">254.200001f</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="number">254.2f</span> == <span class="number">254.200002f</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="number">254.2f</span> == <span class="number">254.200003f</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="number">254.2f</span> == <span class="number">254.200004f</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="number">254.2f</span> == <span class="number">254.200005f</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="number">254.2f</span> == <span class="number">254.200006f</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="number">254.2f</span> == <span class="number">254.200007f</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="number">254.2f</span> == <span class="number">254.200008f</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="number">254.2f</span> == <span class="number">254.200009f</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="number">254.2f</span> == <span class="number">254.199999f</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="number">254.2f</span> == <span class="number">254.199998f</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="number">254.2f</span> == <span class="number">254.199997f</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="number">254.2f</span> == <span class="number">254.199996f</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="number">254.2f</span> == <span class="number">254.199995f</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="number">254.2f</span> == <span class="number">254.199994f</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="number">254.2f</span> == <span class="number">254.199993f</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="number">254.2f</span> == <span class="number">254.199992f</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="number">254.2f</span> == <span class="number">254.199991f</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="number">254.2f</span> == <span class="number">254.199990f</span>);</span><br></pre></td></tr></table></figure>
<p>你觉得这次又会输出什么呢?</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">255.100006</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>(输出结果我做了缩减, 不然太长了)</p>
<p>也就是说, 除了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">254.200005f</span></span><br><span class="line"><span class="number">254.200006f</span></span><br><span class="line"><span class="number">254.200007f</span></span><br><span class="line"><span class="number">254.200008f</span></span><br><span class="line"><span class="number">254.200009f</span></span><br></pre></td></tr></table></figure>
<p>之外, 编译器认为它们都是相等的, 为什么呢?</p>
<p>精度再次缺失(我只能如此猜测), 因为整数的数字过大, 剩下的留给小数的位数不足以达到6位精度  </p>
<p>所以这次的精度缩减到了5位, 而因为四舍五入(我只能再次如此猜测 (눈_눈))的关系</p>
<p>(其实说四舍五入有点不对, 应该是: 数字的二进制表示刚好进入了有效的区间)</p>
<p>一些能达到 254.20001 的数字被判段为不等, 而一些 254.19999 的数字又可四舍五入的关系被判断为相等  </p>
<p>所以, 整数数字的大小会影响小数的精度 (我感觉我在说废话 (눈_눈)), 而当整数过大时, 比如 0x7fffffffff </p>
<p>所有的小数精度全都会缺失(unsigned float 可能是例外, 不过不影响结论)</p>
<p>下面我又做了一次比较, 我将254换成了126, 输出结果是</p>
<pre><code>0 0 0 0 0 0 0 0 0 1 1 1 1 1 0 0 0 0</code></pre><p>emmm… 其实这次的有效精度还是接近5位</p>
<p>不过能够在5位之外, 能判断更多的数字了</p>
<p>(这个数字并未完全达到6位, 也许 0.000005 能判断到, 0.000004 却不能, 就像上面那样) </p>
<h3 id="底层到底对我们的代码做了什么"><a href="#底层到底对我们的代码做了什么" class="headerlink" title="底层到底对我们的代码做了什么"></a>底层到底对我们的代码做了什么</h3><p>又到了喜闻乐见的看汇编环节 ┑(￣Д ￣)┍</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> f = <span class="number">0.1f</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%f\n"</span>, f);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%f\n"</span>, f * <span class="number">2</span>);</span><br><span class="line"><span class="keyword">float</span> f2 = <span class="number">0x7fff</span> + <span class="number">0.1f</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%f\n"</span>, f2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%f\n"</span>, f2 * <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>它在汇编中的样子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">.cfi_startproc</span><br><span class="line">    pushq   %rbp</span><br><span class="line">    .cfi_def_cfa_offset 16</span><br><span class="line">    .cfi_offset 6, -16</span><br><span class="line">    movq    %rsp, %rbp</span><br><span class="line">    .cfi_def_cfa_register 6</span><br><span class="line">    subq    $16, %rsp			&#x2F;&#x2F; 依旧是开辟了16个直接的栈帧, 为什么不是8(我有两个float)?</span><br><span class="line">    movl    .LC0(%rip), %eax	&#x2F;&#x2F; .long   1036831949</span><br><span class="line">    movl    %eax, -4(%rbp)		&#x2F;&#x2F; 将变量放到了栈中</span><br><span class="line">    movss   -4(%rbp), %xmm0		&#x2F;&#x2F; 放到了浮点数寄存器中</span><br><span class="line">    cvtps2pd        %xmm0, %xmm0	&#x2F;&#x2F; emmm... PS2PD Single-Precision Double-Precision</span><br><span class="line">    						&#x2F;&#x2F; 它将两个单精度浮点数转化成了双精度, 这可不在我的预料之中 ∑(￣□￣;)</span><br><span class="line">    movl    $.LC1, %edi</span><br><span class="line">    movl    $1, %eax</span><br><span class="line">    call    printf</span><br><span class="line">    movss   -4(%rbp), %xmm0</span><br><span class="line">    addss   %xmm0, %xmm0</span><br><span class="line">    unpcklps        %xmm0, %xmm0</span><br><span class="line">    cvtps2pd        %xmm0, %xmm0</span><br><span class="line">    movl    $.LC1, %edi</span><br><span class="line">    movl    $1, %eax</span><br><span class="line">    call    printf</span><br><span class="line">    movl    .LC2(%rip), %eax	&#x2F;&#x2F; .long   1191181875</span><br><span class="line">    movl    %eax, -8(%rbp)</span><br><span class="line">    movss   -8(%rbp), %xmm0</span><br><span class="line">    cvtps2pd        %xmm0, %xmm0</span><br><span class="line">    movl    $.LC1, %edi</span><br><span class="line">    movl    $1, %eax</span><br><span class="line">    call    printf</span><br><span class="line">    movss   -8(%rbp), %xmm0</span><br><span class="line">    addss   %xmm0, %xmm0</span><br><span class="line">    unpcklps        %xmm0, %xmm0</span><br><span class="line">    cvtps2pd        %xmm0, %xmm0</span><br><span class="line">    movl    $.LC1, %edi</span><br><span class="line">    movl    $1, %eax</span><br><span class="line">    call    printf</span><br><span class="line">    movl    $0, %eax</span><br><span class="line">    leave</span><br><span class="line">    .cfi_def_cfa 7, 8</span><br><span class="line">    ret</span><br><span class="line">    .cfi_endproc</span><br></pre></td></tr></table></figure>

<p>关键点在于 .LC1 和 .LC2, 他们的数字, 不过一点数字看不出什么, 需要多一些数据</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1036831949</span> = <span class="number">0.1f</span>	= <span class="number">3</span>dcccccd</span><br><span class="line"><span class="number">1045220557</span> = <span class="number">0.2f</span> 	= <span class="number">3e4</span>ccccd</span><br><span class="line"><span class="number">1038174126</span> = <span class="number">0.11f</span>	= <span class="number">3</span>de147ae</span><br></pre></td></tr></table></figure>

<p>其中 0.1f 和 0.2f 相差 800000</p>
<p>0.1f 和 0.11f 相差 147ae1</p>
<p>emmmm… 想不出来, 或许我该再看看书</p>
<p>嗯 好的, 看完了 (￣ˇ￣)</p>
<p>大概是这样的, 根据不同的位数安排, 计算的结果也有相应的不同</p>
<p>一个浮点数, 1位符号位S, 8位阶码E, 23位小数位M  </p>
<p>其中又分为4种情况: 规格, 非规格, NaN(not a number?), 无穷大</p>
<p>(具体的细节请参考书中的介绍)</p>
<p>总之, 我们用书中的算法来检验一下这几个数字</p>
<p>首先 0.1f, 它的数字是 3dcccccd, 它是一个规格化数字</p>
<p>E = 123 - 127 = -4 , M = 5033165 / 8388735 +１</p>
<p>2的E次方 x M = 0.0999994337644472 </p>
<p>emmm… 没错, 这是一个非常接近 0.1 的数字</p>
<p>(书中说到了小数的舍入, 简单来说是四舍五入, 同时向偶数舍入, 比如 1.245 它会向 1.24 舍入)</p>
<p>(再次很好奇一些需要极其精确的小数运算是如何做到的 （ー_ー？）)</p>
<p>(像存储金额这样的小数精度, 特别是银行, 损失一个精度都很严重啊)</p>
<p><strong>规格化用于表示一些比较大的数字, 而非规格化用于表示一些相对较小的数字</strong></p>
<p>这里顺便再看一下失去精度的结果, 看看他是怎么计算的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%f\n"</span>, <span class="number">255.1f</span>);</span><br></pre></td></tr></table></figure>

<p>奇怪的是, 它有两个数字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">111 .LC0:</span><br><span class="line">112     .long   1073741824</span><br><span class="line">113     .long   1081074483</span><br></pre></td></tr></table></figure>

<p>可惜计算不出来, 这种格式是无穷大(不太明白 (눈_눈))  </p>
<h3 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h3><p>简单来说, 其实也没有做笔记的必要  ┑(￣Д ￣)┍, 书上已经给了你答案</p>
<p>不过还好, 沉浸在思考的海洋中挺不错的(其实都快被淹死了 (눈_눈))</p>
<p>最后, <strong>若无必要, 或者非常确信浮点数的范围, 否则不要使用单精度浮点数</strong></p>
<p>如你所见, 单精度浮点数的范围很小, 一不小心还要失去精度</p>
<p>(这可能也是默认小数是双精度的原因)</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/09/other/headFirstGoAssembly/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cas">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cas's website">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/09/other/headFirstGoAssembly/" class="post-title-link" itemprop="url">other/headFirstGoAssembly</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-09 17:14:16 / Modified: 17:12:51" itemprop="dateCreated datePublished" datetime="2020-01-09T17:14:16+08:00">2020-01-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>下班忘把没读完的 inside the c++ object model 带回去</p>
<p>还好包里有本备用的 go, 简单看了一下前面基础部分</p>
<p>感觉就是, 很”新颖 + 轻巧”, 有很多新的概念和工具, 抛弃了一些沉重的”包袱”</p>
<p>试了一下用例, 看了一下汇编</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1 package main</span><br><span class="line">2 </span><br><span class="line">3 import &quot;fmt&quot;</span><br><span class="line">4     </span><br><span class="line">5 func main() &#123;</span><br><span class="line">6     fmt.Printf(&quot;hello, world\n&quot;)</span><br><span class="line">7 &#125;</span><br></pre></td></tr></table></figure>

<p>汇编:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> 1 # command-line-arguments                                                                 </span><br><span class="line"> 2 &quot;&quot;.main STEXT size&#x3D;88 args&#x3D;0x0 locals&#x3D;0x48                                               </span><br><span class="line"> 3     0x0000 00000 (&#x2F;test&#x2F;go&#x2F;t.go:5)  TEXT    &quot;&quot;.main(SB), $72-0                           				&#x2F;&#x2F; 非常友好地给我加上了对应的源码信息</span><br><span class="line"> 4     0x0000 00000 (&#x2F;test&#x2F;go&#x2F;t.go:5)  MOVQ    (TLS), CX                                    </span><br><span class="line"> 5     0x0009 00009 (&#x2F;test&#x2F;go&#x2F;t.go:5)  CMPQ    SP, 16(CX)                                   </span><br><span class="line"> 6     0x000d 00013 (&#x2F;test&#x2F;go&#x2F;t.go:5)  JLS 81                                               </span><br><span class="line"> 7     0x000f 00015 (&#x2F;test&#x2F;go&#x2F;t.go:5)  SUBQ    $72, SP	&#x2F;&#x2F; 这里应该是在开辟栈帧                                     </span><br><span class="line"> 8     0x0013 00019 (&#x2F;test&#x2F;go&#x2F;t.go:5)  MOVQ    BP, 64(SP)	&#x2F;&#x2F; 栈顶保存了 bp 指针                                   </span><br><span class="line"> 9     0x0018 00024 (&#x2F;test&#x2F;go&#x2F;t.go:5)  LEAQ    64(SP), BP  &#x2F;&#x2F; 重置 bp                                 </span><br><span class="line">10     0x001d 00029 (&#x2F;test&#x2F;go&#x2F;t.go:5)  FUNCDATA    $0, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)	&#x2F;&#x2F; gc ? garbage collection?</span><br><span class="line">11     0x001d 00029 (&#x2F;test&#x2F;go&#x2F;t.go:5)  FUNCDATA    $1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)</span><br><span class="line">12     0x001d 00029 (&#x2F;test&#x2F;go&#x2F;t.go:5)  FUNCDATA    $3, gclocals·9fb7f0986f647f17cb53dda1484e0f7a(SB)	&#x2F;&#x2F; 看不懂 &#x3D; &#x3D;</span><br><span class="line">13     0x001d 00029 (&#x2F;test&#x2F;go&#x2F;t.go:6)  PCDATA  $2, $1                                       </span><br><span class="line">14     0x001d 00029 (&#x2F;test&#x2F;go&#x2F;t.go:6)  PCDATA  $0, $0	&#x2F;&#x2F; 还是看不懂 &#x3D; &#x3D;</span><br><span class="line">15     0x001d 00029 (&#x2F;test&#x2F;go&#x2F;t.go:6)  LEAQ    go.string.&quot;hello, world\n&quot;(SB), AX           						&#x2F;&#x2F; 加载字符串文本, 者很方便, 我直接可以看到字符串</span><br><span class="line">16     0x0024 00036 (&#x2F;test&#x2F;go&#x2F;t.go:6)  PCDATA  $2, $0                                       </span><br><span class="line">17     0x0024 00036 (&#x2F;test&#x2F;go&#x2F;t.go:6)  MOVQ    AX, (SP)                                     </span><br><span class="line">18     0x0028 00040 (&#x2F;test&#x2F;go&#x2F;t.go:6)  MOVQ    $13, 8(SP)	&#x2F;&#x2F; 应该是指字符串长度</span><br><span class="line">19     0x0031 00049 (&#x2F;test&#x2F;go&#x2F;t.go:6)  MOVQ    $0, 16(SP)  &#x2F;&#x2F; 后续参数数量?                                 </span><br><span class="line">20     0x003a 00058 (&#x2F;test&#x2F;go&#x2F;t.go:6)  XORPS   X0, X0	&#x2F;&#x2F; 单精度异或?</span><br><span class="line">21     0x003d 00061 (&#x2F;test&#x2F;go&#x2F;t.go:6)  MOVUPS  X0, 24(SP)                                   						&#x2F;&#x2F; 代码中没有用到单精度浮点数, 为什么会有这个指令?</span><br><span class="line">22     0x0042 00066 (&#x2F;test&#x2F;go&#x2F;t.go:6)  CALL    fmt.Printf(SB) &#x2F;&#x2F; 调用                              					&#x2F;&#x2F; 这样的格式很清晰</span><br><span class="line">23     0x0047 00071 (&#x2F;test&#x2F;go&#x2F;t.go:7)  MOVQ    64(SP), BP  &#x2F;&#x2F; 返还 bp                                 </span><br><span class="line">24     0x004c 00076 (&#x2F;test&#x2F;go&#x2F;t.go:7)  ADDQ    $72, SP	&#x2F;&#x2F; 重置栈顶</span><br><span class="line">25     0x0050 00080 (&#x2F;test&#x2F;go&#x2F;t.go:7)  RET	&#x2F;&#x2F; 结束</span><br><span class="line">26     0x0051 00081 (&#x2F;test&#x2F;go&#x2F;t.go:7)  NOP</span><br><span class="line">27     0x0051 00081 (&#x2F;test&#x2F;go&#x2F;t.go:5)  PCDATA  $0, $-1                                      </span><br><span class="line">28     0x0051 00081 (&#x2F;test&#x2F;go&#x2F;t.go:5)  PCDATA  $2, $-1                                      </span><br><span class="line">29     0x0051 00081 (&#x2F;test&#x2F;go&#x2F;t.go:5)  CALL    runtime.morestack_noctxt(SB)                 								&#x2F;&#x2F; 运行时的什么?</span><br><span class="line">30     0x0056 00086 (&#x2F;test&#x2F;go&#x2F;t.go:5)  JMP 0</span><br></pre></td></tr></table></figure>

<p>FUNCDATA 我怀疑和垃圾回收有关, PCDATA 意义不明 (网上查了一下, 都和垃圾回收有关)</p>
<p>我尝试过添加一个参数, 以用作 fmt.Println(), 但是我并未在代码中找到任何有关参数的信息</p>
<p>仅仅只有一句看起来和那个参数有关</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LEAQ    &quot;&quot;..autotmp_0+64(SP), AX	&#x2F;&#x2F; 就是这句话</span><br><span class="line">PCDATA  $2, $0                  </span><br><span class="line">MOVQ    AX, 16(SP)</span><br></pre></td></tr></table></figure>
<p>而且我差点忽略的一点是, 这里参数的传递是用栈</p>
<p>顺便, 我在文件的末尾找到了这些信息, 看起来像是某种标记</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">213 gclocals·69c1753bd5f81501d95132d08af04464 SRODATA dupok size&#x3D;8        </span><br><span class="line">214     0x0000 02 00 00 00 00 00 00 00                          ........  </span><br><span class="line">215 gclocals·568470801006e5c0dc3947ea998fe279 SRODATA dupok size&#x3D;10       </span><br><span class="line">216     0x0000 02 00 00 00 02 00 00 00 00 02                    ..........</span><br><span class="line">217 gclocals·9fb7f0986f647f17cb53dda1484e0f7a SRODATA dupok size&#x3D;10       </span><br><span class="line">218     0x0000 02 00 00 00 01 00 00 00 00 01                    ..........</span><br><span class="line">219 gclocals·33cdeccccebe80329f1fdbee7f5874cb SRODATA dupok size&#x3D;8        </span><br><span class="line">220     0x0000 01 00 00 00 00 00 00 00                          ........</span><br></pre></td></tr></table></figure>

<p>我再次使用了变量存储值的形式, 然后我的数字能够正常看见了:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">0x0034 00052 (&#x2F;test&#x2F;go&#x2F;t.go:7)  MOVQ    $100, 8(SP)	&#x2F;&#x2F; 我的数字在这里</span><br><span class="line">0x003d 00061 (&#x2F;test&#x2F;go&#x2F;t.go:7)  CALL    runtime.convT2E64(SB)</span><br><span class="line">0x0042 00066 (&#x2F;test&#x2F;go&#x2F;t.go:7)  MOVQ    16(SP), AX</span><br><span class="line">0x0047 00071 (&#x2F;test&#x2F;go&#x2F;t.go:7)  PCDATA  $2, $2</span><br><span class="line">0x0047 00071 (&#x2F;test&#x2F;go&#x2F;t.go:7)  MOVQ    24(SP), CX</span><br><span class="line">0x004c 00076 (&#x2F;test&#x2F;go&#x2F;t.go:7)  MOVQ    AX, &quot;&quot;..autotmp_1+64(SP)</span><br><span class="line">0x0051 00081 (&#x2F;test&#x2F;go&#x2F;t.go:7)  PCDATA  $2, $0</span><br><span class="line">0x0051 00081 (&#x2F;test&#x2F;go&#x2F;t.go:7)  MOVQ    CX, &quot;&quot;..autotmp_1+72(SP)</span><br><span class="line">0x0056 00086 (&#x2F;test&#x2F;go&#x2F;t.go:7)  PCDATA  $2, $1</span><br><span class="line">0x0056 00086 (&#x2F;test&#x2F;go&#x2F;t.go:7)  LEAQ    go.string.&quot;hello, world\n%d&quot;(SB), AX</span><br><span class="line">0x005d 00093 (&#x2F;test&#x2F;go&#x2F;t.go:7)  PCDATA  $2, $0</span><br><span class="line">0x005d 00093 (&#x2F;test&#x2F;go&#x2F;t.go:7)  MOVQ    AX, (SP)</span><br><span class="line">0x0061 00097 (&#x2F;test&#x2F;go&#x2F;t.go:7)  MOVQ    $15, 8(SP)</span><br><span class="line">0x006a 00106 (&#x2F;test&#x2F;go&#x2F;t.go:7)  PCDATA  $2, $1</span><br><span class="line">0x006a 00106 (&#x2F;test&#x2F;go&#x2F;t.go:7)  LEAQ    &quot;&quot;..autotmp_1+64(SP), AX</span><br><span class="line">0x006f 00111 (&#x2F;test&#x2F;go&#x2F;t.go:7)  PCDATA  $2, $0</span><br><span class="line">0x006f 00111 (&#x2F;test&#x2F;go&#x2F;t.go:7)  MOVQ    AX, 16(SP)</span><br><span class="line">0x0074 00116 (&#x2F;test&#x2F;go&#x2F;t.go:7)  MOVQ    $1, 24(SP)</span><br><span class="line">0x007d 00125 (&#x2F;test&#x2F;go&#x2F;t.go:7)  MOVQ    $1, 32(SP)</span><br><span class="line">0x0086 00134 (&#x2F;test&#x2F;go&#x2F;t.go:7)  CALL    fmt.Printf(SB)	</span><br><span class="line">						&#x2F;&#x2F; 但是在调用之前, 我并没看到我的数字被加载了, 为什么?</span><br><span class="line">						&#x2F;&#x2F; 我唯一比较怀疑的是那个 CALL runtime.convT2E64(SB)</span><br></pre></td></tr></table></figure>

<p>好吧, 我的数据再度丢失了, 我甚至不知道它是如何被传过去的…</p>
<h3 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h3><p>go的汇编基于 plan 9(一个新的操作系统), 感觉到了新的技术和观点</p>
<p>并且它也更加友好, 我明显觉得看它的汇编会更轻松一些</p>
<p>(除了那个 PCDATA, FUNCDATA, 和那个已经被我跟丢的变量)</p>
<p>emmm… 很不错, 觉得自己听了别人的建议, 去学新的语言</p>
<p>而不学现在看起来很强大, 但是已经很老了的 java 是一个正确的决定</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/09/other/implementionThreadInUserAndKernelSpace/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cas">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cas's website">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/09/other/implementionThreadInUserAndKernelSpace/" class="post-title-link" itemprop="url">other/implementionThreadInUserAndKernelSpace</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-09 17:14:16 / Modified: 17:13:31" itemprop="dateCreated datePublished" datetime="2020-01-09T17:14:16+08:00">2020-01-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>之前就看过关于在内核以及用户空间实现线程的文章, 到现在还对于其中的一些点一知半解, 比如: 为什么实现在用户空间的线程比实现在内核空间的快?. 今天碰巧看到了这篇文章, 原文出自 &lt;modern operating system, fourth edition&gt;</p>
<h2 id="threads-implementation-in-kernel-and-user-space"><a href="#threads-implementation-in-kernel-and-user-space" class="headerlink" title="threads implementation in kernel and user space"></a>threads implementation in kernel and user space</h2><h3 id="2-2-4-Implementing-Threads-in-User-Space"><a href="#2-2-4-Implementing-Threads-in-User-Space" class="headerlink" title="2.2.4 Implementing Threads in User Space"></a>2.2.4 Implementing Threads in User Space</h3><p>There are two main places to implement threads: user space and the kernel.<br>The choice is a bit controversial, and a hybrid implementation is also possible. We<br>will now describe these methods, along with their advantages and disadvantages.</p>
<p>有两种主要的地方用于实现线程: 用户空间以及内核空间. 如何在哪里实现具有一定争议性, 同时, 一种混合的实现也是可能的. 我们将会概述这些方法, 以及他们的优点和缺点.</p>
<p>The first method is to put the threads package entirely in user space. The kernel knows nothing about them. As far as the kernel is concerned, it is managing<br>ordinary, single-threaded processes. The first, and most obvious, advantage is that<br>a user-level threads package can be implemented on an operating system that does<br>not support threads. All operating systems used to fall into this category, and even<br>now some still do. With this approach, threads are implemented by a library.</p>
<p>第一种方法是将整个线程包放到用户空间. 内核对此毫无所知. 就内核而言, 它依旧像对待单线程对象一样.</p>
<p>首先, 最明显的优点是, 用户级别的线程可以实现在一个不支持多线程的操作系统上.所有的操作系统曾经都是这种类型, 直到现在还有部分保留, 在这种方式下, 线程通过一个库实现.</p>
<p>All of these implementations have the same general structure, illustrated in<br>Fig. 2-16(a). The threads run on top of a run-time system, which is a collection of<br>procedures that manage threads. We have seen four of these already: pthread create, pthread exit, pthread join, and pthread yield, but usually there are more.</p>
<p>所有的实现有同样通用的结构, 如图2-16(a). 线程运行于运行时系统上(一系列管理线程的程序). 我们已经见过四种这样的程序了: 线程创建, 退出, 加入, 放弃(这是本书前面部分的内容, 但为什么是 pthread 呢? 难道是基于 posix 标准的线程实现?)</p>
<p><img src="https://imgur.com/ljUry5a.png" alt=""></p>
<p>When threads are managed in user space, each process needs its own private<br>thread table to keep track of the threads in that process. This table is analogous to<br>the kernel’s process table, except that it keeps track only of the per-thread proper-<br>ties, such as each thread’s program counter, stack pointer, registers, state, and so<br>forth. The thread table is managed by the run-time system. When a thread is<br>moved to ready state or blocked state, the information needed to restart it is stored<br>in the thread table, exactly the same way as the kernel stores information about<br>processes in the process table.</p>
<p>当线程管理于用户空间时, 每个进程需要拥有独有的线程表, 以用于持续跟踪进程中的线程. 这个表类似与内核的进程表, 不过它只跟踪每个线程的属性. 比如每个线程的程序计数器, 栈指针, 寄存器, 状态, 以及… </p>
<p>线程表由运行时系统管理, 当线程转变为就绪/阻塞状态时, 用于重启的信息就存储在线程表中, 就和内核在进程表中存储关于进程的信息一样.</p>
<p>When a thread does something that may cause it to become blocked locally, for<br>example, waiting for another thread in its process to complete some work, it calls a<br>run-time system procedure. This procedure checks to see if the thread must be put<br>into blocked state. If so, it stores the thread’s registers (i.e., its own) in the thread<br>table, looks in the table for a ready thread to run, and reloads the machine registers<br>with the new thread’s saved values. As soon as the stack pointer and program<br>counter have been switched, the new thread comes to life again automatically.</p>
<p>如果线程做了某些操作导致它本地阻塞时, 比如: 等待进程中的其他线程完成某些工作. 它调用一个运行时作业调度. </p>
<p>这个程序检查线程是否必须置于阻塞态, 如果是, 它在线程表中存储线程的寄存器(它自己的). 在表中查找一个就绪态线程运行, 重新加载新线程的寄存器. 同时栈指针和程序计数器也会切换, 新线程再次自动运行.</p>
<p> If the machine happens to have an instruction to store all the registers and another<br>one to load them all, the entire thread switch can be done in just a handful of in-<br>structions. Doing thread switching like this is at least an order of magnitude—<br>maybe more—faster than trapping to the kernel and is a strong argument in favor<br>of user-level threads packages.</p>
<p>如果机器开始有一个指令可以存储所有的寄存器, 同时另一个指令加载他们, 那么整个线程的切换就只需要少量的指令.</p>
<p>要完成这样的线程切换比捕获内核至少快一个数量级, 或许更快. 这是一个对用户级线程拥护者强有力的论点.</p>
<p>However, there is one key difference with processes. When a thread is finished<br>running for the moment, for example, when it calls thread yield, the code of<br>thread yield can save the thread’s information in the thread table itself. Fur-<br>thermore, it can then call the thread scheduler to pick another thread to run. The<br>procedure that saves the thread’s state and the scheduler are just local procedures,<br>so invoking them is much more efficient than making a kernel call. Among other<br>issues, no trap is needed, no context switch is needed, the memory cache need not<br>be flushed, and so on. This makes thread scheduling very fast.</p>
<p>然而, 有一个关于进程的关键不同. 当线程暂停时, 比如: 调用 yield, 保存线程的信息到线程表中.</p>
<p>更进步一, 调用线程调度, 选择另一个线程执行. 程序保存线程状态, 因为调度只是本地程序, 所以调用其会比内核调用更加高效. 其他方面, 没有捕获, 没有环境切换, 内存缓冲也不需要刷新, 等等. 这使得线程调度非常快.</p>
<p>User-level threads also have other advantages. They allow each process to have<br>its own customized scheduling algorithm. For some applications, for example,<br>those with a garbage-collector thread, not having to worry about a thread being<br>stopped at an inconvenient moment is a plus. They also scale better, since kernel<br>threads invariably require some table space and stack space in the kernel, which<br>can be a problem if there are a very large number of threads.</p>
<p>用户级线程还有其他优点. 它使每个进程都可以有自己的特定调度算法. 对于一些应用, 比如垃圾回收线程, 不用担心线程在不适当时候停下来, 这是一个优点. 他们拥有更好的伸缩性, 因为内核线程总是需要一些表空间和栈空间, 当线程逐渐增加时, 会造成麻烦.</p>
<p>Despite their better performance, user-level threads packages have some major<br>problems. First among these is the problem of how blocking system calls are im-<br>plemented. Suppose that a thread reads from the keyboard before any keys hav e<br>been hit. Letting the thread actually make the system call is unacceptable, since<br>this will stop all the threads. One of the main goals of having threads in the first<br>place was to allow each one to use blocking calls, but to prevent one blocked<br>thread from affecting the others. With blocking system calls, it is hard to see how<br>this goal can be achieved readily.</p>
<p>即使它们拥有更好的性能, 用户级线程包也有一些固有的问题. </p>
<p>首先, 如何实现阻塞的系统调用. 假如线程等待来自键盘的输入, 让这个线程准确执行系统调用是不允许的, 因为这会阻塞所有线程, 线程的首要目的之一是允许每个线程使用阻塞调用, 但是保证一个阻塞线程不会影响其他线程. 可以看出这很难实现.</p>
<p>The system calls could all be changed to be nonblocking (e.g., a read on the<br>keyboard would just return 0 bytes if no characters were already buffered), but re-<br>quiring changes to the operating system is unattractive. Besides, one argument for<br>user-level threads was precisely that they could run with existing operating sys-<br>tems. In addition, changing the semantics of read will require changes to many<br>user programs.</p>
<p>系统调用必须都变为非阻塞的(比如, 读取键盘输入应该在没有任何字符被缓存时返回0), 但是这对于操作系统而已不太友好. 次外(我真不知道怎么翻译这句…). 另外, 改变读取的语义将会影响到大量用户程序.</p>
<p>Another alternative is available in the event that it is possible to tell in advance<br>if a call will block. In most versions of UNIX, a system call, select , exists, which<br>allows the caller to tell whether a prospective read will block. When this call is<br>present, the library procedure read can be replaced with a new one that first does a<br>select call and then does the read call only if it is safe (i.e., will not block). If the<br>read call will block, the call is not made. Instead, another thread is run. The next<br>time the run-time system gets control, it can check again to see if the read is now<br>safe. This approach requires rewriting parts of the system call library, and is inef-<br>ficient and inelegant, but there is little choice. The code placed around the system<br>call to do the checking is called a jacket or wrapper.</p>
<p>在这种情况下还有另一个方法: 提前告知一个调用将会被阻塞是可行的(??? 啥意思啊 = =).</p>
<p>在多个 UNIX 版本中, 选择性地存在系统调用运行调用者判断未来的读操作将会阻塞. 当这样的调用存在时, 库程序读取替换成一个首先做判断, 然后当确定是安全的时候读取(比如, 非阻塞).不会执行会阻塞的读操作, 另一个线程将会运行. </p>
<p>在下次运行时系统获得控制时, 会再次检查读操作是否是安全的. 这个方法需要重写部分系统调用库. 不那么高效和优雅. 不过这是一个选择, 放置在系统函数周围的代码去检查的这种方法被称为 jacket 或 wrapper.</p>
<p>Somewhat analogous to the problem of blocking system calls is the problem of<br>page faults. We will study these in Chap. 3. For the moment, suffice it to say that<br>computers can be set up in such a way that not all of the program is in main memo-<br>ry at once. If the program calls or jumps to an instruction that is not in memory, a<br>page fault occurs and the operating system will go and get the missing instruction<br>(and its neighbors) from disk. This is called a page fault. The process is blocked<br>while the necessary instruction is being located and read in. If a thread causes a<br>page fault, the kernel, unaware of even the existence of threads, naturally blocks<br>the entire process until the disk I/O is complete, even though other threads might<br>be runnable.01</p>
<p>(简单来说, 这段说的是页错误, 主存和磁盘间虚拟空间内容的交换.)</p>
<p>Another problem with user-level thread packages is that if a thread starts run-<br>ning, no other thread in that process will ever run unless the first thread voluntarily<br>gives up the CPU. Within a single process, there are no clock interrupts, making it<br>impossible to schedule processes round-robin fashion (taking turns). Unless a<br>thread enters the run-time system of its own free will, the scheduler will never get a<br>chance.</p>
<p>用户级线程将面临的另一个问题是: 当线程开始执行时, 除非自愿放弃, 不然其他线程无法执行. </p>
<p>单线程程序, 不会产生时钟终端, 使用 round-robin 调度器管理进程是不可能的. 除非线程自愿进入运行时系统. 否则调度器将不会生效.</p>
<p>One possible solution to the problem of threads running forever is to have the<br>run-time system request a clock signal (interrupt) once a second to give it control,<br>but this, too, is crude and messy to program. Periodic clock interrupts at a higher<br>frequency are not always possible, and even if they are, the total overhead may be<br>substantial. Furthermore, a thread might also need a clock interrupt, interfering<br>with the run-time system’s use of the clock.</p>
<p>一个可能的方法是: 让运行时系统每秒请求一个时钟信号来控制它(总而言之这是一个馊主意).</p>
<p>Another, and really the most devastating, argument against user-level threads is<br>that programmers generally want threads precisely in applications where the<br>threads block often, as, for example, in a multithreaded Web server. These threads<br>are constantly making system calls. Once a trap has occurred to the kernel to carry<br>out the system call, it is hardly any more work for the kernel to switch threads if<br>the old one has blocked, and having the kernel do this eliminates the need for con-<br>stantly making select system calls that check to see if read system calls are safe.<br>For applications that are essentially entirely CPU bound and rarely block, what is<br>the point of having threads at all? No one would seriously propose computing the<br>first n prime numbers or playing chess using threads because there is nothing to be<br>gained by doing it that way.</p>
<p>另一个反对用户级线程的论证(也是最具破坏性的)是, 程序员通常希望线程在线程经常阻塞的应用中使用, 比如, 在一个多线程 web 服务器中. 线程不间断地使用系统调用, 一旦内核执行系统调用, 如果旧线程已被阻塞, 那么切换线程就几乎没有其他需要做的了. …(后面我翻不下去了, 大概意思是, 这样的话, 程序就没有必要使用多线程了)</p>
<p>(总结归纳一下: 大概意思是, 用户级线程最大的优点是在于其切换起来很快, 但是我们通常希望在频繁发生线程阻塞的应用中使用线程, 而在这种情况下, 线程切换所需的操作就会变少(如果旧线程已经被阻塞了的话), 那么 用户级线程存在的意义就不大了)</p>
<h3 id="2-2-5-Implementing-Threads-in-the-Kernel"><a href="#2-2-5-Implementing-Threads-in-the-Kernel" class="headerlink" title="2.2.5 Implementing Threads in the Kernel"></a>2.2.5 Implementing Threads in the Kernel</h3><p>Now let us consider having the kernel know about and manage the threads. No<br>run-time system is needed in each, as shown in Fig. 2-16(b). Also, there is no<br>thread table in each process. Instead, the kernel has a thread table that keeps track<br>of all the threads in the system. When a thread wants to create a new thread or<br>destroy an existing thread, it makes a kernel call, which then does the creation or<br>destruction by updating the kernel thread table.</p>
<p>现在, 让我们考虑让内核知道如何管理线程. 如图 2-16(b) 所示, 在进程中没有运行时系统, 也没有线程表. 内核有张线程表, 用于跟踪系统中的所有线程. 当线程想要创建或删除一个线程时, 使用一个内核调用, 然后通过更新内核线程表来创建或删除.</p>
<p>The kernel’s thread table holds each thread’s registers, state, and other infor-<br>mation. The information is the same as with user-level threads, but now kept in the<br>kernel instead of in user space (inside the run-time system). This information is a<br>subset of the information that traditional kernels maintain about their single-<br>threaded processes, that is, the process state. In addition, the kernel also maintains<br>the traditional process table to keep track of processes.</p>
<p>内核的线程表保存每个线程的寄存器, 状态, 以及其他信息. 与用户级线程保存的信息一致, 只是保存在内核中. </p>
<p>这些信息是传统内核管理的单线程进程信息的子集. 内核也同样管理传统的进程表, 以用于跟踪进程.</p>
<p>All calls that might block a thread are implemented as system calls, at consid-<br>erably greater cost than a call to a run-time system procedure. When a thread<br>blocks, the kernel, at its option, can run either another thread from the same proc-<br>ess (if one is ready) or a thread from a different process. With user-level threads,<br>the run-time system keeps running threads from its own process until the kernel<br>takes the CPU away from it (or there are no ready threads left to run).</p>
<p>所有可能阻塞线程的调用都被实现为系统调用, 相对运行时系统的调用, 明显有很大的额外消耗. 当线程阻塞时, 内核可以选择同进程下的线程运行, 也可以运行另一个进程的线程. 但用户级线程只会运行本进程的线程, 直到内核不让其使用 CPU 资源.</p>
<p>Due to the relatively greater cost of creating and destroying threads in the ker-<br>nel, some systems take an environmentally correct approach and recycle their<br>threads. When a thread is destroyed, it is marked as not runnable, but its kernel<br>data structures are not otherwise affected. Later, when a new thread must be creat-<br>ed, an old thread is reactivated, saving some overhead. Thread recycling is also<br>possible for user-level threads, but since the thread-management overhead is much<br>smaller, there is less incentive to do this.</p>
<p>因为在内核中创建和销毁线程操作相对更费力, 一些系统使用与环境相关的方法, 重利用它们的线程. </p>
<p>当线程销毁时, 将其标记为不可运行, 但是其内核数据结构不受影响, 随后, 当新线程需要创建时, 重新利用这些资源.  用户级线程也可以使用这个方法, 不过因为线程管理的消耗较小, 并不是很有必要这么做</p>
<p>Kernel threads do not require any new, nonblocking system calls. In addition,<br>if one thread in a process causes a page fault, the kernel can easily check to see if<br>the process has any other runnable threads, and if so, run one of them while wait-<br>ing for the required page to be brought in from the disk. Their main disadvantage is<br>that the cost of a system call is substantial, so if thread operations (creation, termi-<br>nation, etc.) a common, much more overhead will be incurred.</p>
<p>内核线程不需要任何新的, 非阻塞系统调用. 另外, 如果线程导致了页错误, 内核可以轻松地检查进程是否有其他线程可运行, 如果有, 在等待所需的页加载入内存中时, 执行该线程. 它们潜在的问题是: 系统调用比较耗时, 所以如果线程操作比较常见, 则会有更多的负载.</p>
<p>While kernel threads solve some problems, they do not solve all problems. For<br>example, what happens when a multithreaded process forks? Does the new proc-<br>ess have as many threads as the old one did, or does it have just one? In many<br>cases, the best choice depends on what the process is planning to do next. If it is<br>going to call exec to start a new program, probably one thread is the correct choice,<br>but if it continues to execute, reproducing all the threads is probably best.</p>
<p>内核线程依旧有一些未能解决的问题, 比如, 当多线程进程执行 fork 的时候, 会发生什么? 新的进程是否会像旧进程一样拥有同样多的线程呢? 还是只拥有一个呢? 在大多数情况下, 取决于进程将要做什么, 如果它将会调用 exec 执行一个新的程序, 当然只有一个好, 但是如果是继续运行的话, 则保留所有的线程则是最好的.</p>
<p>(PS: 在 linux posix 线程下, 默认是同样多的线程)</p>
<p>Another issue is signals. Remember that signals are sent to processes, not to<br>threads, at least in the classical model. When a signal comes in, which thread<br>should handle it? Possibly threads could register their interest in certain signals, so<br>when a signal came in it would be given to the thread that said it wants it. But what<br>happens if two or more threads register for the same signal? These are only two of<br>the problems threads introduce, and there are more.</p>
<p>另一个问题是信号. 信号是发给进程的, 而并非线程(至少在经典模型下). 当信号到达时, 那个线程来处理它呢? 可能线程会注册自己感兴趣的信号, 所以, 当信号到达, 会交由那个注册线程处理. 但是如果多个线程注册了同样的信号呢? 这仅仅是线程引入的其中两个问题.</p>
<h3 id="2-2-6-Hybrid-Implementations"><a href="#2-2-6-Hybrid-Implementations" class="headerlink" title="2.2.6 Hybrid Implementations"></a>2.2.6 Hybrid Implementations</h3><p>Various ways have been investigated to try to combine the advantages of user-<br>level threads with kernel-level threads. One way is use kernel-level threads and<br>then multiplex user-level threads onto some or all of them, as shown in Fig. 2-17.<br>When this approach is used, the programmer can determine how many kernel<br>threads to use and how many user-level threads to multiplex on each one. This<br>model gives the ultimate in flexibility.</p>
<p>已经有多种方法被研究出来, 用于融合用户级线程和内核级线程. 其中一种方法是使用内核级别线程, 然后每个内核线程使用多个用户级别线程. 如 2-17. </p>
<p>程序能够知晓多少内核线程, 多少用户线程被使用. 这种模型给予了很大的灵活性.</p>
<p><img src="https://imgur.com/Bcc4Uzh.png" alt=""></p>
<p>With this approach, the kernel is aware of only the kernel-level threads and<br>schedules those. Some of those threads may have multiple user-level threads multi-<br>plexed on top of them. These user-level threads are created, destroyed, and sched-<br>uled just like user-level threads in a process that runs on an operating system with-<br>out multithreading capability. In this model, each kernel-level thread has some set<br>of user-level threads that take turns using it.</p>
<p>在这种方法下, 内核只至少内核线程, 并调度它们. 其中一些内核线程上可能存在多个用户级线程. 这些用户线程将会在进程中管控. </p>
<p>内核线程和用户线程各有其优势, 用户线程效率更高, 但是操作系统不知情的情况下, 会产生许多逻辑上是多线程, 但物理上依旧是单线程才会产生的错误. 比如 信号, 中断. 而内核线程虽然相对效率低, 并且占用内核空间, 但是操作系统知晓是多线程, 与操作系统间有更多协作的空间.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/09/other/install%20vim8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cas">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cas's website">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/09/other/install%20vim8/" class="post-title-link" itemprop="url">other/install vim8</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-09 17:14:16 / Modified: 17:13:54" itemprop="dateCreated datePublished" datetime="2020-01-09T17:14:16+08:00">2020-01-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在和 master vim quickly 的作者邮件中 </p>
<p>发现了自己的vim版本还可以再更新, 于是有了这篇笔记</p>
<p>参考教程:</p>
<p><a href="https://www.tecmint.com/vim-8-0-install-in-ubuntu-linux-systems/" target="_blank" rel="noopener">https://www.tecmint.com/vim-8-0-install-in-ubuntu-linux-systems/</a></p>
<p><a href="https://www.systutorials.com/241762/how-to-upgrade-vim-to-version-8-on-centos-7/" target="_blank" rel="noopener">https://www.systutorials.com/241762/how-to-upgrade-vim-to-version-8-on-centos-7/</a></p>
<p>vim的git地址:</p>
<p><a href="https://github.com/vim/vim" target="_blank" rel="noopener">https://github.com/vim/vim</a></p>
<p>vim8安装指南:</p>
<p><a href="https://github.com/vim/vim/blob/master/src/INSTALL" target="_blank" rel="noopener">https://github.com/vim/vim/blob/master/src/INSTALL</a></p>
<h3 id="安装vim8"><a href="#安装vim8" class="headerlink" title="安装vim8"></a>安装vim8</h3><ol>
<li><p>首先需要源代码</p>
<p>git clone <a href="https://github.com/vim/vim.git" target="_blank" rel="noopener">https://github.com/vim/vim.git</a></p>
</li>
<li><p>编译</p>
<p>cd &lt;vim repo 路径&gt;/src</p>
<p>make</p>
<p>make install</p>
<p>现在应该就已经获得了新的vim可执行文件, 将他覆盖原来的vim就好</p>
</li>
</ol>
<p>@btw: 中途可能会遇到一些问题</p>
<ul>
<li>安装编译vim所需的API<ul>
<li>yum  -y install  ncurses-devel</li>
</ul>
</li>
<li>覆盖时提示出错<ul>
<li>因为可能vim还在其他地方被运行, 使用 losf 查看进程, kill 掉</li>
</ul>
</li>
</ul>
<p>具体的可以参考上面的教程链接, 这里只是简单概述</p>
<p>顺便给一份通常的vim设置</p>
<pre><code>&quot;General&quot;
set number    &quot;Show line numbers&quot;
set linebreak    &quot;Break lines at word (requires Wrap lines)&quot;
set showbreak=+++    &quot;Wrap-broken line prefix&quot;
set textwidth=100    &quot;Line wrap (number of cols)&quot;
set showmatch    &quot;Highlight matching brace&quot;
set visualbell    &quot;Use visual bell (no beeping)&quot;

set hlsearch    &quot;Highlight all search results&quot;
set smartcase    &quot;Enable smart-case search&quot;
set ignorecase    &quot;Always case-insensitive&quot;
set incsearch    &quot;Searches for strings incrementally&quot;

set autoindent    &quot;Auto-indent new lines&quot;
set shiftwidth=4    &quot;Number of auto-indent spaces&quot;
set smartindent    &quot;Enable smart-indent&quot;
set smarttab    &quot;Enable smart-tabs&quot;
set softtabstop=4    &quot;Number of spaces per Tab&quot;

&quot;Advanced&quot;
set ruler    &quot;Show row and column ruler information&quot;
​    
set undolevels=1000    &quot;Number of undo levels&quot;
set backspace=indent,eol,start    &quot;Backspace behaviour&quot;</code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/09/other/linux/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cas">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cas's website">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/09/other/linux/" class="post-title-link" itemprop="url">other/linux</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-09 17:14:16 / Modified: 17:13:54" itemprop="dateCreated datePublished" datetime="2020-01-09T17:14:16+08:00">2020-01-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <pre><code>mkdir 创建文件夹指令  
su 切换到管理员模式  
sudo 以管理员模式执行命令
sudo passwd 以用户密码更改管理员密码
rm -f * 删除当前目录下所有文件
clear 清空终端窗口(实际还存在, 只不过看不见了, 和cmd一样)

apt-get install [工具名] 安装工具  
CentOS下是使用yum

更改vim配色
1. 下载vim文件
2. 放到~/.vim/colors文件夹下(没有就创建)
3. 更改vimrc文件, 路径: /etc/vim/vimrc, 增加指令: colorscheme [配色方案名]
PS: 默认的colors文件夹路径: /usr/share/vim/vim80/colors
之后发现vimrc文件在/etc目录下, 而vim文件放在了~/.vim目录下
emmmmm, 已经想不起当时怎么弄的了... 就这样吧, 可能是版本问题...

更改tab间距
同样更改vimrc文件, 增加如下指令: 
set ts=4 // 设置table间距为4
set expandtab // 不清楚 - -</code></pre><p>以上环境为ubuntu 18<br>PS: 想起之前刚接触linux, 安装g++, gcc参照了错误的教程(那沙雕教程又是装插件又是下安装包)<br>好不容易装完之后又被vi的输入和命令行模式, 嘟嘟嘟嘟嘟, 气得半死<br>之后又好不容易写好一个测试代码, ctrl+s一保存, 直接TMD不响应了<br>(事后才得知这是关闭向终端输入的接口, 只需要ctrl+q就可以重新打开输入, 留下了属于无知者的泪水…)<br>一系列操作让我直接删除ubuntu… </p>
<p>vim查询字符串 <code>/字符串</code><br>PS: 但是之后被搜索的字符串会持续高亮显示, 使输入<code>noh</code>可还原  </p>
<p>vim注释多行<br>control + v<br>上下键/(j/k) 键选中操作的行<br>shift + i<br>输入<code>//</code> (视语言而定)<br>连续两次 ESC</p>
<p>取消多行注释<br>control + v<br>上下左右键 选中需要注释的符号<br>d</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/09/other/permission/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cas">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cas's website">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/09/other/permission/" class="post-title-link" itemprop="url">other/permission</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-09 17:14:16 / Modified: 17:13:54" itemprop="dateCreated datePublished" datetime="2020-01-09T17:14:16+08:00">2020-01-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="permission-denied"><a href="#permission-denied" class="headerlink" title="permission denied"></a>permission denied</h3><blockquote>
<p>有些时候, linux下执行/访问文件的时候, 都会报这个错</p>
<p>错误的原因是: 权限被拒绝, 那么linux的权限是怎么规定的?</p>
</blockquote>
<h3 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h3><blockquote>
<p>执行ll后, 显示的信息:</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-rwxrwxr-x 1 wd wd  8419 Nov  8 10:47 a.out</span><br><span class="line">-rw-rw-r-- 1 wd wd 60579 Oct 25 21:11 t</span><br><span class="line">-rw-rw-r-- 1 wd wd   272 Oct 25 21:11 t.cpp</span><br><span class="line">-rw-rw-r-- 1 wd wd   369 Nov  8 10:47 time.cpp</span><br><span class="line">-rw-rw-r-- 1 wd wd 71784 Oct 29 11:53 t.o</span><br><span class="line">-rw-rw-r-- 1 wd wd  5815 Oct 29 11:57 t.s</span><br></pre></td></tr></table></figure>
<p>其中 -rw-rw-r– 这一串代表的就是linux的文件权限, 一共有10个字符  </p>
<p>其中最开始的字符代表文件类型, 比如:  - 代表一般文件, l 代表链接文件</p>
<p>后面9个字符分为三部分, 分别代表: user(用户), group(组), other(其他)</p>
<p>每个部分有3个字符, 分别表示: r(read, 可读), w(write, 可写), x(execute 可执行)</p>
<p>如果某一部分没有这个权限, 则用 - 占位</p>
<p>因此可知 -rw-rw-r– 意为:</p>
<p>一般文件, 拥有者可读写, 同组用户可读写, 其他用户可读</p>
<h3 id="隐藏属性"><a href="#隐藏属性" class="headerlink" title="隐藏属性"></a>隐藏属性</h3><p>除此之外, linux的文件还有隐藏的属性</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[...]$ lsattr .</span><br><span class="line">-------------e- ./t.o</span><br><span class="line">-------------e- ./a.out</span><br><span class="line">-------------e- ./t.s</span><br><span class="line">-------------e- ./time.cpp</span><br><span class="line">-------------e- ./t</span><br><span class="line">-------------e- ./t.cpp</span><br></pre></td></tr></table></figure>
<p>通过lsattr(attribute), 可以查询文件的隐藏属性, 其中比较重要的属性有:</p>
<p>a: append, 只能添加, 不能更改和删除</p>
<p>i: 不能删除. 改名, 设置链接, 同时也无法写入和添加数据</p>
<p>属性的增加和删除, 可以通过chattr + - 来设置, 如果想直接赋予一个新的属性, 可以使用 = </p>
<h3 id="特殊权限"><a href="#特殊权限" class="headerlink" title="特殊权限"></a>特殊权限</h3><p>文件除此之外还有一些特殊的权限, SUID, SGID, SBIT</p>
<p>SUID位于user权限组: 拥有这个属性的文件, 最后一个字符位s, 例如: -rws——</p>
<p>​    SUID仅对二进制程序有效</p>
<p>​    SUID意为如果执行者拥有x权限, 当执行文件时, 执行者暂时拥有root权限</p>
<p>SGID位于group权限组: 拥有这个属性的文件, 最后一个字符位s, 例如: —-rws—</p>
<p>​    SGID意为如果执行者拥有x权限, 当执行文件时, 执行者暂时拥有用户组权限</p>
<p>SBIT位于other权限组:</p>
<p>​    SBIT仅对目录游泳: 拥有这个属性的文件, 最后一个字符位t, 例如: ——-rwt</p>
<p>​    SBIT意为: 当前面目录下, A仅仅只能删除(包括移动和重命名)A拥有的文件(文件持有者是A)</p>
<p>​        不能删除B的文件</p>
<p>以上来自鸟哥私房菜, 详细参照第二部分</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">cas</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">106</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">cas</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
