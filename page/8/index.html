<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Muse',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="cas&#39;s website">
<meta property="og:url" content="http://yoursite.com/page/8/index.html">
<meta property="og:site_name" content="cas&#39;s website">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="cas">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>cas's website</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">cas's website</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">casyup.me@outlook.com</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="Searching..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/09/other/permission/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cas">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cas's website">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/09/other/permission/" class="post-title-link" itemprop="url">other/permission</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-09 17:14:16 / Modified: 17:13:54" itemprop="dateCreated datePublished" datetime="2020-01-09T17:14:16+08:00">2020-01-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="permission-denied"><a href="#permission-denied" class="headerlink" title="permission denied"></a>permission denied</h3><blockquote>
<p>有些时候, linux下执行/访问文件的时候, 都会报这个错</p>
<p>错误的原因是: 权限被拒绝, 那么linux的权限是怎么规定的?</p>
</blockquote>
<h3 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h3><blockquote>
<p>执行ll后, 显示的信息:</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-rwxrwxr-x 1 wd wd  8419 Nov  8 10:47 a.out</span><br><span class="line">-rw-rw-r-- 1 wd wd 60579 Oct 25 21:11 t</span><br><span class="line">-rw-rw-r-- 1 wd wd   272 Oct 25 21:11 t.cpp</span><br><span class="line">-rw-rw-r-- 1 wd wd   369 Nov  8 10:47 time.cpp</span><br><span class="line">-rw-rw-r-- 1 wd wd 71784 Oct 29 11:53 t.o</span><br><span class="line">-rw-rw-r-- 1 wd wd  5815 Oct 29 11:57 t.s</span><br></pre></td></tr></table></figure>
<p>其中 -rw-rw-r– 这一串代表的就是linux的文件权限, 一共有10个字符  </p>
<p>其中最开始的字符代表文件类型, 比如:  - 代表一般文件, l 代表链接文件</p>
<p>后面9个字符分为三部分, 分别代表: user(用户), group(组), other(其他)</p>
<p>每个部分有3个字符, 分别表示: r(read, 可读), w(write, 可写), x(execute 可执行)</p>
<p>如果某一部分没有这个权限, 则用 - 占位</p>
<p>因此可知 -rw-rw-r– 意为:</p>
<p>一般文件, 拥有者可读写, 同组用户可读写, 其他用户可读</p>
<h3 id="隐藏属性"><a href="#隐藏属性" class="headerlink" title="隐藏属性"></a>隐藏属性</h3><p>除此之外, linux的文件还有隐藏的属性</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[...]$ lsattr .</span><br><span class="line">-------------e- ./t.o</span><br><span class="line">-------------e- ./a.out</span><br><span class="line">-------------e- ./t.s</span><br><span class="line">-------------e- ./time.cpp</span><br><span class="line">-------------e- ./t</span><br><span class="line">-------------e- ./t.cpp</span><br></pre></td></tr></table></figure>
<p>通过lsattr(attribute), 可以查询文件的隐藏属性, 其中比较重要的属性有:</p>
<p>a: append, 只能添加, 不能更改和删除</p>
<p>i: 不能删除. 改名, 设置链接, 同时也无法写入和添加数据</p>
<p>属性的增加和删除, 可以通过chattr + - 来设置, 如果想直接赋予一个新的属性, 可以使用 = </p>
<h3 id="特殊权限"><a href="#特殊权限" class="headerlink" title="特殊权限"></a>特殊权限</h3><p>文件除此之外还有一些特殊的权限, SUID, SGID, SBIT</p>
<p>SUID位于user权限组: 拥有这个属性的文件, 最后一个字符位s, 例如: -rws——</p>
<p>​    SUID仅对二进制程序有效</p>
<p>​    SUID意为如果执行者拥有x权限, 当执行文件时, 执行者暂时拥有root权限</p>
<p>SGID位于group权限组: 拥有这个属性的文件, 最后一个字符位s, 例如: —-rws—</p>
<p>​    SGID意为如果执行者拥有x权限, 当执行文件时, 执行者暂时拥有用户组权限</p>
<p>SBIT位于other权限组:</p>
<p>​    SBIT仅对目录游泳: 拥有这个属性的文件, 最后一个字符位t, 例如: ——-rwt</p>
<p>​    SBIT意为: 当前面目录下, A仅仅只能删除(包括移动和重命名)A拥有的文件(文件持有者是A)</p>
<p>​        不能删除B的文件</p>
<p>以上来自鸟哥私房菜, 详细参照第二部分</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/09/other/pointAndRefrence/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cas">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cas's website">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/09/other/pointAndRefrence/" class="post-title-link" itemprop="url">other/pointAndRefrence</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-09 17:14:16 / Modified: 17:12:51" itemprop="dateCreated datePublished" datetime="2020-01-09T17:14:16+08:00">2020-01-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近看了&lt;现代操作系统&gt;, 从内存管理那一章中获得了一些东西: 分页和分段  </p>
<p>其中分页的概念让我对内存的管理有了更加清晰的认知</p>
<h3 id="什么是分页"><a href="#什么是分页" class="headerlink" title="什么是分页?"></a>什么是分页?</h3><p>就是将内存分为一个个小的页面(以4k为例). </p>
<p>在将磁盘数据加载进内存时, 以页为单位, 而将内存中的数据换出到磁盘中时, 也以页为单位. </p>
<p>对此, 一个具体的虚拟地址可以分为两部分:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">页号 + 地址</span><br></pre></td></tr></table></figure>

<p>其中, 页号会被替换, 而地址会被保留:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">真实的地址 + 地址</span><br></pre></td></tr></table></figure>

<p>真实的地址存放到进程虚拟地址映射表中  </p>
<p>emmm… 也就是说, <strong>虚拟地址中, 有部分的地址是真实的</strong></p>
<p>(如果我能知道那部分假的地址, 是否就有办法操作真实磁盘中的数据呢? 我突然有了不太好的想法 :) )</p>
<h3 id="指针中是否会保留原始变量的地址"><a href="#指针中是否会保留原始变量的地址" class="headerlink" title="指针中是否会保留原始变量的地址?"></a>指针中是否会保留原始变量的地址?</h3><p>指针中存放了数据, 而这样的数据能够找到指针所指向的变量  </p>
<p>那么, 这样的数据是什么呢? 最直接的, 那么应该是地址, 考虑以下程序:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="number">11</span>     <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="number">12</span>     <span class="keyword">int</span> *p = &amp;i;</span><br><span class="line"><span class="number">13</span>     <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, &amp;i);</span><br><span class="line"><span class="number">14</span>     <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, &amp;p);</span><br><span class="line"><span class="number">15</span>     <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *((<span class="keyword">int</span> *)&amp;p));</span><br><span class="line"><span class="number">16</span> </span><br><span class="line"><span class="number">17</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">18</span> &#125;</span><br></pre></td></tr></table></figure>

<p>15打印的是指针本身内存中所指向的东西, 将它与变量i的地址做以下对比, 会相同么?  以下是输出结果:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x7fff12ca4efc</span><br><span class="line">0x7fff12ca4ef0</span><br><span class="line">315248380</span><br></pre></td></tr></table></figure>

<p>i的地址是 0x7fff12ca4efc, 而p中保存的值(我将它解释为整数)是: 315248380  </p>
<p>整型数字不怎么直观, 将它转为hex试试?  =&gt; 0x12ca4efc </p>
<p>有没有觉得熟悉?  0x7fff12ca4efc —– 0x12ca4efc   </p>
<p>除前面的 0x7fff, 后面的数字是一样的, 所以我们可以说指针保存了变量的地址, 但是并不准确  </p>
<p>那么 0x7fff 就是那个页号么? 指针中只会存放真是地址? 好像不那么对…</p>
<p>emmm… 好像可以继续尝试, 因为当前环境是32位的, 这个地址数字明显超出了32位的表现范围</p>
<p>(我居然忽略了这一点 = =…)</p>
<p>或许我能获得更多的数据? 在代码中加入了下面一行:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">16</span>     <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ((<span class="keyword">int</span> *)&amp;p)[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>

<p>得到了数据: 32767 =&gt; 0x7fff  </p>
<p>所以指针中直接保存了变量的地址(我们之前并没有拿到完全的数据, 地址超过了int的大小)  </p>
<p><strong>指针就是地址</strong></p>
<p>emmm… 好像这个笔记不是那么有意义做了…</p>
<p>我是不是太慢了? 这些东西应该是初学者就可以去钻研的内容</p>
<p>(@btw: 为什么是[1] 而不是 [-1])</p>
<h3 id="是否有办法知道哪些数据是与页号有关的"><a href="#是否有办法知道哪些数据是与页号有关的" class="headerlink" title="是否有办法知道哪些数据是与页号有关的?"></a>是否有办法知道哪些数据是与页号有关的?</h3><p>emmm… 那些东西与内核有关, 我现在没有办法获得</p>
<h3 id="其他的耦合知识-volatile"><a href="#其他的耦合知识-volatile" class="headerlink" title="其他的耦合知识: volatile"></a>其他的耦合知识: volatile</h3><p>在书中我还读到了一个非常有趣的知识, 那就是进程表项有一个<strong>是否缓存标志位</strong></p>
<p>这个标志位的意思是, 如果该位是1, 表示该页不被缓存  </p>
<p>意思是什么呢? 如果要访问的数据是在该页中的, 那么访问时会去访问磁盘  </p>
<p>而写入的时候, 也会直接往磁盘中写入, 因为内存中不缓存该页的数据</p>
<p>仔细想想和什么东西有关? 嗯, c++的 volatile 关键字</p>
<p>我打赌, volatile的实现一定与这东西有关(至少实现类似) 不过我现在的能力暂时无法证实</p>
<p>同时还有一个疑问, volatile 修饰一个变量, 而一个页是4k的, 如何将这两个东西分开呢? </p>
<h3 id="为什么是-1-而不是-1"><a href="#为什么是-1-而不是-1" class="headerlink" title="为什么是[1] 而不是 [-1]"></a>为什么是[1] 而不是 [-1]</h3><p>上面的例子中, 我继续访问数据, 使用的是 [1] 而不是 [-1]</p>
<p>我一开始是用 [-1], 因为栈是往下增长的, 之后发现 [1] 是正确的, 为什么?</p>
<p>的确实际上应该是 [1], 不然局部数组的访问就要乱套了 </p>
<p>但是栈的确是向下增长的, 从 fc 和 f0 中可以看出来 </p>
<p>那么底层到底对我的代码做了什么? 或许可以从汇编中得到答案</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">12 main:</span><br><span class="line">13 .LFB1079:</span><br><span class="line">14     .cfi_startproc</span><br><span class="line">15     .cfi_personality 0x3,__gxx_personality_v0</span><br><span class="line">16     pushq   %rbp</span><br><span class="line">17     .cfi_def_cfa_offset 16</span><br><span class="line">18     .cfi_offset 6, -16</span><br><span class="line">19     movq    %rsp, %rbp		&#x2F;&#x2F; 保存了栈底指针</span><br><span class="line">20     .cfi_def_cfa_register 6</span><br><span class="line">21     subq    $16, %rsp		&#x2F;&#x2F; 开拓栈帧, 16个字节</span><br><span class="line">22     movl    $1, -4(%rbp)		&#x2F;&#x2F; 嗯, 我们的数字1被放入内存了</span><br><span class="line">23     leaq    -4(%rbp), %rax	&#x2F;&#x2F; 将变量1的地址放入rax</span><br><span class="line">24     movq    %rax, -16(%rbp)	&#x2F;&#x2F; 将rax的值放入了栈... 栈顶?(因为这里是-16)</span><br><span class="line">25     leaq    -4(%rbp), %rax	&#x2F;&#x2F; 又将变量1的地址放入rax</span><br><span class="line">26     movq    %rax, %rsi		</span><br><span class="line">27     movl    $.LC0, %edi		&#x2F;&#x2F; .LC0:.string &quot;%p\n&quot;</span><br><span class="line">28     movl    $0, %eax			</span><br><span class="line">29     call    printf			&#x2F;&#x2F; rax存了变量1的地址, 这里应该对应: printf(&quot;%p\n&quot;, &amp;i);</span><br><span class="line">30     leaq    -16(%rbp), %rax	&#x2F;&#x2F; 将栈顶的地址放入了rax</span><br><span class="line">31     movq    %rax, %rsi		</span><br><span class="line">32     movl    $.LC0, %edi</span><br><span class="line">33     movl    $0, %eax</span><br><span class="line">34     call    printf			&#x2F;&#x2F; 现在rax是栈顶, 所以对应这一句: printf(&quot;%p\n&quot;, &amp;p);</span><br><span class="line">35     leaq    -16(%rbp), %rax	&#x2F;&#x2F; 把p的地址放入rax</span><br><span class="line">36     movl    (%rax), %eax		&#x2F;&#x2F; 又移动到eax</span><br><span class="line">37     movl    %eax, %esi		&#x2F;&#x2F; 还移动 &#x3D; &#x3D;</span><br><span class="line">38     movl    $.LC1, %edi		&#x2F;&#x2F; .LC1:.string &quot;%d\n&quot;</span><br><span class="line">39     movl    $0, %eax</span><br><span class="line">40     call    printf			&#x2F;&#x2F; 对应: printf(&quot;%d\n&quot;, ((int *)&amp;p)[0]);</span><br><span class="line">41     leaq    -16(%rbp), %rax	</span><br><span class="line">42     addq    $4, %rax			&#x2F;&#x2F; *将rax+4, 也就是往栈顶移动的</span><br><span class="line">43     movl    (%rax), %eax</span><br><span class="line">44     movl    %eax, %esi</span><br><span class="line">45     movl    $.LC1, %edi</span><br><span class="line">46     movl    $0, %eax</span><br><span class="line">47     call    printf			&#x2F;&#x2F; 对应: printf(&quot;%d\n&quot;, ((int *)&amp;p)[1]);</span><br><span class="line">48     movl    $0, %eax</span><br><span class="line">49     leave</span><br><span class="line">50     .cfi_def_cfa 7, 8</span><br><span class="line">51     ret</span><br><span class="line">52     .cfi_endproc</span><br></pre></td></tr></table></figure>

<p>那么了解了, 虽然栈是往下移动的, 分配栈帧时也是往下移动的  </p>
<p>但是 [1] 这种位移时, 是往上移动的, 也就是往高地址移动的</p>
<p>因为变量本身的地址开始是在栈的低地址, 是往上移动的  </p>
<p>没有问题, 是正常的 :)</p>
<p>但是我又发现一个问题, 这里指针所占用的空间为8字节!</p>
<p>不过又想了一下, 这好像也正常的, 毕竟64位嘛…</p>
<h3 id="引用呢-引用又是什么样子的呢"><a href="#引用呢-引用又是什么样子的呢" class="headerlink" title="引用呢? 引用又是什么样子的呢?"></a>引用呢? 引用又是什么样子的呢?</h3><p>时隔几天, 突然想到了这个东西, 引用又是什么样子的呢? 它和指针实质的区别?</p>
<p>参考以下代码:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;i2 = i;</span><br><span class="line"><span class="keyword">int</span> *pi = &amp;i;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p\n"</span>, &amp;i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p\n"</span>, &amp;i2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p\n"</span>, &amp;pi);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *pi);</span><br></pre></td></tr></table></figure>

<p>emmm… 这很简单, 分别打印地址和值</p>
<p>我们来看看汇编:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line">.LFB1084:</span><br><span class="line">    .cfi_startproc</span><br><span class="line">    .cfi_personality 0x3,__gxx_personality_v0</span><br><span class="line">    pushq   %rbp</span><br><span class="line">    .cfi_def_cfa_offset 16</span><br><span class="line">    .cfi_offset 6, -16</span><br><span class="line">    movq    %rsp, %rbp</span><br><span class="line">    .cfi_def_cfa_register 6</span><br><span class="line">    subq    $32, %rsp			&#x2F;&#x2F; 32字节的栈帧</span><br><span class="line">    movl    $100, -12(%rbp)		&#x2F;&#x2F; i</span><br><span class="line">    leaq    -12(%rbp), %rax		&#x2F;&#x2F; i 的地址放入了rax</span><br><span class="line">    movq    %rax, -8(%rbp)		&#x2F;&#x2F; 直接将 rax 的值放入了 i2, 也就是说, 引用也保存了变量的地址</span><br><span class="line">    leaq    -12(%rbp), %rax		&#x2F;&#x2F; 这是一个完全可以优化掉的操作</span><br><span class="line">    movq    %rax, -24(%rbp)		&#x2F;&#x2F; pi </span><br><span class="line">    leaq    -12(%rbp), %rax		&#x2F;&#x2F; 你家 rax 都没变过, 你怎么还来 (눈_눈)</span><br><span class="line">    movq    %rax, %rsi</span><br><span class="line">    movl    $.LC0, %edi</span><br><span class="line">    movl    $0, %eax</span><br><span class="line">    call    printf				&#x2F;&#x2F; &amp;i</span><br><span class="line">    movq    -8(%rbp), %rax		&#x2F;&#x2F; 这里直接将栈中的值放进入了</span><br><span class="line">    movq    %rax, %rsi</span><br><span class="line">    movl    $.LC0, %edi</span><br><span class="line">    movl    $0, %eax</span><br><span class="line">    call    printf				&#x2F;&#x2F; &amp;i2</span><br><span class="line">    leaq    -24(%rbp), %rax		&#x2F;&#x2F; 注意, 这是 lea</span><br><span class="line">    movq    %rax, %rsi</span><br><span class="line">    movl    $.LC0, %edi</span><br><span class="line">    movl    $0, %eax</span><br><span class="line">    call    printf				&#x2F;&#x2F; &amp;pi</span><br><span class="line">    movl    -12(%rbp), %eax</span><br><span class="line">    movl    %eax, %esi</span><br><span class="line">    movl    $.LC1, %edi</span><br><span class="line">    movl    $0, %eax</span><br><span class="line">    call    printf				&#x2F;&#x2F; i</span><br><span class="line">    movq    -8(%rbp), %rax		&#x2F;&#x2F; 直接将地址放入 rax</span><br><span class="line">    movl    (%rax), %eax		&#x2F;&#x2F; 将这个地址中的值放入了(即 i 的地址) eax</span><br><span class="line">    movl    %eax, %esi</span><br><span class="line">    movl    $.LC1, %edi</span><br><span class="line">    movl    $0, %eax</span><br><span class="line">    call    printf				&#x2F;&#x2F; i2</span><br><span class="line">    movq    -24(%rbp), %rax</span><br><span class="line">    movl    (%rax), %eax</span><br><span class="line">    movl    %eax, %esi</span><br><span class="line">    movl    $.LC1, %edi</span><br><span class="line">    movl    $0, %eax</span><br><span class="line">    call    printf				&#x2F;&#x2F; pi</span><br><span class="line">    movl    $0, %eax</span><br><span class="line">    leave</span><br><span class="line">    .cfi_def_cfa 7, 8</span><br><span class="line">    ret</span><br><span class="line">    .cfi_endproc</span><br></pre></td></tr></table></figure>

<p>引用和指针并无关键性的区别, 引用也会占用内存(废话 (눈_눈), 不过我记得培训时有个沙雕老师说不占)</p>
<p>当使用引用的值时, 它是像指针一样使用</p>
<p>而当对引用取地址时, 它是直接拿存储的数据, 而并非用存储的数据去寻址</p>
<p>(这应当是编译器的规定, 它这么编译了引用)</p>
<p>唯一不同是, 引用占了8字节, 这很合理, 但是为什么指针是12字节</p>
<p>(这是一个我在之前忽视了的点, 我曾看过那4字节中是什么, 结果是 0 </p>
<p>(用指针的时候, 也用的是 movq, 这意味着只使用了 64 位, 即 8 字节, 为什么中空了 4 字节?)</p>
<p>或许我可以再试试赋值的时候, 引用和指针的不同之处</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i2 = <span class="number">100</span>;</span><br><span class="line">*pi = <span class="number">111</span>;</span><br></pre></td></tr></table></figure>

<p>汇编:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line">.LFB1078:</span><br><span class="line">    .cfi_startproc</span><br><span class="line">    .cfi_personality 0x3,__gxx_personality_v0</span><br><span class="line">    pushq   %rbp			&#x2F;&#x2F; 通过压栈的方式保存bp</span><br><span class="line">    .cfi_def_cfa_offset 16</span><br><span class="line">    .cfi_offset 6, -16</span><br><span class="line">    movq    %rsp, %rbp		&#x2F;&#x2F; 它没有显示说明栈帧有多大, 让我有点不习惯 ∑(￣□￣;)</span><br><span class="line">    .cfi_def_cfa_register 6</span><br><span class="line">    movl    $2147483647, -20(%rbp)</span><br><span class="line">    leaq    -20(%rbp), %rax</span><br><span class="line">    movq    %rax, -16(%rbp)</span><br><span class="line">    leaq    -20(%rbp), %rax</span><br><span class="line">    movq    %rax, -8(%rbp)</span><br><span class="line">    movq    -16(%rbp), %rax</span><br><span class="line">    movl    $100, (%rax)	&#x2F;&#x2F; 它是用寄存器寻址的方式来赋值的</span><br><span class="line">    movq    -8(%rbp), %rax</span><br><span class="line">    movl    $111, (%rax)</span><br><span class="line">    movl    $0, %eax</span><br><span class="line">    leave</span><br><span class="line">    .cfi_def_cfa 7, 8</span><br><span class="line">    ret</span><br><span class="line">    .cfi_endproc</span><br></pre></td></tr></table></figure>

<p>也就是说, 赋值是一样的, 嗯, 完全一样 </p>
<h3 id="指针和引用的安全性"><a href="#指针和引用的安全性" class="headerlink" title="指针和引用的安全性"></a>指针和引用的安全性</h3><p>还记得为什么引用比指针安全么? 因为对于引用是像值一样去使用它, 它仅仅是别名  </p>
<p>(其实不是别名, 如你所见, 有些时候访问引用其实还是访问的是引用所占的内存)  </p>
<p>它不会出现意外的 delete, 因为管理了它本身数据的访问, 也不会出现一些指针原有的错误(空指针,  野指针…)  </p>
<p>我更倾向于: <strong>引用是一个加了顶层const的非空, 不可用于delete的指针</strong></p>
<h3 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h3><p>引用和指针的本质都是地址</p>
<h3 id="题外话-尝试篡改引用指向的对象"><a href="#题外话-尝试篡改引用指向的对象" class="headerlink" title="题外话: 尝试篡改引用指向的对象"></a>题外话: 尝试篡改引用指向的对象</h3><p>等等, 引用的内存也是在栈中的, 虽然 c++ 不让我用光明正大的方式修改它</p>
<p>但是, 既然是在栈中的数据, 那么, 我应该是可以改的, 那么就来试一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int i &#x3D; 100;</span><br><span class="line">int i2 &#x3D; 200;</span><br><span class="line">int &amp;ref_i &#x3D; i;</span><br><span class="line"></span><br><span class="line">long long *desc &#x3D; (long long *)(&amp;i) + 1;&#x2F;&#x2F; 经过计算, i 的地址往上 8 个字节就是引用对象的内存</span><br><span class="line">char arr[64];	</span><br><span class="line">sprintf(arr, &quot;%ld&quot;, &amp;i2);	&#x2F;&#x2F; 将 &amp;i2 解释为ld类型数据, 放入数组中</span><br><span class="line">string s(arr);				&#x2F;&#x2F; 构建string对象, 主要是为了能使用 stoll (눈_눈)</span><br><span class="line"></span><br><span class="line">printf(&quot;%d\n&quot;, ref_i);		&#x2F;&#x2F; 100</span><br><span class="line">*desc &#x3D; stoll(s);			&#x2F;&#x2F; 现在, 它里面存储的数据是 i2 的地址了</span><br><span class="line">printf(&quot;%d\n&quot;, ref_i);		&#x2F;&#x2F; 200  成功了, 它指向了 i2  (￣ˇ￣)</span><br><span class="line">i2 &#x3D; 300;</span><br><span class="line">printf(&quot;%d\n&quot;, ref_i);		&#x2F;&#x2F; 300 再次验证, 没错, 我们更改了引用指向的对象</span><br></pre></td></tr></table></figure>

<p>汇编就不用看了, 因为这个程序就是根据自己脑补汇编中的样子来编写的</p>
<p>同理, 常量, 常量指针, 这些东西只要绕过编译器设的障碍就可以修改 (突然感受到了指针的魅力)</p>
<p>注: 经测试, 代码在 4.4 版本下的编译器可以, 而 4.8 版本的就不行</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/09/other/sed/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cas">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cas's website">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/09/other/sed/" class="post-title-link" itemprop="url">other/sed</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-09 17:14:16 / Modified: 17:13:54" itemprop="dateCreated datePublished" datetime="2020-01-09T17:14:16+08:00">2020-01-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h1><p>sed常用于处理文件, 它会逐行执行</p>
<h3 id="基础选项"><a href="#基础选项" class="headerlink" title="基础选项"></a>基础选项</h3><h4 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h4><p>s选项用于替换</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed 's/text/val/' f.txt</span><br></pre></td></tr></table></figure>

<p>以上语句会将 f.txt 文本中的 text 替换成 val</p>
<p>@note: 但实际不会更改文件内容, 而仅仅是替换后打印出来</p>
<p>​    如果想作用于文件, 需要结合 -i 参数</p>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>d选项删除</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed '/text/d' f.txt</span><br></pre></td></tr></table></figure>

<p>以上语句会将f.txt 文本中出现 text 的行删除</p>
<p>@btw: 为什么这里的 d 在后面?</p>
<h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><p>c选项用于修改</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'/text/c test2'</span> f.txt</span><br></pre></td></tr></table></figure>

<p>以上语句会将f.txt 文本中出现 text 的行修改成 test2</p>
<p>@note: 修改会修改整个一行</p>
<p>@btw: </p>
<p>​    从语义上来讲的话, 貌似理解成替换要合理一些. 因为是替换掉了整个一行</p>
<p>​    但是 c 选项的完整单词是 change(修改), 而 s 选项的完整单词是 substitute(替换)</p>
<p>​    所以, 遵从编写者的原意, 这里理解为修改整个一行</p>
<h4 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h4><p>y选项用于处理单个字符的转换</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed 'y/10/22/' f.txt</span><br></pre></td></tr></table></figure>

<p>以上语句会将f.txt 文本中出现的 1 转换成2, 同时 0 也会转换成 2 </p>
<p>@note: 可以将命令置于文件中, 然后使用 -f 选项指定文件</p>
<p>@btw: 替换类型的命令都是将选项置于行首, 其余均是置于行尾</p>
<h4 id="取反"><a href="#取反" class="headerlink" title="取反"></a>取反</h4><p>! 选项用于取反</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed '/text/!d' f.txt</span><br></pre></td></tr></table></figure>

<p>删除不包含 text 文本的行</p>
<p>@btw: 如果SQL也能直接取反结果集就好了 = =</p>
<h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><h4 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h4><p>n选项用于移动到下一行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed '/text val/&#123;n;d&#125;' f.txt</span><br></pre></td></tr></table></figure>

<p>当这条语句匹配到 text val 时, 会跳转到下一行, 然后删除行(删除的是匹配行的下一行)</p>
<h4 id="合并两行"><a href="#合并两行" class="headerlink" title="合并两行"></a>合并两行</h4><p>N选项用于将两行的数据视为一行来处理</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed '/text val/&#123;N;d&#125;' f.txt</span><br></pre></td></tr></table></figure>

<p>这条语句会将匹配行, 及匹配行的下一行, 当做一行处理(一起删掉)</p>
<p>@btw: 同样的格式还有</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed 'N; /text val/d' f.txt</span><br></pre></td></tr></table></figure>

<p>它会完成和上个指令一样的操作</p>
<h4 id="选择性删除"><a href="#选择性删除" class="headerlink" title="选择性删除"></a>选择性删除</h4><p>D选项… 怎么说呢 = = , 看实例吧</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed '/text val/&#123;N;/val text/D&#125;' f.txt</span><br></pre></td></tr></table></figure>

<p>当某一行有 text val 时, 并且下一行有 val text 时</p>
<p>D选项会删除前一个匹配行(也就是说 text val 所在的行会被删除)</p>
<h4 id="多行打印"><a href="#多行打印" class="headerlink" title="多行打印"></a>多行打印</h4><p>emmmm, 略(并不是说不会, 而是感觉没什么用)</p>
<p>(N和D其实运用上已经很少了, P就更少了…)</p>
<h3 id="保持空间"><a href="#保持空间" class="headerlink" title="保持空间"></a>保持空间</h3><p>emmmm, 略</p>
<p>(倒不是说保持空间没用, 相反, 保持空间在某些特定的场合)</p>
<p>(它能起到独一无二的作用, 但是现在对于我来说, 了解一下就好 = =)</p>
<h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>b选项用于跳过一些分支(b完整的单词是 branch, 但是我觉得 break 怎么更好 = =)</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed '&#123;2, 3b; s/10/\\/&#125;' f.txt</span><br></pre></td></tr></table></figure>

<p>命令会将 10 替换成 \ , 但是会跳过 2 - 3 行</p>
<p>@btw: 分支可以指定标识符, 就像goto一样. 这里就直接给一个书上的例子</p>
<p><img src="https://i.imgur.com/aKj1l7Q.png" alt=""></p>
<p>emmmm, 将第一行标记(其实也只有第一行)</p>
<p>每次将一个逗号删除(其实是替换), 循环替换</p>
<p>@btw:</p>
<p>​    看似很厉害, 实则没啥用, 因为可以用 g </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">```shell</span><br><span class="line">'s/,//g'</span><br><span class="line">```</span><br></pre></td></tr></table></figure>

<p>​    上述选项将会做出同样的效果</p>
<p>​    emmm, 我是不是忘了说 g ?</p>
<p>​    g 代表修改会作用于一整行, 当然 也可以使用数字来指定</p>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>略</p>
<h3 id="模式替代"><a href="#模式替代" class="headerlink" title="模式替代"></a>模式替代</h3><h4 id="通配符-amp"><a href="#通配符-amp" class="headerlink" title="通配符 &amp;"></a>通配符 &amp;</h4><p>&amp; 用于匹配模式</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed 's/.0/"&amp;"/g' f.txt</span><br></pre></td></tr></table></figure>

<p>&amp; 匹配整个模式, 以上语句将会用 “” 把所有 0 及 0前面 的支付括起来</p>
<p>也可以使用单个模式</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed 's/\(.\)\(0\)/\1 32/g' f.txt</span><br></pre></td></tr></table></figure>

<p>() 括起来的部分视为一个模式, \1 引用一个模式</p>
<p>上述语句将会把所有以 .0 的语句替换为 . 32 </p>
<p>@note: </p>
<p>​    这个例子将会只保留 . 匹配的内容, 而 &amp; 将会保留所有内容</p>
<p>​    &amp; 模式匹配是我在进阶章里面看到的最有用的东西</p>
<p>emmm, 关于 sed 的内容还有一些, 不过现在就先到这里吧 = =</p>
<p>@supplement</p>
<p>​    模式匹配: 增/删/改中可以运用模式匹配</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed '/test/i\this is a test' t.txt</span><br></pre></td></tr></table></figure>

<p>​    这条语句将会在有 test 字符串的那一行, 执行插入操作</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/09/other/some%20useful%20define/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cas">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cas's website">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/09/other/some%20useful%20define/" class="post-title-link" itemprop="url">other/some useful define</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-09 17:14:16 / Modified: 17:13:31" itemprop="dateCreated datePublished" datetime="2020-01-09T17:14:16+08:00">2020-01-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="保留条件表达式的第一个值"><a href="#保留条件表达式的第一个值" class="headerlink" title="保留条件表达式的第一个值"></a>保留条件表达式的第一个值</h2><pre><code>// CE: condition expression, RETAIN: 保持
#define CE_RETAIN1(a, b) ((a) ? (a) : (b))</code></pre><p>考虑一个情况, 当一个值有效时, 使用它, 否则使用另外一个数<br>如果直接写的话, 不太容易理解  </p>
<pre><code>(exp) ? (exp) : -1;</code></pre><p>当exp非常长的时候(或许可以保存成变量, 但是某些情况下, 不知道该用什么名字<br>而自己比较常用变量名差不多用光了, 或者这只是个只用一次的值), 如  </p>
<pre><code>val = func(a) * i + 10 ? func(a) * i + 10 : -1;</code></pre><p>而如果用宏定义的话就比较清晰了</p>
<pre><code>val = CE_RETAIN1(func(a) * i + 10, -1);</code></pre><p>PS: 但是如果的确出现表达式过长的情况, 可能考虑优化代码是最好的解决方案</p>
<h2 id="直接面向结果的函数"><a href="#直接面向结果的函数" class="headerlink" title="直接面向结果的函数"></a>直接面向结果的函数</h2><pre><code>void show() { setvisible(true); }    
void hide() { setvisible(false); }</code></pre><p>使用show(), hide()的情况下, 一目了然, 而通过参数的话, 理解会稍麻烦一些</p>
<h2 id="getInstance"><a href="#getInstance" class="headerlink" title="getInstance"></a>getInstance</h2><p>getInstance多数情况下作为一个类的公有接口, 用于获得一个实例<br>普通的书写方案如下        </p>
<pre><code>class A{
    int i; // 不仅仅是数据, 也可能是一个类
public:
    int&amp; getInstance() { return i; }
};</code></pre><p>使用这种方式的情况会存在两个问题  </p>
<ol>
<li>即使我从不使用i, 也从未掉用过getInstance这个函数, 但依旧给i分配了空间  </li>
<li>i依旧能在其他接口中被访问  </li>
</ol>
<p>上述两种情况并不一定会造成影响, 但可以考虑排除这种隐藏问题  </p>
<pre><code>int&amp; getInstance() {
    static int i;

    return i;
}</code></pre><p>静态变量在未被访问过的情况下, 不会分配空间<br>并且只存在于当前作用域, 有良好的安全性</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/09/other/some%20useful%20skill/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cas">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cas's website">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/09/other/some%20useful%20skill/" class="post-title-link" itemprop="url">other/some useful skill</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-09 17:14:16 / Modified: 17:13:31" itemprop="dateCreated datePublished" datetime="2020-01-09T17:14:16+08:00">2020-01-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="保留条件表达式的第一个值"><a href="#保留条件表达式的第一个值" class="headerlink" title="保留条件表达式的第一个值"></a>保留条件表达式的第一个值</h2><pre><code>// CE: condition expression, RETAIN: 保持
#define CE_RETAIN1(a, b) ((a) ? (a) : (b))</code></pre><p>考虑一个情况, 当一个值有效时, 使用它, 否则使用另外一个数<br>如果直接写的话, 不太容易理解  </p>
<pre><code>(exp) ? (exp) : -1;</code></pre><p>当exp非常长的时候(或许可以保存成变量, 但是某些情况下, 不知道该用什么名字<br>而自己比较常用变量名差不多用光了, 或者这只是个只用一次的值), 如  </p>
<pre><code>val = func(a) * i + 10 ? func(a) * i + 10 : -1;</code></pre><p>而如果用宏定义的话就比较清晰了</p>
<pre><code>val = CE_RETAIN1(func(a) * i + 10, -1);</code></pre><p>PS: 但是如果的确出现表达式过长的情况, 可能考虑优化代码是最好的解决方案</p>
<h2 id="直接面向结果的函数"><a href="#直接面向结果的函数" class="headerlink" title="直接面向结果的函数"></a>直接面向结果的函数</h2><pre><code>void show() { setvisible(true); }    
void hide() { setvisible(false); }</code></pre><p>使用show(), hide()的情况下, 一目了然, 而通过参数的话, 理解会稍麻烦一些</p>
<h2 id="getInstance"><a href="#getInstance" class="headerlink" title="getInstance"></a>getInstance</h2><p>getInstance多数情况下作为一个类的公有接口, 用于获得一个实例<br>普通的书写方案如下        </p>
<pre><code>class A{
    int i; // 不仅仅是数据, 也可能是一个类
public:
    int&amp; getInstance() { return i; }
};</code></pre><p>使用这种方式的情况会存在两个问题  </p>
<ol>
<li>即使我从不使用i, 也从未掉用过getInstance这个函数, 但依旧给i分配了空间  </li>
<li>i依旧能在其他接口中被访问  </li>
</ol>
<p>上述两种情况并不一定会造成影响, 但可以考虑排除这种隐藏问题  </p>
<pre><code>int&amp; getInstance() {
    static int i;

    return i;
}</code></pre><p>静态变量在未被访问过的情况下, 不会分配空间<br>并且只存在于当前作用域, 有良好的安全性</p>
<h2 id="保存变量"><a href="#保存变量" class="headerlink" title="保存变量"></a>保存变量</h2><p>局部变量速度优于函数调用, 类似如果频繁用到数组的长度, 可以使用变量保存.size()的值</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/09/other/sort/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cas">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cas's website">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/09/other/sort/" class="post-title-link" itemprop="url">other/sort</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-09 17:14:16 / Modified: 17:13:31" itemprop="dateCreated datePublished" datetime="2020-01-09T17:14:16+08:00">2020-01-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="https://www.hackerearth.com/zh/practice/algorithms/sorting/bubble-sort/tutorial/" target="_blank" rel="noopener">source link</a></p>
<h2 id="Sort"><a href="#Sort" class="headerlink" title="Sort"></a>Sort</h2><h3 id="Bubble-Sort"><a href="#Bubble-Sort" class="headerlink" title="Bubble Sort"></a>Bubble Sort</h3><p>Bubble is the most common algorithm to sort an array. It based on the idea of repeatedly comparing adjacent element and then swapping their  value if exist in the wrong order </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[j])</span><br><span class="line">                swap(nums[i], nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Selection-sort"><a href="#Selection-sort" class="headerlink" title="Selection sort"></a>Selection sort</h3><p>The selection sort is based on finding the minimum or maximum in an unsorted array and putting it to a sorted array</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">min</span> = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[<span class="built_in">min</span>] &gt; nums[j])</span><br><span class="line">                <span class="built_in">min</span> = j;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums[i], nums[<span class="built_in">min</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Insertion-sort"><a href="#Insertion-sort" class="headerlink" title="Insertion sort"></a>Insertion sort</h3><p>From left to right, find each element’s correct position</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = nums[i];</span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        <span class="keyword">while</span>(j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            nums[j] = nums[j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &lt;= v)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            --j;                            </span><br><span class="line">        &#125;</span><br><span class="line">        nums[j] = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Merge-sort"><a href="#Merge-sort" class="headerlink" title="Merge sort"></a>Merge sort</h3><p>Merge sort is a divide-and-conquer algorithm based on repeatedly breaking down an array to two sub-array and then merge them</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> b, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = (b + e) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> q = m + <span class="number">1</span>, p = b;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = b; i &lt;= e; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p &gt; m)</span><br><span class="line">            v.push_back(nums[q++]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (q &gt; e)</span><br><span class="line">            v.push_back(nums[p++]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[q] &gt; nums[p])</span><br><span class="line">            v.push_back(nums[p++]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            v.push_back(nums[q++]);              </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> val : v)</span><br><span class="line">        nums[b++] = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> b, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b &gt;= e) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    mergeSort(nums, b, (e + b) / <span class="number">2</span>);</span><br><span class="line">    mergeSort(nums, (e + b) / <span class="number">2</span> + <span class="number">1</span>, e);</span><br><span class="line">    merge(nums, b, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Quick-sort"><a href="#Quick-sort" class="headerlink" title="Quick sort"></a>Quick sort</h3><p>Quick sort is also a divide-and-conquer algorithm. But it reduces the space complexity and removes the use of auxiliary array that is used in merger sort<br>One of the most important factors to influence performance is the pivot.<br>I chose the pivot from the middle, front, and back of the array. Sometimes will improve performance</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partion</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> b, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = e;</span><br><span class="line">    <span class="keyword">int</span> m = (b + e) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (nums[b] &gt; nums[m])</span><br><span class="line">        swap(nums[b], nums[m]);</span><br><span class="line">    <span class="keyword">if</span> (nums[b] &gt; nums[e])</span><br><span class="line">        swap(nums[b], nums[e]);</span><br><span class="line">    <span class="keyword">if</span> (nums[m] &gt; nums[e])</span><br><span class="line">        swap(nums[m], nums[e]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> piv = nums[m];</span><br><span class="line">    swap(nums[e--], nums[m]);</span><br><span class="line">    <span class="keyword">while</span> (b &lt; e) &#123;</span><br><span class="line">        <span class="keyword">while</span> (b &lt; e &amp;&amp; nums[b] &lt; piv)</span><br><span class="line">            ++b;</span><br><span class="line">        <span class="keyword">while</span> (b &lt; e &amp;&amp; nums[e] &gt;= piv)</span><br><span class="line">            --e;</span><br><span class="line">        <span class="keyword">if</span> (b &gt;= e) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        swap(nums[b], nums[e]);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(nums[p], nums[b]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> b, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b &gt;= e) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> p = partion(nums, b, e);</span><br><span class="line">    quickSort(nums, b, p - <span class="number">1</span>);</span><br><span class="line">    quickSort(nums, p + <span class="number">1</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Heap-sort"><a href="#Heap-sort" class="headerlink" title="Heap sort"></a>Heap sort</h3><p>Heap sort uses a structure called heap to sort the array. Heap is a complete binary tree.<br>left sub-tree index = 2 * root index + 1<br>right sub-tree index = 2 * root index + 2</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> n, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> largest = i;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> r = l + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l &lt; n &amp;&amp; nums[l] &gt; nums[largest])</span><br><span class="line">        largest = l;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r &lt; n &amp;&amp; nums[r] &gt; nums[largest])</span><br><span class="line">        largest = r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">        swap(nums[i], nums[largest]);</span><br><span class="line">        heapify(nums, n, largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;                </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.<span class="built_in">size</span>() / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        heapify(nums, nums.<span class="built_in">size</span>(), i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        swap(nums[<span class="number">0</span>], nums[i]);</span><br><span class="line">        heapify(nums, i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/09/other/sort2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cas">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cas's website">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/09/other/sort2/" class="post-title-link" itemprop="url">other/sort2</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-09 17:14:16 / Modified: 17:13:31" itemprop="dateCreated datePublished" datetime="2020-01-09T17:14:16+08:00">2020-01-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>this is a follow-up to <a href="http://49.235.55.145/html_note/sort.html" target="_blank" rel="noopener">sort</a></p>
<p>these sort algorithms based on &lt;Algorithms, 4th&gt;</p>
<h2 id="shell-sort"><a href="#shell-sort" class="headerlink" title="shell sort"></a>shell sort</h2><p>shell sort is a better version sort algorithm based on insert sort.</p>
<p>when a[0] is the biggest number but head of array, for move the number to the end of the array, need swap length(a) elements. </p>
<p>shell sort 是基于插入排序的改良版本</p>
<p>当 a[0] 是整个数组最大的元素时, 为了移动这个元素到数组的尾端, 需要交换 length(a) 次元素. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (h &lt; v.<span class="built_in">size</span>() / <span class="number">3</span>) h = h * <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (h &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = h; j &lt; v.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = j; i &gt;= h &amp;&amp; v[i] &lt; v[i - h]; i -= h)</span><br><span class="line">                swap(v[i], v[i - h]);                         </span><br><span class="line">        &#125;</span><br><span class="line">        h /= <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="bottom-up-sort"><a href="#bottom-up-sort" class="headerlink" title="bottom-up sort"></a>bottom-up sort</h2><p>bottom-up sort is a down-top method based on merge sort.</p>
<p>bottom-up sort 基于合并排序, 是一种从底至上的方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v, <span class="keyword">int</span> b, <span class="keyword">int</span> m, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2 = v;</span><br><span class="line">    <span class="keyword">int</span> mid = m++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = b; i &lt;= e; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &gt; mid)</span><br><span class="line">            v[i] = v2[m++];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (m &gt; e)</span><br><span class="line">            v[i] = v2[b++];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (v2[b] &lt; v2[m])</span><br><span class="line">            v[i] = v2[b++];</span><br><span class="line">        <span class="keyword">else</span>·</span><br><span class="line">            v[i] = v2[m++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bottomupSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; v.<span class="built_in">size</span>(); i *= <span class="number">2</span>)&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; v.<span class="built_in">size</span>() - i; j = j + <span class="number">2</span> * i)</span><br><span class="line">			merge(v, j, j + i <span class="number">-1</span>, <span class="built_in">min</span>(<span class="keyword">int</span>(v.<span class="built_in">size</span>() - <span class="number">1</span>, j + <span class="number">2</span> * i - <span class="number">1</span>)));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="a-better-version-of-quick-sort"><a href="#a-better-version-of-quick-sort" class="headerlink" title="a better version of quick sort"></a>a better version of quick sort</h2><p>if an array with some duplicate numbers,  skip these numbers will be more effective</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QS_MIN_LENGTH 7</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> b, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b &gt;= e) <span class="keyword">return</span>;                          </span><br><span class="line"></span><br><span class="line">    <span class="comment">// if element too little, insertSort more effective than quickSort</span></span><br><span class="line">    <span class="keyword">if</span> (e - b &lt; QS_MIN_LENGTH)</span><br><span class="line">        insertSort(nums, b, e);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// meduim of three can get more effetive pivot</span></span><br><span class="line">    <span class="keyword">int</span> m = (b + e) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (nums[b] &gt; nums[m])</span><br><span class="line">        swap(nums[b], nums[m]);</span><br><span class="line">    <span class="keyword">if</span> (nums[b] &gt; nums[e])</span><br><span class="line">        swap(nums[b], nums[e]);</span><br><span class="line">    <span class="keyword">if</span> (nums[m] &gt; nums[e])</span><br><span class="line">        swap(nums[m], nums[e]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pivot = nums[m];</span><br><span class="line">    <span class="comment">// skip elements equal pivot</span></span><br><span class="line">    <span class="keyword">int</span> lt = b + <span class="number">1</span>, eq = lt, gt = e - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (eq &lt;= gt) &#123; </span><br><span class="line">        <span class="keyword">if</span> (nums[eq] &lt; pivot)</span><br><span class="line">            swap(nums[lt++], nums[eq++]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[eq] &gt; pivot)</span><br><span class="line">            swap(nums[eq], nums[gt--]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            eq++;</span><br><span class="line">    &#125;       </span><br><span class="line"></span><br><span class="line">    quickSort(nums, b, lt - <span class="number">1</span>);</span><br><span class="line">    quickSort(nums, gt + <span class="number">1</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="a-sort-algorithm-without-compare"><a href="#a-sort-algorithm-without-compare" class="headerlink" title="a sort algorithm without compare"></a>a sort algorithm without compare</h3><p>I saw a string sort algorithm without compare in &lt;algorithm 4th&gt;. so take some notes</p>
<p>I’m to lazy to write this code, please check the book…</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/09/other/useful%20skill/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cas">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cas's website">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/09/other/useful%20skill/" class="post-title-link" itemprop="url">other/useful skill</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-09 17:14:16 / Modified: 17:13:54" itemprop="dateCreated datePublished" datetime="2020-01-09T17:14:16+08:00">2020-01-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="vim中执行cmd"><a href="#vim中执行cmd" class="headerlink" title="vim中执行cmd"></a>vim中执行cmd</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!cmd</span><br></pre></td></tr></table></figure>



<h4 id="vim中编写额外的文件"><a href="#vim中编写额外的文件" class="headerlink" title="vim中编写额外的文件"></a>vim中编写额外的文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">args filename</span><br></pre></td></tr></table></figure>



<h4 id="sed处理文件"><a href="#sed处理文件" class="headerlink" title="sed处理文件"></a>sed处理文件</h4><h4 id="at和crontab定时"><a href="#at和crontab定时" class="headerlink" title="at和crontab定时"></a>at和crontab定时</h4><h4 id="流重定向"><a href="#流重定向" class="headerlink" title="流重定向"></a>流重定向</h4><p>“&gt;”:  输出重定向, 这个操作符会覆盖已有文件的内容, 若文件不存在, 则创建</p>
<p>“&gt;&gt;”: 同样也是输出重定向, 这个操作符会将内容添加到文件尾部, 同样的, 若文件不存在, 则创建文件</p>
<p>@note:</p>
<p>​    比较特殊的是内联输入重定向: “&lt;&lt;”, 我现在也不太明白这东西的实质用法和含义</p>
<p>​    只知道它的行为: 它可以使用命令行的内容作为输入流, 并且可以指定一个”标识”来表示结束</p>
<h4 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h4><p>@brief: </p>
<p>​    将一个命令的输出作为另一个命令的输入. 例如:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat file | less</span><br></pre></td></tr></table></figure>

<p>cat仅仅只是查看文件, 但并不会增加一些控制功能(如翻页, 搜索…)  </p>
<p>less则提供了相关的更高级的功能, 将cat的输入(文件内容)作为less的输入</p>
<p>@note: </p>
<p>​    其实这个例子很没有必要, 现实中这么写, 可能会被diss到死. 因为可以直接使用 less file</p>
<h4 id="创建一个新文件"><a href="#创建一个新文件" class="headerlink" title="创建一个新文件"></a>创建一个新文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch file</span><br></pre></td></tr></table></figure>



<h4 id="置空文件内容"><a href="#置空文件内容" class="headerlink" title="置空文件内容"></a>置空文件内容</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /dev/null &gt; file</span><br></pre></td></tr></table></figure>

<p>@note: </p>
<p>​    更加简便的方式是 &gt; file</p>
<h4 id="单引号和双引号"><a href="#单引号和双引号" class="headerlink" title="单引号和双引号"></a>单引号和双引号</h4><p>需要注意的是, 单引号中, 双引号不需要转义.</p>
<p>同样的, 双引号中, 单引号不需要转义</p>
<p>这会在某些场合下, 让你的字符串更加简洁易懂, 同时还更好改, 更不容易写错</p>
<p>@ps:</p>
<p>​    我曾在一次 crontab 任务中遇到这种场合, 我使用了 crontab file 的形式来添加任务</p>
<p>​    同时使用 echo + 重定向 的形式往文件中添加内容, 而要执行的命令中就包含些许单引号和双引号</p>
<p>​    (不过我倒是没有在这里面用到这个技巧, 因为我第一次就写对了 :) )</p>
<h4 id="md5加密"><a href="#md5加密" class="headerlink" title="md5加密"></a>md5加密</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo "test" | md5sum</span><br></pre></td></tr></table></figure>



<h4 id="查看自己的公网信息"><a href="#查看自己的公网信息" class="headerlink" title="查看自己的公网信息"></a>查看自己的公网信息</h4><pre><code>curl cip.cc</code></pre><p>简析: curl 为一个在服务器中传递数据的攻击, 而 cip.cc 为一个查询网络信息的网站  </p>
<p>当你登录 cip.cc 时, 它应当会根据你访问网站时的信息, 查询你 IP 的相关信息, 并返还给你</p>
<h4 id="传递大量文件-远端和本地"><a href="#传递大量文件-远端和本地" class="headerlink" title="传递大量文件(远端和本地)"></a>传递大量文件(远端和本地)</h4><pre><code>rsync</code></pre><p>具体用法参照 man 手册</p>
<h4 id="查看本地IP端口信息"><a href="#查看本地IP端口信息" class="headerlink" title="查看本地IP端口信息"></a>查看本地IP端口信息</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -tunlp</span><br></pre></td></tr></table></figure>

<p>t : TCP</p>
<p>u : UDP</p>
<p>n : 不经过域名服务器</p>
<p>l : 显示监控中服务器的socket</p>
<p>p : 显示监控中的程序识别码和名称    </p>
<p>@btw: 可以加入 -a 选项, 这会将所有(包括当前未监听)的端口信息都列出来</p>
<p>​    与之相关的命令还有 nmap, nc</p>
<h4 id="查看本机服务"><a href="#查看本机服务" class="headerlink" title="查看本机服务"></a>查看本机服务</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service --status-all | grep running</span><br></pre></td></tr></table></figure>

<p>这个命令可以查看本机现在运行的所有服务</p>
<p>@note: –status-all 之间不能空格.  “–status -all” 这是错误的写法</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/09/other/virtualFunction/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cas">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cas's website">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/09/other/virtualFunction/" class="post-title-link" itemprop="url">other/virtualFunction</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-09 17:14:16 / Modified: 17:12:51" itemprop="dateCreated datePublished" datetime="2020-01-09T17:14:16+08:00">2020-01-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>想深入了解一下(或者说验证)对象底层是如何工作的</p>
<p>重点是虚函数的调用, 虚指针的生成, 虚表中的数据</p>
<p>以及这些数据在多重继承, 虚继承, 多重虚继承环境下的表现</p>
<h3 id="虚指针-virtual-point"><a href="#虚指针-virtual-point" class="headerlink" title="虚指针(virtual point)"></a>虚指针(virtual point)</h3><p>考虑以下代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"A %d\n"</span>, _i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"A2 %d\n"</span>, _i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> _i = <span class="number">10</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"B %d\n"</span>, _i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> _i = <span class="number">20</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    A *pa = &amp;b;</span><br><span class="line">    </span><br><span class="line">    pa-&gt;func();		<span class="comment">// B 20</span></span><br><span class="line">    pa-&gt;func2();	<span class="comment">// A2 10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出和预期一致, 其中 func 是被 B 覆盖过的虚函数, 而 func2 则未被覆盖</p>
<p>以下是生成的汇编代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line">.LFB1199:</span><br><span class="line">    pushq   %rbp</span><br><span class="line">    movq    %rsp, %rbp</span><br><span class="line">    subq    $32, %rsp</span><br><span class="line">    movq    $_ZTV1B+16, -32(%rbp)	&#x2F;&#x2F; 又是这个东西, 现在我怀疑它是 lippman 说的 thunk</span><br><span class="line">    							&#x2F;&#x2F; 后面知道了, **其实这就是虚指针, 它被放到了头部**</span><br><span class="line">    							&#x2F;&#x2F; 编译器非常聪明, 在即使有 vptr, nontrivial 的情况下</span><br><span class="line">    							&#x2F;&#x2F; 也并未生成构造函数</span><br><span class="line">    movl    $10, -24(%rbp)	</span><br><span class="line">    movl    $20, -20(%rbp)</span><br><span class="line">    leaq    -32(%rbp), %rax</span><br><span class="line">    movq    %rax, -8(%rbp)</span><br><span class="line">    movq    -8(%rbp), %rax</span><br><span class="line">    movq    (%rax), %rax	&#x2F;&#x2F; rax &#x3D; vptr	拿到虚指针地址</span><br><span class="line">    movq    (%rax), %rax	&#x2F;&#x2F; rax &#x3D; *vptr	获得虚指针中的地址(槽 0)</span><br><span class="line">    movq    -8(%rbp), %rdx	&#x2F;&#x2F; member data 是直接位移得到的</span><br><span class="line">    movq    %rdx, %rdi</span><br><span class="line">    call    *%rax		&#x2F;&#x2F; 调用slot0</span><br><span class="line">    movq    -8(%rbp), %rax</span><br><span class="line">    movq    (%rax), %rax</span><br><span class="line">    addq    $8, %rax	&#x2F;&#x2F; 虚指针地址 +8 位移(也就是下一个槽)</span><br><span class="line">    movq    (%rax), %rax	&#x2F;&#x2F; 获得 slot1 的地址</span><br><span class="line">    movq    -8(%rbp), %rdx</span><br><span class="line">    movq    %rdx, %rdi</span><br><span class="line">    call    *%rax	&#x2F;&#x2F; 调用slot1</span><br><span class="line">    movl    $0, %eax</span><br><span class="line">    leave</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>

<p>所以调用方式和书中一致, 从 vptr 索引虚表, 获得相应的 slot</p>
<p>这些信息全部都是在编译的时候由编译器生成</p>
<p>有一个点我忽略了: <strong>单一继承对象只有一个虚表</strong></p>
<p>后续我加上 C 对象后( C 继承自 A ), 让 B 继承 A, 这样A中就有 B C</p>
<p>但是依旧只有一个虚表, 仅当我让A再继承一个对象时, 这时产生了 2 个虚表</p>
<p>可能会问, 那么C对象是如何通过 pc-&gt;A::func() 这样的形式来调用 A 作用域的函数的呢?</p>
<p>答案是, 这会是一个单纯的函数调用, 并不会通过虚表或虚指针, 也没有任何的偏移</p>
<p>(emmm… 也就是说普通成员函数对于类来说, 可能更像是个陌生人, 即使它是成员)</p>
<p>(这也是为什么大多数情况下基类需要 virtual destruct 的原因)</p>
<h3 id="虚析构是如何被调用的"><a href="#虚析构是如何被调用的" class="headerlink" title="虚析构是如何被调用的"></a>虚析构是如何被调用的</h3><p>在写标题的时候大概猜到了, 其实虚析构就是一个在子类中占了一个不能被重写的虚表槽</p>
<p>应该就是通过简单的偏移来调用的, 来试一下</p>
<p>(重点在于虚析构是不可能被覆盖的, 因为子类中不可能存在同名的函数)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">5</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"> <span class="number">6</span> <span class="keyword">public</span>:</span><br><span class="line"> <span class="number">7</span>     <span class="keyword">virtual</span> ~A() &#123;</span><br><span class="line"> <span class="number">8</span>         <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, <span class="string">"A destruct"</span>);</span><br><span class="line"> <span class="number">9</span>     &#125;</span><br><span class="line"><span class="number">10</span> &#125;;</span><br><span class="line"><span class="number">11</span> </span><br><span class="line"><span class="number">12</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="number">13</span> <span class="keyword">public</span>:</span><br><span class="line"><span class="number">14</span>     <span class="keyword">virtual</span> ~B() &#123;</span><br><span class="line"><span class="number">15</span>         <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, <span class="string">"B destruct"</span>);</span><br><span class="line"><span class="number">16</span>     &#125;</span><br><span class="line"><span class="number">17</span> &#125;;</span><br><span class="line"><span class="number">18</span> </span><br><span class="line"><span class="number">19</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="number">20</span>     B a;</span><br><span class="line"><span class="number">21</span> </span><br><span class="line"><span class="number">22</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">23</span> &#125;</span><br></pre></td></tr></table></figure>

<p>汇编:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">161 main:</span><br><span class="line">162 .LFB1204:</span><br><span class="line">163     .cfi_startproc</span><br><span class="line">164     pushq   %rbp</span><br><span class="line">165     .cfi_def_cfa_offset 16</span><br><span class="line">166     .cfi_offset 6, -16</span><br><span class="line">167     movq    %rsp, %rbp</span><br><span class="line">168     .cfi_def_cfa_register 6</span><br><span class="line">169     pushq   %rbx</span><br><span class="line">170     subq    $24, %rsp</span><br><span class="line">171     .cfi_offset 3, -24</span><br><span class="line">172     movq    $_ZTV1B+16, -32(%rbp)</span><br><span class="line">173     movl    $0, %ebx</span><br><span class="line">174     leaq    -32(%rbp), %rax</span><br><span class="line">175     movq    %rax, %rdi</span><br><span class="line">176     call    _ZN1BD1Ev	&#x2F;&#x2F; 就是这里调用了析构函数</span><br><span class="line">177     movl    %ebx, %eax</span><br><span class="line">178     addq    $24, %rsp</span><br><span class="line">179     popq    %rbx</span><br><span class="line">180     popq    %rbp</span><br><span class="line">181     .cfi_def_cfa 7, 8</span><br><span class="line">182     ret</span><br><span class="line">183     .cfi_endproc</span><br></pre></td></tr></table></figure>

<p>B的析构:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> 89 _ZN1BD2Ev:	&#x2F;&#x2F; 如果足够细心, 那么注意到了这里是 _ZN1BD2Ev 而并非 _ZN1BD1Ev</span><br><span class="line"> 				&#x2F;&#x2F; 对此, 我发现编译器类似有个中间层一样的东西(或者说会符号替换?)</span><br><span class="line"> 				&#x2F;&#x2F; 然后其实会跳转到这里来, 汇编中将这两个东西相关联</span><br><span class="line"> 90 .LFB1201:</span><br><span class="line"> 91     .cfi_startproc</span><br><span class="line"> 92     .cfi_personality 0x3,__gxx_personality_v0</span><br><span class="line"> 93     .cfi_lsda 0x3,.LLSDA1201</span><br><span class="line"> 94     pushq   %rbp</span><br><span class="line"> 95     .cfi_def_cfa_offset 16</span><br><span class="line"> 96     .cfi_offset 6, -16</span><br><span class="line"> 97     movq    %rsp, %rbp</span><br><span class="line"> 98     .cfi_def_cfa_register 6</span><br><span class="line"> 99     subq    $16, %rsp</span><br><span class="line">100     movq    %rdi, -8(%rbp)</span><br><span class="line">101     movq    -8(%rbp), %rax</span><br><span class="line">102     movq    $_ZTV1B+16, (%rax)</span><br><span class="line">103     movl    $.LC1, %edi</span><br><span class="line">104     call    puts	&#x2F;&#x2F; 编译器知道只是打印一个字符串, 所以调用的是 puts</span><br><span class="line">105     movq    -8(%rbp), %rax</span><br><span class="line">106     movq    %rax, %rdi</span><br><span class="line">107     call    _ZN1AD2Ev	&#x2F;&#x2F; 和我想的不一样, 又一样...</span><br><span class="line">108     movl    $0, %eax</span><br><span class="line">109     testl   %eax, %eax</span><br><span class="line">110     je  .L6	&#x2F;&#x2F; 这里我也不太懂, 这个不是必跳么?</span><br><span class="line">111     movq    -8(%rbp), %rax</span><br><span class="line">112     movq    %rax, %rdi</span><br><span class="line">113     call    _ZdlPv	&#x2F;&#x2F; 这个东西没有找到</span><br></pre></td></tr></table></figure>

<p>和预料中不同的是, A 的析构函数是直接调用的, 而并非偏移  </p>
<p>想了想这在意料之中, 因为编译器将它优化成了普通函数</p>
<p>至于 _ZdlPv, 没有在汇编中找到这个符号 … </p>
<p>(我试了一下, 没有什么好的方式让它像被虚函数一样调用, 很可惜…)</p>
<h3 id="虚继承的析构函数调用"><a href="#虚继承的析构函数调用" class="headerlink" title="虚继承的析构函数调用"></a>虚继承的析构函数调用</h3><p>感觉非常奇怪, 所以本来是打算看看就好的, 因为之前花功夫去看了看虚继承的内存布局</p>
<p>不过实在太奇怪了, 所以打算好好分析一下, 顺便我在之前分析的时候好像忘了看虚继承的虚函数调用了</p>
<p>因为那时候好像已经晕了… </p>
<p>它会怎么被调用呢? 最无趣的情况就是像上面那样硬编码</p>
<p>不过在虚继承这种比较复杂的环境下, 编译器可能会做出其他反应也说不定?</p>
<p>源码就单纯的E被CD虚继承, B继承CD, 这里直接汇编:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line">.LFB1212:</span><br><span class="line">    .cfi_startproc</span><br><span class="line">    pushq   %rbp</span><br><span class="line">    .cfi_def_cfa_offset 16</span><br><span class="line">    .cfi_offset 6, -16</span><br><span class="line">    movq    %rsp, %rbp</span><br><span class="line">    .cfi_def_cfa_register 6</span><br><span class="line">    pushq   %rbx	&#x2F;&#x2F; 这里, 与前面的 pushq 无关</span><br><span class="line">    subq    $56, %rsp</span><br><span class="line">    .cfi_offset 3, -24</span><br><span class="line">    leaq    -64(%rbp), %rax	&#x2F;&#x2F; 前面有 pushq, 所以这里是 -64</span><br><span class="line">    movq    %rax, %rdi</span><br><span class="line">    call    _ZN1BC1Ev	&#x2F;&#x2F; 构造</span><br><span class="line">    movl    $0, %ebx</span><br><span class="line">    leaq    -64(%rbp), %rax</span><br><span class="line">    movq    %rax, %rdi</span><br><span class="line">    call    _ZN1BD1Ev	&#x2F;&#x2F; 析构</span><br><span class="line">    movl    %ebx, %eax</span><br><span class="line">    addq    $56, %rsp</span><br><span class="line">    popq    %rbx</span><br><span class="line">    popq    %rbp</span><br><span class="line">    .cfi_def_cfa 7, 8</span><br><span class="line">    ret</span><br><span class="line">    .cfi_endproc</span><br></pre></td></tr></table></figure>

<p>B的析构函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">457 _ZN1BD1Ev:</span><br><span class="line">458 .LFB1210:</span><br><span class="line">459     .cfi_startproc</span><br><span class="line">460     .cfi_personality 0x3,__gxx_personality_v0</span><br><span class="line">461     .cfi_lsda 0x3,.LLSDA1210</span><br><span class="line">462     pushq   %rbp</span><br><span class="line">463     .cfi_def_cfa_offset 16</span><br><span class="line">464     .cfi_offset 6, -16</span><br><span class="line">465     movq    %rsp, %rbp</span><br><span class="line">466     .cfi_def_cfa_register 6</span><br><span class="line">467     subq    $16, %rsp</span><br><span class="line">468     movq    %rdi, -8(%rbp)</span><br><span class="line">469     movl    $_ZTV1B+24, %edx</span><br><span class="line">470     movq    -8(%rbp), %rax</span><br><span class="line">471     movq    %rdx, (%rax)	&#x2F;&#x2F; 栈顶加入了虚指针 +24</span><br><span class="line">472     movl    $32, %edx</span><br><span class="line">473     movq    -8(%rbp), %rax</span><br><span class="line">474     addq    %rax, %rdx</span><br><span class="line">475     movl    $_ZTV1B+104, %eax</span><br><span class="line">476     movq    %rax, (%rdx)	&#x2F;&#x2F; 栈顶 -32 处加入了虚指针 +104</span><br><span class="line">477     movl    $_ZTV1B+64, %edx</span><br><span class="line">478     movq    -8(%rbp), %rax</span><br><span class="line">479     movq    %rdx, 16(%rax)	&#x2F;&#x2F; 栈顶 -16 处加入了虚指针 +64</span><br><span class="line">480     movq    -8(%rbp), %rax</span><br><span class="line">481     movl    28(%rax), %eax</span><br><span class="line">482     movl    %eax, %esi</span><br><span class="line">483     movl    $.LC3, %edi	&#x2F;&#x2F; .string &quot;B destruct: %d\n&quot;</span><br><span class="line">484     movl    $0, %eax</span><br><span class="line">485     call    printf</span><br><span class="line">486     movl    $_ZTT1B+24, %eax</span><br><span class="line">487     movq    -8(%rbp), %rdx</span><br><span class="line">488     addq    $16, %rdx</span><br><span class="line">489     movq    %rax, %rsi</span><br><span class="line">490     movq    %rdx, %rdi</span><br><span class="line">491     call    _ZN1CD2Ev	&#x2F;&#x2F; 硬编码...</span><br><span class="line">492     movl    $_ZTT1B+8, %edx</span><br><span class="line">493     movq    -8(%rbp), %rax</span><br><span class="line">494     movq    %rdx, %rsi</span><br><span class="line">495     movq    %rax, %rdi</span><br><span class="line">496     call    _ZN1AD2Ev</span><br><span class="line">497     movl    $2, %eax</span><br><span class="line">498     testl   %eax, %eax</span><br><span class="line">499     je  .L23</span><br><span class="line">500     movq    -8(%rbp), %rax</span><br><span class="line">501     addq    $32, %rax</span><br><span class="line">502     movq    %rax, %rdi</span><br><span class="line">503     call    _ZN1ED2Ev</span><br><span class="line">504     nop</span><br></pre></td></tr></table></figure>

<p>虚函数是通过硬编码来调用的  </p>
<p>不过有个非常不错的发现, 我在 _ZTT1B 中发现了 LTHUNK 的影子</p>
<p>在 _ZTT1B  中有 LTHUNK  相关的代码, 不过很可惜, 这些猜测无从证明…</p>
<p>来看看虚函数的调用吧:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">911 main:</span><br><span class="line">912 .LFB1216:</span><br><span class="line">913     .cfi_startproc</span><br><span class="line">914     .cfi_personality 0x3,__gxx_personality_v0</span><br><span class="line">915     .cfi_lsda 0x3,.LLSDA1216</span><br><span class="line">916     pushq   %rbp</span><br><span class="line">917     .cfi_def_cfa_offset 16</span><br><span class="line">918     .cfi_offset 6, -16</span><br><span class="line">919     movq    %rsp, %rbp</span><br><span class="line">920     .cfi_def_cfa_register 6</span><br><span class="line">921     pushq   %rbx</span><br><span class="line">922     subq    $88, %rsp</span><br><span class="line">923     .cfi_offset 3, -24</span><br><span class="line">924     leaq    -96(%rbp), %rax</span><br><span class="line">925     movq    %rax, %rdi</span><br><span class="line">926     call    _ZN1BC1Ev</span><br><span class="line">927     leaq    -96(%rbp), %rax</span><br><span class="line">928     movq    %rax, -24(%rbp)</span><br><span class="line">929     movq    -24(%rbp), %rax</span><br><span class="line">930     movq    (%rax), %rax	&#x2F;&#x2F; 解引用</span><br><span class="line">931     addq    $16, %rax		&#x2F;&#x2F; +16</span><br><span class="line">932     movq    (%rax), %rax	&#x2F;&#x2F; 取这个槽中的地址</span><br><span class="line">933     movq    -24(%rbp), %rdx</span><br><span class="line">934     movq    %rdx, %rdi</span><br><span class="line">935 .LEHB0:</span><br><span class="line">936     call    *%rax</span><br><span class="line">937     leaq    -96(%rbp), %rax</span><br><span class="line">938     movq    %rax, -32(%rbp)</span><br><span class="line">939     movq    -32(%rbp), %rax</span><br><span class="line">940     movq    (%rax), %rax</span><br><span class="line">941     addq    $16, %rax		&#x2F;&#x2F; +16</span><br><span class="line">942     movq    (%rax), %rax</span><br><span class="line">943     movq    -32(%rbp), %rdx</span><br><span class="line">944     movq    %rdx, %rdi</span><br><span class="line">945     call    *%rax			&#x2F;&#x2F; A, B使用了一样的虚表和槽, 仅仅是this指针不同</span><br><span class="line">946     leaq    -96(%rbp), %rax</span><br><span class="line">947     addq    $16, %rax		&#x2F;&#x2F; +16</span><br><span class="line">948     movq    %rax, -40(%rbp)</span><br><span class="line">949     movq    -40(%rbp), %rax</span><br><span class="line">950     movq    (%rax), %rax	</span><br><span class="line">951     addq    $16, %rax		&#x2F;&#x2F; +16</span><br><span class="line">952     movq    (%rax), %rax</span><br><span class="line">953     movq    -40(%rbp), %rdx</span><br><span class="line">954     movq    %rdx, %rdi</span><br><span class="line">955     call    *%rax			&#x2F;&#x2F; C 先是 +16 取到自己的虚表, 然后同样使用槽 1</span><br><span class="line">956 .LEHE0:</span><br><span class="line">957     movl    $0, %ebx</span><br><span class="line">958     leaq    -96(%rbp), %rax</span><br><span class="line">959     movq    %rax, %rdi</span><br><span class="line"> 960     call    _ZN1BD1Ev</span><br><span class="line">961     movl    %ebx, %eax</span><br><span class="line">962     jmp .L39</span><br><span class="line">963 .L38:</span><br><span class="line">964     movq    %rax, %rbx</span><br><span class="line">965     leaq    -96(%rbp), %rax</span><br><span class="line">966     movq    %rax, %rdi</span><br><span class="line">967     call    _ZN1BD1Ev</span><br><span class="line">968     movq    %rbx, %rax</span><br><span class="line">969     movq    %rax, %rdi</span><br><span class="line">970 .LEHB1:</span><br><span class="line">971     call    _Unwind_Resume</span><br><span class="line">972 .LEHE1:</span><br><span class="line">973 .L39:</span><br><span class="line">974     addq    $88, %rsp</span><br><span class="line">975     popq    %rbx</span><br><span class="line">976     popq    %rbp</span><br><span class="line">977     .cfi_def_cfa 7, 8</span><br><span class="line">978     ret</span><br><span class="line">979     .cfi_endproc</span><br></pre></td></tr></table></figure>

<p>普通虚函数的调用就是找到自己的虚表, 调用对应的槽</p>
<p>这个虚继承来的虚函数调用和普通继承的虚函数调用方式基本一致</p>
<p>多态是如何实现的呢?</p>
<p>每个构造函数, 都会覆写它的所有虚指针, 使他指向不同的地址(但是这些地址都不相同!!!)</p>
<p>如你所见, 当C指针去调用时, 发生了偏移, 虽然取到了同样的 slot, 但却不是同一张虚表</p>
<p>那么我能想到的就是有多张相同的虚表</p>
<p>(我只能如此猜测, 我想不到为什么这样的情况下还能调用同一个函数)</p>
<p>(但是为什么要有相同的呢? 这又是一个问题)</p>
<p>我尝试了看看这些虚表中是什么数据, 可惜失败了, 或者说看不懂</p>
<p>但是同一个类的虚表是完全相同的, 这可以肯定</p>
<p>不同的情况仅在于A类中C类和单独的C类, 这两个C类的虚表是不一样的</p>
<h3 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h3><p>虚函数机制和书中所说基本一致</p>
<ol>
<li>找到对应的虚表</li>
<li>调用槽中的函数</li>
</ol>
<h3 id="review"><a href="#review" class="headerlink" title="review"></a>review</h3><p>我在 objdump 的输出中发现, 诸如 _ZTI1C 这样的东西在链接的时候会转化成一个数字常量</p>
<p>有些可能会是基于某个位置的偏移(比如 %rip)</p>
<p>编译器会利用它进行直接寻址, 有些会利用它进行间接寻址</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/09/other/virtualInherit/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cas">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cas's website">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/09/other/virtualInherit/" class="post-title-link" itemprop="url">other/virtualInherit</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-09 17:14:16 / Modified: 17:12:51" itemprop="dateCreated datePublished" datetime="2020-01-09T17:14:16+08:00">2020-01-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>想要了解一下虚继承的内部数据结构</p>
<p>(语言: c++, 编译器: g++(4.8.5))</p>
<h3 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h3><p>考虑以下代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> _i = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> _i = <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> _i = <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B, <span class="keyword">public</span> C&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> _i = <span class="number">4</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>单纯的虚拟继承而已, 我使用了这种方式打印它们的内部数据</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">D a;</span><br><span class="line"><span class="keyword">void</span> *p = &amp;a;</span><br><span class="line"><span class="keyword">int</span> *pi = (<span class="keyword">int</span> *)p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(a) / <span class="number">4</span>; ++i)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, pi[i]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"val:%d\n"</span>, a._i);</span><br></pre></td></tr></table></figure>

<p>然后它们A, B, C, D内部数据情况如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">A: 	<span class="number">1</span></span><br><span class="line">B: 	<span class="number">4196632</span></span><br><span class="line">    <span class="number">0</span></span><br><span class="line">    <span class="number">2</span></span><br><span class="line">    <span class="number">1</span></span><br><span class="line">C: 	<span class="number">4196632</span></span><br><span class="line">    <span class="number">0</span></span><br><span class="line">    <span class="number">3</span></span><br><span class="line">    <span class="number">1</span></span><br><span class="line">D:	<span class="number">4196760</span></span><br><span class="line">    <span class="number">0</span></span><br><span class="line">    <span class="number">2</span></span><br><span class="line">    <span class="number">0</span></span><br><span class="line">    <span class="number">4196784</span></span><br><span class="line">    <span class="number">0</span></span><br><span class="line">    <span class="number">3</span></span><br><span class="line">    <span class="number">4</span></span><br><span class="line">    <span class="number">1</span></span><br><span class="line">    <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>emmm… </p>
<p>OK, 我可以把前两个 4 字节认为是虚指针(A没有) </p>
<p>那么A, B, C的内存分布就不用看了, 唯一比较特殊的是<strong>虚基类在内存的高地址</strong></p>
<p>然后D的内部分布… 这… emmm… 仔细一想, 还好, 重要的是(Q1: 为什么最后补了一个0 ??)</p>
<h3 id="存取方式"><a href="#存取方式" class="headerlink" title="存取方式"></a>存取方式</h3><p>我试着访问了一下数据</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">D a;</span><br><span class="line">A *pa = &amp;a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, pa-&gt;_i);</span><br><span class="line">B *pb = &amp;a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, pb-&gt;_i);</span><br><span class="line">C *pc = &amp;a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, pc-&gt;_i);</span><br><span class="line">D *pd = &amp;a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, pd-&gt;_i);</span><br></pre></td></tr></table></figure>

<p>来看一看汇编</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">pushq   %rbp</span><br><span class="line">.cfi_def_cfa_offset 16</span><br><span class="line">.cfi_offset 6, -16</span><br><span class="line">movq    %rsp, %rbp</span><br><span class="line">.cfi_def_cfa_register 6</span><br><span class="line">subq    $80, %rsp		&#x2F;&#x2F; 80 栈帧</span><br><span class="line">leaq    -80(%rbp), %rax	</span><br><span class="line">movq    %rax, %rdi	</span><br><span class="line">call    _ZN1DC1Ev		&#x2F;&#x2F; 这里是构造函数, 稍后可能需要看看它的构造</span><br><span class="line">leaq    -80(%rbp), %rax</span><br><span class="line">addq    $32, %rax		&#x2F;&#x2F; +32, OK, 向上 32 字节的确是 1</span><br><span class="line">movq    %rax, -8(%rbp)	</span><br><span class="line">movq    -8(%rbp), %rax</span><br><span class="line">movl    (%rax), %eax</span><br><span class="line">movl    %eax, %esi</span><br><span class="line">movl    $.LC0, %edi</span><br><span class="line">movl    $0, %eax</span><br><span class="line">call    printf			&#x2F;&#x2F; 1 第一次printf</span><br><span class="line">leaq    -80(%rbp), %rax</span><br><span class="line">movq    %rax, -16(%rbp)</span><br><span class="line">movq    -16(%rbp), %rax	&#x2F;&#x2F; B 类型指针并没有经过偏移, 这和预料的一样</span><br><span class="line">movl    8(%rax), %eax	&#x2F;&#x2F; 这里+8, 跳过了虚指针</span><br><span class="line">movl    %eax, %esi</span><br><span class="line">movl    $.LC0, %edi</span><br><span class="line">movl    $0, %eax</span><br><span class="line">call    printf			&#x2F;&#x2F; 2 第二次printf</span><br><span class="line">leaq    -80(%rbp), %rax</span><br><span class="line">addq    $16, %rax		&#x2F;&#x2F; +16 C类型指针跳过了 B的内存, 这也没什么不对</span><br><span class="line">movq    %rax, -24(%rbp)</span><br><span class="line">movq    -24(%rbp), %rax	</span><br><span class="line">movl    8(%rax), %eax	&#x2F;&#x2F; 同理</span><br><span class="line">movl    %eax, %esi</span><br><span class="line">movl    $.LC0, %edi</span><br><span class="line">movl    $0, %eax</span><br><span class="line">call    printf			&#x2F;&#x2F; 3 第三次printf</span><br><span class="line">leaq    -80(%rbp), %rax</span><br><span class="line">movq    %rax, -32(%rbp)</span><br><span class="line">movq    -32(%rbp), %rax</span><br><span class="line">movl    28(%rax), %eax	&#x2F;&#x2F; +28 OK~</span><br><span class="line">movl    %eax, %esi</span><br><span class="line">movl    $.LC0, %edi</span><br><span class="line">movl    $0, %eax</span><br><span class="line">call    printf			&#x2F;&#x2F; 4 第四次printf</span><br><span class="line">movl    $0, %eax</span><br><span class="line">leave</span><br></pre></td></tr></table></figure>

<p>数据的访问在编译时就已经定好的, 不存在额外效率影响</p>
<p>A指针    偏移了 +32 字节     直接访问数据</p>
<p>B指针    未偏移             访问数据时跳过了虚指针(8字节)</p>
<p>C指针    偏移 +16 字节     访问数据时跳过了虚指针(8字节)</p>
<p>D指针    未偏移             访问数据时跳过了虚指针 + B, C类数据(共28字节)</p>
<p>或许看一下访问虚基类的数据会有所了解? </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">pushq   %rbp</span><br><span class="line">.cfi_def_cfa_offset 16</span><br><span class="line">.cfi_offset 6, -16</span><br><span class="line">movq    %rsp, %rbp</span><br><span class="line">.cfi_def_cfa_register 6</span><br><span class="line">subq    $80, %rsp</span><br><span class="line">leaq    -80(%rbp), %rax</span><br><span class="line">movq    %rax, %rdi</span><br><span class="line">call    _ZN1DC1Ev</span><br><span class="line">leaq    -80(%rbp), %rax</span><br><span class="line">addq    $32, %rax</span><br><span class="line">movq    %rax, -8(%rbp)</span><br><span class="line">movq    -8(%rbp), %rax</span><br><span class="line">movl    (%rax), %eax</span><br><span class="line">movl    %eax, %esi</span><br><span class="line">movl    $.LC0, %edi</span><br><span class="line">movl    $0, %eax</span><br><span class="line">call    printf			&#x2F;&#x2F; 基类访问方式和上面的汇编并没有不同</span><br><span class="line">leaq    -80(%rbp), %rax</span><br><span class="line">movq    %rax, -16(%rbp)</span><br><span class="line">movq    -16(%rbp), %rax</span><br><span class="line">movq    (%rax), %rax	&#x2F;&#x2F; 取指针指向的值, 也就是D的地址</span><br><span class="line">subq    $24, %rax		&#x2F;&#x2F; D地址减去24字节 也就是说, 它前面还有东西</span><br><span class="line">movq    (%rax), %rax	&#x2F;&#x2F; 获得那个地址中的值</span><br><span class="line">movq    %rax, %rdx</span><br><span class="line">movq    -16(%rbp), %rax</span><br><span class="line">addq    %rdx, %rax		&#x2F;&#x2F; 增加了 rdx 大小, </span><br><span class="line">movl    (%rax), %eax</span><br><span class="line">movl    %eax, %esi</span><br><span class="line">movl    $.LC0, %edi</span><br><span class="line">movl    $0, %eax</span><br><span class="line">call    printf</span><br><span class="line">leaq    -80(%rbp), %rax</span><br><span class="line">addq    $16, %rax</span><br><span class="line">movq    %rax, -24(%rbp)</span><br><span class="line">movq    -24(%rbp), %rax</span><br><span class="line">movq    (%rax), %rax</span><br><span class="line">subq    $24, %rax</span><br><span class="line">movq    (%rax), %rax</span><br><span class="line">movq    %rax, %rdx</span><br><span class="line">movq    -24(%rbp), %rax</span><br><span class="line">addq    %rdx, %rax</span><br><span class="line">movl    (%rax), %eax</span><br><span class="line">movl    %eax, %esi</span><br><span class="line">movl    $.LC0, %edi</span><br><span class="line">movl    $0, %eax</span><br><span class="line">call    printf</span><br><span class="line">leaq    -80(%rbp), %rax</span><br><span class="line">movq    %rax, -32(%rbp)</span><br><span class="line">movq    -32(%rbp), %rax</span><br><span class="line">movq    (%rax), %rax</span><br><span class="line">subq    $24, %rax</span><br><span class="line">movq    (%rax), %rax</span><br><span class="line">movq    %rax, %rdx</span><br><span class="line">movq    -32(%rbp), %rax</span><br><span class="line">addq    %rdx, %rax</span><br><span class="line">movl    (%rax), %eax</span><br><span class="line">movl    %eax, %esi</span><br><span class="line">movl    $.LC0, %edi</span><br><span class="line">movl    $0, %eax</span><br><span class="line">call    printf</span><br><span class="line">movl    $0, %eax</span><br><span class="line">leave</span><br></pre></td></tr></table></figure>

<p>emmm… 有一个重大的发现就是, <strong>基类对象前面有数据</strong></p>
<p>这些数据应该是偏移, 这些偏移配合 + 指针本身的地址能够访问到正确的虚基类数据</p>
<p>也就是说, 这是 深入探索对象 中, 对于虚基类的两种实现方式中的第一种</p>
<p>即: 在每个基类中添加虚基类的偏移, 但是又不全对…</p>
<p>越来越糊涂了 (눈_눈), 深吸一口气, 想想自己要干嘛… emmmm….</p>
<p>这样吧, 完整地看一遍构造的过程, 这样应该就明白了</p>
<p>(如果还是晕, 那么就希望下次遇到这个问题的时候能够更从容一些)</p>
<p>(我已经再这个问题上花太多时间, 再这样下去反而不好, 这也不是一个很重要/常用的知识)</p>
<h3 id="完整的构造过程"><a href="#完整的构造过程" class="headerlink" title="完整的构造过程"></a>完整的构造过程</h3><p>首先是 main 区块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line">.LFB1196:</span><br><span class="line">    pushq	%rbp</span><br><span class="line">    movq	%rsp, %rbp</span><br><span class="line">    subq	$48, %rsp	&#x2F;&#x2F; 48 字节栈帧, 为什么是 48 呢?</span><br><span class="line">    leaq	-48(%rbp), %rax</span><br><span class="line">    movq	%rax, %rdi</span><br><span class="line">    call	_ZN1DC1Ev	&#x2F;&#x2F; 调用构造函数</span><br><span class="line">    movl	$0, %eax</span><br><span class="line">    leave</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>
<p>然后是D的构造函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">_ZN1DC1Ev:</span><br><span class="line">.LFB1208:</span><br><span class="line">    pushq	%rbp</span><br><span class="line">    movq	%rsp, %rbp</span><br><span class="line">    subq	$16, %rsp		&#x2F;&#x2F; 它再次开辟了 16 字节的栈帧</span><br><span class="line">    movq	%rdi, -8(%rbp)	&#x2F;&#x2F; 把原栈顶指针放入了栈中</span><br><span class="line">    movq	-8(%rbp), %rax	</span><br><span class="line">    addq	$32, %rax		&#x2F;&#x2F; 原栈顶指针 +32 偏移, 距栈底还有 16 字节</span><br><span class="line">    movq	%rax, %rdi</span><br><span class="line">    call	_ZN1AC2Ev		&#x2F;&#x2F; 这里留了 16 字节用于 A 的构造</span><br><span class="line">    movl	$_ZTT1D+8, %edx	&#x2F;&#x2F; 我很好奇地查了 $_ZTT1D 这东西是多少, 然而事实让我绝望...</span><br><span class="line">    						&#x2F;&#x2F; 它有非常多的耦合, 短时间内我根本无法计算出这东西是多少!!!</span><br><span class="line">    						&#x2F;&#x2F; 而且里面的代码是以.开头的, 这意味着是伪指令... (;´༎ຶД༎ຶ&#96;)</span><br><span class="line">    movq	-8(%rbp), %rax</span><br><span class="line">    movq	%rdx, %rsi		&#x2F;&#x2F; rdx 从未被赋值过, 我很好奇它将什么值给了 rsi</span><br><span class="line">    						&#x2F;&#x2F; 对了, 在上面一句用到了 edx, 这和 rdx 有关</span><br><span class="line">    						&#x2F;&#x2F; 暂且把它认为是一个, 编译器施加的魔法: magic</span><br><span class="line">    movq	%rax, %rdi		&#x2F;&#x2F; 原栈顶指针</span><br><span class="line">    call	_ZN1BC2Ev		&#x2F;&#x2F; 调用 B 构造函数</span><br><span class="line">    movl	$_ZTT1D+16, %eax</span><br><span class="line">    movq	-8(%rbp), %rdx	&#x2F;&#x2F; 拿出原栈顶指针</span><br><span class="line">    addq	$16, %rdx		&#x2F;&#x2F; +16 偏移</span><br><span class="line">    movq	%rax, %rsi</span><br><span class="line">    movq	%rdx, %rdi</span><br><span class="line">    call	_ZN1CC2Ev		&#x2F;&#x2F; 调用 C 构造函数</span><br><span class="line">    movl	$_ZTV1D+24, %edxl</span><br><span class="line">    movq	-8(%rbp), %rax</span><br><span class="line">    movq	%rdx, (%rax)	&#x2F;&#x2F; 这里与调用 B 时的步骤重复了 :), 覆写</span><br><span class="line">    movl	$_ZTV1D+48, %edx</span><br><span class="line">    movq	-8(%rbp), %rax</span><br><span class="line">    movq	%rdx, 16(%rax)	&#x2F;&#x2F; 这里与调用 C 时的步骤重复了 :), 覆写</span><br><span class="line">    movq	-8(%rbp), %rax</span><br><span class="line">    movl	$444, 28(%rax)	&#x2F;&#x2F; 写入值</span><br><span class="line">    leave</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>
<p>A的构造函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">_ZN1AC2Ev:</span><br><span class="line">.LFB1199:</span><br><span class="line">    pushq	%rbp</span><br><span class="line">    movq	%rsp, %rbp</span><br><span class="line">    movq	%rdi, -8(%rbp)</span><br><span class="line">    movq	-8(%rbp), %rax</span><br><span class="line">    movl	$111, (%rax)	&#x2F;&#x2F; 将 $111 放入了参数 rdi 指向的内存中 movl: 4字节</span><br><span class="line">    popq	%rbp</span><br><span class="line">    ret		&#x2F;&#x2F; 嗯, 没了, 所以编译器仅仅对这 4 字节赋值</span><br><span class="line">    		&#x2F;&#x2F; 剩下的 12 字节呢?</span><br><span class="line">    		&#x2F;&#x2F; 其中8字节没用过, 或者不在 D 的内存中, 因为 sizeof d 是40, 而非48</span><br></pre></td></tr></table></figure>
<p>B的构造函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">_ZN1BC2Ev:</span><br><span class="line">.LFB1202:</span><br><span class="line">    pushq	%rbp</span><br><span class="line">    movq	%rsp, %rbp</span><br><span class="line">    movq	%rdi, -8(%rbp)	&#x2F;&#x2F; 原栈顶指针</span><br><span class="line">    movq	%rsi, -16(%rbp)	&#x2F;&#x2F; 未知的原 rdx(magic)</span><br><span class="line">    movq	-16(%rbp), %rax</span><br><span class="line">    movq	(%rax), %rdx	&#x2F;&#x2F; magic的地址 -16 中的值放入 rdx</span><br><span class="line">    movq	-8(%rbp), %rax</span><br><span class="line">    movq	%rdx, (%rax)	&#x2F;&#x2F; 将 rdx 中的值放入了栈顶, 这里是q, 占了 8 字节</span><br><span class="line">    movq	-8(%rbp), %rax</span><br><span class="line">    movl	$222, 8(%rax)	&#x2F;&#x2F; 栈顶 +8 偏移中, 放入了 $222</span><br><span class="line">    popq	%rbp</span><br><span class="line">    ret				&#x2F;&#x2F; 共写入了 12 字节</span><br></pre></td></tr></table></figure>
<p>C的构造函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">_ZN1CC2Ev:</span><br><span class="line">.LFB1205:</span><br><span class="line">    pushq	%rbp</span><br><span class="line">    movq	%rsp, %rbp</span><br><span class="line">    movq	%rdi, -8(%rbp)</span><br><span class="line">    movq	%rsi, -16(%rbp)</span><br><span class="line">    movq	-16(%rbp), %rax</span><br><span class="line">    movq	(%rax), %rdx</span><br><span class="line">    movq	-8(%rbp), %rax</span><br><span class="line">    movq	%rdx, (%rax)</span><br><span class="line">    movq	-8(%rbp), %rax</span><br><span class="line">    movl	$333, 8(%rax)</span><br><span class="line">    popq	%rbp		&#x2F;&#x2F; 步骤与 B 基本相同</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>
<p>也就是说, 在D的构造中, ABC的构造都被调用了</p>
<p>要注意的一点是, BC都未调用A的构造, A的构造仅在D中调用了一次</p>
<p>同时要注意的是, BC会用那个编译器给的数字往自身的内存布局中写值</p>
<p>但是如果其上有D, D会将那个值覆写一次, 假设其值恒定不变, 位移分别为:</p>
<p>8 16 24 48</p>
<p>这是一组有规律的数字, 以 8 为开始, 每个数字是前面数字之和(这个就是偏移)</p>
<p>剩下来最重要的是, D覆写了什么?</p>
<p>再次来看看是如何访问虚基类数据的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">D a;</span><br><span class="line">C *pd = &amp;a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, pd-&gt;A::_i);</span><br></pre></td></tr></table></figure>


<p>汇编:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">.LFB1196:</span><br><span class="line">    pushq   %rbp</span><br><span class="line">    movq    %rsp, %rbp</span><br><span class="line">    subq    $48, %rsp</span><br><span class="line">    leaq    -48(%rbp), %rax</span><br><span class="line">    movq    %rax, %rdi</span><br><span class="line">    call    _ZN1DC1Ev</span><br><span class="line">    leaq    -48(%rbp), %rax</span><br><span class="line">    addq    $16, %rax		&#x2F;&#x2F; 因为是 C 类型指针, 所以做了 +16 偏移</span><br><span class="line">    movq    %rax, -8(%rbp)	&#x2F;&#x2F; C *pd &#x3D; &amp;a;</span><br><span class="line">    movq    -8(%rbp), %rax</span><br><span class="line">    movq    (%rax), %rax	&#x2F;&#x2F; 获得了指针中的值</span><br><span class="line">    subq    $24, %rax		&#x2F;&#x2F; 该值减去 24 </span><br><span class="line">    movq    (%rax), %rax	&#x2F;&#x2F; 再以该值间接寻址</span><br><span class="line">    movq    %rax, %rdx</span><br><span class="line">    movq    -8(%rbp), %rax</span><br><span class="line">    addq    %rdx, %rax		&#x2F;&#x2F; rdx 本身的值 + 指针的值</span><br><span class="line">    movl    (%rax), %eax	&#x2F;&#x2F; 间接寻址得到的值就是虚基类的值</span><br><span class="line">    movl    %eax, %esi</span><br><span class="line">    movl    $.LC0, %edi</span><br><span class="line">    movl    $0, %eax</span><br><span class="line">    call    printf</span><br><span class="line">    movl    $0, %eax</span><br><span class="line">    leave</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>

<p>这次要清晰得多了, 我们以上面D的内存布局为例:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4196760</span>	<span class="comment">// 2. 它减去 24 到了这里 </span></span><br><span class="line">    	<span class="comment">// 3. 用这里的值寻址得到了某个数 x </span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">4196784</span>	<span class="comment">// 1. 这是一开始 C 指针指向的内存</span></span><br><span class="line">    	<span class="comment">// 4. 用这个指针 + x 得到了虚基类数据的地址</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>那么在代码中试一下, 如果没有错误的话, 那个 x 应该是 4</p>
<p>(这个地址明显非常低, 它甚至没达到 8 字节, 这应该是编译的时候准备好的数据)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">D a;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> *pl = (<span class="keyword">long</span> <span class="keyword">long</span> *)&amp;a;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> *pl2 = (<span class="keyword">long</span> <span class="keyword">long</span> *)&amp;pl;</span><br><span class="line">*pl2 = *pl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%ld\n"</span>, *pl);	<span class="comment">// 16</span></span><br></pre></td></tr></table></figure>


<p>取出来了 16, emmm… 嗯, 没错, 4 个 4字节 4 x 4 = 16 !!!!!!! </p>
<p>PS: 有没有思考过为什么通过双间接才能去到虚基类呢?</p>
<p>这里明显的一个问题是, 虚基类的数据是通过 C 的某个地址索引到 D 的某个地址</p>
<p>然后再用 C 的地址索引到虚基类数据, 有两次的跳转 </p>
<p>我再次试了一下有继承三个虚基类的情况(就是D再继承了一个类似 BC的类)</p>
<p>发现它的访问方式是一样的, 也就是说, 每一个自身都会往前寻找固定的字节(编译后固定)</p>
<p>然后用那个地址的数据 + 指针本身的地址(我不知道我又没有表达清楚, 不过我感觉我没有 :) )</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> _i = <span class="number">555</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B, <span class="keyword">public</span> C, <span class="keyword">public</span> E&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> _i = <span class="number">444</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    D a;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> *pl = (<span class="keyword">long</span> <span class="keyword">long</span> *)&amp;a;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> *pl2 = (<span class="keyword">long</span> <span class="keyword">long</span> *)&amp;pl;</span><br><span class="line">    *pl2 = *pl;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%ld\n"</span>, *pl);   <span class="comment">// 32</span></span><br><span class="line"></span><br><span class="line">    pl = (<span class="keyword">long</span> <span class="keyword">long</span> *)&amp;a + <span class="number">2</span>;</span><br><span class="line">    pl2 = (<span class="keyword">long</span> <span class="keyword">long</span> *)&amp;pl;</span><br><span class="line">    *pl2 = *pl;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%ld\n"</span>, *pl);   <span class="comment">// 16</span></span><br><span class="line"></span><br><span class="line">    pl = (<span class="keyword">long</span> <span class="keyword">long</span> *)&amp;a + <span class="number">4</span>;</span><br><span class="line">    pl2 = (<span class="keyword">long</span> <span class="keyword">long</span> *)&amp;pl;</span><br><span class="line">    *pl2 = *pl;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%ld\n"</span>, *pl);   <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>内存布局:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4196856</span>	(<span class="number">32</span>)<span class="comment">// 2. 通过这个地址拿到偏移</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">222</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">4196880</span>	(<span class="number">16</span>)<span class="comment">// 1. C对象, 当我要找虚基类对象时, 我先往上移动固定字节</span></span><br><span class="line">    		<span class="comment">// 这些移动的大小都是在编译时就写死了的常量(编译器自动计算)</span></span><br><span class="line">    		<span class="comment">// 往上移动的字节会随着数据大小而改变, 但是数据中的地址是不变的</span></span><br><span class="line">    		<span class="comment">// 比如我这里是4196880, 那么无论往上移动多少</span></span><br><span class="line">    		<span class="comment">// 上一个地址中存的值恒定为 当前值 - 24 (4196856)</span></span><br><span class="line">    	<span class="comment">// 3. 根据拿到的偏移 + 地址获取虚基类数据</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">333</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">4196904</span> (<span class="number">0</span>)<span class="comment">// E对象, 它如果想拿到虚基类数据, 执行和 C 对象一样的操作就好</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">555</span></span><br><span class="line"><span class="number">444</span></span><br><span class="line"><span class="number">111</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>这样的内存布局在其他方面可能还会有用</p>
<p>那么为什么会有 0 呢? 我估计是因为要实现这种内存布局, 或者说什么其他原因</p>
<h3 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h3><p> 我很怀疑下次我看笔记时, 我自己看不看得懂我在说什么…</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">cas</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">107</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">cas</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
