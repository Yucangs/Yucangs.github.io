<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Muse',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="cas&#39;s website">
<meta property="og:url" content="http://yoursite.com/page/8/index.html">
<meta property="og:site_name" content="cas&#39;s website">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="cas">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>cas's website</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">cas's website</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">casyup.me@outlook.com</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="Searching..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/09/other/some%20useful%20define/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cas">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cas's website">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/09/other/some%20useful%20define/" class="post-title-link" itemprop="url">other/some useful define</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-09 17:14:16 / Modified: 17:13:31" itemprop="dateCreated datePublished" datetime="2020-01-09T17:14:16+08:00">2020-01-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="保留条件表达式的第一个值"><a href="#保留条件表达式的第一个值" class="headerlink" title="保留条件表达式的第一个值"></a>保留条件表达式的第一个值</h2><pre><code>// CE: condition expression, RETAIN: 保持
#define CE_RETAIN1(a, b) ((a) ? (a) : (b))</code></pre><p>考虑一个情况, 当一个值有效时, 使用它, 否则使用另外一个数<br>如果直接写的话, 不太容易理解  </p>
<pre><code>(exp) ? (exp) : -1;</code></pre><p>当exp非常长的时候(或许可以保存成变量, 但是某些情况下, 不知道该用什么名字<br>而自己比较常用变量名差不多用光了, 或者这只是个只用一次的值), 如  </p>
<pre><code>val = func(a) * i + 10 ? func(a) * i + 10 : -1;</code></pre><p>而如果用宏定义的话就比较清晰了</p>
<pre><code>val = CE_RETAIN1(func(a) * i + 10, -1);</code></pre><p>PS: 但是如果的确出现表达式过长的情况, 可能考虑优化代码是最好的解决方案</p>
<h2 id="直接面向结果的函数"><a href="#直接面向结果的函数" class="headerlink" title="直接面向结果的函数"></a>直接面向结果的函数</h2><pre><code>void show() { setvisible(true); }    
void hide() { setvisible(false); }</code></pre><p>使用show(), hide()的情况下, 一目了然, 而通过参数的话, 理解会稍麻烦一些</p>
<h2 id="getInstance"><a href="#getInstance" class="headerlink" title="getInstance"></a>getInstance</h2><p>getInstance多数情况下作为一个类的公有接口, 用于获得一个实例<br>普通的书写方案如下        </p>
<pre><code>class A{
    int i; // 不仅仅是数据, 也可能是一个类
public:
    int&amp; getInstance() { return i; }
};</code></pre><p>使用这种方式的情况会存在两个问题  </p>
<ol>
<li>即使我从不使用i, 也从未掉用过getInstance这个函数, 但依旧给i分配了空间  </li>
<li>i依旧能在其他接口中被访问  </li>
</ol>
<p>上述两种情况并不一定会造成影响, 但可以考虑排除这种隐藏问题  </p>
<pre><code>int&amp; getInstance() {
    static int i;

    return i;
}</code></pre><p>静态变量在未被访问过的情况下, 不会分配空间<br>并且只存在于当前作用域, 有良好的安全性</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/09/other/some%20useful%20skill/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cas">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cas's website">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/09/other/some%20useful%20skill/" class="post-title-link" itemprop="url">other/some useful skill</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-09 17:14:16 / Modified: 17:13:31" itemprop="dateCreated datePublished" datetime="2020-01-09T17:14:16+08:00">2020-01-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="保留条件表达式的第一个值"><a href="#保留条件表达式的第一个值" class="headerlink" title="保留条件表达式的第一个值"></a>保留条件表达式的第一个值</h2><pre><code>// CE: condition expression, RETAIN: 保持
#define CE_RETAIN1(a, b) ((a) ? (a) : (b))</code></pre><p>考虑一个情况, 当一个值有效时, 使用它, 否则使用另外一个数<br>如果直接写的话, 不太容易理解  </p>
<pre><code>(exp) ? (exp) : -1;</code></pre><p>当exp非常长的时候(或许可以保存成变量, 但是某些情况下, 不知道该用什么名字<br>而自己比较常用变量名差不多用光了, 或者这只是个只用一次的值), 如  </p>
<pre><code>val = func(a) * i + 10 ? func(a) * i + 10 : -1;</code></pre><p>而如果用宏定义的话就比较清晰了</p>
<pre><code>val = CE_RETAIN1(func(a) * i + 10, -1);</code></pre><p>PS: 但是如果的确出现表达式过长的情况, 可能考虑优化代码是最好的解决方案</p>
<h2 id="直接面向结果的函数"><a href="#直接面向结果的函数" class="headerlink" title="直接面向结果的函数"></a>直接面向结果的函数</h2><pre><code>void show() { setvisible(true); }    
void hide() { setvisible(false); }</code></pre><p>使用show(), hide()的情况下, 一目了然, 而通过参数的话, 理解会稍麻烦一些</p>
<h2 id="getInstance"><a href="#getInstance" class="headerlink" title="getInstance"></a>getInstance</h2><p>getInstance多数情况下作为一个类的公有接口, 用于获得一个实例<br>普通的书写方案如下        </p>
<pre><code>class A{
    int i; // 不仅仅是数据, 也可能是一个类
public:
    int&amp; getInstance() { return i; }
};</code></pre><p>使用这种方式的情况会存在两个问题  </p>
<ol>
<li>即使我从不使用i, 也从未掉用过getInstance这个函数, 但依旧给i分配了空间  </li>
<li>i依旧能在其他接口中被访问  </li>
</ol>
<p>上述两种情况并不一定会造成影响, 但可以考虑排除这种隐藏问题  </p>
<pre><code>int&amp; getInstance() {
    static int i;

    return i;
}</code></pre><p>静态变量在未被访问过的情况下, 不会分配空间<br>并且只存在于当前作用域, 有良好的安全性</p>
<h2 id="保存变量"><a href="#保存变量" class="headerlink" title="保存变量"></a>保存变量</h2><p>局部变量速度优于函数调用, 类似如果频繁用到数组的长度, 可以使用变量保存.size()的值</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/09/other/sort/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cas">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cas's website">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/09/other/sort/" class="post-title-link" itemprop="url">other/sort</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-09 17:14:16 / Modified: 17:13:31" itemprop="dateCreated datePublished" datetime="2020-01-09T17:14:16+08:00">2020-01-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="https://www.hackerearth.com/zh/practice/algorithms/sorting/bubble-sort/tutorial/" target="_blank" rel="noopener">source link</a></p>
<h2 id="Sort"><a href="#Sort" class="headerlink" title="Sort"></a>Sort</h2><h3 id="Bubble-Sort"><a href="#Bubble-Sort" class="headerlink" title="Bubble Sort"></a>Bubble Sort</h3><p>Bubble is the most common algorithm to sort an array. It based on the idea of repeatedly comparing adjacent element and then swapping their  value if exist in the wrong order </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[j])</span><br><span class="line">                swap(nums[i], nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Selection-sort"><a href="#Selection-sort" class="headerlink" title="Selection sort"></a>Selection sort</h3><p>The selection sort is based on finding the minimum or maximum in an unsorted array and putting it to a sorted array</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">min</span> = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[<span class="built_in">min</span>] &gt; nums[j])</span><br><span class="line">                <span class="built_in">min</span> = j;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums[i], nums[<span class="built_in">min</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Insertion-sort"><a href="#Insertion-sort" class="headerlink" title="Insertion sort"></a>Insertion sort</h3><p>From left to right, find each element’s correct position</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = nums[i];</span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        <span class="keyword">while</span>(j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            nums[j] = nums[j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &lt;= v)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            --j;                            </span><br><span class="line">        &#125;</span><br><span class="line">        nums[j] = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Merge-sort"><a href="#Merge-sort" class="headerlink" title="Merge sort"></a>Merge sort</h3><p>Merge sort is a divide-and-conquer algorithm based on repeatedly breaking down an array to two sub-array and then merge them</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> b, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = (b + e) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> q = m + <span class="number">1</span>, p = b;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = b; i &lt;= e; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p &gt; m)</span><br><span class="line">            v.push_back(nums[q++]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (q &gt; e)</span><br><span class="line">            v.push_back(nums[p++]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[q] &gt; nums[p])</span><br><span class="line">            v.push_back(nums[p++]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            v.push_back(nums[q++]);              </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> val : v)</span><br><span class="line">        nums[b++] = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> b, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b &gt;= e) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    mergeSort(nums, b, (e + b) / <span class="number">2</span>);</span><br><span class="line">    mergeSort(nums, (e + b) / <span class="number">2</span> + <span class="number">1</span>, e);</span><br><span class="line">    merge(nums, b, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Quick-sort"><a href="#Quick-sort" class="headerlink" title="Quick sort"></a>Quick sort</h3><p>Quick sort is also a divide-and-conquer algorithm. But it reduces the space complexity and removes the use of auxiliary array that is used in merger sort<br>One of the most important factors to influence performance is the pivot.<br>I chose the pivot from the middle, front, and back of the array. Sometimes will improve performance</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partion</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> b, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = e;</span><br><span class="line">    <span class="keyword">int</span> m = (b + e) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (nums[b] &gt; nums[m])</span><br><span class="line">        swap(nums[b], nums[m]);</span><br><span class="line">    <span class="keyword">if</span> (nums[b] &gt; nums[e])</span><br><span class="line">        swap(nums[b], nums[e]);</span><br><span class="line">    <span class="keyword">if</span> (nums[m] &gt; nums[e])</span><br><span class="line">        swap(nums[m], nums[e]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> piv = nums[m];</span><br><span class="line">    swap(nums[e--], nums[m]);</span><br><span class="line">    <span class="keyword">while</span> (b &lt; e) &#123;</span><br><span class="line">        <span class="keyword">while</span> (b &lt; e &amp;&amp; nums[b] &lt; piv)</span><br><span class="line">            ++b;</span><br><span class="line">        <span class="keyword">while</span> (b &lt; e &amp;&amp; nums[e] &gt;= piv)</span><br><span class="line">            --e;</span><br><span class="line">        <span class="keyword">if</span> (b &gt;= e) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        swap(nums[b], nums[e]);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(nums[p], nums[b]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> b, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b &gt;= e) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> p = partion(nums, b, e);</span><br><span class="line">    quickSort(nums, b, p - <span class="number">1</span>);</span><br><span class="line">    quickSort(nums, p + <span class="number">1</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Heap-sort"><a href="#Heap-sort" class="headerlink" title="Heap sort"></a>Heap sort</h3><p>Heap sort uses a structure called heap to sort the array. Heap is a complete binary tree.<br>left sub-tree index = 2 * root index + 1<br>right sub-tree index = 2 * root index + 2</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> n, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> largest = i;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> r = l + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l &lt; n &amp;&amp; nums[l] &gt; nums[largest])</span><br><span class="line">        largest = l;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r &lt; n &amp;&amp; nums[r] &gt; nums[largest])</span><br><span class="line">        largest = r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">        swap(nums[i], nums[largest]);</span><br><span class="line">        heapify(nums, n, largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;                </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.<span class="built_in">size</span>() / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        heapify(nums, nums.<span class="built_in">size</span>(), i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        swap(nums[<span class="number">0</span>], nums[i]);</span><br><span class="line">        heapify(nums, i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/09/other/sort2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cas">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cas's website">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/09/other/sort2/" class="post-title-link" itemprop="url">other/sort2</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-09 17:14:16 / Modified: 17:13:31" itemprop="dateCreated datePublished" datetime="2020-01-09T17:14:16+08:00">2020-01-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>this is a follow-up to <a href="http://49.235.55.145/html_note/sort.html" target="_blank" rel="noopener">sort</a></p>
<p>these sort algorithms based on &lt;Algorithms, 4th&gt;</p>
<h2 id="shell-sort"><a href="#shell-sort" class="headerlink" title="shell sort"></a>shell sort</h2><p>shell sort is a better version sort algorithm based on insert sort.</p>
<p>when a[0] is the biggest number but head of array, for move the number to the end of the array, need swap length(a) elements. </p>
<p>shell sort 是基于插入排序的改良版本</p>
<p>当 a[0] 是整个数组最大的元素时, 为了移动这个元素到数组的尾端, 需要交换 length(a) 次元素. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (h &lt; v.<span class="built_in">size</span>() / <span class="number">3</span>) h = h * <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (h &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = h; j &lt; v.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = j; i &gt;= h &amp;&amp; v[i] &lt; v[i - h]; i -= h)</span><br><span class="line">                swap(v[i], v[i - h]);                         </span><br><span class="line">        &#125;</span><br><span class="line">        h /= <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="bottom-up-sort"><a href="#bottom-up-sort" class="headerlink" title="bottom-up sort"></a>bottom-up sort</h2><p>bottom-up sort is a down-top method based on merge sort.</p>
<p>bottom-up sort 基于合并排序, 是一种从底至上的方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v, <span class="keyword">int</span> b, <span class="keyword">int</span> m, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2 = v;</span><br><span class="line">    <span class="keyword">int</span> mid = m++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = b; i &lt;= e; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &gt; mid)</span><br><span class="line">            v[i] = v2[m++];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (m &gt; e)</span><br><span class="line">            v[i] = v2[b++];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (v2[b] &lt; v2[m])</span><br><span class="line">            v[i] = v2[b++];</span><br><span class="line">        <span class="keyword">else</span>·</span><br><span class="line">            v[i] = v2[m++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bottomupSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; v.<span class="built_in">size</span>(); i *= <span class="number">2</span>)&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; v.<span class="built_in">size</span>() - i; j = j + <span class="number">2</span> * i)</span><br><span class="line">			merge(v, j, j + i <span class="number">-1</span>, <span class="built_in">min</span>(<span class="keyword">int</span>(v.<span class="built_in">size</span>() - <span class="number">1</span>, j + <span class="number">2</span> * i - <span class="number">1</span>)));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="a-better-version-of-quick-sort"><a href="#a-better-version-of-quick-sort" class="headerlink" title="a better version of quick sort"></a>a better version of quick sort</h2><p>if an array with some duplicate numbers,  skip these numbers will be more effective</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QS_MIN_LENGTH 7</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> b, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b &gt;= e) <span class="keyword">return</span>;                          </span><br><span class="line"></span><br><span class="line">    <span class="comment">// if element too little, insertSort more effective than quickSort</span></span><br><span class="line">    <span class="keyword">if</span> (e - b &lt; QS_MIN_LENGTH)</span><br><span class="line">        insertSort(nums, b, e);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// meduim of three can get more effetive pivot</span></span><br><span class="line">    <span class="keyword">int</span> m = (b + e) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (nums[b] &gt; nums[m])</span><br><span class="line">        swap(nums[b], nums[m]);</span><br><span class="line">    <span class="keyword">if</span> (nums[b] &gt; nums[e])</span><br><span class="line">        swap(nums[b], nums[e]);</span><br><span class="line">    <span class="keyword">if</span> (nums[m] &gt; nums[e])</span><br><span class="line">        swap(nums[m], nums[e]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pivot = nums[m];</span><br><span class="line">    <span class="comment">// skip elements equal pivot</span></span><br><span class="line">    <span class="keyword">int</span> lt = b + <span class="number">1</span>, eq = lt, gt = e - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (eq &lt;= gt) &#123; </span><br><span class="line">        <span class="keyword">if</span> (nums[eq] &lt; pivot)</span><br><span class="line">            swap(nums[lt++], nums[eq++]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[eq] &gt; pivot)</span><br><span class="line">            swap(nums[eq], nums[gt--]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            eq++;</span><br><span class="line">    &#125;       </span><br><span class="line"></span><br><span class="line">    quickSort(nums, b, lt - <span class="number">1</span>);</span><br><span class="line">    quickSort(nums, gt + <span class="number">1</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="a-sort-algorithm-without-compare"><a href="#a-sort-algorithm-without-compare" class="headerlink" title="a sort algorithm without compare"></a>a sort algorithm without compare</h3><p>I saw a string sort algorithm without compare in &lt;algorithm 4th&gt;. so take some notes</p>
<p>I’m to lazy to write this code, please check the book…</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/09/other/useful%20skill/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cas">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cas's website">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/09/other/useful%20skill/" class="post-title-link" itemprop="url">other/useful skill</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-09 17:14:16 / Modified: 17:13:54" itemprop="dateCreated datePublished" datetime="2020-01-09T17:14:16+08:00">2020-01-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="vim中执行cmd"><a href="#vim中执行cmd" class="headerlink" title="vim中执行cmd"></a>vim中执行cmd</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!cmd</span><br></pre></td></tr></table></figure>



<h4 id="vim中编写额外的文件"><a href="#vim中编写额外的文件" class="headerlink" title="vim中编写额外的文件"></a>vim中编写额外的文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">args filename</span><br></pre></td></tr></table></figure>



<h4 id="sed处理文件"><a href="#sed处理文件" class="headerlink" title="sed处理文件"></a>sed处理文件</h4><h4 id="at和crontab定时"><a href="#at和crontab定时" class="headerlink" title="at和crontab定时"></a>at和crontab定时</h4><h4 id="流重定向"><a href="#流重定向" class="headerlink" title="流重定向"></a>流重定向</h4><p>“&gt;”:  输出重定向, 这个操作符会覆盖已有文件的内容, 若文件不存在, 则创建</p>
<p>“&gt;&gt;”: 同样也是输出重定向, 这个操作符会将内容添加到文件尾部, 同样的, 若文件不存在, 则创建文件</p>
<p>@note:</p>
<p>​    比较特殊的是内联输入重定向: “&lt;&lt;”, 我现在也不太明白这东西的实质用法和含义</p>
<p>​    只知道它的行为: 它可以使用命令行的内容作为输入流, 并且可以指定一个”标识”来表示结束</p>
<h4 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h4><p>@brief: </p>
<p>​    将一个命令的输出作为另一个命令的输入. 例如:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat file | less</span><br></pre></td></tr></table></figure>

<p>cat仅仅只是查看文件, 但并不会增加一些控制功能(如翻页, 搜索…)  </p>
<p>less则提供了相关的更高级的功能, 将cat的输入(文件内容)作为less的输入</p>
<p>@note: </p>
<p>​    其实这个例子很没有必要, 现实中这么写, 可能会被diss到死. 因为可以直接使用 less file</p>
<h4 id="创建一个新文件"><a href="#创建一个新文件" class="headerlink" title="创建一个新文件"></a>创建一个新文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch file</span><br></pre></td></tr></table></figure>



<h4 id="置空文件内容"><a href="#置空文件内容" class="headerlink" title="置空文件内容"></a>置空文件内容</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /dev/null &gt; file</span><br></pre></td></tr></table></figure>

<p>@note: </p>
<p>​    更加简便的方式是 &gt; file</p>
<h4 id="单引号和双引号"><a href="#单引号和双引号" class="headerlink" title="单引号和双引号"></a>单引号和双引号</h4><p>需要注意的是, 单引号中, 双引号不需要转义.</p>
<p>同样的, 双引号中, 单引号不需要转义</p>
<p>这会在某些场合下, 让你的字符串更加简洁易懂, 同时还更好改, 更不容易写错</p>
<p>@ps:</p>
<p>​    我曾在一次 crontab 任务中遇到这种场合, 我使用了 crontab file 的形式来添加任务</p>
<p>​    同时使用 echo + 重定向 的形式往文件中添加内容, 而要执行的命令中就包含些许单引号和双引号</p>
<p>​    (不过我倒是没有在这里面用到这个技巧, 因为我第一次就写对了 :) )</p>
<h4 id="md5加密"><a href="#md5加密" class="headerlink" title="md5加密"></a>md5加密</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo "test" | md5sum</span><br></pre></td></tr></table></figure>



<h4 id="查看自己的公网信息"><a href="#查看自己的公网信息" class="headerlink" title="查看自己的公网信息"></a>查看自己的公网信息</h4><pre><code>curl cip.cc</code></pre><p>简析: curl 为一个在服务器中传递数据的攻击, 而 cip.cc 为一个查询网络信息的网站  </p>
<p>当你登录 cip.cc 时, 它应当会根据你访问网站时的信息, 查询你 IP 的相关信息, 并返还给你</p>
<h4 id="传递大量文件-远端和本地"><a href="#传递大量文件-远端和本地" class="headerlink" title="传递大量文件(远端和本地)"></a>传递大量文件(远端和本地)</h4><pre><code>rsync</code></pre><p>具体用法参照 man 手册</p>
<h4 id="查看本地IP端口信息"><a href="#查看本地IP端口信息" class="headerlink" title="查看本地IP端口信息"></a>查看本地IP端口信息</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -tunlp</span><br></pre></td></tr></table></figure>

<p>t : TCP</p>
<p>u : UDP</p>
<p>n : 不经过域名服务器</p>
<p>l : 显示监控中服务器的socket</p>
<p>p : 显示监控中的程序识别码和名称    </p>
<p>@btw: 可以加入 -a 选项, 这会将所有(包括当前未监听)的端口信息都列出来</p>
<p>​    与之相关的命令还有 nmap, nc</p>
<h4 id="查看本机服务"><a href="#查看本机服务" class="headerlink" title="查看本机服务"></a>查看本机服务</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service --status-all | grep running</span><br></pre></td></tr></table></figure>

<p>这个命令可以查看本机现在运行的所有服务</p>
<p>@note: –status-all 之间不能空格.  “–status -all” 这是错误的写法</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/09/other/virtualFunction/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cas">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cas's website">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/09/other/virtualFunction/" class="post-title-link" itemprop="url">other/virtualFunction</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-09 17:14:16 / Modified: 17:12:51" itemprop="dateCreated datePublished" datetime="2020-01-09T17:14:16+08:00">2020-01-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>想深入了解一下(或者说验证)对象底层是如何工作的</p>
<p>重点是虚函数的调用, 虚指针的生成, 虚表中的数据</p>
<p>以及这些数据在多重继承, 虚继承, 多重虚继承环境下的表现</p>
<h3 id="虚指针-virtual-point"><a href="#虚指针-virtual-point" class="headerlink" title="虚指针(virtual point)"></a>虚指针(virtual point)</h3><p>考虑以下代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"A %d\n"</span>, _i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"A2 %d\n"</span>, _i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> _i = <span class="number">10</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"B %d\n"</span>, _i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> _i = <span class="number">20</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    A *pa = &amp;b;</span><br><span class="line">    </span><br><span class="line">    pa-&gt;func();		<span class="comment">// B 20</span></span><br><span class="line">    pa-&gt;func2();	<span class="comment">// A2 10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出和预期一致, 其中 func 是被 B 覆盖过的虚函数, 而 func2 则未被覆盖</p>
<p>以下是生成的汇编代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line">.LFB1199:</span><br><span class="line">    pushq   %rbp</span><br><span class="line">    movq    %rsp, %rbp</span><br><span class="line">    subq    $32, %rsp</span><br><span class="line">    movq    $_ZTV1B+16, -32(%rbp)	&#x2F;&#x2F; 又是这个东西, 现在我怀疑它是 lippman 说的 thunk</span><br><span class="line">    							&#x2F;&#x2F; 后面知道了, **其实这就是虚指针, 它被放到了头部**</span><br><span class="line">    							&#x2F;&#x2F; 编译器非常聪明, 在即使有 vptr, nontrivial 的情况下</span><br><span class="line">    							&#x2F;&#x2F; 也并未生成构造函数</span><br><span class="line">    movl    $10, -24(%rbp)	</span><br><span class="line">    movl    $20, -20(%rbp)</span><br><span class="line">    leaq    -32(%rbp), %rax</span><br><span class="line">    movq    %rax, -8(%rbp)</span><br><span class="line">    movq    -8(%rbp), %rax</span><br><span class="line">    movq    (%rax), %rax	&#x2F;&#x2F; rax &#x3D; vptr	拿到虚指针地址</span><br><span class="line">    movq    (%rax), %rax	&#x2F;&#x2F; rax &#x3D; *vptr	获得虚指针中的地址(槽 0)</span><br><span class="line">    movq    -8(%rbp), %rdx	&#x2F;&#x2F; member data 是直接位移得到的</span><br><span class="line">    movq    %rdx, %rdi</span><br><span class="line">    call    *%rax		&#x2F;&#x2F; 调用slot0</span><br><span class="line">    movq    -8(%rbp), %rax</span><br><span class="line">    movq    (%rax), %rax</span><br><span class="line">    addq    $8, %rax	&#x2F;&#x2F; 虚指针地址 +8 位移(也就是下一个槽)</span><br><span class="line">    movq    (%rax), %rax	&#x2F;&#x2F; 获得 slot1 的地址</span><br><span class="line">    movq    -8(%rbp), %rdx</span><br><span class="line">    movq    %rdx, %rdi</span><br><span class="line">    call    *%rax	&#x2F;&#x2F; 调用slot1</span><br><span class="line">    movl    $0, %eax</span><br><span class="line">    leave</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>

<p>所以调用方式和书中一致, 从 vptr 索引虚表, 获得相应的 slot</p>
<p>这些信息全部都是在编译的时候由编译器生成</p>
<p>有一个点我忽略了: <strong>单一继承对象只有一个虚表</strong></p>
<p>后续我加上 C 对象后( C 继承自 A ), 让 B 继承 A, 这样A中就有 B C</p>
<p>但是依旧只有一个虚表, 仅当我让A再继承一个对象时, 这时产生了 2 个虚表</p>
<p>可能会问, 那么C对象是如何通过 pc-&gt;A::func() 这样的形式来调用 A 作用域的函数的呢?</p>
<p>答案是, 这会是一个单纯的函数调用, 并不会通过虚表或虚指针, 也没有任何的偏移</p>
<p>(emmm… 也就是说普通成员函数对于类来说, 可能更像是个陌生人, 即使它是成员)</p>
<p>(这也是为什么大多数情况下基类需要 virtual destruct 的原因)</p>
<h3 id="虚析构是如何被调用的"><a href="#虚析构是如何被调用的" class="headerlink" title="虚析构是如何被调用的"></a>虚析构是如何被调用的</h3><p>在写标题的时候大概猜到了, 其实虚析构就是一个在子类中占了一个不能被重写的虚表槽</p>
<p>应该就是通过简单的偏移来调用的, 来试一下</p>
<p>(重点在于虚析构是不可能被覆盖的, 因为子类中不可能存在同名的函数)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">5</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"> <span class="number">6</span> <span class="keyword">public</span>:</span><br><span class="line"> <span class="number">7</span>     <span class="keyword">virtual</span> ~A() &#123;</span><br><span class="line"> <span class="number">8</span>         <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, <span class="string">"A destruct"</span>);</span><br><span class="line"> <span class="number">9</span>     &#125;</span><br><span class="line"><span class="number">10</span> &#125;;</span><br><span class="line"><span class="number">11</span> </span><br><span class="line"><span class="number">12</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="number">13</span> <span class="keyword">public</span>:</span><br><span class="line"><span class="number">14</span>     <span class="keyword">virtual</span> ~B() &#123;</span><br><span class="line"><span class="number">15</span>         <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, <span class="string">"B destruct"</span>);</span><br><span class="line"><span class="number">16</span>     &#125;</span><br><span class="line"><span class="number">17</span> &#125;;</span><br><span class="line"><span class="number">18</span> </span><br><span class="line"><span class="number">19</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="number">20</span>     B a;</span><br><span class="line"><span class="number">21</span> </span><br><span class="line"><span class="number">22</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">23</span> &#125;</span><br></pre></td></tr></table></figure>

<p>汇编:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">161 main:</span><br><span class="line">162 .LFB1204:</span><br><span class="line">163     .cfi_startproc</span><br><span class="line">164     pushq   %rbp</span><br><span class="line">165     .cfi_def_cfa_offset 16</span><br><span class="line">166     .cfi_offset 6, -16</span><br><span class="line">167     movq    %rsp, %rbp</span><br><span class="line">168     .cfi_def_cfa_register 6</span><br><span class="line">169     pushq   %rbx</span><br><span class="line">170     subq    $24, %rsp</span><br><span class="line">171     .cfi_offset 3, -24</span><br><span class="line">172     movq    $_ZTV1B+16, -32(%rbp)</span><br><span class="line">173     movl    $0, %ebx</span><br><span class="line">174     leaq    -32(%rbp), %rax</span><br><span class="line">175     movq    %rax, %rdi</span><br><span class="line">176     call    _ZN1BD1Ev	&#x2F;&#x2F; 就是这里调用了析构函数</span><br><span class="line">177     movl    %ebx, %eax</span><br><span class="line">178     addq    $24, %rsp</span><br><span class="line">179     popq    %rbx</span><br><span class="line">180     popq    %rbp</span><br><span class="line">181     .cfi_def_cfa 7, 8</span><br><span class="line">182     ret</span><br><span class="line">183     .cfi_endproc</span><br></pre></td></tr></table></figure>

<p>B的析构:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> 89 _ZN1BD2Ev:	&#x2F;&#x2F; 如果足够细心, 那么注意到了这里是 _ZN1BD2Ev 而并非 _ZN1BD1Ev</span><br><span class="line"> 				&#x2F;&#x2F; 对此, 我发现编译器类似有个中间层一样的东西(或者说会符号替换?)</span><br><span class="line"> 				&#x2F;&#x2F; 然后其实会跳转到这里来, 汇编中将这两个东西相关联</span><br><span class="line"> 90 .LFB1201:</span><br><span class="line"> 91     .cfi_startproc</span><br><span class="line"> 92     .cfi_personality 0x3,__gxx_personality_v0</span><br><span class="line"> 93     .cfi_lsda 0x3,.LLSDA1201</span><br><span class="line"> 94     pushq   %rbp</span><br><span class="line"> 95     .cfi_def_cfa_offset 16</span><br><span class="line"> 96     .cfi_offset 6, -16</span><br><span class="line"> 97     movq    %rsp, %rbp</span><br><span class="line"> 98     .cfi_def_cfa_register 6</span><br><span class="line"> 99     subq    $16, %rsp</span><br><span class="line">100     movq    %rdi, -8(%rbp)</span><br><span class="line">101     movq    -8(%rbp), %rax</span><br><span class="line">102     movq    $_ZTV1B+16, (%rax)</span><br><span class="line">103     movl    $.LC1, %edi</span><br><span class="line">104     call    puts	&#x2F;&#x2F; 编译器知道只是打印一个字符串, 所以调用的是 puts</span><br><span class="line">105     movq    -8(%rbp), %rax</span><br><span class="line">106     movq    %rax, %rdi</span><br><span class="line">107     call    _ZN1AD2Ev	&#x2F;&#x2F; 和我想的不一样, 又一样...</span><br><span class="line">108     movl    $0, %eax</span><br><span class="line">109     testl   %eax, %eax</span><br><span class="line">110     je  .L6	&#x2F;&#x2F; 这里我也不太懂, 这个不是必跳么?</span><br><span class="line">111     movq    -8(%rbp), %rax</span><br><span class="line">112     movq    %rax, %rdi</span><br><span class="line">113     call    _ZdlPv	&#x2F;&#x2F; 这个东西没有找到</span><br></pre></td></tr></table></figure>

<p>和预料中不同的是, A 的析构函数是直接调用的, 而并非偏移  </p>
<p>想了想这在意料之中, 因为编译器将它优化成了普通函数</p>
<p>至于 _ZdlPv, 没有在汇编中找到这个符号 … </p>
<p>(我试了一下, 没有什么好的方式让它像被虚函数一样调用, 很可惜…)</p>
<h3 id="虚继承的析构函数调用"><a href="#虚继承的析构函数调用" class="headerlink" title="虚继承的析构函数调用"></a>虚继承的析构函数调用</h3><p>感觉非常奇怪, 所以本来是打算看看就好的, 因为之前花功夫去看了看虚继承的内存布局</p>
<p>不过实在太奇怪了, 所以打算好好分析一下, 顺便我在之前分析的时候好像忘了看虚继承的虚函数调用了</p>
<p>因为那时候好像已经晕了… </p>
<p>它会怎么被调用呢? 最无趣的情况就是像上面那样硬编码</p>
<p>不过在虚继承这种比较复杂的环境下, 编译器可能会做出其他反应也说不定?</p>
<p>源码就单纯的E被CD虚继承, B继承CD, 这里直接汇编:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line">.LFB1212:</span><br><span class="line">    .cfi_startproc</span><br><span class="line">    pushq   %rbp</span><br><span class="line">    .cfi_def_cfa_offset 16</span><br><span class="line">    .cfi_offset 6, -16</span><br><span class="line">    movq    %rsp, %rbp</span><br><span class="line">    .cfi_def_cfa_register 6</span><br><span class="line">    pushq   %rbx	&#x2F;&#x2F; 这里, 与前面的 pushq 无关</span><br><span class="line">    subq    $56, %rsp</span><br><span class="line">    .cfi_offset 3, -24</span><br><span class="line">    leaq    -64(%rbp), %rax	&#x2F;&#x2F; 前面有 pushq, 所以这里是 -64</span><br><span class="line">    movq    %rax, %rdi</span><br><span class="line">    call    _ZN1BC1Ev	&#x2F;&#x2F; 构造</span><br><span class="line">    movl    $0, %ebx</span><br><span class="line">    leaq    -64(%rbp), %rax</span><br><span class="line">    movq    %rax, %rdi</span><br><span class="line">    call    _ZN1BD1Ev	&#x2F;&#x2F; 析构</span><br><span class="line">    movl    %ebx, %eax</span><br><span class="line">    addq    $56, %rsp</span><br><span class="line">    popq    %rbx</span><br><span class="line">    popq    %rbp</span><br><span class="line">    .cfi_def_cfa 7, 8</span><br><span class="line">    ret</span><br><span class="line">    .cfi_endproc</span><br></pre></td></tr></table></figure>

<p>B的析构函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">457 _ZN1BD1Ev:</span><br><span class="line">458 .LFB1210:</span><br><span class="line">459     .cfi_startproc</span><br><span class="line">460     .cfi_personality 0x3,__gxx_personality_v0</span><br><span class="line">461     .cfi_lsda 0x3,.LLSDA1210</span><br><span class="line">462     pushq   %rbp</span><br><span class="line">463     .cfi_def_cfa_offset 16</span><br><span class="line">464     .cfi_offset 6, -16</span><br><span class="line">465     movq    %rsp, %rbp</span><br><span class="line">466     .cfi_def_cfa_register 6</span><br><span class="line">467     subq    $16, %rsp</span><br><span class="line">468     movq    %rdi, -8(%rbp)</span><br><span class="line">469     movl    $_ZTV1B+24, %edx</span><br><span class="line">470     movq    -8(%rbp), %rax</span><br><span class="line">471     movq    %rdx, (%rax)	&#x2F;&#x2F; 栈顶加入了虚指针 +24</span><br><span class="line">472     movl    $32, %edx</span><br><span class="line">473     movq    -8(%rbp), %rax</span><br><span class="line">474     addq    %rax, %rdx</span><br><span class="line">475     movl    $_ZTV1B+104, %eax</span><br><span class="line">476     movq    %rax, (%rdx)	&#x2F;&#x2F; 栈顶 -32 处加入了虚指针 +104</span><br><span class="line">477     movl    $_ZTV1B+64, %edx</span><br><span class="line">478     movq    -8(%rbp), %rax</span><br><span class="line">479     movq    %rdx, 16(%rax)	&#x2F;&#x2F; 栈顶 -16 处加入了虚指针 +64</span><br><span class="line">480     movq    -8(%rbp), %rax</span><br><span class="line">481     movl    28(%rax), %eax</span><br><span class="line">482     movl    %eax, %esi</span><br><span class="line">483     movl    $.LC3, %edi	&#x2F;&#x2F; .string &quot;B destruct: %d\n&quot;</span><br><span class="line">484     movl    $0, %eax</span><br><span class="line">485     call    printf</span><br><span class="line">486     movl    $_ZTT1B+24, %eax</span><br><span class="line">487     movq    -8(%rbp), %rdx</span><br><span class="line">488     addq    $16, %rdx</span><br><span class="line">489     movq    %rax, %rsi</span><br><span class="line">490     movq    %rdx, %rdi</span><br><span class="line">491     call    _ZN1CD2Ev	&#x2F;&#x2F; 硬编码...</span><br><span class="line">492     movl    $_ZTT1B+8, %edx</span><br><span class="line">493     movq    -8(%rbp), %rax</span><br><span class="line">494     movq    %rdx, %rsi</span><br><span class="line">495     movq    %rax, %rdi</span><br><span class="line">496     call    _ZN1AD2Ev</span><br><span class="line">497     movl    $2, %eax</span><br><span class="line">498     testl   %eax, %eax</span><br><span class="line">499     je  .L23</span><br><span class="line">500     movq    -8(%rbp), %rax</span><br><span class="line">501     addq    $32, %rax</span><br><span class="line">502     movq    %rax, %rdi</span><br><span class="line">503     call    _ZN1ED2Ev</span><br><span class="line">504     nop</span><br></pre></td></tr></table></figure>

<p>虚函数是通过硬编码来调用的  </p>
<p>不过有个非常不错的发现, 我在 _ZTT1B 中发现了 LTHUNK 的影子</p>
<p>在 _ZTT1B  中有 LTHUNK  相关的代码, 不过很可惜, 这些猜测无从证明…</p>
<p>来看看虚函数的调用吧:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">911 main:</span><br><span class="line">912 .LFB1216:</span><br><span class="line">913     .cfi_startproc</span><br><span class="line">914     .cfi_personality 0x3,__gxx_personality_v0</span><br><span class="line">915     .cfi_lsda 0x3,.LLSDA1216</span><br><span class="line">916     pushq   %rbp</span><br><span class="line">917     .cfi_def_cfa_offset 16</span><br><span class="line">918     .cfi_offset 6, -16</span><br><span class="line">919     movq    %rsp, %rbp</span><br><span class="line">920     .cfi_def_cfa_register 6</span><br><span class="line">921     pushq   %rbx</span><br><span class="line">922     subq    $88, %rsp</span><br><span class="line">923     .cfi_offset 3, -24</span><br><span class="line">924     leaq    -96(%rbp), %rax</span><br><span class="line">925     movq    %rax, %rdi</span><br><span class="line">926     call    _ZN1BC1Ev</span><br><span class="line">927     leaq    -96(%rbp), %rax</span><br><span class="line">928     movq    %rax, -24(%rbp)</span><br><span class="line">929     movq    -24(%rbp), %rax</span><br><span class="line">930     movq    (%rax), %rax	&#x2F;&#x2F; 解引用</span><br><span class="line">931     addq    $16, %rax		&#x2F;&#x2F; +16</span><br><span class="line">932     movq    (%rax), %rax	&#x2F;&#x2F; 取这个槽中的地址</span><br><span class="line">933     movq    -24(%rbp), %rdx</span><br><span class="line">934     movq    %rdx, %rdi</span><br><span class="line">935 .LEHB0:</span><br><span class="line">936     call    *%rax</span><br><span class="line">937     leaq    -96(%rbp), %rax</span><br><span class="line">938     movq    %rax, -32(%rbp)</span><br><span class="line">939     movq    -32(%rbp), %rax</span><br><span class="line">940     movq    (%rax), %rax</span><br><span class="line">941     addq    $16, %rax		&#x2F;&#x2F; +16</span><br><span class="line">942     movq    (%rax), %rax</span><br><span class="line">943     movq    -32(%rbp), %rdx</span><br><span class="line">944     movq    %rdx, %rdi</span><br><span class="line">945     call    *%rax			&#x2F;&#x2F; A, B使用了一样的虚表和槽, 仅仅是this指针不同</span><br><span class="line">946     leaq    -96(%rbp), %rax</span><br><span class="line">947     addq    $16, %rax		&#x2F;&#x2F; +16</span><br><span class="line">948     movq    %rax, -40(%rbp)</span><br><span class="line">949     movq    -40(%rbp), %rax</span><br><span class="line">950     movq    (%rax), %rax	</span><br><span class="line">951     addq    $16, %rax		&#x2F;&#x2F; +16</span><br><span class="line">952     movq    (%rax), %rax</span><br><span class="line">953     movq    -40(%rbp), %rdx</span><br><span class="line">954     movq    %rdx, %rdi</span><br><span class="line">955     call    *%rax			&#x2F;&#x2F; C 先是 +16 取到自己的虚表, 然后同样使用槽 1</span><br><span class="line">956 .LEHE0:</span><br><span class="line">957     movl    $0, %ebx</span><br><span class="line">958     leaq    -96(%rbp), %rax</span><br><span class="line">959     movq    %rax, %rdi</span><br><span class="line"> 960     call    _ZN1BD1Ev</span><br><span class="line">961     movl    %ebx, %eax</span><br><span class="line">962     jmp .L39</span><br><span class="line">963 .L38:</span><br><span class="line">964     movq    %rax, %rbx</span><br><span class="line">965     leaq    -96(%rbp), %rax</span><br><span class="line">966     movq    %rax, %rdi</span><br><span class="line">967     call    _ZN1BD1Ev</span><br><span class="line">968     movq    %rbx, %rax</span><br><span class="line">969     movq    %rax, %rdi</span><br><span class="line">970 .LEHB1:</span><br><span class="line">971     call    _Unwind_Resume</span><br><span class="line">972 .LEHE1:</span><br><span class="line">973 .L39:</span><br><span class="line">974     addq    $88, %rsp</span><br><span class="line">975     popq    %rbx</span><br><span class="line">976     popq    %rbp</span><br><span class="line">977     .cfi_def_cfa 7, 8</span><br><span class="line">978     ret</span><br><span class="line">979     .cfi_endproc</span><br></pre></td></tr></table></figure>

<p>普通虚函数的调用就是找到自己的虚表, 调用对应的槽</p>
<p>这个虚继承来的虚函数调用和普通继承的虚函数调用方式基本一致</p>
<p>多态是如何实现的呢?</p>
<p>每个构造函数, 都会覆写它的所有虚指针, 使他指向不同的地址(但是这些地址都不相同!!!)</p>
<p>如你所见, 当C指针去调用时, 发生了偏移, 虽然取到了同样的 slot, 但却不是同一张虚表</p>
<p>那么我能想到的就是有多张相同的虚表</p>
<p>(我只能如此猜测, 我想不到为什么这样的情况下还能调用同一个函数)</p>
<p>(但是为什么要有相同的呢? 这又是一个问题)</p>
<p>我尝试了看看这些虚表中是什么数据, 可惜失败了, 或者说看不懂</p>
<p>但是同一个类的虚表是完全相同的, 这可以肯定</p>
<p>不同的情况仅在于A类中C类和单独的C类, 这两个C类的虚表是不一样的</p>
<h3 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h3><p>虚函数机制和书中所说基本一致</p>
<ol>
<li>找到对应的虚表</li>
<li>调用槽中的函数</li>
</ol>
<h3 id="review"><a href="#review" class="headerlink" title="review"></a>review</h3><p>我在 objdump 的输出中发现, 诸如 _ZTI1C 这样的东西在链接的时候会转化成一个数字常量</p>
<p>有些可能会是基于某个位置的偏移(比如 %rip)</p>
<p>编译器会利用它进行直接寻址, 有些会利用它进行间接寻址</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/09/other/virtualInherit/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cas">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cas's website">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/09/other/virtualInherit/" class="post-title-link" itemprop="url">other/virtualInherit</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-09 17:14:16 / Modified: 17:12:51" itemprop="dateCreated datePublished" datetime="2020-01-09T17:14:16+08:00">2020-01-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>想要了解一下虚继承的内部数据结构</p>
<p>(语言: c++, 编译器: g++(4.8.5))</p>
<h3 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h3><p>考虑以下代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> _i = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> _i = <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> _i = <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B, <span class="keyword">public</span> C&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> _i = <span class="number">4</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>单纯的虚拟继承而已, 我使用了这种方式打印它们的内部数据</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">D a;</span><br><span class="line"><span class="keyword">void</span> *p = &amp;a;</span><br><span class="line"><span class="keyword">int</span> *pi = (<span class="keyword">int</span> *)p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(a) / <span class="number">4</span>; ++i)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, pi[i]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"val:%d\n"</span>, a._i);</span><br></pre></td></tr></table></figure>

<p>然后它们A, B, C, D内部数据情况如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">A: 	<span class="number">1</span></span><br><span class="line">B: 	<span class="number">4196632</span></span><br><span class="line">    <span class="number">0</span></span><br><span class="line">    <span class="number">2</span></span><br><span class="line">    <span class="number">1</span></span><br><span class="line">C: 	<span class="number">4196632</span></span><br><span class="line">    <span class="number">0</span></span><br><span class="line">    <span class="number">3</span></span><br><span class="line">    <span class="number">1</span></span><br><span class="line">D:	<span class="number">4196760</span></span><br><span class="line">    <span class="number">0</span></span><br><span class="line">    <span class="number">2</span></span><br><span class="line">    <span class="number">0</span></span><br><span class="line">    <span class="number">4196784</span></span><br><span class="line">    <span class="number">0</span></span><br><span class="line">    <span class="number">3</span></span><br><span class="line">    <span class="number">4</span></span><br><span class="line">    <span class="number">1</span></span><br><span class="line">    <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>emmm… </p>
<p>OK, 我可以把前两个 4 字节认为是虚指针(A没有) </p>
<p>那么A, B, C的内存分布就不用看了, 唯一比较特殊的是<strong>虚基类在内存的高地址</strong></p>
<p>然后D的内部分布… 这… emmm… 仔细一想, 还好, 重要的是(Q1: 为什么最后补了一个0 ??)</p>
<h3 id="存取方式"><a href="#存取方式" class="headerlink" title="存取方式"></a>存取方式</h3><p>我试着访问了一下数据</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">D a;</span><br><span class="line">A *pa = &amp;a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, pa-&gt;_i);</span><br><span class="line">B *pb = &amp;a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, pb-&gt;_i);</span><br><span class="line">C *pc = &amp;a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, pc-&gt;_i);</span><br><span class="line">D *pd = &amp;a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, pd-&gt;_i);</span><br></pre></td></tr></table></figure>

<p>来看一看汇编</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">pushq   %rbp</span><br><span class="line">.cfi_def_cfa_offset 16</span><br><span class="line">.cfi_offset 6, -16</span><br><span class="line">movq    %rsp, %rbp</span><br><span class="line">.cfi_def_cfa_register 6</span><br><span class="line">subq    $80, %rsp		&#x2F;&#x2F; 80 栈帧</span><br><span class="line">leaq    -80(%rbp), %rax	</span><br><span class="line">movq    %rax, %rdi	</span><br><span class="line">call    _ZN1DC1Ev		&#x2F;&#x2F; 这里是构造函数, 稍后可能需要看看它的构造</span><br><span class="line">leaq    -80(%rbp), %rax</span><br><span class="line">addq    $32, %rax		&#x2F;&#x2F; +32, OK, 向上 32 字节的确是 1</span><br><span class="line">movq    %rax, -8(%rbp)	</span><br><span class="line">movq    -8(%rbp), %rax</span><br><span class="line">movl    (%rax), %eax</span><br><span class="line">movl    %eax, %esi</span><br><span class="line">movl    $.LC0, %edi</span><br><span class="line">movl    $0, %eax</span><br><span class="line">call    printf			&#x2F;&#x2F; 1 第一次printf</span><br><span class="line">leaq    -80(%rbp), %rax</span><br><span class="line">movq    %rax, -16(%rbp)</span><br><span class="line">movq    -16(%rbp), %rax	&#x2F;&#x2F; B 类型指针并没有经过偏移, 这和预料的一样</span><br><span class="line">movl    8(%rax), %eax	&#x2F;&#x2F; 这里+8, 跳过了虚指针</span><br><span class="line">movl    %eax, %esi</span><br><span class="line">movl    $.LC0, %edi</span><br><span class="line">movl    $0, %eax</span><br><span class="line">call    printf			&#x2F;&#x2F; 2 第二次printf</span><br><span class="line">leaq    -80(%rbp), %rax</span><br><span class="line">addq    $16, %rax		&#x2F;&#x2F; +16 C类型指针跳过了 B的内存, 这也没什么不对</span><br><span class="line">movq    %rax, -24(%rbp)</span><br><span class="line">movq    -24(%rbp), %rax	</span><br><span class="line">movl    8(%rax), %eax	&#x2F;&#x2F; 同理</span><br><span class="line">movl    %eax, %esi</span><br><span class="line">movl    $.LC0, %edi</span><br><span class="line">movl    $0, %eax</span><br><span class="line">call    printf			&#x2F;&#x2F; 3 第三次printf</span><br><span class="line">leaq    -80(%rbp), %rax</span><br><span class="line">movq    %rax, -32(%rbp)</span><br><span class="line">movq    -32(%rbp), %rax</span><br><span class="line">movl    28(%rax), %eax	&#x2F;&#x2F; +28 OK~</span><br><span class="line">movl    %eax, %esi</span><br><span class="line">movl    $.LC0, %edi</span><br><span class="line">movl    $0, %eax</span><br><span class="line">call    printf			&#x2F;&#x2F; 4 第四次printf</span><br><span class="line">movl    $0, %eax</span><br><span class="line">leave</span><br></pre></td></tr></table></figure>

<p>数据的访问在编译时就已经定好的, 不存在额外效率影响</p>
<p>A指针    偏移了 +32 字节     直接访问数据</p>
<p>B指针    未偏移             访问数据时跳过了虚指针(8字节)</p>
<p>C指针    偏移 +16 字节     访问数据时跳过了虚指针(8字节)</p>
<p>D指针    未偏移             访问数据时跳过了虚指针 + B, C类数据(共28字节)</p>
<p>或许看一下访问虚基类的数据会有所了解? </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">pushq   %rbp</span><br><span class="line">.cfi_def_cfa_offset 16</span><br><span class="line">.cfi_offset 6, -16</span><br><span class="line">movq    %rsp, %rbp</span><br><span class="line">.cfi_def_cfa_register 6</span><br><span class="line">subq    $80, %rsp</span><br><span class="line">leaq    -80(%rbp), %rax</span><br><span class="line">movq    %rax, %rdi</span><br><span class="line">call    _ZN1DC1Ev</span><br><span class="line">leaq    -80(%rbp), %rax</span><br><span class="line">addq    $32, %rax</span><br><span class="line">movq    %rax, -8(%rbp)</span><br><span class="line">movq    -8(%rbp), %rax</span><br><span class="line">movl    (%rax), %eax</span><br><span class="line">movl    %eax, %esi</span><br><span class="line">movl    $.LC0, %edi</span><br><span class="line">movl    $0, %eax</span><br><span class="line">call    printf			&#x2F;&#x2F; 基类访问方式和上面的汇编并没有不同</span><br><span class="line">leaq    -80(%rbp), %rax</span><br><span class="line">movq    %rax, -16(%rbp)</span><br><span class="line">movq    -16(%rbp), %rax</span><br><span class="line">movq    (%rax), %rax	&#x2F;&#x2F; 取指针指向的值, 也就是D的地址</span><br><span class="line">subq    $24, %rax		&#x2F;&#x2F; D地址减去24字节 也就是说, 它前面还有东西</span><br><span class="line">movq    (%rax), %rax	&#x2F;&#x2F; 获得那个地址中的值</span><br><span class="line">movq    %rax, %rdx</span><br><span class="line">movq    -16(%rbp), %rax</span><br><span class="line">addq    %rdx, %rax		&#x2F;&#x2F; 增加了 rdx 大小, </span><br><span class="line">movl    (%rax), %eax</span><br><span class="line">movl    %eax, %esi</span><br><span class="line">movl    $.LC0, %edi</span><br><span class="line">movl    $0, %eax</span><br><span class="line">call    printf</span><br><span class="line">leaq    -80(%rbp), %rax</span><br><span class="line">addq    $16, %rax</span><br><span class="line">movq    %rax, -24(%rbp)</span><br><span class="line">movq    -24(%rbp), %rax</span><br><span class="line">movq    (%rax), %rax</span><br><span class="line">subq    $24, %rax</span><br><span class="line">movq    (%rax), %rax</span><br><span class="line">movq    %rax, %rdx</span><br><span class="line">movq    -24(%rbp), %rax</span><br><span class="line">addq    %rdx, %rax</span><br><span class="line">movl    (%rax), %eax</span><br><span class="line">movl    %eax, %esi</span><br><span class="line">movl    $.LC0, %edi</span><br><span class="line">movl    $0, %eax</span><br><span class="line">call    printf</span><br><span class="line">leaq    -80(%rbp), %rax</span><br><span class="line">movq    %rax, -32(%rbp)</span><br><span class="line">movq    -32(%rbp), %rax</span><br><span class="line">movq    (%rax), %rax</span><br><span class="line">subq    $24, %rax</span><br><span class="line">movq    (%rax), %rax</span><br><span class="line">movq    %rax, %rdx</span><br><span class="line">movq    -32(%rbp), %rax</span><br><span class="line">addq    %rdx, %rax</span><br><span class="line">movl    (%rax), %eax</span><br><span class="line">movl    %eax, %esi</span><br><span class="line">movl    $.LC0, %edi</span><br><span class="line">movl    $0, %eax</span><br><span class="line">call    printf</span><br><span class="line">movl    $0, %eax</span><br><span class="line">leave</span><br></pre></td></tr></table></figure>

<p>emmm… 有一个重大的发现就是, <strong>基类对象前面有数据</strong></p>
<p>这些数据应该是偏移, 这些偏移配合 + 指针本身的地址能够访问到正确的虚基类数据</p>
<p>也就是说, 这是 深入探索对象 中, 对于虚基类的两种实现方式中的第一种</p>
<p>即: 在每个基类中添加虚基类的偏移, 但是又不全对…</p>
<p>越来越糊涂了 (눈_눈), 深吸一口气, 想想自己要干嘛… emmmm….</p>
<p>这样吧, 完整地看一遍构造的过程, 这样应该就明白了</p>
<p>(如果还是晕, 那么就希望下次遇到这个问题的时候能够更从容一些)</p>
<p>(我已经再这个问题上花太多时间, 再这样下去反而不好, 这也不是一个很重要/常用的知识)</p>
<h3 id="完整的构造过程"><a href="#完整的构造过程" class="headerlink" title="完整的构造过程"></a>完整的构造过程</h3><p>首先是 main 区块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line">.LFB1196:</span><br><span class="line">    pushq	%rbp</span><br><span class="line">    movq	%rsp, %rbp</span><br><span class="line">    subq	$48, %rsp	&#x2F;&#x2F; 48 字节栈帧, 为什么是 48 呢?</span><br><span class="line">    leaq	-48(%rbp), %rax</span><br><span class="line">    movq	%rax, %rdi</span><br><span class="line">    call	_ZN1DC1Ev	&#x2F;&#x2F; 调用构造函数</span><br><span class="line">    movl	$0, %eax</span><br><span class="line">    leave</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>
<p>然后是D的构造函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">_ZN1DC1Ev:</span><br><span class="line">.LFB1208:</span><br><span class="line">    pushq	%rbp</span><br><span class="line">    movq	%rsp, %rbp</span><br><span class="line">    subq	$16, %rsp		&#x2F;&#x2F; 它再次开辟了 16 字节的栈帧</span><br><span class="line">    movq	%rdi, -8(%rbp)	&#x2F;&#x2F; 把原栈顶指针放入了栈中</span><br><span class="line">    movq	-8(%rbp), %rax	</span><br><span class="line">    addq	$32, %rax		&#x2F;&#x2F; 原栈顶指针 +32 偏移, 距栈底还有 16 字节</span><br><span class="line">    movq	%rax, %rdi</span><br><span class="line">    call	_ZN1AC2Ev		&#x2F;&#x2F; 这里留了 16 字节用于 A 的构造</span><br><span class="line">    movl	$_ZTT1D+8, %edx	&#x2F;&#x2F; 我很好奇地查了 $_ZTT1D 这东西是多少, 然而事实让我绝望...</span><br><span class="line">    						&#x2F;&#x2F; 它有非常多的耦合, 短时间内我根本无法计算出这东西是多少!!!</span><br><span class="line">    						&#x2F;&#x2F; 而且里面的代码是以.开头的, 这意味着是伪指令... (;´༎ຶД༎ຶ&#96;)</span><br><span class="line">    movq	-8(%rbp), %rax</span><br><span class="line">    movq	%rdx, %rsi		&#x2F;&#x2F; rdx 从未被赋值过, 我很好奇它将什么值给了 rsi</span><br><span class="line">    						&#x2F;&#x2F; 对了, 在上面一句用到了 edx, 这和 rdx 有关</span><br><span class="line">    						&#x2F;&#x2F; 暂且把它认为是一个, 编译器施加的魔法: magic</span><br><span class="line">    movq	%rax, %rdi		&#x2F;&#x2F; 原栈顶指针</span><br><span class="line">    call	_ZN1BC2Ev		&#x2F;&#x2F; 调用 B 构造函数</span><br><span class="line">    movl	$_ZTT1D+16, %eax</span><br><span class="line">    movq	-8(%rbp), %rdx	&#x2F;&#x2F; 拿出原栈顶指针</span><br><span class="line">    addq	$16, %rdx		&#x2F;&#x2F; +16 偏移</span><br><span class="line">    movq	%rax, %rsi</span><br><span class="line">    movq	%rdx, %rdi</span><br><span class="line">    call	_ZN1CC2Ev		&#x2F;&#x2F; 调用 C 构造函数</span><br><span class="line">    movl	$_ZTV1D+24, %edxl</span><br><span class="line">    movq	-8(%rbp), %rax</span><br><span class="line">    movq	%rdx, (%rax)	&#x2F;&#x2F; 这里与调用 B 时的步骤重复了 :), 覆写</span><br><span class="line">    movl	$_ZTV1D+48, %edx</span><br><span class="line">    movq	-8(%rbp), %rax</span><br><span class="line">    movq	%rdx, 16(%rax)	&#x2F;&#x2F; 这里与调用 C 时的步骤重复了 :), 覆写</span><br><span class="line">    movq	-8(%rbp), %rax</span><br><span class="line">    movl	$444, 28(%rax)	&#x2F;&#x2F; 写入值</span><br><span class="line">    leave</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>
<p>A的构造函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">_ZN1AC2Ev:</span><br><span class="line">.LFB1199:</span><br><span class="line">    pushq	%rbp</span><br><span class="line">    movq	%rsp, %rbp</span><br><span class="line">    movq	%rdi, -8(%rbp)</span><br><span class="line">    movq	-8(%rbp), %rax</span><br><span class="line">    movl	$111, (%rax)	&#x2F;&#x2F; 将 $111 放入了参数 rdi 指向的内存中 movl: 4字节</span><br><span class="line">    popq	%rbp</span><br><span class="line">    ret		&#x2F;&#x2F; 嗯, 没了, 所以编译器仅仅对这 4 字节赋值</span><br><span class="line">    		&#x2F;&#x2F; 剩下的 12 字节呢?</span><br><span class="line">    		&#x2F;&#x2F; 其中8字节没用过, 或者不在 D 的内存中, 因为 sizeof d 是40, 而非48</span><br></pre></td></tr></table></figure>
<p>B的构造函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">_ZN1BC2Ev:</span><br><span class="line">.LFB1202:</span><br><span class="line">    pushq	%rbp</span><br><span class="line">    movq	%rsp, %rbp</span><br><span class="line">    movq	%rdi, -8(%rbp)	&#x2F;&#x2F; 原栈顶指针</span><br><span class="line">    movq	%rsi, -16(%rbp)	&#x2F;&#x2F; 未知的原 rdx(magic)</span><br><span class="line">    movq	-16(%rbp), %rax</span><br><span class="line">    movq	(%rax), %rdx	&#x2F;&#x2F; magic的地址 -16 中的值放入 rdx</span><br><span class="line">    movq	-8(%rbp), %rax</span><br><span class="line">    movq	%rdx, (%rax)	&#x2F;&#x2F; 将 rdx 中的值放入了栈顶, 这里是q, 占了 8 字节</span><br><span class="line">    movq	-8(%rbp), %rax</span><br><span class="line">    movl	$222, 8(%rax)	&#x2F;&#x2F; 栈顶 +8 偏移中, 放入了 $222</span><br><span class="line">    popq	%rbp</span><br><span class="line">    ret				&#x2F;&#x2F; 共写入了 12 字节</span><br></pre></td></tr></table></figure>
<p>C的构造函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">_ZN1CC2Ev:</span><br><span class="line">.LFB1205:</span><br><span class="line">    pushq	%rbp</span><br><span class="line">    movq	%rsp, %rbp</span><br><span class="line">    movq	%rdi, -8(%rbp)</span><br><span class="line">    movq	%rsi, -16(%rbp)</span><br><span class="line">    movq	-16(%rbp), %rax</span><br><span class="line">    movq	(%rax), %rdx</span><br><span class="line">    movq	-8(%rbp), %rax</span><br><span class="line">    movq	%rdx, (%rax)</span><br><span class="line">    movq	-8(%rbp), %rax</span><br><span class="line">    movl	$333, 8(%rax)</span><br><span class="line">    popq	%rbp		&#x2F;&#x2F; 步骤与 B 基本相同</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>
<p>也就是说, 在D的构造中, ABC的构造都被调用了</p>
<p>要注意的一点是, BC都未调用A的构造, A的构造仅在D中调用了一次</p>
<p>同时要注意的是, BC会用那个编译器给的数字往自身的内存布局中写值</p>
<p>但是如果其上有D, D会将那个值覆写一次, 假设其值恒定不变, 位移分别为:</p>
<p>8 16 24 48</p>
<p>这是一组有规律的数字, 以 8 为开始, 每个数字是前面数字之和(这个就是偏移)</p>
<p>剩下来最重要的是, D覆写了什么?</p>
<p>再次来看看是如何访问虚基类数据的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">D a;</span><br><span class="line">C *pd = &amp;a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, pd-&gt;A::_i);</span><br></pre></td></tr></table></figure>


<p>汇编:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">.LFB1196:</span><br><span class="line">    pushq   %rbp</span><br><span class="line">    movq    %rsp, %rbp</span><br><span class="line">    subq    $48, %rsp</span><br><span class="line">    leaq    -48(%rbp), %rax</span><br><span class="line">    movq    %rax, %rdi</span><br><span class="line">    call    _ZN1DC1Ev</span><br><span class="line">    leaq    -48(%rbp), %rax</span><br><span class="line">    addq    $16, %rax		&#x2F;&#x2F; 因为是 C 类型指针, 所以做了 +16 偏移</span><br><span class="line">    movq    %rax, -8(%rbp)	&#x2F;&#x2F; C *pd &#x3D; &amp;a;</span><br><span class="line">    movq    -8(%rbp), %rax</span><br><span class="line">    movq    (%rax), %rax	&#x2F;&#x2F; 获得了指针中的值</span><br><span class="line">    subq    $24, %rax		&#x2F;&#x2F; 该值减去 24 </span><br><span class="line">    movq    (%rax), %rax	&#x2F;&#x2F; 再以该值间接寻址</span><br><span class="line">    movq    %rax, %rdx</span><br><span class="line">    movq    -8(%rbp), %rax</span><br><span class="line">    addq    %rdx, %rax		&#x2F;&#x2F; rdx 本身的值 + 指针的值</span><br><span class="line">    movl    (%rax), %eax	&#x2F;&#x2F; 间接寻址得到的值就是虚基类的值</span><br><span class="line">    movl    %eax, %esi</span><br><span class="line">    movl    $.LC0, %edi</span><br><span class="line">    movl    $0, %eax</span><br><span class="line">    call    printf</span><br><span class="line">    movl    $0, %eax</span><br><span class="line">    leave</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>

<p>这次要清晰得多了, 我们以上面D的内存布局为例:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4196760</span>	<span class="comment">// 2. 它减去 24 到了这里 </span></span><br><span class="line">    	<span class="comment">// 3. 用这里的值寻址得到了某个数 x </span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">4196784</span>	<span class="comment">// 1. 这是一开始 C 指针指向的内存</span></span><br><span class="line">    	<span class="comment">// 4. 用这个指针 + x 得到了虚基类数据的地址</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>那么在代码中试一下, 如果没有错误的话, 那个 x 应该是 4</p>
<p>(这个地址明显非常低, 它甚至没达到 8 字节, 这应该是编译的时候准备好的数据)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">D a;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> *pl = (<span class="keyword">long</span> <span class="keyword">long</span> *)&amp;a;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> *pl2 = (<span class="keyword">long</span> <span class="keyword">long</span> *)&amp;pl;</span><br><span class="line">*pl2 = *pl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%ld\n"</span>, *pl);	<span class="comment">// 16</span></span><br></pre></td></tr></table></figure>


<p>取出来了 16, emmm… 嗯, 没错, 4 个 4字节 4 x 4 = 16 !!!!!!! </p>
<p>PS: 有没有思考过为什么通过双间接才能去到虚基类呢?</p>
<p>这里明显的一个问题是, 虚基类的数据是通过 C 的某个地址索引到 D 的某个地址</p>
<p>然后再用 C 的地址索引到虚基类数据, 有两次的跳转 </p>
<p>我再次试了一下有继承三个虚基类的情况(就是D再继承了一个类似 BC的类)</p>
<p>发现它的访问方式是一样的, 也就是说, 每一个自身都会往前寻找固定的字节(编译后固定)</p>
<p>然后用那个地址的数据 + 指针本身的地址(我不知道我又没有表达清楚, 不过我感觉我没有 :) )</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> _i = <span class="number">555</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B, <span class="keyword">public</span> C, <span class="keyword">public</span> E&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> _i = <span class="number">444</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    D a;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> *pl = (<span class="keyword">long</span> <span class="keyword">long</span> *)&amp;a;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> *pl2 = (<span class="keyword">long</span> <span class="keyword">long</span> *)&amp;pl;</span><br><span class="line">    *pl2 = *pl;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%ld\n"</span>, *pl);   <span class="comment">// 32</span></span><br><span class="line"></span><br><span class="line">    pl = (<span class="keyword">long</span> <span class="keyword">long</span> *)&amp;a + <span class="number">2</span>;</span><br><span class="line">    pl2 = (<span class="keyword">long</span> <span class="keyword">long</span> *)&amp;pl;</span><br><span class="line">    *pl2 = *pl;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%ld\n"</span>, *pl);   <span class="comment">// 16</span></span><br><span class="line"></span><br><span class="line">    pl = (<span class="keyword">long</span> <span class="keyword">long</span> *)&amp;a + <span class="number">4</span>;</span><br><span class="line">    pl2 = (<span class="keyword">long</span> <span class="keyword">long</span> *)&amp;pl;</span><br><span class="line">    *pl2 = *pl;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%ld\n"</span>, *pl);   <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>内存布局:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4196856</span>	(<span class="number">32</span>)<span class="comment">// 2. 通过这个地址拿到偏移</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">222</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">4196880</span>	(<span class="number">16</span>)<span class="comment">// 1. C对象, 当我要找虚基类对象时, 我先往上移动固定字节</span></span><br><span class="line">    		<span class="comment">// 这些移动的大小都是在编译时就写死了的常量(编译器自动计算)</span></span><br><span class="line">    		<span class="comment">// 往上移动的字节会随着数据大小而改变, 但是数据中的地址是不变的</span></span><br><span class="line">    		<span class="comment">// 比如我这里是4196880, 那么无论往上移动多少</span></span><br><span class="line">    		<span class="comment">// 上一个地址中存的值恒定为 当前值 - 24 (4196856)</span></span><br><span class="line">    	<span class="comment">// 3. 根据拿到的偏移 + 地址获取虚基类数据</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">333</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">4196904</span> (<span class="number">0</span>)<span class="comment">// E对象, 它如果想拿到虚基类数据, 执行和 C 对象一样的操作就好</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">555</span></span><br><span class="line"><span class="number">444</span></span><br><span class="line"><span class="number">111</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>这样的内存布局在其他方面可能还会有用</p>
<p>那么为什么会有 0 呢? 我估计是因为要实现这种内存布局, 或者说什么其他原因</p>
<h3 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h3><p> 我很怀疑下次我看笔记时, 我自己看不看得懂我在说什么…</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/09/leetcode/160IntersectionofTwoLinkedList/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cas">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cas's website">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/09/leetcode/160IntersectionofTwoLinkedList/" class="post-title-link" itemprop="url">leetcode/160IntersectionofTwoLinkedList</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-09 17:08:55 / Modified: 17:07:59" itemprop="dateCreated datePublished" datetime="2020-01-09T17:08:55+08:00">2020-01-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Intersection-of-two-linked-list"><a href="#Intersection-of-two-linked-list" class="headerlink" title="Intersection of two linked list"></a>Intersection of two linked list</h2><p><img src="https://imgur.com/nhmAc0h.png" alt=""></p>
<p>获得两条链表的连接点</p>
<h3 id="my-solution-36ms-100"><a href="#my-solution-36ms-100" class="headerlink" title="my solution (36ms, 100%)"></a>my solution (36ms, 100%)</h3><p>(虽然效率看起来是最好的, 但是其实比起最好的算法要差不少)</p>
<p>核心难点在于两条链表的长度不一定相等, 这样就不能遍历节点用等于的形式来判断  </p>
<p>那么拿到两条链表的长度, 让较长的链表前进若干次, 以达到长度相等的情形, 那么就可以遍历了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> deep_A = <span class="number">0</span>, deep_B = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode *temp_head = headA;</span><br><span class="line">        <span class="keyword">while</span> (temp_head) &#123;</span><br><span class="line">            temp_head = temp_head-&gt;next;</span><br><span class="line">            ++deep_A;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        temp_head = headB;</span><br><span class="line">        <span class="keyword">while</span> (temp_head) &#123;</span><br><span class="line">            temp_head = temp_head-&gt;next;</span><br><span class="line">            ++deep_B;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> distance = <span class="built_in">abs</span>(deep_A - deep_B);</span><br><span class="line">        <span class="keyword">if</span> (deep_A &gt; deep_B) &#123;</span><br><span class="line">            <span class="keyword">while</span> (distance) &#123;</span><br><span class="line">                headA = headA-&gt;next;</span><br><span class="line">                --distance;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (distance) &#123;</span><br><span class="line">                headB = headB-&gt;next;</span><br><span class="line">                --distance;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (headA &amp;&amp; headB &amp;&amp; headA != headB) &#123;</span><br><span class="line">            headA = headA-&gt;next;</span><br><span class="line">            headB = headB-&gt;next;    </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> headA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>代码如下, 会产生 3 次遍历, 两次完整的遍历 O(3n) =&gt; O(n)</p>
<h3 id="the-best-solution"><a href="#the-best-solution" class="headerlink" title="the best solution"></a>the best solution</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode *p = headA;</span><br><span class="line">        ListNode *q = headB;</span><br><span class="line">        <span class="keyword">while</span> (p != q) &#123;</span><br><span class="line">            p = (p ? p-&gt;next: headB);</span><br><span class="line">            q = (q ? q-&gt;next: headA);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>原来还可以这么做!!!</p>
<p>算法的核心思想在于, A + B = B + A</p>
<p>假设有两条链表, 长度不等</p>
<pre><code>0 0 0 2 1 1    // A
0 0 2 1 1    // B</code></pre><p>其中将他们的链接点标为 2</p>
<p>那么有以下组合链表</p>
<pre><code>0 0 0 2 1 1 0 0 2 1 1    // A + B
0 0 2 1 1 0 0 0 2 1 1    // B + A</code></pre><p>他们如果有链接点, 那么在第二次循环时必然相等  </p>
<p>我是用求深度差来解决这个问题, 这个算法更加巧妙地用组合链表的形式规避了这个深度差</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/09/leetcode/152MaximumProductSubarray/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cas">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cas's website">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/09/leetcode/152MaximumProductSubarray/" class="post-title-link" itemprop="url">leetcode/152MaximumProductSubarray</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-09 17:08:55 / Modified: 17:07:59" itemprop="dateCreated datePublished" datetime="2020-01-09T17:08:55+08:00">2020-01-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="152-Maximum-Product-Subarray"><a href="#152-Maximum-Product-Subarray" class="headerlink" title="152 Maximum Product Subarray"></a>152 Maximum Product Subarray</h2><p><img src="https://imgur.com/soCfHk6.png" alt=""></p>
<p>找到数组中最大的连续乘积</p>
<h3 id="my-solution-8ms-100"><a href="#my-solution-8ms-100" class="headerlink" title="my solution (8ms, 100%)"></a>my solution (8ms, 100%)</h3><p>先将乘积以 0 为分界线分开, 这样得到的就是一段段最大的乘积(暂时无视正负)</p>
<p>而如果得到的数是负数, 那么分为 4 种情况 </p>
<ol>
<li>从左到右, 找到第一个负数, 用当前乘积除以它</li>
<li>从左到右, 找到第一个负数, 以该负数为界限, 获取左边的乘积</li>
<li>从右到左, 找到第一个负数, 用当前乘积除以它</li>
<li>从右到左,, 找到第一个负数, 以该负数为界限, 获取右边的乘积</li>
</ol>
<p>这四种情况最大者, 视为这一段的最大值, 而所有这些段再做比较, 就得到了整个数组连续乘积的最大值</p>
<p>代码如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> _ = [] () &#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; ();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">size_t</span> <span class="built_in">size</span> = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> ( !<span class="built_in">size</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> e = <span class="built_in">size</span>;</span><br><span class="line">        <span class="keyword">int</span> ret = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">while</span> (b &lt; e) &#123;</span><br><span class="line">            <span class="keyword">int</span> tb = b;</span><br><span class="line">            <span class="keyword">while</span> (b &lt; e &amp;&amp; nums[b] != <span class="number">0</span>) ++b;</span><br><span class="line">            <span class="keyword">if</span> (b - tb &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                ret = <span class="built_in">max</span>(ret, nums[tb]);</span><br><span class="line">                <span class="keyword">if</span> (b &lt; e)</span><br><span class="line">                    ret = <span class="built_in">max</span>(ret, nums[b]);</span><br><span class="line">                b += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> tb2 = tb;</span><br><span class="line">            <span class="keyword">while</span> (tb2 &lt; b) sum *= nums[tb2++];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> sumneg1 = <span class="number">1</span>;</span><br><span class="line">                tb2 = tb;</span><br><span class="line">                <span class="keyword">while</span> (tb2 &lt; b) &#123; </span><br><span class="line">                    sumneg1 *= nums[tb2];</span><br><span class="line">                    <span class="keyword">if</span> (nums[tb2] &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">                    ++tb2;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> sum1 = sumneg1 / nums[tb2] == <span class="number">1</span> ? sumneg1 : </span><br><span class="line">                    sumneg1 / nums[tb2];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> sumneg2 = <span class="number">1</span>;</span><br><span class="line">                tb2 = b - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (tb2 &gt;= tb) &#123;</span><br><span class="line">                    sumneg2 *= nums[tb2];</span><br><span class="line">                    <span class="keyword">if</span> (nums[tb2] &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">                    --tb2;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> sum2 = sumneg2 / nums[tb2] == <span class="number">1</span> ? sumneg2 : </span><br><span class="line">                    sumneg2 / nums[tb2];</span><br><span class="line"></span><br><span class="line">                sum /= <span class="built_in">max</span>(sumneg1, sumneg2);</span><br><span class="line">                sum = <span class="built_in">max</span>(sum, sum1);</span><br><span class="line">                sum = <span class="built_in">max</span>(sum, sum2);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ret = <span class="built_in">max</span>(ret, sum);</span><br><span class="line">            b += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>不太满意, 代码有点过长了…</p>
<p><img src="https://imgur.com/KGRgySn.png" alt=""></p>
<h3 id="best-solution"><a href="#best-solution" class="headerlink" title="best solution"></a>best solution</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> max_num[len] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> min_num[len] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">max</span> = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">min</span> = nums[<span class="number">0</span>];</span><br><span class="line">        max_num[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        min_num[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp1 = max_num[i<span class="number">-1</span>] * nums[i];</span><br><span class="line">            <span class="keyword">int</span> tmp2 = min_num[i<span class="number">-1</span>] * nums[i];</span><br><span class="line">            <span class="keyword">int</span> cur_max_num = tmp1 &gt; tmp2 ? tmp1 : tmp2;</span><br><span class="line">            <span class="keyword">int</span> cur_min_num = tmp1 &lt; tmp2 ? tmp1 : tmp2;</span><br><span class="line">            max_num[i] = cur_max_num &gt;= nums[i] ? cur_max_num : nums[i];</span><br><span class="line">            min_num[i] = cur_min_num &lt;= nums[i] ? cur_min_num : nums[i];</span><br><span class="line">            <span class="built_in">max</span> = <span class="built_in">max</span> &gt; max_num[i] ? <span class="built_in">max</span> : max_num[i];</span><br><span class="line">            <span class="built_in">min</span> = <span class="built_in">min</span> &lt; min_num[i] ? <span class="built_in">min</span> : min_num[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>啊. 简洁的小东西</p>
<p>不过, 我不是太懂这个代码的含义…  </p>
<p>不过我觉得我的想法会好点, 虽然代码实现起来有点困难  </p>
<p>但是它能一次性跳过很大一片区域, 对于连续整数很多的情况, 能够很快地计算出来  </p>
<p>而这种的话会完完整整的遍历一次</p>
<p>emmm. 是的, 我觉得我的想法会好一点 :)</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/09/leetcode/135Candy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cas">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cas's website">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/09/leetcode/135Candy/" class="post-title-link" itemprop="url">leetcode/135Candy</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-09 17:08:55 / Modified: 17:07:59" itemprop="dateCreated datePublished" datetime="2020-01-09T17:08:55+08:00">2020-01-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Candy"><a href="#Candy" class="headerlink" title="Candy"></a>Candy</h2><p><img src="https://imgur.com/x5xFxEL.png" alt=""></p>
<p>按照规则给每个小孩发糖果</p>
<ol>
<li>每个小孩的糖果数至少为 1</li>
<li>每个小孩获得的糖果数比他临近的, 并且权重比他小的小孩获得的要多</li>
</ol>
<h3 id="my-solution-12ms-100-00"><a href="#my-solution-12ms-100-00" class="headerlink" title="my solution(12ms, 100.00%)"></a>my solution(12ms, 100.00%)</h3><p>虽然做出来了, 但是并不高兴 = =, 因为代码太过复杂</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> _ = [] () &#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; ();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">candy</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; ratings)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">size_t</span> <span class="built_in">size</span> = ratings.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">size</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">size</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; candys(<span class="built_in">size</span>, <span class="number">0</span>);  </span><br><span class="line"></span><br><span class="line">		<span class="comment">// 填充所有可以直接确定的数</span></span><br><span class="line">        <span class="keyword">if</span> (ratings[<span class="number">0</span>] &lt;= ratings[<span class="number">1</span>]) </span><br><span class="line">            candys[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (ratings[<span class="built_in">size</span> - <span class="number">1</span>] &lt;= ratings[<span class="built_in">size</span> - <span class="number">2</span>]) </span><br><span class="line">            candys[<span class="built_in">size</span> - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + <span class="number">1</span> &lt; <span class="built_in">size</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> minn = <span class="built_in">min</span>(ratings[i], ratings[i - <span class="number">1</span>]);</span><br><span class="line">            minn = <span class="built_in">min</span>(minn, ratings[i + <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ratings[i] == minn)</span><br><span class="line">                candys[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 正向遍历</span></span><br><span class="line">        <span class="keyword">if</span> (ratings[<span class="number">0</span>] &gt; ratings[<span class="number">1</span>] &amp;&amp; candys[<span class="number">1</span>]) </span><br><span class="line">            candys[<span class="number">0</span>] = candys[<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (ratings[<span class="built_in">size</span> - <span class="number">1</span>] &gt; ratings[<span class="built_in">size</span> - <span class="number">2</span>] &amp;&amp; candys[<span class="built_in">size</span> - <span class="number">2</span>]) </span><br><span class="line">            candys[<span class="built_in">size</span> - <span class="number">1</span>] = candys[<span class="built_in">size</span> - <span class="number">2</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + <span class="number">1</span> &lt; <span class="built_in">size</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (candys[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> minn, maxn;</span><br><span class="line">                <span class="comment">// 当他是临近的人中权重最大的人时, 他的糖果数是</span></span><br><span class="line">         		<span class="comment">// max(left, right) + 1</span></span><br><span class="line">                <span class="keyword">if</span> (ratings[i + <span class="number">1</span>] == ratings[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (candys[i + <span class="number">1</span>] &amp;&amp; candys[i - <span class="number">1</span>])</span><br><span class="line">                        candys[i] = <span class="built_in">max</span>(candys[i + <span class="number">1</span>], candys[i - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ratings[i + <span class="number">1</span>] &gt; ratings[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                    minn = i - <span class="number">1</span>;</span><br><span class="line">                    maxn = i + <span class="number">1</span>;</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    minn = i + <span class="number">1</span>;</span><br><span class="line">                    maxn = i - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">				</span><br><span class="line">				<span class="comment">// 当他只比其中一个大时, 他的糖果数是 min + 1</span></span><br><span class="line">                <span class="keyword">if</span> (ratings[i] &lt;= ratings[maxn] &amp;&amp; candys[minn])</span><br><span class="line">                    candys[i] = candys[minn] + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 这里和第一处的判断是相同的, 第一处只是为了减少一些操作</span></span><br><span class="line">                <span class="keyword">if</span> (ratings[i] &gt; ratings[maxn] &amp;&amp; candys[maxn] &amp;&amp; candys[minn])</span><br><span class="line">                    candys[i] = <span class="built_in">max</span>(candys[maxn], candys[minn]) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 反向遍历, 逻辑相同</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">size</span> - <span class="number">2</span>; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (candys[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> minn, maxn;</span><br><span class="line">                <span class="keyword">if</span> (ratings[i + <span class="number">1</span>] == ratings[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (candys[i + <span class="number">1</span>] &amp;&amp; candys[i - <span class="number">1</span>])</span><br><span class="line">                        candys[i] = <span class="built_in">max</span>(candys[i + <span class="number">1</span>], candys[i - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ratings[i + <span class="number">1</span>] &gt; ratings[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                    minn = i - <span class="number">1</span>;</span><br><span class="line">                    maxn = i + <span class="number">1</span>;</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    minn = i + <span class="number">1</span>;</span><br><span class="line">                    maxn = i - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (ratings[i] &lt;= ratings[maxn] &amp;&amp; candys[minn])</span><br><span class="line">                    candys[i] = candys[minn] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (ratings[i] &gt; ratings[maxn] &amp;&amp; candys[maxn] &amp;&amp; candys[minn])</span><br><span class="line">                    candys[i] = <span class="built_in">max</span>(candys[maxn], candys[minn]) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ratings[<span class="number">0</span>] &gt; ratings[<span class="number">1</span>] &amp;&amp; candys[<span class="number">1</span>]) </span><br><span class="line">            candys[<span class="number">0</span>] = candys[<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (ratings[<span class="built_in">size</span> - <span class="number">1</span>] &gt; ratings[<span class="built_in">size</span> - <span class="number">2</span>] &amp;&amp; candys[<span class="built_in">size</span> - <span class="number">2</span>]) </span><br><span class="line">            candys[<span class="built_in">size</span> - <span class="number">1</span>] = candys[<span class="built_in">size</span> - <span class="number">2</span>] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; ++i)</span><br><span class="line">            ret += candys[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>整体代码会有 3 次遍历, 但是代码太多, 太复杂了…</p>
<p><img src="https://imgur.com/BFwX292.png" alt=""></p>
<p>如果没有看到最好算法的简洁程度, 我可能还能再高兴一下…</p>
<h3 id="best-solution"><a href="#best-solution" class="headerlink" title="best solution"></a>best solution</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">candy</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; ratings)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; num(ratings.<span class="built_in">size</span>(), <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; ratings.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (ratings[i] &gt; ratings[i<span class="number">-1</span>]) &#123;</span><br><span class="line">        num[i] = num[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = ratings.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (ratings[i] &gt; ratings[i+<span class="number">1</span>] &amp;&amp; num[i] &lt;= num[i+<span class="number">1</span>]) &#123;</span><br><span class="line">        num[i] = num[i+<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">      sum += num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> x = []() &#123;</span><br><span class="line">  ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">  <span class="built_in">cin</span>.tie(<span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">cout</span>.tie(<span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>
<p>(做完题的喜悦被冲刷得干干净净…, 啊… 真的是羞愧难当啊…)</p>
<p>(我为什么总是把问题复杂化了呢…)</p>
<p>逻辑上大致相同, 只不过他只需要一次 反向遍历, 一次 正向遍历</p>
<p>其中每次遍历所需要判断的条件都十分简单并且清晰</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">cas</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">104</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">cas</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
