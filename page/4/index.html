<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Muse',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="cas&#39;s website">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="cas&#39;s website">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="cas">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>cas's website</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">cas's website</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">casyup.me@outlook.com</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/09/other/Linux_command/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cas">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cas's website">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/09/other/Linux_command/" class="post-title-link" itemprop="url">other/Linux_command</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-09 17:14:16 / Modified: 17:13:54" itemprop="dateCreated datePublished" datetime="2020-01-09T17:14:16+08:00">2020-01-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>ps aux |　grep “reg” 查看进程后通过正则表达式筛选 </p>
<p>pwdx ID 根据进程ID查找文件路径  </p>
<p>whatis [] 查看命令的简单描述  </p>
<p>apropos [] 查看相关指令的文档位置</p>
<p>su “username” 切换用户(su默认切换root用户)</p>
<p>history 查看命令行记录<br>只能查看当前用户的命令行记录, 并且该命令无法查看文件中执行的命令行  </p>
<p>Ctrl+l　清屏</p>
<p>ZZ(upper) 保存并退出VI  </p>
<h3 id="多文件vim"><a href="#多文件vim" class="headerlink" title="多文件vim"></a>多文件vim</h3><pre><code>vim file1 file2   # 编辑file1和file2, 默认显示file1
:buffers          # 显示所有正在编辑的文件
:bnum             # 显示num编号的文件(num由:buffers调用后显示)
:n/N                 # 切换到下一个/上一个文件</code></pre><h3 id="批量注释-反注释"><a href="#批量注释-反注释" class="headerlink" title="批量注释/反注释"></a>批量注释/反注释</h3><pre><code>ctrl + v     #
选中注释行  
shift + i  
输入</code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/09/other/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cas">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cas's website">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/09/other/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/" class="post-title-link" itemprop="url">other/Linux学习笔记2</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-09 17:14:16 / Modified: 17:13:54" itemprop="dateCreated datePublished" datetime="2020-01-09T17:14:16+08:00">2020-01-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>撤销命令 <code>:u</code><br>PS: 之前修改文件时忘记切换到管理员模式, wq之后告诉我没有权限<br>但这时我已经退不出去了, 一直提示不能修改之类的问题<br>使用这个命令撤销wq指令, 再出去切换管理员模式, 修改文件  </p>
<p>增加root用户<br>切换管理员模式, 执行 <code>visudo</code> 指令  </p>
<pre><code>在 root ALL=(ALL) ALL 处增加 你的名字 ALL=(ALL) ALL  </code></pre><p>PS: 使用sudo时提示我不在sudoers中, 无法sudo执行指令  </p>
<p>vim跳到行尾 <code>:$</code><br>PS: 一直按着下箭头很累的… 到达行尾没停下来还会被嘟<del>~</del><br>顺便, 到达指定行命令 <code>:n</code> 表示行数, <code>:10</code> 跳到第十行</p>
<p>UNIX环境高级编程中的apue.h文件<br>这个文件是作者编写的, 需要到<a href="http://www.apuebook.com/code3e.html" target="_blank" rel="noopener">http://www.apuebook.com/code3e.html</a>下载<br>下载之后解压, 将 <code>apue.h</code> 文件和 <code>error.c</code> 文件拷贝到 <code>/usr/include</code> 文件夹下<br>修改apue.h文件, 在最后一行(#endif)之前, 添加 <code>#include &quot;error.c&quot;</code>   </p>
<p>更改文件/文件夹权限指令  <code>chmod</code><br>上述加上apue.h文件之后, 提示error.c文件不可访问<br>原来是文件默认属性为 -rw——-<br>执行 <code>chmod -R 666 文件名</code> 更改权限<br>PS: 用man查了一下chmod指令-R选项是递归执行…<br>emmmmmmmm 这好像是用于文件夹的, 有点尴尬  </p>
<p>man手册 <code>man 1 要查询的指令</code><br>linux中不知道一些指令的具体用法, 可以使用man手册来查<br>PS: 1表示手册1, 好像是分为多个手册, linux命令行使用的大多指令在手册1中(猜测)<br>man手册中还包含函数 比如 <code>man 3 atoi</code> 就可以查询函数atoi的具体信息</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/09/other/O(n)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cas">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cas's website">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/09/other/O(n)/" class="post-title-link" itemprop="url">other/O(n)</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-09 17:14:16 / Modified: 17:13:31" itemprop="dateCreated datePublished" datetime="2020-01-09T17:14:16+08:00">2020-01-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度用于描述算法的效率, 是衡量算法优劣的重要指标  </p>
<h3 id="O-1"><a href="#O-1" class="headerlink" title="O(1)"></a>O(1)</h3><pre><code>void func(int n){
    std::cout &lt;&lt; n &lt;&lt; std::cout;
}</code></pre><p>将自变量视作n, n在此情景下为传入的参数<br>将因变量视作t, t在此情景下为函数执行的指令次数(这个就是时间复杂度)<br>上述算法中, 无论n是多少, t都为1, 则此算法复杂度记做: O(1)</p>
<p>O(1)复杂度的算法效率不因外界因素而改变  </p>
<p>PS: 也称作常量级复杂度, 是最理想的复杂度  </p>
<h3 id="O-2n"><a href="#O-2n" class="headerlink" title="O(2n)"></a>O(2n)</h3><p>略</p>
<p>PS: 其中O(2n)就是呈2倍复杂度增加, 而O(nn)则意为n倍增加  </p>
<h3 id="O-n"><a href="#O-n" class="headerlink" title="O(n)"></a>O(n)</h3><pre><code>void func(int n){
    for(int i = 0; i &lt; n; ++i){
        std::cout &lt;&lt; i &lt;&lt; std::endl;
    }
}</code></pre><p>上述算法中 t = n + 1(其中的1为最后一次的失败), 算法复杂度为O(n)</p>
<p>O(n)复杂度的算法效率会因外界因素而改变, 其规律为: 复杂度呈1:1形式增加    </p>
<p>PS: O(n)是比较常见的复杂度, 效率一般  </p>
<h3 id="O-n-2-O-n-n"><a href="#O-n-2-O-n-n" class="headerlink" title="O(n^2)/O(n^n)"></a>O(n^2)/O(n^n)</h3><pre><code>void func(int n){
    for(int i = 0; i &lt; n; ++i){
        for(int j = 0; j &lt; n; ++i){
            std::cout &lt;&lt; i &lt;&lt; std::endl;
        }
    }
}</code></pre><p>上述算法中 t = n * n + 1, 记做: O(n^2)  </p>
<p>O(n^2)复杂度的算法效率会随外界的影响平方倍变化<br>同理, 则O(n^n)复杂度的算法效率会随外界的影响呈n次方倍增加 </p>
<p>PS: 出现这种复杂度的代码, 则需要考虑优化</p>
<h3 id="O-log-n"><a href="#O-log-n" class="headerlink" title="O(log n)"></a>O(log n)</h3><p>要想明白O(log n)时间复杂度, 则先得复习<a href="https://zh.wikipedia.org/wiki/%E5%AF%B9%E6%95%B0" target="_blank" rel="noopener">对数</a><br>(如果你还没把数学还给数学老师的话, 就不必了)</p>
<p>这东西我也不大说得清楚, 就直接粘贴网上的案例了:</p>
<p><img src="https://i.imgur.com/JGXST7I.png" alt=""></p>
<p>PS: O(log n)的复杂度计算好像不太容易, 一般人还不一定计算得出来… </p>
<p>RET: 总的来说时间复杂度就是一个随着计算数据增加, 算法效率呈何种形式增加的一种规律<br>了解一下时间复杂度是很有必要的<br>以后别人问你 你的算法效率如何的时候. 就可以回答: 我的算法时间复杂度是O(1)!  </p>
<p>以上经验参照自<a href="https://www.jianshu.com/p/f4cca5ce055a" target="_blank" rel="noopener">简书</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/09/other/README/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cas">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cas's website">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/09/other/README/" class="post-title-link" itemprop="url">other/README</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-09 17:14:16 / Modified: 17:12:51" itemprop="dateCreated datePublished" datetime="2020-01-09T17:14:16+08:00">2020-01-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>与具体环境, 具体语言无关, 理论和原理的理解</p>
<p>具体来说就是研究语言的汇编代码, 或者某个技术的框架(暂时没有)</p>
<h3 id="1-优化前还是优化后的汇编"><a href="#1-优化前还是优化后的汇编" class="headerlink" title="1. 优化前还是优化后的汇编"></a>1. 优化前还是优化后的汇编</h3><p>  对此我选择优化后的代码, 虽然优化前的代码更能表现出语言特性, 但是执行的毕竟是优化后的代码</p>
<p>  (隔天当我分析(多重继承 + 虚继承)时就有点后悔做出这个决定, 编译器优化后的代码与书上的讲解有很大差别, 并且是像迷宫一样的结构…)</p>
<h3 id="2-是否需要在某些数字-字符前后加空格"><a href="#2-是否需要在某些数字-字符前后加空格" class="headerlink" title="2. 是否需要在某些数字/字符前后加空格"></a>2. 是否需要在某些数字/字符前后加空格</h3><p>  这个源自于写代码时 int i = 1; 这样…</p>
<p>  当中文和英文/数字混杂时, 下意识想加空格分开, 我打算保持这个习惯</p>
<h3 id="3-要不要去掉无用的汇编信息-例如-cfi-伪指令"><a href="#3-要不要去掉无用的汇编信息-例如-cfi-伪指令" class="headerlink" title="3. 要不要去掉无用的汇编信息, 例如 .cfi 伪指令"></a>3. 要不要去掉无用的汇编信息, 例如 .cfi 伪指令</h3><p>  我打算尽量保持它原有的样子</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/09/other/crontab/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cas">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cas's website">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/09/other/crontab/" class="post-title-link" itemprop="url">other/crontab</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-09 17:14:16 / Modified: 17:13:54" itemprop="dateCreated datePublished" datetime="2020-01-09T17:14:16+08:00">2020-01-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="需求描述"><a href="#需求描述" class="headerlink" title="需求描述"></a>需求描述</h3><p>设计一个定时关机的工具  </p>
<p>该工具使用lua语言, 通过PLINK链接服务器  </p>
<p>接收用户输入, 使用crontab/at设置定时器</p>
<h3 id="详细代码"><a href="#详细代码" class="headerlink" title="详细代码"></a>详细代码</h3><h4 id="timer-table"><a href="#timer-table" class="headerlink" title="timer table"></a>timer table</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">package</span>.<span class="built_in">path</span> = <span class="built_in">package</span>.<span class="built_in">path</span> .. <span class="string">";../../script/?.lua"</span></span><br><span class="line"><span class="comment">-- inc是工具类</span></span><br><span class="line"><span class="keyword">local</span> inc = <span class="built_in">require</span>(<span class="string">"inc"</span>)</span><br><span class="line"><span class="comment">-- config记录了服务器的配置信息</span></span><br><span class="line"><span class="keyword">local</span> <span class="built_in">config</span> = <span class="built_in">require</span>(<span class="string">"config"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- timer用于处理整个定时任务</span></span><br><span class="line"><span class="keyword">local</span> timer = &#123;&#125;</span><br><span class="line">timer.file = <span class="string">"crontabtask.sh"</span>			<span class="comment">-- 文件名, 因为使用 crontab [file]形式添加任务</span></span><br><span class="line">timer.<span class="built_in">path</span> = <span class="string">"/tmp/"</span>					<span class="comment">-- 文件位于服务器那个路径下</span></span><br><span class="line">timer.fullName = timer.<span class="built_in">path</span>..timer.file	<span class="comment">-- 路径+文件名, 当前为: /tmp/crontabtask.sh</span></span><br><span class="line">timer.filenamemask = <span class="string">"CRONTAB_TASK_"</span>	<span class="comment">-- 掩码, 用于区分任务</span></span><br><span class="line">timer.servername = <span class="literal">nil</span>					<span class="comment">-- 服务器名称, 这里仅仅占位, 会在之后设置</span></span><br></pre></td></tr></table></figure>

<p>timer是任务处理表(类), 因为bash下, 没有办法直接使用vim编辑(或者说我不知道有什么办法能这么做)  </p>
<p>所以 crontab -e 的方式被舍弃了, 使用 crontab [filename] 的形式来添加任务 </p>
<p>(这样的好处是统一使用某一文件作为任务文件,  后续可以使用某种手段(比如修改配置), 来重新定义crontab -e)</p>
<p>(坏处就是动到了系统的东西, 这并不一定是好事)</p>
<h4 id="lobby"><a href="#lobby" class="headerlink" title="lobby"></a>lobby</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 大厅</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timer.lobby</span><span class="params">()</span></span></span><br><span class="line">    inc.p(<span class="string">"请输入要操作的服务器ID"</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">local</span> serverID = <span class="built_in">tonumber</span>(<span class="built_in">io</span>.<span class="built_in">stdin</span>:<span class="built_in">read</span>())</span><br><span class="line">    <span class="keyword">local</span> scfg, servercfg = inc.getserverinfo(serverID)</span><br><span class="line"></span><br><span class="line">    inc.confirm_oper_server(scfg, &#123;servercfg&#125;, <span class="string">"即将操作该服务器"</span>)</span><br><span class="line">    <span class="comment">-- 检查文件是否存在</span></span><br><span class="line">    timer.checkFileExists(scfg, servercfg)</span><br><span class="line">    <span class="keyword">local</span> sFolder = <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">"%s%d.p%d"</span>, </span><br><span class="line">        <span class="built_in">config</span>.gamename, servercfg.id, servercfg.port)</span><br><span class="line">    timer.servername = sFolder</span><br><span class="line">    <span class="comment">-- 根据用户的选项, 我们重新设置了文件掩码, 加上了当前服务器名</span></span><br><span class="line">    <span class="comment">-- 这样更加安全, 也可以筛选统一主机下, 不同服务器任务了</span></span><br><span class="line">    timer.filenamemask = timer.filenamemask..timer.servername</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">        inc.p(<span class="string">"\n选择操作类型[1: 增加, 2: 删除, 4:查询]"</span>, <span class="number">10</span>)</span><br><span class="line">        <span class="keyword">local</span> operatetype = <span class="built_in">io</span>.<span class="built_in">stdin</span>:<span class="built_in">read</span>()</span><br><span class="line">        <span class="keyword">if</span> operatetype == <span class="string">'1'</span> <span class="keyword">then</span></span><br><span class="line">            <span class="comment">-- 增加定时器</span></span><br><span class="line">            timer.addTimerTask(scfg, servercfg)</span><br><span class="line">            <span class="comment">-- 判断是否增加成功</span></span><br><span class="line">            timer.isAddSuccess(scfg, servercfg)</span><br><span class="line">            <span class="comment">-- 自动刷新定时器列表</span></span><br><span class="line">            timer.searchTimerTask(scfg, servercfg)</span><br><span class="line">        <span class="keyword">elseif</span> operatetype == <span class="string">'2'</span> <span class="keyword">then</span></span><br><span class="line">            <span class="comment">-- 删除定时器</span></span><br><span class="line">            timer.deleteTimerTask(scfg, servercfg)</span><br><span class="line">            <span class="comment">-- 自动刷新定时器列表</span></span><br><span class="line">            timer.searchTimerTask(scfg, servercfg)</span><br><span class="line">        <span class="keyword">elseif</span> operatetype == <span class="string">'3'</span> <span class="keyword">then</span></span><br><span class="line">            <span class="comment">-- 预留</span></span><br><span class="line">        <span class="keyword">elseif</span> operatetype == <span class="string">'4'</span> <span class="keyword">then</span></span><br><span class="line">            <span class="comment">-- 刷新定时器列表</span></span><br><span class="line">            timer.searchTimerTask(scfg, servercfg)</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            inc.p(<span class="string">"操作码异常"</span>, <span class="number">14</span>)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>大厅界面, 先让用户选择一个操作的服务器, 设置相应的参数, 然后让用户一直操作该服务器</p>
<h4 id="checkFileExists"><a href="#checkFileExists" class="headerlink" title="checkFileExists"></a>checkFileExists</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 检查文件是否存在</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timer.checkFileExists</span><span class="params">(scfg, servercfg)</span></span></span><br><span class="line">    <span class="comment">-- 看一下目录下是否存配置文件</span></span><br><span class="line">    <span class="keyword">local</span> cmds = &#123;&#125;</span><br><span class="line">    <span class="built_in">table</span>.<span class="built_in">insert</span>(cmds, <span class="string">"cd "</span>..timer.<span class="built_in">path</span>)</span><br><span class="line">    <span class="built_in">table</span>.<span class="built_in">insert</span>(cmds, <span class="string">"ls crontab*"</span>);</span><br><span class="line">    <span class="keyword">local</span> filename;</span><br><span class="line">    inc.popen_server_cmds(scfg, cmds, <span class="function"><span class="keyword">function</span> <span class="params">(res)</span></span></span><br><span class="line">        <span class="comment">-- 因为某些原因, 不用在意这行代码. 它的作用是获取文件名</span></span><br><span class="line">        filename = res[<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">end</span>, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">string</span>.<span class="built_in">find</span>(filename, <span class="string">"crontab"</span>) == <span class="literal">nil</span>) <span class="keyword">then</span></span><br><span class="line">        <span class="comment">-- 没找到配置文件, 就新建一个</span></span><br><span class="line">        inc.p(<span class="string">"未找到文件, 即将创建空文件: "</span>, <span class="number">10</span>)</span><br><span class="line">        <span class="keyword">local</span> cmds = &#123;&#125;</span><br><span class="line">        <span class="built_in">table</span>.<span class="built_in">insert</span>(cmds, <span class="string">"touch "</span>..timer.fullName)</span><br><span class="line">        inc.popen_server_cmds(scfg, cmds, <span class="literal">nil</span>, <span class="literal">true</span>)</span><br><span class="line">        inc.p(<span class="string">"创建成功: "</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="comment">-- 如果配置文件已经存在了, 那么就直接使用当前文件</span></span><br><span class="line">        inc.p(<span class="string">"已找到文件: "</span>..filename, <span class="number">10</span>)</span><br><span class="line">        timer.file = filename</span><br><span class="line">        timer.fullName = timer.<span class="built_in">path</span>..timer.file</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>检查配置文件是否已存在, 存在则世界使用它, 不存在, 则创建一个</p>
<h4 id="addTimerTask"><a href="#addTimerTask" class="headerlink" title="addTimerTask"></a>addTimerTask</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 增加定时器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timer.addTimerTask</span><span class="params">(scfg, servercfg)</span></span></span><br><span class="line">    <span class="comment">-- 设置时间</span></span><br><span class="line">    <span class="keyword">local</span> timetab = &#123;&#125;</span><br><span class="line">    inc.p(<span class="string">"请输入任务名"</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">local</span> taskname = <span class="built_in">io</span>.<span class="built_in">stdin</span>:<span class="built_in">read</span>()</span><br><span class="line">    <span class="keyword">local</span> ttaskname = taskname..timer.filenamemask</span><br><span class="line">    <span class="comment">-- 检测任务名是否存在, 任务名用于删, 查任务</span></span><br><span class="line">    <span class="keyword">while</span> (timer.checkTaskName(scfg, servercfg, ttaskname) == <span class="literal">true</span>) <span class="keyword">do</span></span><br><span class="line">        inc.p(<span class="string">"任务重名, 请重新输入"</span>, <span class="number">14</span>)</span><br><span class="line">        taskname = <span class="built_in">io</span>.<span class="built_in">stdin</span>:<span class="built_in">read</span>()</span><br><span class="line">        ttaskname = taskname..timer.filenamemask</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 设置定时器触发时间</span></span><br><span class="line">    inc.p(<span class="string">"请输入服务器关闭时间(月)"</span>, <span class="number">10</span>)</span><br><span class="line">    timetab.month = <span class="built_in">io</span>.<span class="built_in">stdin</span>:<span class="built_in">read</span>()</span><br><span class="line">    inc.p(<span class="string">"请输入服务器关闭时间(日)"</span>, <span class="number">10</span>)</span><br><span class="line">    timetab.day = <span class="built_in">io</span>.<span class="built_in">stdin</span>:<span class="built_in">read</span>()</span><br><span class="line">    inc.p(<span class="string">"请输入服务器关闭时间(时)"</span>, <span class="number">10</span>)</span><br><span class="line">    timetab.hour = <span class="built_in">io</span>.<span class="built_in">stdin</span>:<span class="built_in">read</span>()</span><br><span class="line">    inc.p(<span class="string">"请输入服务器关闭时间(分)"</span>, <span class="number">10</span>)</span><br><span class="line">    timetab.minute = <span class="built_in">io</span>.<span class="built_in">stdin</span>:<span class="built_in">read</span>()</span><br><span class="line">    inc.p(<span class="string">"服务器将计划于 "</span>..timetab.month..<span class="string">"月"</span>..timetab.day..<span class="string">"日"</span>..</span><br><span class="line">        timetab.hour..<span class="string">"时"</span>..timetab.minute..<span class="string">"分 关闭, 确定? [输入y继续]"</span>, <span class="number">12</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">io</span>.<span class="built_in">stdin</span>:<span class="built_in">read</span>() ~= <span class="string">'y'</span> <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 这里构造了一条命令, 这条命令实现了添加一个定时器</span></span><br><span class="line">    <span class="comment">-- 这个定时器会到指定的服务器下, 调用 kill.net 来关闭服务器</span></span><br><span class="line">    <span class="comment">-- 关闭之后, 再使用 sed 命令, 将定时器删除, 然后重置定时器</span></span><br><span class="line">    <span class="keyword">local</span> cmds = &#123;&#125;;</span><br><span class="line">    <span class="keyword">local</span> dir = timer.getFullPath(servercfg)</span><br><span class="line">    <span class="keyword">local</span> timestamp = timetab.minute..<span class="string">' '</span>..timetab.hour..<span class="string">' '</span>..timetab.day..<span class="string">' '</span>..</span><br><span class="line">        timetab.month..<span class="string">' '</span>..<span class="string">'*'</span></span><br><span class="line">    <span class="built_in">table</span>.<span class="built_in">insert</span>(cmds, <span class="string">"echo \""</span>..timestamp..<span class="string">" echo \""</span>..ttaskname..<span class="string">"\""</span></span><br><span class="line">        ..<span class="string">';cd '</span>..dir..<span class="string">';./kill.net'</span>..</span><br><span class="line">        <span class="string">";sed -i \"/"</span>..ttaskname..<span class="string">"/d\" "</span>..timer.fullName..</span><br><span class="line">        <span class="string">";crontab "</span>..timer.fullName..<span class="string">"\" &gt;&gt; "</span>..timer.fullName)</span><br><span class="line">    <span class="built_in">print</span> (cmds[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">-- 这是一个外部工具类中的函数, 主要是使用PLINK携带用户信息和验证, 链接服务器</span></span><br><span class="line">    <span class="comment">-- 然后执行 cmds 中保存的命令</span></span><br><span class="line">    inc.popen_server_cmds(scfg, cmds, <span class="literal">nil</span>, <span class="literal">true</span>)</span><br><span class="line">    <span class="comment">-- 保存当前任务名, 用于判断任务是否成功</span></span><br><span class="line">    timer.lastTask = ttaskname;</span><br><span class="line">    timer.syncTask(scfg, servercfg)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h4 id="checkTaskName"><a href="#checkTaskName" class="headerlink" title="checkTaskName"></a>checkTaskName</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 检查文件名</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timer.checkTaskName</span><span class="params">(scfg, servercfg, ttaskname)</span></span></span><br><span class="line">    <span class="keyword">local</span> cmds = &#123;&#125;</span><br><span class="line">    <span class="built_in">table</span>.<span class="built_in">insert</span>(cmds, <span class="string">"crontab -l"</span>)</span><br><span class="line">    <span class="keyword">local</span> dupname = <span class="literal">false</span></span><br><span class="line">    <span class="comment">-- 第三个参数是回调函数, res中存储了执行 cmds 后, 服务器的输出</span></span><br><span class="line">    <span class="comment">-- 使用 crontab -l 查看了当前已有的任务, 如果找到了任务名, 则说明任务名重复</span></span><br><span class="line">    inc.popen_server_cmds(scfg, cmds, <span class="function"><span class="keyword">function</span> <span class="params">(res)</span></span></span><br><span class="line">        <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">pairs</span>(res) <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">string</span>.<span class="built_in">find</span>(v, ttaskname)) <span class="keyword">then</span></span><br><span class="line">                dupname = <span class="literal">true</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span>, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dupname</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h4 id="syncTask"><a href="#syncTask" class="headerlink" title="syncTask"></a>syncTask</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 同步任务</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timer.syncTask</span><span class="params">(scfg, servercfg)</span></span></span><br><span class="line">    <span class="keyword">local</span> cmds = &#123;&#125;</span><br><span class="line">    <span class="built_in">table</span>.<span class="built_in">insert</span>(cmds, <span class="string">"cd "</span>..timer.<span class="built_in">path</span>)</span><br><span class="line">    <span class="built_in">table</span>.<span class="built_in">insert</span>(cmds, <span class="string">"crontab "</span>..<span class="string">'./'</span>..timer.file);</span><br><span class="line">    <span class="comment">-- 其实就是执行 crontab [filename], 这里可以合为一句的</span></span><br><span class="line">    inc.popen_server_cmds(scfg, cmds, <span class="literal">nil</span>, <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h4 id="isAddSuccess"><a href="#isAddSuccess" class="headerlink" title="isAddSuccess"></a>isAddSuccess</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 是否增加成功</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timer.isAddSuccess</span><span class="params">(scfg, servercfg)</span></span></span><br><span class="line">    <span class="keyword">local</span> cmds = &#123;&#125;</span><br><span class="line">    <span class="built_in">table</span>.<span class="built_in">insert</span>(cmds, <span class="string">"cat "</span>..timer.fullName);</span><br><span class="line">    <span class="keyword">local</span> size1 = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">-- 获取文件中的行数</span></span><br><span class="line">    inc.popen_server_cmds(scfg, cmds, <span class="function"><span class="keyword">function</span> <span class="params">(res)</span></span></span><br><span class="line">        size1 = #res</span><br><span class="line">    <span class="keyword">end</span>, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> cmds = &#123;&#125;</span><br><span class="line">    <span class="built_in">table</span>.<span class="built_in">insert</span>(cmds, <span class="string">"crontab -l"</span>);</span><br><span class="line">    <span class="keyword">local</span> size2 = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">-- 获取实际 crontab 任务的行数</span></span><br><span class="line">    inc.popen_server_cmds(scfg, cmds, <span class="function"><span class="keyword">function</span> <span class="params">(res)</span></span></span><br><span class="line">        size2 = #res</span><br><span class="line">    <span class="keyword">end</span>, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 如果行数不一致, 那么就说明加入失败</span></span><br><span class="line">    <span class="comment">-- 加入失败一般只有一种原因: 时间格式错误</span></span><br><span class="line">    <span class="comment">-- 我们也可以编写代码在执行加入前就判断, 但是判断时间的话, 涉及到平年和润年, 还涉及大小月</span></span><br><span class="line">    <span class="comment">-- 并且是服务器的时间, 所以也不能直接在windows上调用函数处理</span></span><br><span class="line">    <span class="comment">-- 考虑到这些原因, 就让linux帮我们做了这件事(反正行数不一致, 肯定是失败了)</span></span><br><span class="line">    <span class="keyword">if</span> size1 ~= size2 <span class="keyword">then</span> </span><br><span class="line">        <span class="comment">-- 添加失败就回滚一次任务</span></span><br><span class="line">        timer.rollBack(scfg, servercfg)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        inc.p(<span class="string">"添加定时任务成功"</span>, <span class="number">14</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h4 id="rollBack"><a href="#rollBack" class="headerlink" title="rollBack"></a>rollBack</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 回滚一次任务</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timer.rollBack</span><span class="params">(scfg, servercfg)</span></span></span><br><span class="line">    <span class="keyword">local</span> cmds = &#123;&#125;</span><br><span class="line">    <span class="comment">-- 这里使用了 sed 来处理, 其中用到了我们之前记录的 lastTask</span></span><br><span class="line">    <span class="built_in">table</span>.<span class="built_in">insert</span>(cmds, <span class="string">"sed -i "</span>..<span class="string">'/'</span>..timer.lastTask..<span class="string">"/d"</span>..</span><br><span class="line">        <span class="string">' '</span>..timer.fullName);</span><br><span class="line">    inc.popen_server_cmds(scfg, cmds, <span class="literal">nil</span>, <span class="literal">true</span>)</span><br><span class="line">    inc.p(<span class="string">"时间格式错误, 已回滚"</span>, <span class="number">12</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h4 id="searchTimerTask"><a href="#searchTimerTask" class="headerlink" title="searchTimerTask"></a>searchTimerTask</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询定时器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timer.searchTimerTask</span><span class="params">(scfg, servercfg)</span></span></span><br><span class="line">    <span class="keyword">local</span> cmds = &#123;&#125;</span><br><span class="line">    <span class="built_in">table</span>.<span class="built_in">insert</span>(cmds, <span class="string">"crontab -l"</span>)</span><br><span class="line">    inc.p(<span class="string">"\n当前已有任务: "</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">local</span> orisrc = &#123;&#125;</span><br><span class="line">    <span class="comment">-- 查看当前已有的任务</span></span><br><span class="line">    inc.popen_server_cmds(scfg, cmds, <span class="function"><span class="keyword">function</span> <span class="params">(res)</span></span></span><br><span class="line">        orisrc = res</span><br><span class="line">    <span class="keyword">end</span>, <span class="literal">true</span>)</span><br><span class="line">	</span><br><span class="line">    <span class="comment">-- 这里是为了将数据格式化成方便看懂的格式</span></span><br><span class="line">    timer.regex(orisrc, servercfg)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h4 id="regex"><a href="#regex" class="headerlink" title="regex"></a>regex</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 检测记录, 筛选信息</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timer.regex</span><span class="params">(orisrc, servercfg)</span></span></span><br><span class="line">    <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">pairs</span>(orisrc) <span class="keyword">do</span></span><br><span class="line">        <span class="comment">-- 获取任务时间戳</span></span><br><span class="line">        <span class="keyword">local</span> taskstamp;</span><br><span class="line">        <span class="keyword">for</span> v2 <span class="keyword">in</span> <span class="built_in">string</span>.<span class="built_in">gmatch</span>(v, <span class="string">"%d+%s%d+%s%d+%s%d+"</span>) <span class="keyword">do</span> </span><br><span class="line">            taskstamp = v2</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">-- 获取任务名</span></span><br><span class="line">        <span class="keyword">local</span> taskname;</span><br><span class="line">        <span class="keyword">for</span> v3 <span class="keyword">in</span> <span class="built_in">string</span>.<span class="built_in">gmatch</span>(v, <span class="string">"echo.*"</span>..timer.filenamemask..<span class="string">';'</span>) <span class="keyword">do</span> </span><br><span class="line">            v3 = <span class="built_in">string</span>.<span class="built_in">sub</span>(v3, <span class="number">6</span>, #v3 - #timer.filenamemask - <span class="number">1</span>)</span><br><span class="line">            taskname = v3 </span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">-- 获取服务器名</span></span><br><span class="line">        <span class="keyword">local</span> hostname;</span><br><span class="line">        <span class="keyword">for</span> v4 <span class="keyword">in</span> <span class="built_in">string</span>.<span class="built_in">gmatch</span>(v, <span class="string">"CRONTAB_TASK.*;cd%s/data/server/"</span>) <span class="keyword">do</span> </span><br><span class="line">            v4 = <span class="built_in">string</span>.<span class="built_in">sub</span>(v4, <span class="number">14</span>, #v4 - <span class="number">17</span>)</span><br><span class="line">            hostname = v4 </span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">-- 如果这条信息是任务信息, 格式化打印出来</span></span><br><span class="line">        <span class="keyword">if</span> (taskstamp ~= <span class="literal">nil</span> <span class="keyword">and</span> taskname ~= <span class="literal">nil</span> <span class="keyword">and</span> hostname == timer.servername) <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">local</span> timetab = &#123;&#125;</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">string</span>.<span class="built_in">gmatch</span>(taskstamp, <span class="string">"%d+"</span>) <span class="keyword">do</span></span><br><span class="line">                <span class="built_in">table</span>.<span class="built_in">insert</span>(timetab, i);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">            inc.p(<span class="string">"服务器: "</span>..hostname..<span class="string">"  ========  任务名: "</span>..taskname..</span><br><span class="line">                <span class="string">"  ========  时间: "</span>..</span><br><span class="line">                timetab[<span class="number">4</span>]..<span class="string">"月"</span>..timetab[<span class="number">3</span>]..<span class="string">"日"</span>..</span><br><span class="line">                timetab[<span class="number">2</span>]..<span class="string">"时"</span>..timetab[<span class="number">1</span>]..<span class="string">"分"</span>, <span class="number">14</span>)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h4 id="deleteTimerTask"><a href="#deleteTimerTask" class="headerlink" title="deleteTimerTask"></a>deleteTimerTask</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除定时器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timer.deleteTimerTask</span><span class="params">(scfg, servercfg)</span></span></span><br><span class="line">    inc.p(<span class="string">"请输入任务名(暂不支持中文)"</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">local</span> taskname = <span class="built_in">io</span>.<span class="built_in">stdin</span>:<span class="built_in">read</span>()</span><br><span class="line">    <span class="keyword">local</span> dir = timer.getFullPath(servercfg)</span><br><span class="line">    <span class="keyword">local</span> cmds = &#123;&#125;</span><br><span class="line">    <span class="built_in">table</span>.<span class="built_in">insert</span>(cmds, <span class="string">"cd "</span>..dir)</span><br><span class="line">    <span class="keyword">local</span> ttaskname = taskname..timer.filenamemask</span><br><span class="line">    <span class="comment">-- 执行一条 sed 命令, 删除一个任务</span></span><br><span class="line">    <span class="built_in">table</span>.<span class="built_in">insert</span>(cmds, <span class="string">"sed -i "</span>..<span class="string">'/'</span>..ttaskname..<span class="string">"/d"</span>..</span><br><span class="line">        <span class="string">' '</span>..timer.fullName);</span><br><span class="line">    inc.popen_server_cmds(scfg, cmds, <span class="literal">nil</span>, <span class="literal">true</span>)</span><br><span class="line">    <span class="comment">-- 同步一次</span></span><br><span class="line">    timer.syncTask(scfg, servercfg)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>


<h3 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h3><p>那么代码就这些了, 其中主要就是使用lua编写程序, 通过PLINK传递命令行信息</p>
<p>以此达到远程控制服务器定时器的效果</p>
<p>其中最主要的技术是: </p>
<p>lua语言基础, lua正则表达式  </p>
<p>{ crontab, sed } 命令行, 数据流重定向  </p>
<p>(emmmmmm… 看起来好像没什么厉害的…)</p>
<p>以及从&lt;重构&gt;中学到的代码技术  </p>
<p>(一开始看重构这本书的时候, 本来对里面一些降低效率的做法不太满意)</p>
<p>(但是真的使用了之后, 发现代码的确好多了, 无论是易读, 编写, 调试, 增加/删除方面, 都有明显提升)</p>
<p>(不过可惜没有运用到&lt;设计模式&gt;中的东西(或许我用到了, 只是没注意到?) )</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/09/other/debug%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cas">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cas's website">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/09/other/debug%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">other/debug的小技巧</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-09 17:14:16 / Modified: 17:12:35" itemprop="dateCreated datePublished" datetime="2020-01-09T17:14:16+08:00">2020-01-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>#关于“逆向”思维<br>    forward_list<int>::iterator it;</p>
<pre><code>inline void ptf(forward_list&lt;int&gt;::iterator fli)
{
    if (fli == it)
    {
        return;
    }

    //这里我保存了当前迭代器中的值
    forward_list&lt;int&gt;::value_type i = *fli;
    //前向列表没有重载+，（其实可以写一个），注意此处的++
    ptf(++fli);

    //我原先是在此处打印fli中的值
    cout &lt;&lt; i &lt;&lt; endl;
//    ptf(++fli);
}

int main()
{
    forward_list&lt;int&gt; fli{1, 2, 3, 4, 5};
    it = fli.end();

    ptf (fli.begin());

    system(&quot;pause&quot;);
}</code></pre><p>参考上面的代码，在上文中唯一打印的一处，会出现错误，经过排查，发现是解引用了end迭代器<br>其实上文的错误正常情况下很快就能排查出来，但是当时我排查了半个多小时…  </p>
<p>为什么会出现这一系列错误呢，属于一个巧合，就和《思考，快与慢》中的介绍一样，思维陷入了误区<br>无形地被一些因素（快思考）误导了：  </p>
<ol>
<li><p>我不常用单向链表，在获取下一个元素的时候，我自然而然地想到了获得它的下一个节点的指针（因为我来写的话就是这么实现的）<br> 但是我发现并没有这样的操作，花费了一些时间，才想到，它重载了++运算符，这里浪费了一点时间<br> （如果我不自以为是地认为它的接口应当是获得下一个节点指针的话，就不会这样。但这也不能全怪我的“系统一”，毕竟在大多数情况下<br> “系统一”会帮我快速处理问题而不经过“系统二”，对于这种情况，<strong>多慎重考虑一下可能会取得不错的效果</strong>）</p>
</li>
<li><p>系统的报错很奇怪，我一开始不知道自己错在了哪里，排查之后才发现是解引用出错了，之后才又发现我解引用了end迭代器<br> （其中函数最开始的if，让我误以为我跳过了end的情况，并且使用++时，我的思维还停留在恍然大悟中（原来它重载了++运算<br> 而没有直接给我下一个节点的指针），所以我没有考虑到++之后，它又指向end迭代器了）之后再思考时，我没有第一时间想到++的问题<br> <strong>对于这种问题，最好的方法是在编写代码时保持心平气和</strong></p>
</li>
<li><p>错误的方向：我以为可能是forward_list个人的问题（其中做了什么操作？），我又用vector去试验了，这里又浪费了时间，<br> 等我排查完个可能之后又去猜测其他的问题，才找了原因<br> （<strong>不够熟悉</strong>，如果我对知识点都很了解的话，我就不至于手动排查这个问题原因）</p>
</li>
</ol>
<p>最后，我想到了在笨办法学python中，作者对于debug的建议：<strong>代码从后往前看</strong><br>这是个不错的想法，当正向思维被困住时，利用逆向思维，就更多的思考这代码为什么这样写，这之前该如何操作<br>想来，如果一开始我就用逆向的思维来debug的话，这个问题我一开始应该就能发现：  </p>
<ol>
<li>最后一句打印了迭代器中的值，emmm 这不能是end迭代器，它的++操作返回了什么类型？这个类型重载了&lt;&lt;么？…  </li>
<li>然后上一句将迭代器递增之后当做参数使用了递归结构，这里已经把迭代器递增了，上面应该会出现结束递归的判断吧  </li>
<li>看到递归的判断了，emmm，当迭代器为end的时候是不操作的，很好，应该是这样，最后一次会跳过end迭代器，<br> 第一次打印的值应该是指向back迭代器的，emmmm…  等等，第一次打印之前我做了什么操作来着？++？<br> 那又指向了end迭代器了，这不是我想要的效果</li>
</ol>
<p>大概思维导图是这样的话，能够节省我不少的时间吧<br>重申：<br><strong>心平气和，专一地思考，不要沉溺于其他的事情</strong><br><strong>逆向思维，反向看代码更能排查出问题</strong><br><strong>有很强的基础，能解决不少不必要的问题</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/09/other/firstClassValue/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cas">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cas's website">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/09/other/firstClassValue/" class="post-title-link" itemprop="url">other/firstClassValue</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-09 17:14:16 / Modified: 17:12:51" itemprop="dateCreated datePublished" datetime="2020-01-09T17:14:16+08:00">2020-01-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="第一级值"><a href="#第一级值" class="headerlink" title="第一级值"></a>第一级值</h4><p>长久以来一直不太明白之前在 lua 一本书中提到的 “第一类值”   </p>
<p>直到今天在一本书上看到类似的解释:</p>
<pre><code>一般而言, 程序设计语言总会对计算元素的可能使用方式强加上某些限制  
带有最少限制的元素具有&quot;第一级&quot;的状态, 第一级元素的某些特权包括:
* 可以用变量命名
* 可以提供给过程作为参数
* 可以由过程作为结果返回
* 可以包含在数据结构中</code></pre><p>上述说的是第一级值, 猜想应该是第一类值拥有第一级特权</p>
<h4 id="第一类函数"><a href="#第一类函数" class="headerlink" title="第一类函数"></a>第一类函数</h4><p>以下摘自 wiki 对第一类函数(first-class function)的解释</p>
<pre><code>In computer science, a programming language is said to have first-    class functions if it treats functions as first-class citizens. This means the language supports passing functions as arguments to other functions, returning them as the values from other functions, and assigning them to variables or storing them in data structures
在计算机科学中, 一个编程语言如果对他函数就像第一类公民(??)一样, 那么就说他有第一类函数
这意味着语言支持将函数作为参数传递给其他函数
从其他函数中将其作为值返回
将其复制给变量, 或者保存到数据结构中</code></pre><h4 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h4><p>顺便 wiki 说了一下什么是高阶函数</p>
<pre><code>First-class functions are a necessity for the functional programming style, in which the use of higher-order functions is a standard practice. A simple example of a higher-ordered function is the map function, which takes, as its arguments, a function and a list, and returns the list formed by applying the function to each member of the list. For a language to support map, it must support passing a function as an argument.
第一类函数对于函数化编程是必要的
其中使用高阶函数就是一个标准的实践
一个高阶函数的简单案例就是map函数
(...能意会, 但没法翻译...)
它必须支持传递函数作为参数</code></pre><h4 id="lambda-是如何工作的"><a href="#lambda-是如何工作的" class="headerlink" title="lambda 是如何工作的"></a>lambda 是如何工作的</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;                                    </span><br><span class="line">    auto f &#x3D; [](int x, int y) &#123; return x + y; &#125;;</span><br><span class="line">    printf(&quot;%d\n&quot;,  f(1, 2) );                                                        </span><br><span class="line">    return 0;                                   </span><br><span class="line">&#125;                                               </span><br><span class="line">...</span><br><span class="line">_ZZ4mainENKUliiE_clEii:         </span><br><span class="line">.LFB3999:                       </span><br><span class="line">▹   .cfi_startproc              </span><br><span class="line">▹   pushq▹  %rbp                </span><br><span class="line">▹   .cfi_def_cfa_offset 16      </span><br><span class="line">▹   .cfi_offset 6, -16          </span><br><span class="line">▹   movq▹   %rsp, %rbp          </span><br><span class="line">▹   .cfi_def_cfa_register 6     </span><br><span class="line">▹   movq▹   %rdi, -8(%rbp)      &#x2F;&#x2F; 唯一的区别在于, 多传了一个&quot;this&quot;</span><br><span class="line">▹   movl▹   %esi, -12(%rbp)     </span><br><span class="line">▹   movl▹   %edx, -16(%rbp)     </span><br><span class="line">▹   movl▹   -16(%rbp), %eax     </span><br><span class="line">▹   movl▹   -12(%rbp), %edx     </span><br><span class="line">▹   addl▹   %edx, %eax          </span><br><span class="line">▹   popq▹   %rbp                </span><br><span class="line">▹   .cfi_def_cfa 7, 8           </span><br><span class="line">▹   ret                         </span><br><span class="line">...</span><br><span class="line">▹   subq▹   $16, %rsp</span><br><span class="line">▹   leaq▹   -1(%rbp), %rax	&#x2F;&#x2F; 这个 this 指向了当前栈帧, 但是这里为什么要 -1 ?</span><br><span class="line">▹   movl▹   $2, %edx</span><br><span class="line">▹   movl▹   $1, %esi</span><br><span class="line">▹   movq▹   %rax, %rdi            </span><br><span class="line">▹   call▹   _ZZ4mainENKUliiE_clEii</span><br></pre></td></tr></table></figure>

<p>在上面基础上, 让 lambda 捕获局部变量和全局变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">int gi &#x3D; 11;</span><br><span class="line">int main() &#123;</span><br><span class="line">    int i &#x3D; 10;</span><br><span class="line">    auto f &#x3D; [i, gi](int x, int y) &#123; return i + gi + x + y; &#125;;</span><br><span class="line">    printf(&quot;%d\n&quot;,  f(1, 2) );</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">_ZZ4mainENKUliiE_clEii:     </span><br><span class="line">.LFB3999:                   </span><br><span class="line">▹   .cfi_startproc          </span><br><span class="line">▹   pushq▹  %rbp            </span><br><span class="line">▹   .cfi_def_cfa_offset 16  </span><br><span class="line">▹   .cfi_offset 6, -16      </span><br><span class="line">▹   movq▹   %rsp, %rbp      </span><br><span class="line">▹   .cfi_def_cfa_register 6 </span><br><span class="line">▹   movq▹   %rdi, -8(%rbp)  </span><br><span class="line">▹   movl▹   %esi, -12(%rbp) </span><br><span class="line">▹   movl▹   %edx, -16(%rbp) </span><br><span class="line">▹   movq▹   -8(%rbp), %rax  </span><br><span class="line">▹   movl▹   (%rax), %edx    </span><br><span class="line">▹   movl▹   gi(%rip), %eax  	&#x2F;&#x2F; @warning 即使是按值捕获, 全局变量也并未产生复制</span><br><span class="line">▹   addl▹   %eax, %edx      </span><br><span class="line">▹   movl▹   -12(%rbp), %eax </span><br><span class="line">▹   addl▹   %eax, %edx      </span><br><span class="line">▹   movl▹   -16(%rbp), %eax </span><br><span class="line">▹   addl▹   %edx, %eax      </span><br><span class="line">▹   popq▹   %rbp            </span><br><span class="line">▹   .cfi_def_cfa 7, 8       </span><br><span class="line">▹   ret                    </span><br><span class="line">...</span><br><span class="line">▹   subq▹   $16, %rsp             </span><br><span class="line">▹   movl▹   $10, -4(%rbp)         </span><br><span class="line">▹   movl▹   -4(%rbp), %eax        </span><br><span class="line">▹   movl▹   %eax, -16(%rbp)       &#x2F;&#x2F; 复制了一份 i</span><br><span class="line">▹   leaq▹   -16(%rbp), %rax       </span><br><span class="line">▹   movl▹   $2, %edx              </span><br><span class="line">▹   movl▹   $1, %esi              </span><br><span class="line">▹   movq▹   %rax, %rdi            </span><br><span class="line">▹   call▹   _ZZ4mainENKUliiE_clEii</span><br></pre></td></tr></table></figure>

<p>其中关键之处在于对待全局变量的方式, 这有可能产生错误, 事实也的确错了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,  f(<span class="number">1</span>, <span class="number">2</span>) );</span><br><span class="line">gi = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,  f(<span class="number">1</span>, <span class="number">2</span>) );</span><br><span class="line">...</span><br><span class="line"><span class="number">24</span></span><br><span class="line"><span class="number">113</span> <span class="comment">// gi 的值改变后, 输出结果也随之改变, 这不应该是按值捕获的结果</span></span><br></pre></td></tr></table></figure>

<p>那么如果我加上 mutable 去更改这个 gi 呢?</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [i, gi](<span class="keyword">int</span> x, <span class="keyword">int</span> y) <span class="keyword">mutable</span> &#123; gi = <span class="number">110</span>; <span class="keyword">return</span> i + gi + x + y; &#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,  gi);      </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,  f(<span class="number">1</span>, <span class="number">2</span>) );</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,  gi);</span><br><span class="line">...</span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="number">110</span>	<span class="comment">// 改变了! 这可是很重要的细节</span></span><br></pre></td></tr></table></figure>

<p>上述结果, 编译器(gcc 4.8.5)只有一个警告</p>
<p>但是如果不注意这个细节, 去捕获全局变量, 可能会有很严重的错误</p>
<p>接下来专注一下类类型变量, 他会如何捕获 (这里的代码就有点头疼了)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;                                   </span><br><span class="line">    vector&lt;int&gt; v &#123;1, 2, 3, 4&#125;;                </span><br><span class="line">    int i &#x3D; 10;                                </span><br><span class="line">    auto f &#x3D; [i, gi, v](int x, int y) mutable &#123;</span><br><span class="line">        v[2] &#x3D; 10; gi &#x3D; 110;·                  </span><br><span class="line">        return i + gi + x + y; &#125;;              </span><br><span class="line">    printf(&quot;%d\n&quot;,  gi);                       </span><br><span class="line">    printf(&quot;%d\n&quot;,  f(1, 2) );                 </span><br><span class="line">    printf(&quot;%d\n&quot;,  v[2]);                     </span><br><span class="line"></span><br><span class="line">    return 0;                                  </span><br><span class="line">&#125;                                           </span><br><span class="line">...</span><br><span class="line">main:                                                          </span><br><span class="line">.LFB3998:          </span><br><span class="line">▹   pushq▹  %rbp                                                                       </span><br><span class="line">▹   movq▹   %rsp, %rbp                                         </span><br><span class="line">▹   pushq▹  %r13                                               </span><br><span class="line">▹   pushq▹  %r12                                               </span><br><span class="line">▹   pushq▹  %rbx                                               </span><br><span class="line">▹   subq▹   $72, %rsp                                          </span><br><span class="line">▹   leaq▹   -37(%rbp), %rax                                    </span><br><span class="line">▹   movq▹   %rax, %rdi                                         </span><br><span class="line">▹   call▹   _ZNSaIiEC1Ev                                       </span><br><span class="line">▹   movl▹   $._91, %r12d                                       </span><br><span class="line">▹   movl▹   $4, %r13d           &#x2F;&#x2F; 这里的 4 是告诉 vector, 有 4 个元素 (猜的)</span><br><span class="line">▹   leaq▹   -37(%rbp), %rdi                                    </span><br><span class="line">▹   movq▹   %r12, %rcx                                         </span><br><span class="line">▹   movq▹   %r13, %rbx                                         </span><br><span class="line">▹   movq▹   %r12, %rax                                         </span><br><span class="line">▹   movq▹   %r13, %rdx                                         </span><br><span class="line">▹   movq▹   %rcx, %rsi                                         </span><br><span class="line">▹   leaq▹   -64(%rbp), %rax     &#x2F;&#x2F; 按照上下文理解, 这应该就是 vector 的 this 指针   </span><br><span class="line">▹   movq▹   %rdi, %rcx                                         </span><br><span class="line">▹   movq▹   %rax, %rdi                                         </span><br><span class="line">.LEHB0:                                                        </span><br><span class="line">▹   call▹   _ZNSt6vectorIiSaIiEEC1ESt16initializer_listIiERKS0_ &#x2F;&#x2F; 真是个丑陋的小东西 &#x3D; &#x3D; </span><br><span class="line">.LEHE0:                                                        </span><br><span class="line">▹   leaq▹   -37(%rbp), %rax                                    </span><br><span class="line">▹   movq▹   %rax, %rdi                                         </span><br><span class="line">▹   call▹   _ZNSaIiED1Ev                                       </span><br><span class="line">▹   movl▹   $10, -36(%rbp)                                     </span><br><span class="line">▹   movl▹   -36(%rbp), %eax                                    </span><br><span class="line">▹   movl▹   %eax, -96(%rbp)       &#x2F;&#x2F; 上面的 10 是路标, 这个应该就是 lambda 的 this 指针</span><br><span class="line">▹   leaq▹   -64(%rbp), %rax       </span><br><span class="line">▹   leaq▹   -96(%rbp), %rdx</span><br><span class="line">▹   addq▹   $8, %rdx                                           </span><br><span class="line">▹   movq▹   %rax, %rsi                                         </span><br><span class="line">▹   movq▹   %rdx, %rdi                                         </span><br><span class="line">.LEHB1:                                                        </span><br><span class="line">▹   call▹   _ZNSt6vectorIiSaIiEEC1ERKS1_      &#x2F;&#x2F; 上面那句最长的应该是列表初始化, 而这一句                 								&#x2F;&#x2F; 可能是拷贝或者构造? </span><br><span class="line">.LEHE1:                               </span><br><span class="line">▹   movl▹   gi(%rip), %eax       </span><br><span class="line">▹   movl▹   %eax, %esi</span><br><span class="line">▹   movl▹   $.LC0, %edi</span><br><span class="line">▹   movl▹   $0, %eax</span><br><span class="line">.LEHB2:</span><br><span class="line">▹   call▹   printf</span><br><span class="line">▹   leaq▹   -96(%rbp), %rax</span><br><span class="line">▹   movl▹   $2, %edx</span><br><span class="line">▹   movl▹   $1, %esi</span><br><span class="line">▹   movq▹   %rax, %rdi</span><br><span class="line">▹   call▹   _ZZ4mainENUliiE_clEii</span><br><span class="line">...</span><br><span class="line">_ZZ4mainENUliiE_clEii:              </span><br><span class="line">.LFB4000:                           </span><br><span class="line">▹   .cfi_startproc                  </span><br><span class="line">▹   pushq▹  %rbp                    </span><br><span class="line">▹   .cfi_def_cfa_offset 16          </span><br><span class="line">▹   .cfi_offset 6, -16              </span><br><span class="line">▹   movq▹   %rsp, %rbp              </span><br><span class="line">▹   .cfi_def_cfa_register 6         </span><br><span class="line">▹   subq▹   $16, %rsp               </span><br><span class="line">▹   movq▹   %rdi, -8(%rbp)        &#x2F;&#x2F; this 指针  </span><br><span class="line">▹   movl▹   %esi, -12(%rbp)         </span><br><span class="line">▹   movl▹   %edx, -16(%rbp)         </span><br><span class="line">▹   movq▹   -8(%rbp), %rax          </span><br><span class="line">▹   addq▹   $8, %rax                </span><br><span class="line">▹   movl▹   $2, %esi                </span><br><span class="line">▹   movq▹   %rax, %rdi</span><br><span class="line">▹   call▹   _ZNSt6vectorIiSaIiEEixEm</span><br><span class="line">▹   movl▹   $10, (%rax)             &#x2F;&#x2F; 赋值</span><br><span class="line">▹   movl▹   $110, gi(%rip)</span><br><span class="line">▹   movq▹   -8(%rbp), %rax</span><br><span class="line">▹   movl▹   (%rax), %edx</span><br><span class="line">▹   movl▹   gi(%rip), %eax</span><br><span class="line">▹   addl▹   %eax, %edx</span><br><span class="line">▹   movl▹   -12(%rbp), %eax</span><br><span class="line">▹   addl▹   %eax, %edx</span><br><span class="line">▹   movl▹   -16(%rbp), %eax</span><br><span class="line">▹   addl▹   %edx, %eax</span><br><span class="line">▹   leave</span><br><span class="line">▹   .cfi_def_cfa 7, 8</span><br><span class="line">▹   ret</span><br></pre></td></tr></table></figure>
<p>值拷贝类的时候, 会将整个类拷贝一次, 并没有什么特殊的</p>
<p><strong>匿名函数与其说是函数, 不如说是类</strong> 他就像一个重载了调用运算符的类一样</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/09/other/float/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cas">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cas's website">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/09/other/float/" class="post-title-link" itemprop="url">other/float</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-09 17:14:16 / Modified: 17:12:51" itemprop="dateCreated datePublished" datetime="2020-01-09T17:14:16+08:00">2020-01-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在看到&lt;深入理解计算机系统&gt;的浮点数时, 第一想法是:</p>
<ul>
<li>无法精确保存大多数浮点数</li>
<li>精度上的缺失</li>
</ul>
<h3 id="零值的比较"><a href="#零值的比较" class="headerlink" title="零值的比较"></a>零值的比较</h3><p>很多面试题都会考一道浮点数零值比较的题(一般是单精度, 双精度太长了)</p>
<p>我觉得答案应该是:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f &gt; <span class="number">-0.000001f</span> &amp;&amp; f &lt; <span class="number">0.000001f</span></span><br></pre></td></tr></table></figure>

<p>这个题的核心在于 float 什么时候缺失精度</p>
<p>这里我没有使用等于, 因为我认为 0.000001f 和 -0.000001f 并不算缺失了精度 </p>
<p>(百度上的答案是有等于的, 我很怀疑这个答案, 甚至有人还用的是 0.00001 (눈_눈) )</p>
<p>(而google上我好像没有找到类似的答案, 再根据编译器给我的结果, 我只能如此推断)</p>
<p>下面是我推断的依据:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%f\n"</span>, <span class="number">0.000001f</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%f\n"</span>, <span class="number">0.0000006f</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%f\n"</span>, <span class="number">0.0000005f</span>);</span><br></pre></td></tr></table></figure>
<p>你觉得上面会打印什么呢?  输出结果是:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.000001</span></span><br><span class="line"><span class="number">0.000001</span></span><br><span class="line"><span class="number">0.000000</span></span><br></pre></td></tr></table></figure>
<p>这也就是我认为 0.000001 它并未损失精度的原因, 既然未损失, 那么就不能当做 0 值来对待</p>
<p>(再次看不起百度上的解答(눈_눈), 不过… 万一是cas错了呢?)</p>
<p>(损失精度还有更精确的 0.00000055f, 这个数字也被认为是 0.000001)</p>
<h3 id="数字的精度取决于有多少位表示"><a href="#数字的精度取决于有多少位表示" class="headerlink" title="数字的精度取决于有多少位表示"></a>数字的精度取决于有多少位表示</h3><p>上面看到了6为精度的情况, 他准确表示了0.1 (虽然它把 0.0000006f 当做了0.1…)</p>
<p>我们来看看其他的结果, 比如:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%f\n"</span>, <span class="number">255.1f</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="number">254.2f</span> == <span class="number">254.200001f</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="number">254.2f</span> == <span class="number">254.200002f</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="number">254.2f</span> == <span class="number">254.200003f</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="number">254.2f</span> == <span class="number">254.200004f</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="number">254.2f</span> == <span class="number">254.200005f</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="number">254.2f</span> == <span class="number">254.200006f</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="number">254.2f</span> == <span class="number">254.200007f</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="number">254.2f</span> == <span class="number">254.200008f</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="number">254.2f</span> == <span class="number">254.200009f</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="number">254.2f</span> == <span class="number">254.199999f</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="number">254.2f</span> == <span class="number">254.199998f</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="number">254.2f</span> == <span class="number">254.199997f</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="number">254.2f</span> == <span class="number">254.199996f</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="number">254.2f</span> == <span class="number">254.199995f</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="number">254.2f</span> == <span class="number">254.199994f</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="number">254.2f</span> == <span class="number">254.199993f</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="number">254.2f</span> == <span class="number">254.199992f</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="number">254.2f</span> == <span class="number">254.199991f</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="number">254.2f</span> == <span class="number">254.199990f</span>);</span><br></pre></td></tr></table></figure>
<p>你觉得这次又会输出什么呢?</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">255.100006</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>(输出结果我做了缩减, 不然太长了)</p>
<p>也就是说, 除了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">254.200005f</span></span><br><span class="line"><span class="number">254.200006f</span></span><br><span class="line"><span class="number">254.200007f</span></span><br><span class="line"><span class="number">254.200008f</span></span><br><span class="line"><span class="number">254.200009f</span></span><br></pre></td></tr></table></figure>
<p>之外, 编译器认为它们都是相等的, 为什么呢?</p>
<p>精度再次缺失(我只能如此猜测), 因为整数的数字过大, 剩下的留给小数的位数不足以达到6位精度  </p>
<p>所以这次的精度缩减到了5位, 而因为四舍五入(我只能再次如此猜测 (눈_눈))的关系</p>
<p>(其实说四舍五入有点不对, 应该是: 数字的二进制表示刚好进入了有效的区间)</p>
<p>一些能达到 254.20001 的数字被判段为不等, 而一些 254.19999 的数字又可四舍五入的关系被判断为相等  </p>
<p>所以, 整数数字的大小会影响小数的精度 (我感觉我在说废话 (눈_눈)), 而当整数过大时, 比如 0x7fffffffff </p>
<p>所有的小数精度全都会缺失(unsigned float 可能是例外, 不过不影响结论)</p>
<p>下面我又做了一次比较, 我将254换成了126, 输出结果是</p>
<pre><code>0 0 0 0 0 0 0 0 0 1 1 1 1 1 0 0 0 0</code></pre><p>emmm… 其实这次的有效精度还是接近5位</p>
<p>不过能够在5位之外, 能判断更多的数字了</p>
<p>(这个数字并未完全达到6位, 也许 0.000005 能判断到, 0.000004 却不能, 就像上面那样) </p>
<h3 id="底层到底对我们的代码做了什么"><a href="#底层到底对我们的代码做了什么" class="headerlink" title="底层到底对我们的代码做了什么"></a>底层到底对我们的代码做了什么</h3><p>又到了喜闻乐见的看汇编环节 ┑(￣Д ￣)┍</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> f = <span class="number">0.1f</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%f\n"</span>, f);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%f\n"</span>, f * <span class="number">2</span>);</span><br><span class="line"><span class="keyword">float</span> f2 = <span class="number">0x7fff</span> + <span class="number">0.1f</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%f\n"</span>, f2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%f\n"</span>, f2 * <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>它在汇编中的样子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">.cfi_startproc</span><br><span class="line">    pushq   %rbp</span><br><span class="line">    .cfi_def_cfa_offset 16</span><br><span class="line">    .cfi_offset 6, -16</span><br><span class="line">    movq    %rsp, %rbp</span><br><span class="line">    .cfi_def_cfa_register 6</span><br><span class="line">    subq    $16, %rsp			&#x2F;&#x2F; 依旧是开辟了16个直接的栈帧, 为什么不是8(我有两个float)?</span><br><span class="line">    movl    .LC0(%rip), %eax	&#x2F;&#x2F; .long   1036831949</span><br><span class="line">    movl    %eax, -4(%rbp)		&#x2F;&#x2F; 将变量放到了栈中</span><br><span class="line">    movss   -4(%rbp), %xmm0		&#x2F;&#x2F; 放到了浮点数寄存器中</span><br><span class="line">    cvtps2pd        %xmm0, %xmm0	&#x2F;&#x2F; emmm... PS2PD Single-Precision Double-Precision</span><br><span class="line">    						&#x2F;&#x2F; 它将两个单精度浮点数转化成了双精度, 这可不在我的预料之中 ∑(￣□￣;)</span><br><span class="line">    movl    $.LC1, %edi</span><br><span class="line">    movl    $1, %eax</span><br><span class="line">    call    printf</span><br><span class="line">    movss   -4(%rbp), %xmm0</span><br><span class="line">    addss   %xmm0, %xmm0</span><br><span class="line">    unpcklps        %xmm0, %xmm0</span><br><span class="line">    cvtps2pd        %xmm0, %xmm0</span><br><span class="line">    movl    $.LC1, %edi</span><br><span class="line">    movl    $1, %eax</span><br><span class="line">    call    printf</span><br><span class="line">    movl    .LC2(%rip), %eax	&#x2F;&#x2F; .long   1191181875</span><br><span class="line">    movl    %eax, -8(%rbp)</span><br><span class="line">    movss   -8(%rbp), %xmm0</span><br><span class="line">    cvtps2pd        %xmm0, %xmm0</span><br><span class="line">    movl    $.LC1, %edi</span><br><span class="line">    movl    $1, %eax</span><br><span class="line">    call    printf</span><br><span class="line">    movss   -8(%rbp), %xmm0</span><br><span class="line">    addss   %xmm0, %xmm0</span><br><span class="line">    unpcklps        %xmm0, %xmm0</span><br><span class="line">    cvtps2pd        %xmm0, %xmm0</span><br><span class="line">    movl    $.LC1, %edi</span><br><span class="line">    movl    $1, %eax</span><br><span class="line">    call    printf</span><br><span class="line">    movl    $0, %eax</span><br><span class="line">    leave</span><br><span class="line">    .cfi_def_cfa 7, 8</span><br><span class="line">    ret</span><br><span class="line">    .cfi_endproc</span><br></pre></td></tr></table></figure>

<p>关键点在于 .LC1 和 .LC2, 他们的数字, 不过一点数字看不出什么, 需要多一些数据</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1036831949</span> = <span class="number">0.1f</span>	= <span class="number">3</span>dcccccd</span><br><span class="line"><span class="number">1045220557</span> = <span class="number">0.2f</span> 	= <span class="number">3e4</span>ccccd</span><br><span class="line"><span class="number">1038174126</span> = <span class="number">0.11f</span>	= <span class="number">3</span>de147ae</span><br></pre></td></tr></table></figure>

<p>其中 0.1f 和 0.2f 相差 800000</p>
<p>0.1f 和 0.11f 相差 147ae1</p>
<p>emmmm… 想不出来, 或许我该再看看书</p>
<p>嗯 好的, 看完了 (￣ˇ￣)</p>
<p>大概是这样的, 根据不同的位数安排, 计算的结果也有相应的不同</p>
<p>一个浮点数, 1位符号位S, 8位阶码E, 23位小数位M  </p>
<p>其中又分为4种情况: 规格, 非规格, NaN(not a number?), 无穷大</p>
<p>(具体的细节请参考书中的介绍)</p>
<p>总之, 我们用书中的算法来检验一下这几个数字</p>
<p>首先 0.1f, 它的数字是 3dcccccd, 它是一个规格化数字</p>
<p>E = 123 - 127 = -4 , M = 5033165 / 8388735 +１</p>
<p>2的E次方 x M = 0.0999994337644472 </p>
<p>emmm… 没错, 这是一个非常接近 0.1 的数字</p>
<p>(书中说到了小数的舍入, 简单来说是四舍五入, 同时向偶数舍入, 比如 1.245 它会向 1.24 舍入)</p>
<p>(再次很好奇一些需要极其精确的小数运算是如何做到的 （ー_ー？）)</p>
<p>(像存储金额这样的小数精度, 特别是银行, 损失一个精度都很严重啊)</p>
<p><strong>规格化用于表示一些比较大的数字, 而非规格化用于表示一些相对较小的数字</strong></p>
<p>这里顺便再看一下失去精度的结果, 看看他是怎么计算的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%f\n"</span>, <span class="number">255.1f</span>);</span><br></pre></td></tr></table></figure>

<p>奇怪的是, 它有两个数字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">111 .LC0:</span><br><span class="line">112     .long   1073741824</span><br><span class="line">113     .long   1081074483</span><br></pre></td></tr></table></figure>

<p>可惜计算不出来, 这种格式是无穷大(不太明白 (눈_눈))  </p>
<h3 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h3><p>简单来说, 其实也没有做笔记的必要  ┑(￣Д ￣)┍, 书上已经给了你答案</p>
<p>不过还好, 沉浸在思考的海洋中挺不错的(其实都快被淹死了 (눈_눈))</p>
<p>最后, <strong>若无必要, 或者非常确信浮点数的范围, 否则不要使用单精度浮点数</strong></p>
<p>如你所见, 单精度浮点数的范围很小, 一不小心还要失去精度</p>
<p>(这可能也是默认小数是双精度的原因)</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/09/other/headFirstGoAssembly/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cas">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cas's website">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/09/other/headFirstGoAssembly/" class="post-title-link" itemprop="url">other/headFirstGoAssembly</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-09 17:14:16 / Modified: 17:12:51" itemprop="dateCreated datePublished" datetime="2020-01-09T17:14:16+08:00">2020-01-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>下班忘把没读完的 inside the c++ object model 带回去</p>
<p>还好包里有本备用的 go, 简单看了一下前面基础部分</p>
<p>感觉就是, 很”新颖 + 轻巧”, 有很多新的概念和工具, 抛弃了一些沉重的”包袱”</p>
<p>试了一下用例, 看了一下汇编</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1 package main</span><br><span class="line">2 </span><br><span class="line">3 import &quot;fmt&quot;</span><br><span class="line">4     </span><br><span class="line">5 func main() &#123;</span><br><span class="line">6     fmt.Printf(&quot;hello, world\n&quot;)</span><br><span class="line">7 &#125;</span><br></pre></td></tr></table></figure>

<p>汇编:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> 1 # command-line-arguments                                                                 </span><br><span class="line"> 2 &quot;&quot;.main STEXT size&#x3D;88 args&#x3D;0x0 locals&#x3D;0x48                                               </span><br><span class="line"> 3     0x0000 00000 (&#x2F;test&#x2F;go&#x2F;t.go:5)  TEXT    &quot;&quot;.main(SB), $72-0                           				&#x2F;&#x2F; 非常友好地给我加上了对应的源码信息</span><br><span class="line"> 4     0x0000 00000 (&#x2F;test&#x2F;go&#x2F;t.go:5)  MOVQ    (TLS), CX                                    </span><br><span class="line"> 5     0x0009 00009 (&#x2F;test&#x2F;go&#x2F;t.go:5)  CMPQ    SP, 16(CX)                                   </span><br><span class="line"> 6     0x000d 00013 (&#x2F;test&#x2F;go&#x2F;t.go:5)  JLS 81                                               </span><br><span class="line"> 7     0x000f 00015 (&#x2F;test&#x2F;go&#x2F;t.go:5)  SUBQ    $72, SP	&#x2F;&#x2F; 这里应该是在开辟栈帧                                     </span><br><span class="line"> 8     0x0013 00019 (&#x2F;test&#x2F;go&#x2F;t.go:5)  MOVQ    BP, 64(SP)	&#x2F;&#x2F; 栈顶保存了 bp 指针                                   </span><br><span class="line"> 9     0x0018 00024 (&#x2F;test&#x2F;go&#x2F;t.go:5)  LEAQ    64(SP), BP  &#x2F;&#x2F; 重置 bp                                 </span><br><span class="line">10     0x001d 00029 (&#x2F;test&#x2F;go&#x2F;t.go:5)  FUNCDATA    $0, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)	&#x2F;&#x2F; gc ? garbage collection?</span><br><span class="line">11     0x001d 00029 (&#x2F;test&#x2F;go&#x2F;t.go:5)  FUNCDATA    $1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)</span><br><span class="line">12     0x001d 00029 (&#x2F;test&#x2F;go&#x2F;t.go:5)  FUNCDATA    $3, gclocals·9fb7f0986f647f17cb53dda1484e0f7a(SB)	&#x2F;&#x2F; 看不懂 &#x3D; &#x3D;</span><br><span class="line">13     0x001d 00029 (&#x2F;test&#x2F;go&#x2F;t.go:6)  PCDATA  $2, $1                                       </span><br><span class="line">14     0x001d 00029 (&#x2F;test&#x2F;go&#x2F;t.go:6)  PCDATA  $0, $0	&#x2F;&#x2F; 还是看不懂 &#x3D; &#x3D;</span><br><span class="line">15     0x001d 00029 (&#x2F;test&#x2F;go&#x2F;t.go:6)  LEAQ    go.string.&quot;hello, world\n&quot;(SB), AX           						&#x2F;&#x2F; 加载字符串文本, 者很方便, 我直接可以看到字符串</span><br><span class="line">16     0x0024 00036 (&#x2F;test&#x2F;go&#x2F;t.go:6)  PCDATA  $2, $0                                       </span><br><span class="line">17     0x0024 00036 (&#x2F;test&#x2F;go&#x2F;t.go:6)  MOVQ    AX, (SP)                                     </span><br><span class="line">18     0x0028 00040 (&#x2F;test&#x2F;go&#x2F;t.go:6)  MOVQ    $13, 8(SP)	&#x2F;&#x2F; 应该是指字符串长度</span><br><span class="line">19     0x0031 00049 (&#x2F;test&#x2F;go&#x2F;t.go:6)  MOVQ    $0, 16(SP)  &#x2F;&#x2F; 后续参数数量?                                 </span><br><span class="line">20     0x003a 00058 (&#x2F;test&#x2F;go&#x2F;t.go:6)  XORPS   X0, X0	&#x2F;&#x2F; 单精度异或?</span><br><span class="line">21     0x003d 00061 (&#x2F;test&#x2F;go&#x2F;t.go:6)  MOVUPS  X0, 24(SP)                                   						&#x2F;&#x2F; 代码中没有用到单精度浮点数, 为什么会有这个指令?</span><br><span class="line">22     0x0042 00066 (&#x2F;test&#x2F;go&#x2F;t.go:6)  CALL    fmt.Printf(SB) &#x2F;&#x2F; 调用                              					&#x2F;&#x2F; 这样的格式很清晰</span><br><span class="line">23     0x0047 00071 (&#x2F;test&#x2F;go&#x2F;t.go:7)  MOVQ    64(SP), BP  &#x2F;&#x2F; 返还 bp                                 </span><br><span class="line">24     0x004c 00076 (&#x2F;test&#x2F;go&#x2F;t.go:7)  ADDQ    $72, SP	&#x2F;&#x2F; 重置栈顶</span><br><span class="line">25     0x0050 00080 (&#x2F;test&#x2F;go&#x2F;t.go:7)  RET	&#x2F;&#x2F; 结束</span><br><span class="line">26     0x0051 00081 (&#x2F;test&#x2F;go&#x2F;t.go:7)  NOP</span><br><span class="line">27     0x0051 00081 (&#x2F;test&#x2F;go&#x2F;t.go:5)  PCDATA  $0, $-1                                      </span><br><span class="line">28     0x0051 00081 (&#x2F;test&#x2F;go&#x2F;t.go:5)  PCDATA  $2, $-1                                      </span><br><span class="line">29     0x0051 00081 (&#x2F;test&#x2F;go&#x2F;t.go:5)  CALL    runtime.morestack_noctxt(SB)                 								&#x2F;&#x2F; 运行时的什么?</span><br><span class="line">30     0x0056 00086 (&#x2F;test&#x2F;go&#x2F;t.go:5)  JMP 0</span><br></pre></td></tr></table></figure>

<p>FUNCDATA 我怀疑和垃圾回收有关, PCDATA 意义不明 (网上查了一下, 都和垃圾回收有关)</p>
<p>我尝试过添加一个参数, 以用作 fmt.Println(), 但是我并未在代码中找到任何有关参数的信息</p>
<p>仅仅只有一句看起来和那个参数有关</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LEAQ    &quot;&quot;..autotmp_0+64(SP), AX	&#x2F;&#x2F; 就是这句话</span><br><span class="line">PCDATA  $2, $0                  </span><br><span class="line">MOVQ    AX, 16(SP)</span><br></pre></td></tr></table></figure>
<p>而且我差点忽略的一点是, 这里参数的传递是用栈</p>
<p>顺便, 我在文件的末尾找到了这些信息, 看起来像是某种标记</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">213 gclocals·69c1753bd5f81501d95132d08af04464 SRODATA dupok size&#x3D;8        </span><br><span class="line">214     0x0000 02 00 00 00 00 00 00 00                          ........  </span><br><span class="line">215 gclocals·568470801006e5c0dc3947ea998fe279 SRODATA dupok size&#x3D;10       </span><br><span class="line">216     0x0000 02 00 00 00 02 00 00 00 00 02                    ..........</span><br><span class="line">217 gclocals·9fb7f0986f647f17cb53dda1484e0f7a SRODATA dupok size&#x3D;10       </span><br><span class="line">218     0x0000 02 00 00 00 01 00 00 00 00 01                    ..........</span><br><span class="line">219 gclocals·33cdeccccebe80329f1fdbee7f5874cb SRODATA dupok size&#x3D;8        </span><br><span class="line">220     0x0000 01 00 00 00 00 00 00 00                          ........</span><br></pre></td></tr></table></figure>

<p>我再次使用了变量存储值的形式, 然后我的数字能够正常看见了:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">0x0034 00052 (&#x2F;test&#x2F;go&#x2F;t.go:7)  MOVQ    $100, 8(SP)	&#x2F;&#x2F; 我的数字在这里</span><br><span class="line">0x003d 00061 (&#x2F;test&#x2F;go&#x2F;t.go:7)  CALL    runtime.convT2E64(SB)</span><br><span class="line">0x0042 00066 (&#x2F;test&#x2F;go&#x2F;t.go:7)  MOVQ    16(SP), AX</span><br><span class="line">0x0047 00071 (&#x2F;test&#x2F;go&#x2F;t.go:7)  PCDATA  $2, $2</span><br><span class="line">0x0047 00071 (&#x2F;test&#x2F;go&#x2F;t.go:7)  MOVQ    24(SP), CX</span><br><span class="line">0x004c 00076 (&#x2F;test&#x2F;go&#x2F;t.go:7)  MOVQ    AX, &quot;&quot;..autotmp_1+64(SP)</span><br><span class="line">0x0051 00081 (&#x2F;test&#x2F;go&#x2F;t.go:7)  PCDATA  $2, $0</span><br><span class="line">0x0051 00081 (&#x2F;test&#x2F;go&#x2F;t.go:7)  MOVQ    CX, &quot;&quot;..autotmp_1+72(SP)</span><br><span class="line">0x0056 00086 (&#x2F;test&#x2F;go&#x2F;t.go:7)  PCDATA  $2, $1</span><br><span class="line">0x0056 00086 (&#x2F;test&#x2F;go&#x2F;t.go:7)  LEAQ    go.string.&quot;hello, world\n%d&quot;(SB), AX</span><br><span class="line">0x005d 00093 (&#x2F;test&#x2F;go&#x2F;t.go:7)  PCDATA  $2, $0</span><br><span class="line">0x005d 00093 (&#x2F;test&#x2F;go&#x2F;t.go:7)  MOVQ    AX, (SP)</span><br><span class="line">0x0061 00097 (&#x2F;test&#x2F;go&#x2F;t.go:7)  MOVQ    $15, 8(SP)</span><br><span class="line">0x006a 00106 (&#x2F;test&#x2F;go&#x2F;t.go:7)  PCDATA  $2, $1</span><br><span class="line">0x006a 00106 (&#x2F;test&#x2F;go&#x2F;t.go:7)  LEAQ    &quot;&quot;..autotmp_1+64(SP), AX</span><br><span class="line">0x006f 00111 (&#x2F;test&#x2F;go&#x2F;t.go:7)  PCDATA  $2, $0</span><br><span class="line">0x006f 00111 (&#x2F;test&#x2F;go&#x2F;t.go:7)  MOVQ    AX, 16(SP)</span><br><span class="line">0x0074 00116 (&#x2F;test&#x2F;go&#x2F;t.go:7)  MOVQ    $1, 24(SP)</span><br><span class="line">0x007d 00125 (&#x2F;test&#x2F;go&#x2F;t.go:7)  MOVQ    $1, 32(SP)</span><br><span class="line">0x0086 00134 (&#x2F;test&#x2F;go&#x2F;t.go:7)  CALL    fmt.Printf(SB)	</span><br><span class="line">						&#x2F;&#x2F; 但是在调用之前, 我并没看到我的数字被加载了, 为什么?</span><br><span class="line">						&#x2F;&#x2F; 我唯一比较怀疑的是那个 CALL runtime.convT2E64(SB)</span><br></pre></td></tr></table></figure>

<p>好吧, 我的数据再度丢失了, 我甚至不知道它是如何被传过去的…</p>
<h3 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h3><p>go的汇编基于 plan 9(一个新的操作系统), 感觉到了新的技术和观点</p>
<p>并且它也更加友好, 我明显觉得看它的汇编会更轻松一些</p>
<p>(除了那个 PCDATA, FUNCDATA, 和那个已经被我跟丢的变量)</p>
<p>emmm… 很不错, 觉得自己听了别人的建议, 去学新的语言</p>
<p>而不学现在看起来很强大, 但是已经很老了的 java 是一个正确的决定</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/09/other/implementionThreadInUserAndKernelSpace/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cas">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cas's website">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/09/other/implementionThreadInUserAndKernelSpace/" class="post-title-link" itemprop="url">other/implementionThreadInUserAndKernelSpace</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-09 17:14:16 / Modified: 17:13:31" itemprop="dateCreated datePublished" datetime="2020-01-09T17:14:16+08:00">2020-01-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>之前就看过关于在内核以及用户空间实现线程的文章, 到现在还对于其中的一些点一知半解, 比如: 为什么实现在用户空间的线程比实现在内核空间的快?. 今天碰巧看到了这篇文章, 原文出自 &lt;modern operating system, fourth edition&gt;</p>
<h2 id="threads-implementation-in-kernel-and-user-space"><a href="#threads-implementation-in-kernel-and-user-space" class="headerlink" title="threads implementation in kernel and user space"></a>threads implementation in kernel and user space</h2><h3 id="2-2-4-Implementing-Threads-in-User-Space"><a href="#2-2-4-Implementing-Threads-in-User-Space" class="headerlink" title="2.2.4 Implementing Threads in User Space"></a>2.2.4 Implementing Threads in User Space</h3><p>There are two main places to implement threads: user space and the kernel.<br>The choice is a bit controversial, and a hybrid implementation is also possible. We<br>will now describe these methods, along with their advantages and disadvantages.</p>
<p>有两种主要的地方用于实现线程: 用户空间以及内核空间. 如何在哪里实现具有一定争议性, 同时, 一种混合的实现也是可能的. 我们将会概述这些方法, 以及他们的优点和缺点.</p>
<p>The first method is to put the threads package entirely in user space. The kernel knows nothing about them. As far as the kernel is concerned, it is managing<br>ordinary, single-threaded processes. The first, and most obvious, advantage is that<br>a user-level threads package can be implemented on an operating system that does<br>not support threads. All operating systems used to fall into this category, and even<br>now some still do. With this approach, threads are implemented by a library.</p>
<p>第一种方法是将整个线程包放到用户空间. 内核对此毫无所知. 就内核而言, 它依旧像对待单线程对象一样.</p>
<p>首先, 最明显的优点是, 用户级别的线程可以实现在一个不支持多线程的操作系统上.所有的操作系统曾经都是这种类型, 直到现在还有部分保留, 在这种方式下, 线程通过一个库实现.</p>
<p>All of these implementations have the same general structure, illustrated in<br>Fig. 2-16(a). The threads run on top of a run-time system, which is a collection of<br>procedures that manage threads. We have seen four of these already: pthread create, pthread exit, pthread join, and pthread yield, but usually there are more.</p>
<p>所有的实现有同样通用的结构, 如图2-16(a). 线程运行于运行时系统上(一系列管理线程的程序). 我们已经见过四种这样的程序了: 线程创建, 退出, 加入, 放弃(这是本书前面部分的内容, 但为什么是 pthread 呢? 难道是基于 posix 标准的线程实现?)</p>
<p><img src="https://imgur.com/ljUry5a.png" alt=""></p>
<p>When threads are managed in user space, each process needs its own private<br>thread table to keep track of the threads in that process. This table is analogous to<br>the kernel’s process table, except that it keeps track only of the per-thread proper-<br>ties, such as each thread’s program counter, stack pointer, registers, state, and so<br>forth. The thread table is managed by the run-time system. When a thread is<br>moved to ready state or blocked state, the information needed to restart it is stored<br>in the thread table, exactly the same way as the kernel stores information about<br>processes in the process table.</p>
<p>当线程管理于用户空间时, 每个进程需要拥有独有的线程表, 以用于持续跟踪进程中的线程. 这个表类似与内核的进程表, 不过它只跟踪每个线程的属性. 比如每个线程的程序计数器, 栈指针, 寄存器, 状态, 以及… </p>
<p>线程表由运行时系统管理, 当线程转变为就绪/阻塞状态时, 用于重启的信息就存储在线程表中, 就和内核在进程表中存储关于进程的信息一样.</p>
<p>When a thread does something that may cause it to become blocked locally, for<br>example, waiting for another thread in its process to complete some work, it calls a<br>run-time system procedure. This procedure checks to see if the thread must be put<br>into blocked state. If so, it stores the thread’s registers (i.e., its own) in the thread<br>table, looks in the table for a ready thread to run, and reloads the machine registers<br>with the new thread’s saved values. As soon as the stack pointer and program<br>counter have been switched, the new thread comes to life again automatically.</p>
<p>如果线程做了某些操作导致它本地阻塞时, 比如: 等待进程中的其他线程完成某些工作. 它调用一个运行时作业调度. </p>
<p>这个程序检查线程是否必须置于阻塞态, 如果是, 它在线程表中存储线程的寄存器(它自己的). 在表中查找一个就绪态线程运行, 重新加载新线程的寄存器. 同时栈指针和程序计数器也会切换, 新线程再次自动运行.</p>
<p> If the machine happens to have an instruction to store all the registers and another<br>one to load them all, the entire thread switch can be done in just a handful of in-<br>structions. Doing thread switching like this is at least an order of magnitude—<br>maybe more—faster than trapping to the kernel and is a strong argument in favor<br>of user-level threads packages.</p>
<p>如果机器开始有一个指令可以存储所有的寄存器, 同时另一个指令加载他们, 那么整个线程的切换就只需要少量的指令.</p>
<p>要完成这样的线程切换比捕获内核至少快一个数量级, 或许更快. 这是一个对用户级线程拥护者强有力的论点.</p>
<p>However, there is one key difference with processes. When a thread is finished<br>running for the moment, for example, when it calls thread yield, the code of<br>thread yield can save the thread’s information in the thread table itself. Fur-<br>thermore, it can then call the thread scheduler to pick another thread to run. The<br>procedure that saves the thread’s state and the scheduler are just local procedures,<br>so invoking them is much more efficient than making a kernel call. Among other<br>issues, no trap is needed, no context switch is needed, the memory cache need not<br>be flushed, and so on. This makes thread scheduling very fast.</p>
<p>然而, 有一个关于进程的关键不同. 当线程暂停时, 比如: 调用 yield, 保存线程的信息到线程表中.</p>
<p>更进步一, 调用线程调度, 选择另一个线程执行. 程序保存线程状态, 因为调度只是本地程序, 所以调用其会比内核调用更加高效. 其他方面, 没有捕获, 没有环境切换, 内存缓冲也不需要刷新, 等等. 这使得线程调度非常快.</p>
<p>User-level threads also have other advantages. They allow each process to have<br>its own customized scheduling algorithm. For some applications, for example,<br>those with a garbage-collector thread, not having to worry about a thread being<br>stopped at an inconvenient moment is a plus. They also scale better, since kernel<br>threads invariably require some table space and stack space in the kernel, which<br>can be a problem if there are a very large number of threads.</p>
<p>用户级线程还有其他优点. 它使每个进程都可以有自己的特定调度算法. 对于一些应用, 比如垃圾回收线程, 不用担心线程在不适当时候停下来, 这是一个优点. 他们拥有更好的伸缩性, 因为内核线程总是需要一些表空间和栈空间, 当线程逐渐增加时, 会造成麻烦.</p>
<p>Despite their better performance, user-level threads packages have some major<br>problems. First among these is the problem of how blocking system calls are im-<br>plemented. Suppose that a thread reads from the keyboard before any keys hav e<br>been hit. Letting the thread actually make the system call is unacceptable, since<br>this will stop all the threads. One of the main goals of having threads in the first<br>place was to allow each one to use blocking calls, but to prevent one blocked<br>thread from affecting the others. With blocking system calls, it is hard to see how<br>this goal can be achieved readily.</p>
<p>即使它们拥有更好的性能, 用户级线程包也有一些固有的问题. </p>
<p>首先, 如何实现阻塞的系统调用. 假如线程等待来自键盘的输入, 让这个线程准确执行系统调用是不允许的, 因为这会阻塞所有线程, 线程的首要目的之一是允许每个线程使用阻塞调用, 但是保证一个阻塞线程不会影响其他线程. 可以看出这很难实现.</p>
<p>The system calls could all be changed to be nonblocking (e.g., a read on the<br>keyboard would just return 0 bytes if no characters were already buffered), but re-<br>quiring changes to the operating system is unattractive. Besides, one argument for<br>user-level threads was precisely that they could run with existing operating sys-<br>tems. In addition, changing the semantics of read will require changes to many<br>user programs.</p>
<p>系统调用必须都变为非阻塞的(比如, 读取键盘输入应该在没有任何字符被缓存时返回0), 但是这对于操作系统而已不太友好. 次外(我真不知道怎么翻译这句…). 另外, 改变读取的语义将会影响到大量用户程序.</p>
<p>Another alternative is available in the event that it is possible to tell in advance<br>if a call will block. In most versions of UNIX, a system call, select , exists, which<br>allows the caller to tell whether a prospective read will block. When this call is<br>present, the library procedure read can be replaced with a new one that first does a<br>select call and then does the read call only if it is safe (i.e., will not block). If the<br>read call will block, the call is not made. Instead, another thread is run. The next<br>time the run-time system gets control, it can check again to see if the read is now<br>safe. This approach requires rewriting parts of the system call library, and is inef-<br>ficient and inelegant, but there is little choice. The code placed around the system<br>call to do the checking is called a jacket or wrapper.</p>
<p>在这种情况下还有另一个方法: 提前告知一个调用将会被阻塞是可行的(??? 啥意思啊 = =).</p>
<p>在多个 UNIX 版本中, 选择性地存在系统调用运行调用者判断未来的读操作将会阻塞. 当这样的调用存在时, 库程序读取替换成一个首先做判断, 然后当确定是安全的时候读取(比如, 非阻塞).不会执行会阻塞的读操作, 另一个线程将会运行. </p>
<p>在下次运行时系统获得控制时, 会再次检查读操作是否是安全的. 这个方法需要重写部分系统调用库. 不那么高效和优雅. 不过这是一个选择, 放置在系统函数周围的代码去检查的这种方法被称为 jacket 或 wrapper.</p>
<p>Somewhat analogous to the problem of blocking system calls is the problem of<br>page faults. We will study these in Chap. 3. For the moment, suffice it to say that<br>computers can be set up in such a way that not all of the program is in main memo-<br>ry at once. If the program calls or jumps to an instruction that is not in memory, a<br>page fault occurs and the operating system will go and get the missing instruction<br>(and its neighbors) from disk. This is called a page fault. The process is blocked<br>while the necessary instruction is being located and read in. If a thread causes a<br>page fault, the kernel, unaware of even the existence of threads, naturally blocks<br>the entire process until the disk I/O is complete, even though other threads might<br>be runnable.01</p>
<p>(简单来说, 这段说的是页错误, 主存和磁盘间虚拟空间内容的交换.)</p>
<p>Another problem with user-level thread packages is that if a thread starts run-<br>ning, no other thread in that process will ever run unless the first thread voluntarily<br>gives up the CPU. Within a single process, there are no clock interrupts, making it<br>impossible to schedule processes round-robin fashion (taking turns). Unless a<br>thread enters the run-time system of its own free will, the scheduler will never get a<br>chance.</p>
<p>用户级线程将面临的另一个问题是: 当线程开始执行时, 除非自愿放弃, 不然其他线程无法执行. </p>
<p>单线程程序, 不会产生时钟终端, 使用 round-robin 调度器管理进程是不可能的. 除非线程自愿进入运行时系统. 否则调度器将不会生效.</p>
<p>One possible solution to the problem of threads running forever is to have the<br>run-time system request a clock signal (interrupt) once a second to give it control,<br>but this, too, is crude and messy to program. Periodic clock interrupts at a higher<br>frequency are not always possible, and even if they are, the total overhead may be<br>substantial. Furthermore, a thread might also need a clock interrupt, interfering<br>with the run-time system’s use of the clock.</p>
<p>一个可能的方法是: 让运行时系统每秒请求一个时钟信号来控制它(总而言之这是一个馊主意).</p>
<p>Another, and really the most devastating, argument against user-level threads is<br>that programmers generally want threads precisely in applications where the<br>threads block often, as, for example, in a multithreaded Web server. These threads<br>are constantly making system calls. Once a trap has occurred to the kernel to carry<br>out the system call, it is hardly any more work for the kernel to switch threads if<br>the old one has blocked, and having the kernel do this eliminates the need for con-<br>stantly making select system calls that check to see if read system calls are safe.<br>For applications that are essentially entirely CPU bound and rarely block, what is<br>the point of having threads at all? No one would seriously propose computing the<br>first n prime numbers or playing chess using threads because there is nothing to be<br>gained by doing it that way.</p>
<p>另一个反对用户级线程的论证(也是最具破坏性的)是, 程序员通常希望线程在线程经常阻塞的应用中使用, 比如, 在一个多线程 web 服务器中. 线程不间断地使用系统调用, 一旦内核执行系统调用, 如果旧线程已被阻塞, 那么切换线程就几乎没有其他需要做的了. …(后面我翻不下去了, 大概意思是, 这样的话, 程序就没有必要使用多线程了)</p>
<p>(总结归纳一下: 大概意思是, 用户级线程最大的优点是在于其切换起来很快, 但是我们通常希望在频繁发生线程阻塞的应用中使用线程, 而在这种情况下, 线程切换所需的操作就会变少(如果旧线程已经被阻塞了的话), 那么 用户级线程存在的意义就不大了)</p>
<h3 id="2-2-5-Implementing-Threads-in-the-Kernel"><a href="#2-2-5-Implementing-Threads-in-the-Kernel" class="headerlink" title="2.2.5 Implementing Threads in the Kernel"></a>2.2.5 Implementing Threads in the Kernel</h3><p>Now let us consider having the kernel know about and manage the threads. No<br>run-time system is needed in each, as shown in Fig. 2-16(b). Also, there is no<br>thread table in each process. Instead, the kernel has a thread table that keeps track<br>of all the threads in the system. When a thread wants to create a new thread or<br>destroy an existing thread, it makes a kernel call, which then does the creation or<br>destruction by updating the kernel thread table.</p>
<p>现在, 让我们考虑让内核知道如何管理线程. 如图 2-16(b) 所示, 在进程中没有运行时系统, 也没有线程表. 内核有张线程表, 用于跟踪系统中的所有线程. 当线程想要创建或删除一个线程时, 使用一个内核调用, 然后通过更新内核线程表来创建或删除.</p>
<p>The kernel’s thread table holds each thread’s registers, state, and other infor-<br>mation. The information is the same as with user-level threads, but now kept in the<br>kernel instead of in user space (inside the run-time system). This information is a<br>subset of the information that traditional kernels maintain about their single-<br>threaded processes, that is, the process state. In addition, the kernel also maintains<br>the traditional process table to keep track of processes.</p>
<p>内核的线程表保存每个线程的寄存器, 状态, 以及其他信息. 与用户级线程保存的信息一致, 只是保存在内核中. </p>
<p>这些信息是传统内核管理的单线程进程信息的子集. 内核也同样管理传统的进程表, 以用于跟踪进程.</p>
<p>All calls that might block a thread are implemented as system calls, at consid-<br>erably greater cost than a call to a run-time system procedure. When a thread<br>blocks, the kernel, at its option, can run either another thread from the same proc-<br>ess (if one is ready) or a thread from a different process. With user-level threads,<br>the run-time system keeps running threads from its own process until the kernel<br>takes the CPU away from it (or there are no ready threads left to run).</p>
<p>所有可能阻塞线程的调用都被实现为系统调用, 相对运行时系统的调用, 明显有很大的额外消耗. 当线程阻塞时, 内核可以选择同进程下的线程运行, 也可以运行另一个进程的线程. 但用户级线程只会运行本进程的线程, 直到内核不让其使用 CPU 资源.</p>
<p>Due to the relatively greater cost of creating and destroying threads in the ker-<br>nel, some systems take an environmentally correct approach and recycle their<br>threads. When a thread is destroyed, it is marked as not runnable, but its kernel<br>data structures are not otherwise affected. Later, when a new thread must be creat-<br>ed, an old thread is reactivated, saving some overhead. Thread recycling is also<br>possible for user-level threads, but since the thread-management overhead is much<br>smaller, there is less incentive to do this.</p>
<p>因为在内核中创建和销毁线程操作相对更费力, 一些系统使用与环境相关的方法, 重利用它们的线程. </p>
<p>当线程销毁时, 将其标记为不可运行, 但是其内核数据结构不受影响, 随后, 当新线程需要创建时, 重新利用这些资源.  用户级线程也可以使用这个方法, 不过因为线程管理的消耗较小, 并不是很有必要这么做</p>
<p>Kernel threads do not require any new, nonblocking system calls. In addition,<br>if one thread in a process causes a page fault, the kernel can easily check to see if<br>the process has any other runnable threads, and if so, run one of them while wait-<br>ing for the required page to be brought in from the disk. Their main disadvantage is<br>that the cost of a system call is substantial, so if thread operations (creation, termi-<br>nation, etc.) a common, much more overhead will be incurred.</p>
<p>内核线程不需要任何新的, 非阻塞系统调用. 另外, 如果线程导致了页错误, 内核可以轻松地检查进程是否有其他线程可运行, 如果有, 在等待所需的页加载入内存中时, 执行该线程. 它们潜在的问题是: 系统调用比较耗时, 所以如果线程操作比较常见, 则会有更多的负载.</p>
<p>While kernel threads solve some problems, they do not solve all problems. For<br>example, what happens when a multithreaded process forks? Does the new proc-<br>ess have as many threads as the old one did, or does it have just one? In many<br>cases, the best choice depends on what the process is planning to do next. If it is<br>going to call exec to start a new program, probably one thread is the correct choice,<br>but if it continues to execute, reproducing all the threads is probably best.</p>
<p>内核线程依旧有一些未能解决的问题, 比如, 当多线程进程执行 fork 的时候, 会发生什么? 新的进程是否会像旧进程一样拥有同样多的线程呢? 还是只拥有一个呢? 在大多数情况下, 取决于进程将要做什么, 如果它将会调用 exec 执行一个新的程序, 当然只有一个好, 但是如果是继续运行的话, 则保留所有的线程则是最好的.</p>
<p>(PS: 在 linux posix 线程下, 默认是同样多的线程)</p>
<p>Another issue is signals. Remember that signals are sent to processes, not to<br>threads, at least in the classical model. When a signal comes in, which thread<br>should handle it? Possibly threads could register their interest in certain signals, so<br>when a signal came in it would be given to the thread that said it wants it. But what<br>happens if two or more threads register for the same signal? These are only two of<br>the problems threads introduce, and there are more.</p>
<p>另一个问题是信号. 信号是发给进程的, 而并非线程(至少在经典模型下). 当信号到达时, 那个线程来处理它呢? 可能线程会注册自己感兴趣的信号, 所以, 当信号到达, 会交由那个注册线程处理. 但是如果多个线程注册了同样的信号呢? 这仅仅是线程引入的其中两个问题.</p>
<h3 id="2-2-6-Hybrid-Implementations"><a href="#2-2-6-Hybrid-Implementations" class="headerlink" title="2.2.6 Hybrid Implementations"></a>2.2.6 Hybrid Implementations</h3><p>Various ways have been investigated to try to combine the advantages of user-<br>level threads with kernel-level threads. One way is use kernel-level threads and<br>then multiplex user-level threads onto some or all of them, as shown in Fig. 2-17.<br>When this approach is used, the programmer can determine how many kernel<br>threads to use and how many user-level threads to multiplex on each one. This<br>model gives the ultimate in flexibility.</p>
<p>已经有多种方法被研究出来, 用于融合用户级线程和内核级线程. 其中一种方法是使用内核级别线程, 然后每个内核线程使用多个用户级别线程. 如 2-17. </p>
<p>程序能够知晓多少内核线程, 多少用户线程被使用. 这种模型给予了很大的灵活性.</p>
<p><img src="https://imgur.com/Bcc4Uzh.png" alt=""></p>
<p>With this approach, the kernel is aware of only the kernel-level threads and<br>schedules those. Some of those threads may have multiple user-level threads multi-<br>plexed on top of them. These user-level threads are created, destroyed, and sched-<br>uled just like user-level threads in a process that runs on an operating system with-<br>out multithreading capability. In this model, each kernel-level thread has some set<br>of user-level threads that take turns using it.</p>
<p>在这种方法下, 内核只至少内核线程, 并调度它们. 其中一些内核线程上可能存在多个用户级线程. 这些用户线程将会在进程中管控. </p>
<p>内核线程和用户线程各有其优势, 用户线程效率更高, 但是操作系统不知情的情况下, 会产生许多逻辑上是多线程, 但物理上依旧是单线程才会产生的错误. 比如 信号, 中断. 而内核线程虽然相对效率低, 并且占用内核空间, 但是操作系统知晓是多线程, 与操作系统间有更多协作的空间.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">cas</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">86</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">cas</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
