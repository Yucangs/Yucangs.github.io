<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Muse',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="cas&#39;s website">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="cas&#39;s website">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="cas">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>cas's website</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">cas's website</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">casyup.me@outlook.com</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="Searching..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/09/read/JVM-Memory-model/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cas">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cas's website">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/09/read/JVM-Memory-model/" class="post-title-link" itemprop="url">read/JVM-Memory-model</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-09 17:17:40" itemprop="dateCreated datePublished" datetime="2020-01-09T17:17:40+08:00">2020-01-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-09-24 10:45:34" itemprop="dateModified" datetime="2019-09-24T10:45:34+08:00">2019-09-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="https://www.journaldev.com/2856/java-jvm-memory-model-memory-management-in-java" target="_blank" rel="noopener">source link</a></p>
<h1 id="Java-JVM-Memory-Model-Memory-Management-in-Java"><a href="#Java-JVM-Memory-Model-Memory-Management-in-Java" class="headerlink" title="Java (JVM) Memory Model - Memory Management in Java"></a>Java (JVM) Memory Model - Memory Management in Java</h1><h2 id="Java-JVM-Memory-Model"><a href="#Java-JVM-Memory-Model" class="headerlink" title="Java (JVM) Memory Model"></a>Java (JVM) Memory Model</h2><p><a href="https://cdn.journaldev.com/wp-content/uploads/2014/05/Java-Memory-Model.png" target="_blank" rel="noopener"><img src="https://cdn.journaldev.com/wp-content/uploads/2014/05/Java-Memory-Model-450x186.png" alt="Java Memory Model, JVM Memory Model, Memory Management in Java, Java Memory Management"></a></p>
<p>As you can see in the above image, JVM memory is divided into separate parts. At broad level, JVM Heap memory is physically divided into two parts – <strong>Young Generation</strong> and <strong>Old Generation</strong>.</p>
<p>如上图所示, JVM 被分为了多个部分. JVM 堆物理性被分为两部分, Young Generation 和 Old Generation</p>
<h2 id="Memory-Management-in-Java-–-Young-Generation"><a href="#Memory-Management-in-Java-–-Young-Generation" class="headerlink" title="Memory Management in Java – Young Generation"></a>Memory Management in Java – Young Generation</h2><p>The young generation is the place where all the new objects are created. When the young generation is filled, garbage collection is performed. This garbage collection is called <strong>Minor GC</strong>. Young Generation is divided into three parts – <strong>Eden Memory</strong> and two <strong>Survivor Memory</strong> spaces.</p>
<p>所有新创建的对象一开始都在 young generation 中. GC 在 young generation 被填满时执行. 这个 GC 被称为 Minor GC. Young Generation 被分为三部分, Eden Memory 和两个 Survivor Memory 空间 </p>
<p>Important Points about Young Generation Spaces:</p>
<ul>
<li><p>Most of the newly created objects are located in the Eden memory space.</p>
</li>
<li><p>大部分新创建的对象位于 Eden memory 空间</p>
</li>
<li><p>When Eden space is filled with objects, Minor GC is performed and all the survivor objects are moved to one of the survivor spaces.</p>
</li>
<li><p>Minor GC 在 Eden space 被对象填充时执行, 所有的 survivor 对象被移动到其中一个 survivor 空间</p>
</li>
<li><p>Minor GC also checks the survivor objects and move them to the other survivor space. So at a time, one of the survivor space is always empty.</p>
</li>
<li><p>Minor GC 元入会检查 survivor 对象, 将其移动到其他的 survivor 空间. 所以在同一时刻, 有一个 survivor 空间一直是空的</p>
</li>
<li><p>Objects that are survived after many cycles of GC, are moved to the Old generation memory space. Usually, it’s done by setting a threshold for the age of the young generation objects before they become eligible to promote to Old generation.</p>
</li>
<li><p>在多次 GC 循环后仍幸存的对象将会被移动到 Old generation 内存空间. </p>
<p>通常, 是通过给 young generation 对象设置一个年龄的阈值来实现的 (超过这个阈值的对象将会被移动到 Old Generation 中)</p>
</li>
</ul>
<h2 id="Memory-Management-in-Java-–-Old-Generation"><a href="#Memory-Management-in-Java-–-Old-Generation" class="headerlink" title="Memory Management in Java – Old Generation"></a>Memory Management in Java – Old Generation</h2><p>Old Generation memory contains the objects that are long-lived and survived after many rounds of Minor GC. Usually, garbage collection is performed in Old Generation memory when it’s full. Old Generation Garbage Collection is called <strong>Major GC</strong> and usually takes a longer time.</p>
<p>Old Generation 内存包含在多次 Minor GC 循环后仍幸存的对象. 通常, GC 在 Old Generation 被填满时执行.</p>
<p>Old Generation GC 被成为 Major GC, 通常花费更长的时间</p>
<h3 id="Stop-the-World-Event"><a href="#Stop-the-World-Event" class="headerlink" title="Stop the World Event"></a>Stop the World Event</h3><p>All the Garbage Collections are “Stop the World” events because all application threads are stopped until the operation completes.</p>
<p>所有的 GC 都是 “Stop the World” 事件. 因为所有的应用线程阻塞直到操作完成</p>
<p>Since Young generation keeps short-lived objects, Minor GC is very fast and the application doesn’t get affected by this.</p>
<p>因为 Young generation 保持短期存活对象, Minor GC 相当快, 应用不会受此影响</p>
<p>However, Major GC takes a long time because it checks all the live objects. Major GC should be minimized because it will make your application unresponsive for the garbage collection duration. So if you have a responsive application and there are a lot of Major Garbage Collection happening, you will notice timeout errors.</p>
<p>然而, Major GC 花费较长的时间, 因为它会检查所有的存活对象, Major GC 应该尽量少使用. 因为它会在 GC 期间, 使你的程序无相应. 所以如果你有一个响应应用, 同时在应用中存在大量 Major GC 发生时, 你应该注意是否会产生超时错误</p>
<p>The duration taken by garbage collector depends on the strategy used for garbage collection. That’s why it’s necessary to monitor and tune the garbage collector to avoid timeouts in the highly responsive applications.</p>
<p>GC 占用时间取决于 GC 策略, 这就是为什么要在高响应应用程序中需要监控和调整 GC 策略的原因</p>
<h3 id="Java-Memory-Model-–-Permanent-Generation"><a href="#Java-Memory-Model-–-Permanent-Generation" class="headerlink" title="Java Memory Model – Permanent Generation"></a>Java Memory Model – Permanent Generation</h3><p>Permanent Generation or “Perm Gen” contains the application metadata required by the JVM to describe the classes and methods used in the application. Note that Perm Gen is not part of <a href="https://www.journaldev.com/4098/java-heap-space-vs-stack-memory" target="_blank" rel="noopener">Java Heap memory</a>.</p>
<p>Permanent Generation 或 “Perm Gen” 包含 JVM 所需的应用元数据, 描述应用于应用中的类和方法. 注意, Perm Gen 不是 Java Heap memory 的一部分</p>
<p>Perm Gen is populated by JVM at runtime based on the classes used by the application. Perm Gen also contains Java SE library classes and methods. Perm Gen objects are garbage collected in a full garbage collection.</p>
<p>Perm Gen 由 JVM 在运行时填充, 基于被应用程序使用的类. Perm Gen 也包含 Java SE 库类以及方法. Perm Gen 对象在完整的 GC 中被回收</p>
<h3 id="Java-Memory-Model-–-Method-Area"><a href="#Java-Memory-Model-–-Method-Area" class="headerlink" title="Java Memory Model – Method Area"></a>Java Memory Model – Method Area</h3><p>Method Area is part of space in the Perm Gen and used to store class structure (runtime constants and static variables) and code for methods and constructors.</p>
<p>Method Area 是 Perm Gen 空间的一部分. 用于存储类数据结构 (运行时常量和静态变量) 以及 方法的代码和结构</p>
<h3 id="Java-Memory-Model-–-Memory-Pool"><a href="#Java-Memory-Model-–-Memory-Pool" class="headerlink" title="Java Memory Model – Memory Pool"></a>Java Memory Model – Memory Pool</h3><p>Memory Pools are created by JVM memory managers to create a pool of <a href="https://www.journaldev.com/129/how-to-create-immutable-class-in-java" target="_blank" rel="noopener">immutable</a> objects if the implementation supports it. String Pool is a good example of this kind of memory pool. Memory Pool can belong to Heap or Perm Gen, depending on the JVM memory manager implementation.</p>
<p>内存池由 JVM 内存管理器创建, 创建一个不变量对象池 (如果实现支持的话). String 池是这种内存池的一个很好的例子. 内存池可以属于 Heap 或 Perm Gen, 取决于 JVM 内存管理器的实现</p>
<h3 id="Java-Memory-Model-–-Runtime-Constant-Pool"><a href="#Java-Memory-Model-–-Runtime-Constant-Pool" class="headerlink" title="Java Memory Model – Runtime Constant Pool"></a>Java Memory Model – Runtime Constant Pool</h3><p>Runtime constant pool is per-class runtime representation of constant pool in a class. It contains class runtime constants and static methods. Runtime constant pool is part of the method area.</p>
<p>运行时常量池是类中常量池的每个类的运行时表示. 包含类运行时常量和静态方法. 运行时常量池是 method 区域的一部分</p>
<h3 id="Java-Memory-Model-–-Java-Stack-Memory"><a href="#Java-Memory-Model-–-Java-Stack-Memory" class="headerlink" title="Java Memory Model – Java Stack Memory"></a>Java Memory Model – Java Stack Memory</h3><p>Java Stack memory is used for execution of a thread. They contain method specific values that are short-lived and references to other objects in the heap that is getting referred from the method. You should read <a href="https://www.journaldev.com/4098/java-heap-space-vs-stack-memory" target="_blank" rel="noopener">Difference between Stack and Heap Memory</a>.</p>
<p>Java 栈内存用户执行线程. 它们包含方法指定值 (生命周期短, 指向堆中的对象)</p>
<h3 id="Memory-Management-in-Java-–-Java-Heap-Memory-Switches"><a href="#Memory-Management-in-Java-–-Java-Heap-Memory-Switches" class="headerlink" title="Memory Management in Java – Java Heap Memory Switches"></a>Memory Management in Java – Java Heap Memory Switches</h3><p>Java provides a lot of memory switches that we can use to set the memory sizes and their ratios. Some of the commonly used memory switches are:</p>
<p>Java 提供了大量的内存开关, 用于设置内存大小和比例. 一些常用的内存开关有: </p>
<table>
<thead>
<tr>
<th align="left">VM Switch</th>
<th align="left">VM Switch Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-Xms</td>
<td align="left">For setting the initial heap size when JVM starts</td>
</tr>
<tr>
<td align="left">-Xmx</td>
<td align="left">For setting the maximum heap size.</td>
</tr>
<tr>
<td align="left">-Xmn</td>
<td align="left">For setting the size of the Young Generation, rest of the space goes for Old Generation.</td>
</tr>
<tr>
<td align="left">-XX:PermGen</td>
<td align="left">For setting the initial size of the Permanent Generation memory</td>
</tr>
<tr>
<td align="left">-XX:MaxPermGen</td>
<td align="left">For setting the maximum size of Perm Gen</td>
</tr>
<tr>
<td align="left">-XX:SurvivorRatio</td>
<td align="left">For providing ratio of Eden space and Survivor Space, for example if Young Generation size is 10m and VM switch is -XX:SurvivorRatio=2 then 5m will be reserved for Eden Space and 2.5m each for both the Survivor spaces. The default value is 8.</td>
</tr>
<tr>
<td align="left">-XX:NewRatio</td>
<td align="left">For providing ratio of old/new generation sizes. The default value is 2.</td>
</tr>
</tbody></table>
<p>Most of the times, above options are sufficient, but if you want to check out other options too then please check <a href="https://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html" target="_blank" rel="noopener">JVM Options Official Page</a>.</p>
<p>大多数时候, 上面的选项就足够了, 其他选项可以参见… </p>
<h3 id="Memory-Management-in-Java-–-Java-Garbage-Collection"><a href="#Memory-Management-in-Java-–-Java-Garbage-Collection" class="headerlink" title="Memory Management in Java – Java Garbage Collection"></a>Memory Management in Java – Java Garbage Collection</h3><p>Java Garbage Collection is the process to identify and remove the unused objects from the memory and free space to be allocated to objects created in future processing. One of the best features of Java programming language is the <strong>automatic garbage collection</strong>, unlike other programming languages such as C where memory allocation and deallocation is a manual process.</p>
<p>Java GC 是用于从内存中确定和移除未使用对象的进程, 释放内存, 以用于将来创建的对象. Java 的特性之一是自动垃圾回收, 不像其他语言需要手动处理 (其实也不是啦, 栈是不需要管的, 也就是 heap 需要手动释放)</p>
<p><strong>Garbage Collector</strong> is the program running in the background that looks into all the objects in the memory and find out objects that are not referenced by any part of the program. All these unreferenced objects are deleted and space is reclaimed for allocation to other objects.</p>
<p>GC 是一个运行于后台的程序, 查看在内容中的所有对象, 找到没有被程序中任何部分引用的对象. 所有这些未引用对象都会被删除, 空间会回收利用, 以用于其他对象的分配</p>
<p>One of the basic ways of garbage collection involves three steps:</p>
<ol>
<li><p><strong>Marking</strong>: This is the first step where garbage collector identifies which objects are in use and which ones are not in use.</p>
<p>Marking: 这是 GC 用于确定对象是否被使用的第一步</p>
</li>
<li><p><strong>Normal Deletion</strong>: Garbage Collector removes the unused objects and reclaim the free space to be allocated to other objects.</p>
<p>Normal Deletion: GC 移除未使用对象, 回收资源</p>
</li>
<li><p><strong>Deletion with Compacting</strong>: For better performance, after deleting unused objects, all the survived objects can be moved to be together. This will increase the performance of allocation of memory to newer objects.</p>
<p>Deletion with Compacting: 为了获得更好的性能, 在删除未使用对象后, 所有幸存对象可以移到一起, 这可以增加分配新对象的性能</p>
</li>
</ol>
<p>There are two problems with a simple mark and delete approach.</p>
<ol>
<li><p>First one is that it’s not efficient because most of the newly created objects will become unused</p>
<p>首先, 这并不高效, 因为大部分新创建的对象将会变成未使用</p>
</li>
<li><p>Secondly objects that are in-use for multiple garbage collection cycle are most likely to be in-use for future cycles too.</p>
<p>其次, 多个 GC 循环后仍使用的对象在将来也可能是使用的</p>
</li>
</ol>
<p>(总结来说就是, 大多数对象是创建后就失效的, 维护起来有一定成为. 其次, 一个多次 GC 后存在的对象在以后也大概率不会被移除, 这又会产生额外的性能损失)</p>
<p>The above shortcomings with the simple approach is the reason that <strong>Java Garbage Collection is Generational</strong> and we have <strong>Young Generation</strong> and <strong>Old Generation</strong> spaces in the heap memory. I have already explained above how objects are scanned and moved from one generational space to another based on the Minor GC and Major GC.</p>
<p>以上简单方法的缺点是 Java GC 是在堆内存中分代, 使用 Young Generation 和 Old Generation 空间的原因</p>
<h3 id="Memory-Management-in-Java-–-Java-Garbage-Collection-Types"><a href="#Memory-Management-in-Java-–-Java-Garbage-Collection-Types" class="headerlink" title="Memory Management in Java – Java Garbage Collection Types"></a>Memory Management in Java – Java Garbage Collection Types</h3><p>There are five types of garbage collection types that we can use in our applications. We just need to use the JVM switch to enable the garbage collection strategy for the application. Let’s look at each of them one by one.</p>
<p>我们可以在我们的应用中使用五种 GC, 仅需使用 JVM 开关就可使 GC 策略应用于应用. </p>
<ol>
<li><p><strong>Serial GC (-XX:+UseSerialGC)</strong>: Serial GC uses the simple <strong>mark-sweep-compact</strong> approach for young and old generations garbage collection i.e Minor and Major GC.</p>
<p>Serial GC is useful in client machines such as our simple stand-alone applications and machines with smaller CPU. It is good for small applications with low memory footprint.</p>
<p>Serial GC: Serial GC 使用最简单的 <strong>mark-sweep-compact</strong> 方法用于 young 和 old generations GC. 比如, Minor 和 Major GC.</p>
<p>Serial GC 在如我们简单的, 独立的应用和小的 CPU 上很有用, 适用于低内存占用的小型应用</p>
</li>
<li><p><strong>Parallel GC (-XX:+UseParallelGC)</strong>: Parallel GC is same as Serial GC except that is spawns N threads for young generation garbage collection where N is the number of CPU cores in the system. We can control the number of threads using <code>-XX:ParallelGCThreads=n</code> JVM option.</p>
<p>Parallel GC: Parallel GC 类似于 Serial GC, 除了为 young generation GC 产生 N 个线程 (N 是CPU核心数). 可以使用 JVM 选项控制线程的数量</p>
<p>Parallel Garbage Collector is also called throughput collector because it uses multiple CPUs to speed up the GC performance. Parallel GC uses a single thread for Old Generation garbage collection.</p>
<p>Parallel GC 也被称为吞吐量收集器, 因为它使用多个CPU提升GC性能. Parallel GC为Old Generation GC 单独分配一个线程</p>
</li>
<li><p><strong>Parallel Old GC (-XX:+UseParallelOldGC)</strong>: This is same as Parallel GC except that it uses multiple threads for both Young Generation and Old Generation garbage collection.</p>
<p>和Parallel GC相同, 但它对 Young GC 和 Old GC 都使用多线程</p>
</li>
<li><p><strong>Concurrent Mark Sweep (CMS) Collector (-XX:+UseConcMarkSweepGC)</strong>: CMS Collector is also referred as concurrent low pause collector. It does the garbage collection for the Old generation. CMS collector tries to minimize the pauses due to garbage collection by doing most of the garbage collection work concurrently with the application threads.</p>
<p>CMS 收集器也被称为并发低暂停收集器. 它为 Old generation 做 GC 操作. CMS 收集器尝试使用应用线程, 通过并发执行大部分 GC 操作来尽可能减低 GC 的暂停</p>
<p>CMS collector on the young generation uses the same algorithm as that of the parallel collector. This garbage collector is suitable for responsive applications where we can’t afford longer pause times. We can limit the number of threads in CMS collector using <code>-XX:ParallelCMSThreads=n</code> JVM option.</p>
<p>CMS 在 young generation 上像 parallel 收集器一样使用同样的算法, 这个算法适用于不能承担长时间暂停的响应程序, 可以使用选项限制 CMS 收集器使用的线程数</p>
</li>
<li><p><strong>G1 Garbage Collector (-XX:+UseG1GC)</strong>: The Garbage First or G1 garbage collector is available from Java 7 and its long term goal is to replace the CMS collector. The G1 collector is a parallel, concurrent, and incrementally compacting low-pause garbage collector.Garbage First Collector doesn’t work like other collectors and there is no concept of Young and Old generation space. It divides the heap space into multiple equal-sized heap regions. When a garbage collection is invoked, it first collects the region with lesser live data, hence “Garbage First”. You can find more details about it at Garbage-First Collector Oracle Documentation.</p>
<p>G1 GC 从 Java 7 开始支持, 它长期的目标是取代 CMS 收集器. G1 是一个并行, 并发以及递增压紧的低暂停 GC. G1 不像其他收集器, 它没有 Young 和 Old generation 的概念. 它将 heap 空间分为多个相同的 heap 区域. 当GC 执行时, 它首先清理较少存留数据的 heap 区域, 因此成为”Garbage  First”. 你可以在 Oracle 的文档中找到更多关于 G1 收集器的信息.</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/09/read/IteratorsandReverseIterators/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cas">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cas's website">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/09/read/IteratorsandReverseIterators/" class="post-title-link" itemprop="url">read/IteratorsandReverseIterators</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-09 17:17:39" itemprop="dateCreated datePublished" datetime="2020-01-09T17:17:39+08:00">2020-01-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-08-26 15:20:44" itemprop="dateModified" datetime="2019-08-26T15:20:44+08:00">2019-08-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Iterators-and-Reverse-Iterators"><a href="#Iterators-and-Reverse-Iterators" class="headerlink" title="Iterators and Reverse Iterators"></a>Iterators and Reverse Iterators</h2><p>You can convert normal iterators into reverse iterators. Naturally, the iterators must be bidirectional<br>iterators, but note that the logical position of an iterator is moved during the conversion. Consider<br>the following program:</p>
<p>可以将普通的迭代器转换为反向迭代去(当然, 这个迭代器必须是双向的)</p>
<p>请记住, 转换后迭代器的逻辑位置会发生改变, 参考以下程序 : </p>
<pre><code>// iter/reviter2.cpp
#include &lt;iterator&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main()
{
    // create list with elements from 1 to 9
    vector&lt;int&gt; coll = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };

    // find position of element with value 5
    vector&lt;int&gt;::const_iterator pos;
    pos = find (coll.cbegin(), coll.cend(),
    5);

    // print value to which iterator pos refers
    cout &lt;&lt; &quot;pos: &quot; &lt;&lt; *pos &lt;&lt; endl;

    // convert iterator to reverse iterator rpos
    vector&lt;int&gt;::const_reverse_iterator rpos(pos);

    // print value to which reverse iterator rpos refers
    cout &lt;&lt; &quot;rpos: &quot; &lt;&lt; *rpos &lt;&lt; endl;
}</code></pre><p>This program has the following output:<br>    pos: 5<br>    rpos: 4<br>Thus, if you print the value of an iterator and convert the iterator into a reverse iterator, the value has<br>changed. This is not a bug; it’s a feature! This behavior is a consequence of the fact that ranges are<br>half open. To specify all elements of a container, you must use the position after the last argument.<br>However, for a reverse iterator, this is the position before the first element. Unfortunately, such a<br>position may not exist. Containers are not required to guarantee that the position before their first<br>element is valid. Consider that ordinary strings and arrays might also be containers, and the language<br>does not guarantee that arrays don’t start at address zero.</p>
<p>因此, 更改后迭代器的值发生了变化. 这不是一个 bug, 而是一个特性. 这是一个因半开区间而产生的结果.</p>
<p>要指定容器的所有元素, 需要使用最后一个元素后的位置. 然而, 对于反向迭代器而言, 就是一个在第一个元素之前的位置, 不幸的是, 这样的位置是不存在的. 容器不保证他们第一个位置之前的元素是有效的.</p>
<p>参考原始字符串和数组可能也会是容器, 语言不保证数组不从地址0开始</p>
<p>As a result, the designers of reverse iterators use a trick: They “physically” reverse the “half-open<br>principle.” Physically, in a range defined by reverse iterators, the beginning is not included, whereas<br>the end is. However, logically, they behave as usual. Thus, there is a distinction between the physical<br>position that defines the element to which the iterator refers and the logical position that defines the<br>value to which the iterator refers (Figure 9.3). The question is, what happens on a conversion from<br>an iterator to a reverse iterator? Does the iterator keep its logical position (the value) or its physical<br>position (the element)? As the previous example shows, the latter is the case. Thus, the value is<br>moved to the previous element (Figure 9.4) </p>
<p>结论是, 反向迭代器设计用了一个方法 : 它们物理性地反向半开区间. 物理性地, 在反向迭代器的定义中, 开始的元素不包含在内, 而尾端被包含. 然而, 逻辑上, 它们的行为和普通的迭代器一样. 因此, 定义迭代器引用的元素的物理位置和定义迭代器引用的值的逻辑位置是有区别的. </p>
<p>问题是, 当普通迭代器转换为反向迭代器的时候, 会发生什么? 迭代器会保持它的逻辑位置, 还是物理位置? 在上面的案例显示中, 属于后者. 因此, 值移动到了之前的元素位置.</p>
<p><img src="https://imgur.com/Xe1ifka.png" alt=""></p>
<p><img src="https://imgur.com/1rPZHcM.png" alt=""></p>
<h2 id="内部如何处理的"><a href="#内部如何处理的" class="headerlink" title="内部如何处理的"></a>内部如何处理的</h2><p>以上, 就是这篇笔记的原因, 我想看看反向迭代器它的内部是如何工作的</p>
<p>这次的目标是解决如下疑问</p>
<ol>
<li>普通迭代器转换成反向迭代器会做什么?</li>
<li>反向迭代器如何迭代的? </li>
<li>反向迭代器如何保证不会越界? </li>
</ol>
<p>首先, 参考一下 C++ 代码 : </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 9&gt; v&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">	<span class="keyword">auto</span> it = v.<span class="built_in">begin</span>();</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">array</span>&lt;<span class="keyword">int</span>,9&gt;::<span class="function">const_reverse_iterator <span class="title">rit</span><span class="params">(it)</span></span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *rit &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>然后是汇编代码 : </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line">.LFB4368:</span><br><span class="line">▹   .cfi_startproc</span><br><span class="line">▹   pushq▹  %rbp</span><br><span class="line">▹   .cfi_def_cfa_offset 16</span><br><span class="line">▹   .cfi_offset 6, -16</span><br><span class="line">▹   movq▹   %rsp, %rbp</span><br><span class="line">▹   .cfi_def_cfa_register 6</span><br><span class="line">▹   subq▹   $64, %rsp</span><br><span class="line">▹   movl▹   $1, -64(%rbp)</span><br><span class="line">▹   movl▹   $2, -60(%rbp)</span><br><span class="line">▹   movl▹   $3, -56(%rbp)</span><br><span class="line">▹   movl▹   $4, -52(%rbp)</span><br><span class="line">▹   movl▹   $5, -48(%rbp)</span><br><span class="line">▹   movl▹   $6, -44(%rbp)</span><br><span class="line">▹   movl▹   $7, -40(%rbp)</span><br><span class="line">▹   movl▹   $8, -36(%rbp)</span><br><span class="line">▹   movl▹   $9, -32(%rbp)</span><br><span class="line">▹   leaq▹   -64(%rbp), %rax</span><br><span class="line">▹   movq▹   %rax, %rdi</span><br><span class="line">▹   call▹   _ZNSt5arrayIiLm9EE5beginEv	&#x2F;&#x2F; 上述是 array 的初始化代码</span><br><span class="line">▹   movq▹   %rax, -8(%rbp)	&#x2F;&#x2F; 构造的返回值即是 begin</span><br><span class="line">▹   movq▹   -8(%rbp), %rax</span><br><span class="line">▹   movl▹   (%rax), %eax	&#x2F;&#x2F; *it</span><br><span class="line">▹   movl▹   %eax, %esi</span><br><span class="line">▹   movl▹   $_ZSt4cout, %edi</span><br><span class="line">▹   call▹   _ZNSolsEi</span><br><span class="line">▹   movl▹   $_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_, %esi</span><br><span class="line">▹   movq▹   %rax, %rdi</span><br><span class="line">▹   call▹   _ZNSolsEPFRSoS_E</span><br><span class="line">▹   movq▹   -8(%rbp), %rdx	&#x2F;&#x2F; -8(%rbp) 即 it</span><br><span class="line">▹   leaq▹   -16(%rbp), %rax	&#x2F;&#x2F; 这是一块未使用的内存</span><br><span class="line">▹   movq▹   %rdx, %rsi</span><br><span class="line">▹   movq▹   %rax, %rdi</span><br><span class="line">▹   call▹   _ZNSt16reverse_iteratorIPKiEC1ES1_	&#x2F;&#x2F; 这应当就是 reverse_iterator 的 construct</span><br><span class="line">▹   leaq▹   -16(%rbp), %rax</span><br><span class="line">▹   movq▹   %rax, %rdi</span><br><span class="line">▹   call▹   _ZNKSt16reverse_iteratorIPKiEdeEv	&#x2F;&#x2F; 在解引用之前, 会调用这个函数</span><br><span class="line">▹   movl▹   (%rax), %eax	&#x2F;&#x2F; 返回值解引用, 即 *rit</span><br><span class="line">▹   movl▹   %eax, %esi</span><br><span class="line">▹   movl▹   $_ZSt4cout, %edi</span><br><span class="line">▹   call▹   _ZNSolsEi</span><br><span class="line">▹   movl▹   $_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_, %esi</span><br><span class="line">▹   movq▹   %rax, %rdi</span><br><span class="line">▹   call▹   _ZNSolsEPFRSoS_E</span><br><span class="line">▹   movl▹   $0, %eax</span><br><span class="line">▹   leave</span><br><span class="line">▹   .cfi_def_cfa 7, 8</span><br><span class="line">▹   ret</span><br></pre></td></tr></table></figure>

<p>可以看出, 关键点在于 “<em>ZNSt16reverse_iteratorIPKiEC1ES1</em>“ 和 “_ZNKSt16reverse_iteratorIPKiEdeEv” 将是关键</p>
<p>其中, ZNSt16reverse_iteratorIPKiEC1ES1 的代码如下所示 (没有错, 就是这个)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">_ZNSt16reverse_iteratorIPKiEC2ES1_:</span><br><span class="line">.LFB4445:</span><br><span class="line">▹   .cfi_startproc</span><br><span class="line">▹   pushq▹  %rbp</span><br><span class="line">▹   .cfi_def_cfa_offset 16</span><br><span class="line">▹   .cfi_offset 6, -16</span><br><span class="line">▹   movq▹   %rsp, %rbp</span><br><span class="line">▹   .cfi_def_cfa_register 6</span><br><span class="line">▹   subq▹   $16, %rsp</span><br><span class="line">▹   movq▹   %rdi, -8(%rbp)</span><br><span class="line">▹   movq▹   %rsi, -16(%rbp)</span><br><span class="line">▹   movq▹   -8(%rbp), %rax</span><br><span class="line">▹   movq▹   %rax, %rdi</span><br><span class="line">▹   call▹   _ZNSt8iteratorISt26random_access_iterator_tagilPKiRS1_EC2Ev</span><br><span class="line">▹   movq▹   -8(%rbp), %rax</span><br><span class="line">▹   movq▹   -16(%rbp), %rdx</span><br><span class="line">▹   movq▹   %rdx, (%rax)</span><br><span class="line">▹   leave</span><br><span class="line">▹   .cfi_def_cfa 7, 8</span><br><span class="line">▹   ret</span><br></pre></td></tr></table></figure>

<p>代码除 _ZNSt8iteratorISt26random_access_iterator_tagilPKiRS1_EC2Ev 外, 就是简单地将 %rsi(-8(%rbp) 即 it) 的地址放入 %rdi(-16(%rbp) 我提到过的那块未使用的内存)</p>
<p>_ZNSt8iteratorISt26random_access_iterator_tagilPKiRS1_EC2Ev 代码如下所示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">_ZNSt8iteratorISt26random_access_iterator_tagilPKiRS1_EC2Ev:</span><br><span class="line">.LFB4443:</span><br><span class="line">▹   .cfi_startproc</span><br><span class="line">▹   pushq▹  %rbp</span><br><span class="line">▹   .cfi_def_cfa_offset 16</span><br><span class="line">▹   .cfi_offset 6, -16</span><br><span class="line">▹   movq▹   %rsp, %rbp</span><br><span class="line">▹   .cfi_def_cfa_register 6</span><br><span class="line">▹   movq▹   %rdi, -8(%rbp)</span><br><span class="line">▹   popq▹   %rbp</span><br><span class="line">▹   .cfi_def_cfa 7, 8</span><br><span class="line">▹   ret</span><br><span class="line">▹   .cfi_endproc</span><br></pre></td></tr></table></figure>

<p>好像… 什么也没做 = = , 这个函数没有栈帧开辟, movq▹   %rdi, -8(%rbp) 也大概率是个无用的语句</p>
<p>那么, 可以暂时得出结论, 反向迭代器是一个二级指针, 它保存了普通迭代器的地址</p>
<p>那么, 来看另外一个函数 _ZNKSt16reverse_iteratorIPKiEdeEv</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">_ZNKSt16reverse_iteratorIPKiEdeEv:</span><br><span class="line">.LFB4447:</span><br><span class="line">▹   .cfi_startproc</span><br><span class="line">▹   pushq▹  %rbp</span><br><span class="line">▹   .cfi_def_cfa_offset 16</span><br><span class="line">▹   .cfi_offset 6, -16</span><br><span class="line">▹   movq▹   %rsp, %rbp</span><br><span class="line">▹   .cfi_def_cfa_register 6</span><br><span class="line">▹   movq▹   %rdi, -24(%rbp)</span><br><span class="line">▹   movq▹   -24(%rbp), %rax</span><br><span class="line">▹   movq▹   (%rax), %rax</span><br><span class="line">▹   movq▹   %rax, -8(%rbp)</span><br><span class="line">▹   subq▹   $4, -8(%rbp)</span><br><span class="line">▹   movq▹   -8(%rbp), %rax</span><br><span class="line">▹   popq▹   %rbp</span><br><span class="line">▹   .cfi_def_cfa 7, 8</span><br><span class="line">▹   ret</span><br><span class="line">▹   .cfi_endproc</span><br></pre></td></tr></table></figure>

<p>一句话概括: 二级指针解引用 -4. 那么就和文档所说的吻合了, 反向迭代器会往前移动一个位置</p>
<p>这个函数发生在反向迭代器解引用时, 大概可以猜出它的行为</p>
<h2 id="更进一步"><a href="#更进一步" class="headerlink" title="更进一步"></a>更进一步</h2><p>疑问 1 和 疑问 2 解决了, 但是疑问 3 还未解决</p>
<p>我原来想通过更改内存值来看的, 但是貌似有什么防范操作 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Breakpoint 1, main () at t.cpp:13</span><br><span class="line">13	    array&lt;int, 9&gt; v&#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125;;</span><br><span class="line">(gdb) n</span><br><span class="line">14	    auto it &#x3D; v.begin();</span><br><span class="line">(gdb) p &#123;int&#125;0x7fffffffe480	&#x2F;&#x2F; 这里就是 it</span><br><span class="line">$16 &#x3D; 1</span><br><span class="line">(gdb) set &#123;int&#125;0x7fffffffe480 &#x3D; 100	&#x2F;&#x2F; 更改 it 中的值</span><br><span class="line">(gdb) p &#123;int&#125;0x7fffffffe480	&#x2F;&#x2F; 成功更改</span><br><span class="line">$17 &#x3D; 100</span><br><span class="line">(gdb) n</span><br><span class="line">15	    cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">(gdb) n	&#x2F;&#x2F; 本来该打印 1 的, 更改后打印了 100 </span><br><span class="line">100</span><br><span class="line">16	    array&lt;int,9&gt;::const_reverse_iterator rit(it);</span><br><span class="line">(gdb) p v	&#x2F;&#x2F; 再次验证更改是有效的</span><br><span class="line">$18 &#x3D; &#123;_M_elems &#x3D; &#123;100, 2, 3, 4, 5, 6, 7, 8, 9&#125;&#125;</span><br><span class="line">(gdb) p &#123;int&#125;0x7fffffffe47b	&#x2F;&#x2F; 根据推算, 这个就是 rend 的地址</span><br><span class="line">$19 &#x3D; 0</span><br><span class="line">(gdb) set &#123;int&#125;0x7fffffffe47b &#x3D; 200	&#x2F;&#x2F; 更改 rend ( 在程序崩溃的边缘疯狂试探 :) )</span><br><span class="line">(gdb) p &#123;int&#125;0x7fffffffe47b</span><br><span class="line">$20 &#x3D; 200</span><br><span class="line">(gdb) n</span><br><span class="line">17	    cout &lt;&lt; *rit &lt;&lt; endl;</span><br><span class="line">(gdb) n	&#x2F;&#x2F; 结果让人很失望</span><br><span class="line">0</span><br><span class="line">18	&#125;</span><br><span class="line">(gdb) p &#123;int&#125;0x7fffffffe47b &#x2F;&#x2F; 谁让你改回去的!?</span><br><span class="line">$21 &#x3D; 0</span><br></pre></td></tr></table></figure>

<p>我之后在 end 上做了同样的测试, 发现 end 也有防范操作</p>
<p>但我不知道具体是哪里防范了我这个操作, 应该是在解引用时, 但是里面代码不会更改到. </p>
<p>我还看了 objdump 的汇编代码, 依旧没有发现什么特别之处, 和编译器生成的汇编代码是一样的… </p>
<p>算了, 也算有所收获吧… </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/09/read/InnoDBRowFormat/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cas">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cas's website">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/09/read/InnoDBRowFormat/" class="post-title-link" itemprop="url">read/InnoDBRowFormat</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-09 17:17:39" itemprop="dateCreated datePublished" datetime="2020-01-09T17:17:39+08:00">2020-01-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-08-01 21:04:49" itemprop="dateModified" datetime="2019-08-01T21:04:49+08:00">2019-08-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="15-10-InnoDB-Row-Formats"><a href="#15-10-InnoDB-Row-Formats" class="headerlink" title="15.10 InnoDB Row Formats"></a>15.10 InnoDB Row Formats</h2><p>The row format of a table determines how its rows are physically stored, which in turn can affect the performance of queries and DML operations. As more rows fit into a single disk page, queries and index lookups can work faster, less cache memory is required in the buffer pool, and less I/O is required to write out updated values.</p>
<p>表的行格式化确定了如何物理存储方式, 反过来也会影响查询的性能和 DML 的操作.</p>
<p>更多的行放在单个磁盘页上, 查询和索引检索的速度会更快, 缓存池需要的空间也更少, 写出更新数据的 I/O 操作也会减少</p>
<p>The data in each table is divided into pages. The pages that make up each table are arranged in a tree data structure called a B-tree index. Table data and secondary indexes both use this type of structure. The B-tree index that represents an entire table is known as the clustered index, which is organized according to the primary key columns. The nodes of a clustered index data structure contain the values of all columns in the row. The nodes of a secondary index structure contain the values of index columns and primary key columns.</p>
<p>表的数据被分散到多个页中, 组成表的页的范围被限制在 B-tree 索引的树结构中, 表的数据和次级索引都使用这种结构</p>
<p>表示整个表的 B-tree 索引被称作聚簇索引, 根据主键列构造. 聚簇索引的节点数据结构包含行中的所有列, 而次级索引机构包含索引列和主键列(PS. 类似二级指针)</p>
<p>Variable-length columns are an exception to the rule that column values are stored in B-tree index nodes. Variable-length columns that are too long to fit on a B-tree page are stored on separately allocated disk pages called overflow pages. Such columns are referred to as off-page columns. The values of off-page columns are stored in singly-linked lists of overflow pages, with each such column having its own list of one or more overflow pages. Depending on column length, all or a prefix of variable-length column values are stored in the B-tree to avoid wasting storage and having to read a separate page.</p>
<p>可变长度列是列值存储在 B-tree 索引节点规则的一种特殊情况, 可变长度列太长, 无法存储在单个 B-tree 也中, 可变长度列存储在单独分配的磁盘页中, 这些页叫做溢出页, 这些列也叫作页外列</p>
<p>页外列以单链表形式存储在溢出页中, 每个页都有一个或多个溢出页的列表</p>
<p>取决于列的长度, 整个/前缀部分 变长列可以存储在 B-tree 中, 避免存储消耗和读取额外的页</p>
<p>The <code>InnoDB</code> storage engine supports four row formats: <code>REDUNDANT</code>, <code>COMPACT</code>, <code>DYNAMIC</code>, and <code>COMPRESSED</code>.</p>
<p>InnoDB 存储引擎支持 4 种行格式化: REDUNDANT, COMPACT, DYNAMIC  和 COMPRESSED</p>
<p><strong>Table 15.16 InnoDB Row Format Overview</strong></p>
<table>
<thead>
<tr>
<th>Row Format</th>
<th>Compact Storage Characteristics</th>
<th>Enhanced Variable-Length Column Storage</th>
<th>Large Index Key Prefix Support</th>
<th>Compression Support</th>
<th>Supported Tablespace Types</th>
</tr>
</thead>
<tbody><tr>
<td><code>REDUNDANT</code></td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>system, file-per-table, general</td>
</tr>
<tr>
<td><code>COMPACT</code></td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>system, file-per-table, general</td>
</tr>
<tr>
<td><code>DYNAMIC</code></td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>system, file-per-table, general</td>
</tr>
<tr>
<td><code>COMPRESSED</code></td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>file-per-table, general</td>
</tr>
</tbody></table>
<p>The topics that follow describe row format storage characteristics and how to define and determine the row format of a table.</p>
<ul>
<li><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-row-format.html#innodb-row-format-redundant" target="_blank" rel="noopener">REDUNDANT Row Format</a></li>
<li><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-row-format.html#innodb-row-format-compact" target="_blank" rel="noopener">COMPACT Row Format</a></li>
<li><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-row-format.html#innodb-row-format-dynamic" target="_blank" rel="noopener">DYNAMIC Row Format</a></li>
<li><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-row-format.html#innodb-row-format-compressed" target="_blank" rel="noopener">COMPRESSED Row Format</a></li>
<li><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-row-format.html#innodb-row-format-defining" target="_blank" rel="noopener">Defining the Row Format of a Table</a></li>
<li><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-row-format.html#innodb-row-format-detrmining" target="_blank" rel="noopener">Determining the Row Format of a Table</a></li>
</ul>
<h3 id="REDUNDANT-Row-Format"><a href="#REDUNDANT-Row-Format" class="headerlink" title="REDUNDANT Row Format"></a>REDUNDANT Row Format</h3><p>Tables that use the <code>REDUNDANT</code> row format store the first 768 bytes of variable-length column values (<a href="https://dev.mysql.com/doc/refman/8.0/en/char.html" target="_blank" rel="noopener"><code>VARCHAR</code></a>, <a href="https://dev.mysql.com/doc/refman/8.0/en/binary-varbinary.html" target="_blank" rel="noopener"><code>VARBINARY</code></a>, and <a href="https://dev.mysql.com/doc/refman/8.0/en/blob.html" target="_blank" rel="noopener"><code>BLOB</code></a> and <a href="https://dev.mysql.com/doc/refman/8.0/en/blob.html" target="_blank" rel="noopener"><code>TEXT</code></a> types) in the index record within the B-tree node, with the remainder stored on overflow pages. Fixed-length columns greater than or equal to 768 bytes are encoded as variable-length columns, which can be stored off-page. For example, a <code>CHAR(255)</code> column can exceed 768 bytes if the maximum byte length of the character set is greater than 3, as it is with <code>utf8mb4</code>.</p>
<p>使用 REDUNDANT 行格式化在 B-tree 节点记录中只存储变长列值的前 768 字节(VARCHAR, VARBINARY, BLOB, TEXT 类型), 剩下的存储在溢出页中, 固定长度但 &gt;= 768 字节的列被按照变长列编码, 存储到溢出页中</p>
<p>If the value of a column is 768 bytes or less, an overflow page is not used, and some savings in I/O may result, since the value is stored entirely in the B-tree node. This works well for relatively short <code>BLOB</code> column values, but may cause B-tree nodes to fill with data rather than key values, reducing their efficiency. Tables with many <code>BLOB</code>columns could cause B-tree nodes to become too full, and contain too few rows, making the entire index less efficient than if rows were shorter or column values were stored off-page.</p>
<p>如果列的值小于 768 字节, 溢出页不会被用到, 会节省一些 I/O 操作, 因为值完整存储在 B-tree 索引中(PS. 现在我中文的语序都有点乱了, 因为被英文语法的顺序影响了 = =)</p>
<p>这在相对小的 BLOB 列上表现得很好, 但是可能会导致 B-tree 节点被数据填满, 而不是键值, 效率被减少了.</p>
<p>具有太多 BLOB 列的表可能会导致 B-tree 过于充实, 包含的行过于少. 使整个索引的效率低于较短的列或者列存储在溢出页</p>
<h4 id="REDUNDANT-Row-Format-Storage-Characteristics"><a href="#REDUNDANT-Row-Format-Storage-Characteristics" class="headerlink" title="REDUNDANT Row Format Storage Characteristics"></a>REDUNDANT Row Format Storage Characteristics</h4><p>The <code>REDUNDANT</code> row format has the following storage characteristics:</p>
<ul>
<li><p>Each index record contains a 6-byte header. The header is used to link together consecutive records, and for row-level locking.</p>
<p>每个索引记录包含 6 字节的头部, 用于链接连续的记录和行级锁</p>
</li>
<li><p>Records in the clustered index contain fields for all user-defined columns. In addition, there is a 6-byte transaction ID field and a 7-byte roll pointer field.</p>
<p>在聚簇索引记录中包含了所有用户定义的列, 除此之外, 还有 6 字节的事务ID和 7 字节的回滚指针</p>
</li>
<li><p>If no primary key is defined for a table, each clustered index record also contains a 6-byte row ID field.</p>
<p>如果没有为表定义一个主键, 每个聚簇索引记录还包含 6 字节的行 ID 字段</p>
</li>
<li><p>Each secondary index record contains all the primary key columns defined for the clustered index key that are not in the secondary index.</p>
<p>每个次级记录包含为聚簇索引定义的不在次级索引中的所有主键列</p>
</li>
<li><p>A record contains a pointer to each field of the record. If the total length of the fields in a record is less than 128 bytes, the pointer is one byte; otherwise, two bytes. The array of pointers is called the record directory. The area where the pointers point is the data part of the record.</p>
<p>记录包含指向记录每个字段的指针, 如果记录中所有字段长度总和小于 128 字节, 指针大小为 1 字节, 否则为 2 字节 (PS. 这里的 pointer 可能不是指针的意思, 而是类似指示的含义, 它可能是偏移 offset)</p>
<p>指针数组被称为记录目录, 指针指向记录的数据部分</p>
</li>
<li><p>Internally, fixed-length character columns such as <a href="https://dev.mysql.com/doc/refman/8.0/en/char.html" target="_blank" rel="noopener"><code>CHAR(10)</code></a> in stored in fixed-length format. Trailing spaces are not truncated from <a href="https://dev.mysql.com/doc/refman/8.0/en/char.html" target="_blank" rel="noopener"><code>VARCHAR</code></a> columns.</p>
<p>固定长度的列, 例如 CHAR(10) 以固定长度格式化, VARCHAR 结尾空白不会被截断</p>
</li>
<li><p>Fixed-length columns greater than or equal to 768 bytes are encoded as variable-length columns, which can be stored off-page. For example, a <code>CHAR(255)</code> column can exceed 768 bytes if the maximum byte length of the character set is greater than 3, as it is with <code>utf8mb4</code>.</p>
<p>长度 &gt;= 768 字节的列即使是固定的, 也会被当做变长宽度列编码, 存储到溢出页</p>
<p>比如, 一个 CHAR(255) 的列如果字符集的长度超过3, 那么就超过了768 字节, 正如 utf8mb4</p>
</li>
<li><p>An SQL <code>NULL</code> value reserves one or two bytes in the record directory. An SQL <code>NULL</code> value reserves zero bytes in the data part of the record if stored in a variable-length column. For a fixed-length column, the fixed length of the column is reserved in the data part of the record. Reserving fixed space for <code>NULL</code> values permits columns to be updated in place from <code>NULL</code> to non-<code>NULL</code> values without causing index page fragmentation.</p>
<p>SQL NULL 值在记录目录中占有 1 或 2 个字节, 如果存储在变长列中, 在记录的数据部分不占空间. </p>
<p>对于一个固定长度的列, 存储在记录的数据部分, 为 NULL 值保留固定的长度使列的更新可以就地发生, 而不会导致索引页碎片</p>
</li>
</ul>
<h3 id="COMPACT-Row-Format"><a href="#COMPACT-Row-Format" class="headerlink" title="COMPACT Row Format"></a>COMPACT Row Format</h3><p>Tables that use the <code>COMPACT</code> row format store the first 768 bytes of variable-length column values (<a href="https://dev.mysql.com/doc/refman/8.0/en/char.html" target="_blank" rel="noopener"><code>VARCHAR</code></a>, <a href="https://dev.mysql.com/doc/refman/8.0/en/binary-varbinary.html" target="_blank" rel="noopener"><code>VARBINARY</code></a>, and <a href="https://dev.mysql.com/doc/refman/8.0/en/blob.html" target="_blank" rel="noopener"><code>BLOB</code></a> and <a href="https://dev.mysql.com/doc/refman/8.0/en/blob.html" target="_blank" rel="noopener"><code>TEXT</code></a> types) in the index record within the <a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_b_tree" target="_blank" rel="noopener">B-tree</a> node, with the remainder stored on overflow pages. Fixed-length columns greater than or equal to 768 bytes are encoded as variable-length columns, which can be stored off-page. For example, a <code>CHAR(255)</code> column can exceed 768 bytes if the maximum byte length of the character set is greater than 3, as it is with <code>utf8mb4</code>.</p>
<p>(PS. 和 REDUNDANT 一样的 = =)</p>
<p>If the value of a column is 768 bytes or less, an overflow page is not used, and some savings in I/O may result, since the value is stored entirely in the B-tree node. This works well for relatively short <code>BLOB</code> column values, but may cause B-tree nodes to fill with data rather than key values, reducing their efficiency. Tables with many <code>BLOB</code>columns could cause B-tree nodes to become too full, and contain too few rows, making the entire index less efficient than if rows were shorter or column values were stored off-page.</p>
<p>(PS. 怎么还是一样的 = = )</p>
<h4 id="COMPACT-Row-Format-Storage-Characteristics"><a href="#COMPACT-Row-Format-Storage-Characteristics" class="headerlink" title="COMPACT Row Format Storage Characteristics"></a>COMPACT Row Format Storage Characteristics</h4><p>The <code>COMPACT</code> row format has the following storage characteristics:</p>
<ul>
<li><p>Each index record contains a 5-byte header that may be preceded by a variable-length header. The header is used to link together consecutive records, and for row-level locking.</p>
<p>每个索引记录包含 5 字节的头部, 前面可能是变长头部. 头部用于链接记录和行锁</p>
</li>
<li><p>The variable-length part of the record header contains a bit vector for indicating <code>NULL</code> columns. If the number of columns in the index that can be <code>NULL</code> is <em>N</em>, the bit vector occupies <code>CEILING(*N*/8)</code> bytes. (For example, if there are anywhere from 9 to 16 columns that can be <code>NULL</code>, the bit vector uses two bytes.) Columns that are <code>NULL</code>do not occupy space other than the bit in this vector. The variable-length part of the header also contains the lengths of variable-length columns. Each length takes one or two bytes, depending on the maximum length of the column. If all columns in the index are <code>NOT NULL</code> and have a fixed length, the record header has no variable-length part.</p>
<p>变长列记录头部包含空列的位向量 NULL 列, 如果索引中可以是 NULL 的列的数量为 N, 向量占用 CEILING(N/8)字节(例如, 如果有 9 到 16 列可以为空, 向量使用 2 字节) NULL 列不占用空间, 只占用向量中的位</p>
<p>头部的变长部分也包含变长列的长度, 占用 1 到 2 个字节, 取决于列的最大长度, 如果索引中的所有列非空, 并且有一个固定的长度, 那么记录头部不会有变长长度部分</p>
</li>
<li><p>For each non-<code>NULL</code> variable-length field, the record header contains the length of the column in one or two bytes. Two bytes are only needed if part of the column is stored externally in overflow pages or the maximum length exceeds 255 bytes and the actual length exceeds 127 bytes. For an externally stored column, the 2-byte length indicates the length of the internally stored part plus the 20-byte pointer to the externally stored part. The internal part is 768 bytes, so the length is 768+20. The 20-byte pointer stores the true length of the column.</p>
<p>对于每个非空变长字段, 记录头部包含列的长度, 1 ~ 2 字节. 2 字节仅在列的部分存储在溢出页, 或最大长度超过 255 字节, 并且真实长度超过 127 字节</p>
<p>对于一个外部存储的列, 这 2 字节长度代表内部存储部分 + 20 字节的指向外部存储部分的指针 </p>
<p>内部部分是 768 字节, 长度是 768 + 20, 这 20 字节指针存储列的真实长度 (PS. 这里有点不对)</p>
</li>
<li><p>The record header is followed by the data contents of non-<code>NULL</code> columns.</p>
<p>记录头后跟着非空列的数据内容</p>
</li>
<li><p>Records in the clustered index contain fields for all user-defined columns. In addition, there is a 6-byte transaction ID field and a 7-byte roll pointer field.</p>
<p>聚簇索引记录包含所有用户定义列, 同时有 6 字节的事务 ID 和 7 字节的回滚 ID</p>
</li>
<li><p>If no primary key is defined for a table, each clustered index record also contains a 6-byte row ID field.</p>
<p>如果没有为表定义主键, 每个聚簇索引还包含 6 字节的行 ID</p>
</li>
<li><p>Each secondary index record contains all the primary key columns defined for the clustered index key that are not in the secondary index. If any of the primary key columns are variable length, the record header for each secondary index has a variable-length part to record their lengths, even if the secondary index is defined on fixed-length columns.</p>
<p>每个次级索引记录包含所有为聚簇索引定义的不在次级索引中的主键, 如果有主键列是变长的, 每个次级索引的头部有一个变长部分记录次级索引的长度, 即使次级索引是固定的列</p>
</li>
<li><p>Internally, for nonvariable-length character sets, fixed-length character columns such as <a href="https://dev.mysql.com/doc/refman/8.0/en/char.html" target="_blank" rel="noopener"><code>CHAR(10)</code></a> are stored in a fixed-length format.</p>
<p>Trailing spaces are not truncated from <a href="https://dev.mysql.com/doc/refman/8.0/en/char.html" target="_blank" rel="noopener"><code>VARCHAR</code></a> columns.</p>
<p>对非变长字符集, 像 CHAR(10) 这样的固定字符集列以固定长度格式化</p>
<p>VARCHAR 列尾部空白不会被截断</p>
</li>
<li><p>Internally, for variable-length character sets such as <code>utf8mb3</code> and <code>utf8mb4</code>, <code>InnoDB</code> attempts to store <a href="https://dev.mysql.com/doc/refman/8.0/en/char.html" target="_blank" rel="noopener"><code>CHAR(*N*)</code></a> in <em>N</em> bytes by trimming trailing spaces. If the byte length of a <a href="https://dev.mysql.com/doc/refman/8.0/en/char.html" target="_blank" rel="noopener"><code>CHAR(*N*)</code></a> column value exceeds <em>N</em> bytes, trailing spaces are trimmed to a minimum of the column value byte length. The maximum length of a <a href="https://dev.mysql.com/doc/refman/8.0/en/char.html" target="_blank" rel="noopener"><code>CHAR(*N*)</code></a> column is the maximum character byte length × <em>N</em>.</p>
<p>内部, 如 utf8mb3 和 utf8mb4 变长字符集, InnoDB 通过裁剪尾随的空格将 CHAR(N) 存储 N 字节</p>
<p>如果 CHAR(N) 列长度超过 N 字节, 尾端空白被裁剪到列值字节数的最小值, CHAR(N) 列的最大长度是最大字符字节宽度 x N</p>
<p>A minimum of <em>N</em> bytes is reserved for <a href="https://dev.mysql.com/doc/refman/8.0/en/char.html" target="_blank" rel="noopener"><code>CHAR(*N*)</code></a>. Reserving the minimum space <em>N</em> in many cases enables column updates to be done in place without causing index page fragmentation. By comparison, <a href="https://dev.mysql.com/doc/refman/8.0/en/char.html" target="_blank" rel="noopener"><code>CHAR(*N*)</code></a> columns occupy the maximum character byte length × <em>N</em> when using the <code>REDUNDANT</code> row format.</p>
<p>为 CHAR(N) 存储一个最小 N 字节空间, 存储这个最小的 N 空间在很多情况下是列值的更新就地发生, 不导致页碎片. 对比而言, 当使用 REDUNDANT 行格式化时, CHAR(N) 列占有最大字符长度  x N </p>
<p>Fixed-length columns greater than or equal to 768 bytes are encoded as variable-length fields, which can be stored off-page. For example, a <code>CHAR(255)</code> column can exceed 768 bytes if the maximum byte length of the character set is greater than 3, as it is with <code>utf8mb4</code>.</p>
<p>固定长度大于或等于 768 字节的列以变长字段编码, 存储在页外, … (PS. emm… 好像是一样的了)</p>
</li>
</ul>
<p>(PS. REDUNDANT 和 COMPACT 的区别主要有两个 : 1. COMPACT 不保存固定字段的长度 2. COMPACT 会裁剪尾随的空白字符. 所以 REDUNDANT 叫 REDUNDANT, COMPACT 叫 COMPACT, REDUNDANT 牺牲了空间换取效率)</p>
<h3 id="DYNAMIC-Row-Format"><a href="#DYNAMIC-Row-Format" class="headerlink" title="DYNAMIC Row Format"></a>DYNAMIC Row Format</h3><p>When a table is created with <code>ROW_FORMAT=DYNAMIC</code>, <code>InnoDB</code> can store long variable-length column values (for <a href="https://dev.mysql.com/doc/refman/8.0/en/char.html" target="_blank" rel="noopener"><code>VARCHAR</code></a>, <a href="https://dev.mysql.com/doc/refman/8.0/en/binary-varbinary.html" target="_blank" rel="noopener"><code>VARBINARY</code></a>, and <a href="https://dev.mysql.com/doc/refman/8.0/en/blob.html" target="_blank" rel="noopener"><code>BLOB</code></a> and <a href="https://dev.mysql.com/doc/refman/8.0/en/blob.html" target="_blank" rel="noopener"><code>TEXT</code></a> types) fully off-page, with the clustered index record containing only a 20-byte pointer to the overflow page. Fixed-length fields greater than or equal to 768 bytes are encoded as variable-length fields. For example, a <code>CHAR(255)</code> column can exceed 768 bytes if the maximum byte length of the character set is greater than 3, as it is with <code>utf8mb4</code>.</p>
<p>当表被创建为 DYNAMIC 类型时, InnoDB 能将长的变长列完全存储在页外, 聚簇索引只包含 20 字节的指向溢出页的指针. 固定长度 &gt;= 768 的字段按照变长字段存储, 比如 … (PS. 一样的, 就不比如了… = =)</p>
<p>Whether columns are stored off-page depends on the page size and the total size of the row. When a row is too long, the longest columns are chosen for off-page storage until the clustered index record fits on the <a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_b_tree" target="_blank" rel="noopener">B-tree</a> page. <a href="https://dev.mysql.com/doc/refman/8.0/en/blob.html" target="_blank" rel="noopener"><code>TEXT</code></a> and <a href="https://dev.mysql.com/doc/refman/8.0/en/blob.html" target="_blank" rel="noopener"><code>BLOB</code></a> columns that are less than or equal to 40 bytes are stored in line.</p>
<p>列是否存储在页外取决于页的大小和行的总大小. </p>
<p>当行太长时, 最长的列被选为页外存储, 直到聚簇索引记录大小适合保存在 B-tree 页, TEXT 和 BLOB 列 &lt;= 40 字节按行存储</p>
<p>The <code>DYNAMIC</code> row format maintains the efficiency of storing the entire row in the index node if it fits (as do the <code>COMPACT</code> and <code>REDUNDANT</code> formats), but the <code>DYNAMIC</code> row format avoids the problem of filling B-tree nodes with a large number of data bytes of long columns. The <code>DYNAMIC</code> row format is based on the idea that if a portion of a long data value is stored off-page, it is usually most efficient to store the entire value off-page. With <code>DYNAMIC</code> format, shorter columns are likely to remain in the B-tree node, minimizing the number of overflow pages required for a given row.</p>
<p>DYNAMIC 行存储维护在索引节点中存储整行(如果大小匹配的话)的效率(就像 COMPACT 和 REDUNDANT 一样), 但是 DYNAMIC 避免了 B-tree 被大量长列填满的问题</p>
<p>DYNAMIC 行存储基于一部分数据存储在页外的想法, 通常最有效的方法是整个值都存储在页外</p>
<p>使用 DYNAMIC 存储, 较短的行更可能保存在 B-tree 节点, 最小化行所需要的溢出页数量</p>
<p>The <code>DYNAMIC</code> row format supports index key prefixes up to 3072 bytes. </p>
<p>DYNAMIC 行存储支持索引键前缀, 最大可达 3072 字节 (PS. = = 这么大的么…) (需要设置 innodb_large_prefix=1)</p>
<p>Tables that use the <code>DYNAMIC</code> row format can be stored in the system tablespace, file-per-table tablespaces, and general tablespaces. To store <code>DYNAMIC</code> tables in the system tablespace, either disable <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_file_per_table" target="_blank" rel="noopener"><code>innodb_file_per_table</code></a> and use a regular <code>CREATE TABLE</code> or <code>ALTER TABLE</code> statement, or use the <code>TABLESPACE [=] innodb_system</code> table option with <code>CREATE TABLE</code> or <code>ALTER TABLE</code>. The <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_file_per_table" target="_blank" rel="noopener"><code>innodb_file_per_table</code></a> variable is not applicable to general tablespaces, nor is it applicable when using the <code>TABLESPACE [=] innodb_system</code> table option to store <code>DYNAMIC</code> tables in the system tablespace.</p>
<p>使用 DYNAMIC 存储的行能保存在 system tablespace, file-per-table tablespace, 以及 general tablespace 中. </p>
<p>将 DYNAMIC 表存储在 system tablespace 要么取消 innodb_file_per_table 以及使用常规的 CREATE TABLE 或 ALTER TABLE 语句, 或者在 CREATE TABLE 或 ALTER TABLE 时使用 TABLESPACE [=] innodb_system 表选项.</p>
<p>innodb_file_per_table 变量不适用于 general tablespace, 也不适用于使用 TABLESPACE [=] innodb_system 表选项去在 system tablespace 中存储 DYNAMIC 表</p>
<h4 id="DYNAMIC-Row-Format-Storage-Characteristics"><a href="#DYNAMIC-Row-Format-Storage-Characteristics" class="headerlink" title="DYNAMIC Row Format Storage Characteristics"></a>DYNAMIC Row Format Storage Characteristics</h4><p>The <code>DYNAMIC</code> row format is a variation of the <code>COMPACT</code> row format. For storage characteristics, see <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-row-format.html#innodb-compact-row-format-characteristics" target="_blank" rel="noopener">COMPACT Row Format Storage Characteristics</a>.</p>
<p>DYNAMIC 行存储是 COMPACT 行存储的一种变化</p>
<h3 id="COMPRESSED-Row-Format"><a href="#COMPRESSED-Row-Format" class="headerlink" title="COMPRESSED Row Format"></a>COMPRESSED Row Format</h3><p>The <code>COMPRESSED</code> row format uses similar internal details for off-page storage as the <code>DYNAMIC</code> row format, with additional storage and performance considerations from the table and index data being compressed and using smaller page sizes. With the <code>COMPRESSED</code> row format, the <code>KEY_BLOCK_SIZE</code> option controls how much column data is stored in the clustered index, and how much is placed on overflow pages. For more information about the <code>COMPRESSED</code> row format, see <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-compression.html" target="_blank" rel="noopener">Section 15.9, “InnoDB Table and Page Compression”</a>.</p>
<p>COMPRESSED 行存储使用和 DYNAMIC 类似的内部细节 : 页外存储, 压缩表和索引数据以使用更少的页, 考虑额外的存储和性能. </p>
<p>使用 COMPRESSED 行存储, KEY_BLOCK_SIZE 选项控制多少列数据存储在聚簇索引, 多少存储在溢出页. </p>
<p>The <code>COMPRESSED</code> row format supports index key prefixes up to 3072 bytes.</p>
<p>COMPRESSED 行存储支持索引键前缀, 最大可达 3072 字节</p>
<p>Tables that use the <code>COMPRESSED</code> row format can be created in file-per-table tablespaces or general tablespaces. The system tablespace does not support the <code>COMPRESSED</code>row format. To store a <code>COMPRESSED</code> table in a file-per-table tablespace, the <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_file_per_table" target="_blank" rel="noopener"><code>innodb_file_per_table</code></a> variable must be enabled. The <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_file_per_table" target="_blank" rel="noopener"><code>innodb_file_per_table</code></a> variable is not applicable to general tablespaces. General tablespaces support all row formats with the caveat that compressed and uncompressed tables cannot coexist in the same general tablespace due to different physical page sizes. For more information, see <a href="https://dev.mysql.com/doc/refman/8.0/en/general-tablespaces.html" target="_blank" rel="noopener">Section 15.6.3.3, “General Tablespaces”</a>.</p>
<h4 id="Compressed-Row-Format-Storage-Characteristics"><a href="#Compressed-Row-Format-Storage-Characteristics" class="headerlink" title="Compressed Row Format Storage Characteristics"></a>Compressed Row Format Storage Characteristics</h4><p>The <code>COMPRESSED</code> row format is a variation of the <code>COMPACT</code> row format. For storage characteristics, see <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-row-format.html#innodb-compact-row-format-characteristics" target="_blank" rel="noopener">COMPACT Row Format Storage Characteristics</a>.</p>
<h3 id="Defining-the-Row-Format-of-a-Table"><a href="#Defining-the-Row-Format-of-a-Table" class="headerlink" title="Defining the Row Format of a Table"></a>Defining the Row Format of a Table</h3><p>The default row format for <code>InnoDB</code> tables is defined by <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_default_row_format" target="_blank" rel="noopener"><code>innodb_default_row_format</code></a> variable, which has a default value of <code>DYNAMIC</code>. The default row format is used when the <code>ROW_FORMAT</code> table option is not defined explicitly or when <code>ROW_FORMAT=DEFAULT</code> is specified.</p>
<p>innodb_default_row_format 控制默认创建的表行存储类型 (dynamic) , 当表选项 ROW_FORMAT 没有显式指明时才会使用默认配置</p>
<p>The row format of a table can be defined explicitly using the <code>ROW_FORMAT</code> table option in a <a href="https://dev.mysql.com/doc/refman/8.0/en/create-table.html" target="_blank" rel="noopener"><code>CREATE TABLE</code></a> or <a href="https://dev.mysql.com/doc/refman/8.0/en/alter-table.html" target="_blank" rel="noopener"><code>ALTER TABLE</code></a> statement. For example:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1 (c1 <span class="built_in">INT</span>) ROW_FORMAT=DYNAMIC;</span><br></pre></td></tr></table></figure>

<p>An explicitly defined <code>ROW_FORMAT</code> setting overrides the default row format. Specifying <code>ROW_FORMAT=DEFAULT</code> is equivalent to using the implicit default.</p>
<p>The <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_default_row_format" target="_blank" rel="noopener"><code>innodb_default_row_format</code></a> variable can be set dynamically:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SET GLOBAL innodb_default_row_format=DYNAMIC;</span><br></pre></td></tr></table></figure>

<p>Valid <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_default_row_format" target="_blank" rel="noopener"><code>innodb_default_row_format</code></a> options include <code>DYNAMIC</code>, <code>COMPACT</code>, and <code>REDUNDANT</code>. The <code>COMPRESSED</code> row format, which is not supported for use in the system tablespace, cannot be defined as the default. It can only be specified explicitly in a <a href="https://dev.mysql.com/doc/refman/8.0/en/create-table.html" target="_blank" rel="noopener"><code>CREATE TABLE</code></a> or <a href="https://dev.mysql.com/doc/refman/8.0/en/alter-table.html" target="_blank" rel="noopener"><code>ALTER TABLE</code></a> statement. Attempting to set the<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_default_row_format" target="_blank" rel="noopener"><code>innodb_default_row_format</code></a> variable to <code>COMPRESSED</code> returns an error:</p>
<p>COMPRESSED 不能用于默认设置, 只能显式指定</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SET GLOBAL innodb_default_row_format=COMPRESSED;</span><br><span class="line">ERROR 1231 (42000): Variable 'innodb_default_row_format'</span><br><span class="line">can't be <span class="keyword">set</span> <span class="keyword">to</span> the <span class="keyword">value</span> <span class="keyword">of</span> <span class="string">'COMPRESSED'</span></span><br></pre></td></tr></table></figure>

<p>Newly created tables use the row format defined by the <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_default_row_format" target="_blank" rel="noopener"><code>innodb_default_row_format</code></a> variable when a <code>ROW_FORMAT</code> option is not specified explicitly, or when<code>ROW_FORMAT=DEFAULT</code> is used. For example, the following <a href="https://dev.mysql.com/doc/refman/8.0/en/create-table.html" target="_blank" rel="noopener"><code>CREATE TABLE</code></a> statements use the row format defined by the <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_default_row_format" target="_blank" rel="noopener"><code>innodb_default_row_format</code></a> variable.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1 (c1 <span class="built_in">INT</span>);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t2 (c1 <span class="built_in">INT</span>) ROW_FORMAT=<span class="keyword">DEFAULT</span>;</span><br></pre></td></tr></table></figure>

<p>When a <code>ROW_FORMAT</code> option is not specified explicitly, or when <code>ROW_FORMAT=DEFAULT</code> is used, an operation that rebuilds a table silently changes the row format of the table to the format defined by the <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_default_row_format" target="_blank" rel="noopener"><code>innodb_default_row_format</code></a> variable.</p>
<p>Table-rebuilding operations include <a href="https://dev.mysql.com/doc/refman/8.0/en/alter-table.html" target="_blank" rel="noopener"><code>ALTER TABLE</code></a> operations that use <code>ALGORITHM=COPY</code> or <code>ALGORITHM=INPLACE</code> where table rebuilding is required. See <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-online-ddl-operations.html" target="_blank" rel="noopener">Section 15.12.1, “Online DDL Operations”</a> for more information. <a href="https://dev.mysql.com/doc/refman/8.0/en/optimize-table.html" target="_blank" rel="noopener"><code>OPTIMIZE TABLE</code></a> is also a table-rebuilding operation.</p>
<p>The following example demonstrates a table-rebuilding operation that silently changes the row format of a table created without an explicitly defined row format.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT @@innodb_default_row_format;</span><br><span class="line">+<span class="comment">-----------------------------+</span></span><br><span class="line">| @@innodb_default_row_format |</span><br><span class="line">+<span class="comment">-----------------------------+</span></span><br><span class="line">| dynamic                     |</span><br><span class="line">+<span class="comment">-----------------------------+</span></span><br><span class="line"></span><br><span class="line">mysql&gt; CREATE TABLE t1 (c1 INT);</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM INFORMATION_SCHEMA.INNODB_TABLES WHERE NAME LIKE 'test/t1' \G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">     TABLE_ID: 54</span><br><span class="line">         NAME: test/t1</span><br><span class="line">         FLAG: 33</span><br><span class="line">       N_COLS: 4</span><br><span class="line">        SPACE: 35</span><br><span class="line">   ROW_FORMAT: Dynamic</span><br><span class="line">ZIP_PAGE_SIZE: 0</span><br><span class="line">   SPACE_TYPE: Single</span><br><span class="line"></span><br><span class="line">mysql&gt; SET GLOBAL innodb_default_row_format=COMPACT;</span><br><span class="line"></span><br><span class="line">mysql&gt; ALTER TABLE t1 ADD COLUMN (c2 INT);</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM INFORMATION_SCHEMA.INNODB_TABLES WHERE NAME LIKE 'test/t1' \G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">     TABLE_ID: 55</span><br><span class="line">         NAME: test/t1</span><br><span class="line">         FLAG: 1</span><br><span class="line">       N_COLS: 5</span><br><span class="line">        SPACE: 36</span><br><span class="line">   ROW_FORMAT: Compact</span><br><span class="line">ZIP_PAGE_SIZE: 0</span><br><span class="line">   SPACE_TYPE: Single</span><br></pre></td></tr></table></figure>

<p>(PS. 这种情况要格外注意, 更改表操作相当于重新创建, 之前设置的一些默认选项可能已经被改变了)</p>
<p>Consider the following potential issues before changing the row format of existing tables from <code>REDUNDANT</code> or <code>COMPACT</code> to <code>DYNAMIC</code>.</p>
<ul>
<li><p>The <code>REDUNDANT</code> and <code>COMPACT</code> row formats support a maximum index key prefix length of 767 bytes whereas <code>DYNAMIC</code> and <code>COMPRESSED</code> row formats support an index key prefix length of 3072 bytes. In a replication environment, if the <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_default_row_format" target="_blank" rel="noopener"><code>innodb_default_row_format</code></a> variable is set to <code>DYNAMIC</code> on the master, and set to <code>COMPACT</code> on the slave, the following DDL statement, which does not explicitly define a row format, succeeds on the master but fails on the slave:</p>
<p>REDUNDANT 和 COMPACT 行存储支持最大 767 字节的索引键前缀, 然而 DYNAMIC 和 COMPRESSED 行存储支持的长度可达 3072 字节.</p>
<p>在同样的环境下, 如果 innodb_default_row_format 在主环境下设置为 DYNAMIC, 而在次环境下设置为 COMPACT, 下列没有显式定义行存储的语句会在主环境下成功, 而次环境会失败</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1 (c1 <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span>, c2 <span class="built_in">VARCHAR</span>(<span class="number">5000</span>), <span class="keyword">KEY</span> i1(c2(<span class="number">3070</span>)));</span><br></pre></td></tr></table></figure>

<p>For related information, see <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-restrictions.html" target="_blank" rel="noopener">Section 15.6.1.6, “Limits on InnoDB Tables”</a>.</p>
<p>(PS. 原因是 REDUNDANT 和 COMPACT 行存储限制了索引前缀必须低于 768 字节</p>
<p>这里还要加限制, 就是 c2(3070) 真正内存 &lt; 3072 )</p>
</li>
<li><p>Importing a table that does not explicitly define a row format results in a schema mismatch error if the <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_default_row_format" target="_blank" rel="noopener"><code>innodb_default_row_format</code></a> setting on the source server differs from the setting on the destination server. For more information, refer to the limitations outlined in <a href="https://dev.mysql.com/doc/refman/8.0/en/tablespace-copying.html" target="_blank" rel="noopener">Section 15.6.3.7, “Copying Tablespaces to Another Instance”</a>.</p>
<p>导入一个为显式指定行存储的表时, 被导入表的行存储和默认存储设置不一致会产生错误</p>
</li>
</ul>
<h3 id="Determining-the-Row-Format-of-a-Table"><a href="#Determining-the-Row-Format-of-a-Table" class="headerlink" title="Determining the Row Format of a Table"></a>Determining the Row Format of a Table</h3><p>To determine the row format of a table, use <a href="https://dev.mysql.com/doc/refman/8.0/en/show-table-status.html" target="_blank" rel="noopener"><code>SHOW TABLE STATUS</code></a>:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW TABLE STATUS IN test1\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           Name: t1</span><br><span class="line">         Engine: InnoDB</span><br><span class="line">        Version: 10</span><br><span class="line">     Row_format: Dynamic</span><br><span class="line">           Rows: 0</span><br><span class="line"> Avg_row_length: 0</span><br><span class="line">    Data_length: 16384</span><br><span class="line">Max_data_length: 0</span><br><span class="line">   Index_length: 16384</span><br><span class="line">      Data_free: 0</span><br><span class="line"> Auto_increment: 1</span><br><span class="line">    Create_time: 2016-09-14 16:29:38</span><br><span class="line">    Update_time: NULL</span><br><span class="line">     Check_time: NULL</span><br><span class="line">      Collation: utf8mb4_0900_ai_ci</span><br><span class="line">       <span class="keyword">Checksum</span>: <span class="literal">NULL</span></span><br><span class="line"> Create_options: </span><br><span class="line">        <span class="keyword">Comment</span>:</span><br></pre></td></tr></table></figure>

<p>Alternatively, query the <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-tables-table.html" target="_blank" rel="noopener"><code>INFORMATION_SCHEMA.INNODB_TABLES</code></a> table:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT NAME, ROW_FORMAT FROM INFORMATION_SCHEMA.INNODB_TABLES WHERE NAME='test1/t1';</span><br><span class="line">+<span class="comment">----------+------------+</span></span><br><span class="line">| NAME     | ROW_FORMAT |</span><br><span class="line">+<span class="comment">----------+------------+</span></span><br><span class="line">| test1/t1 | Dynamic    |</span><br><span class="line">+<span class="comment">----------+------------+</span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/09/read/InnoDBRedoLog/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cas">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cas's website">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/09/read/InnoDBRedoLog/" class="post-title-link" itemprop="url">read/InnoDBRedoLog</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-09 17:17:39" itemprop="dateCreated datePublished" datetime="2020-01-09T17:17:39+08:00">2020-01-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-08-07 15:22:46" itemprop="dateModified" datetime="2019-08-07T15:22:46+08:00">2019-08-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="15-6-5-Redo-Log"><a href="#15-6-5-Redo-Log" class="headerlink" title="15.6.5 Redo Log"></a>15.6.5 Redo Log</h3><p>By default, the redo log is physically represented on disk by two files named <code>ib_logfile0</code> and <code>ib_logfile1</code>. MySQL writes to the redo log files in a circular fashion. Data in the redo log is encoded in terms of records affected; this data is collectively referred to as redo. The passage of data through the redo log is represented by an ever-increasing <a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_lsn" target="_blank" rel="noopener">LSN</a> value.</p>
<p>默认 redo 日志通过两个叫 ib_logfile0 和 ib_logfile1 的文件物理地记录在磁盘上. MySQL 以循环方式写入到文件中. redo 日志中的数据受记录影响编码. 这些数据统称为 redo. 数据通过 redo 日志的传递由一个不断增长的 LSN 值表示</p>
<p>For related information, see <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-init-startup-configuration.html#innodb-startup-log-file-configuration" target="_blank" rel="noopener">Redo Log File Configuration</a>, and <a href="https://dev.mysql.com/doc/refman/8.0/en/optimizing-innodb-logging.html" target="_blank" rel="noopener">Section 8.5.4, “Optimizing InnoDB Redo Logging”</a>.</p>
<p>For information about data-at-rest encryption for redo logs, see <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-tablespace-encryption.html#innodb-tablespace-encryption-redo-log" target="_blank" rel="noopener">Redo Log Encryption</a>.</p>
<h4 id="Changing-the-Number-or-Size-of-Redo-Log-Files"><a href="#Changing-the-Number-or-Size-of-Redo-Log-Files" class="headerlink" title="Changing the Number or Size of Redo Log Files"></a>Changing the Number or Size of Redo Log Files</h4><ol>
<li>Stop the MySQL server and make sure that it shuts down without errors.</li>
<li>Edit <code>my.cnf</code> to change the log file configuration. To change the log file size, configure <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_log_file_size" target="_blank" rel="noopener"><code>innodb_log_file_size</code></a>. To increase the number of log files, configure<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_log_files_in_group" target="_blank" rel="noopener"><code>innodb_log_files_in_group</code></a>.</li>
<li>Start the MySQL server again.</li>
</ol>
<p>If <code>InnoDB</code> detects that the <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_log_file_size" target="_blank" rel="noopener"><code>innodb_log_file_size</code></a> differs from the redo log file size, it writes a log checkpoint, closes and removes the old log files, creates new log files at the requested size, and opens the new log files.</p>
<h4 id="Group-Commit-for-Redo-Log-Flushing"><a href="#Group-Commit-for-Redo-Log-Flushing" class="headerlink" title="Group Commit for Redo Log Flushing"></a>Group Commit for Redo Log Flushing</h4><p><code>InnoDB</code>, like any other <a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_acid" target="_blank" rel="noopener">ACID</a>-compliant database engine, flushes the <a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_redo_log" target="_blank" rel="noopener">redo log</a> of a transaction before it is committed. <code>InnoDB</code> uses <a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_group_commit" target="_blank" rel="noopener">group commit</a> functionality to group multiple such flush requests together to avoid one flush for each commit. With group commit, <code>InnoDB</code> issues a single write to the log file to perform the commit action for multiple user transactions that commit at about the same time, significantly improving throughput.</p>
<p>InnoDB 像其他 ACID 数据引擎一样, 在事务提交前冲刷 redo 日志, InnoDB 使用组提交功能, 将多个提交请求分组, 避免每次提交都冲刷记录. 在组提交中, InnoDB 为在大约同一时间提交的多次用户事务执行单次文件写入, 显著提高了吞吐量</p>
<p>For more information about performance of <code>COMMIT</code> and other transactional operations, see <a href="https://dev.mysql.com/doc/refman/8.0/en/optimizing-innodb-transaction-management.html" target="_blank" rel="noopener">Section 8.5.2, “Optimizing InnoDB Transaction Management”</a>.</p>
<h4 id="Redo-Log-Archiving"><a href="#Redo-Log-Archiving" class="headerlink" title="Redo Log Archiving"></a>Redo Log Archiving</h4><p>Backup utilities that copy redo log records may sometimes fail to keep pace with redo log generation while a backup operation is in progress, resulting in lost redo log records due to those records being overwritten. This issue most often occurs when there is significant MySQL server activity during the backup operation, and the redo log file storage media operates at a faster speed than the backup storage media. The redo log archiving feature, introduced in MySQL 8.0.17, addresses this issue by sequentially writing redo log records to an archive file in addition to the redo log files. Backup utilities can copy redo log records from the archive file as necessary, thereby avoiding the potential loss of data.</p>
<p>拷贝 redo 日志记录的备份工具可能有时会跟丢 redo 记录日志的生成速度, 当备份操作运行中, 因为这些记录被覆写而导致丢失 redo 日志记录</p>
<p>当备份操作产生大量的 MySQL 服务器活动时这个问题经常发生, 此时 redo 日志文件存储媒介操作处于比备份存储媒介操作更快的速率. 在 MySQL 8.0.17 引进的 redo 日志归档功能, 通过除写入 redo 日志外, 还序列写入 redo 日志记录到归档文件解决这个问题. 备份工具尽可能从归档文件中拷贝 redo 日志记录, 从而规避潜在的数据丢失问题</p>
<p>If redo log archiving is configured on the server, <a href="https://dev.mysql.com/doc/mysql-enterprise-backup/8.0/en/" target="_blank" rel="noopener">MySQL Enterprise Backup</a>, available with the <a href="https://www.mysql.com/products/enterprise/" target="_blank" rel="noopener">MySQL Enterprise Edition</a>, uses the redo log archiving feature when backing up a MySQL server. </p>
<p>Enabling redo log archiving on the server requires setting a value for the <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_redo_log_archive_dirs" target="_blank" rel="noopener"><code>innodb_redo_log_archive_dirs</code></a> system variable. The value is specified as a semicolon-separated list of labeled redo log archive directories. The <code>*label:directory*</code> pair is separated by a colon (<code>:</code>). For example:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SET GLOBAL innodb_redo_log_archive_dirs='label1:directory_path1[;label2:directory_path2;…]';</span><br></pre></td></tr></table></figure>

<p>The <em>label</em> is an arbitrary identifier for the archive directory. It can be any string of characters, with the exception of colons (:), which are not permitted. An empty label is also permitted, but the colon (:) is still required in this case. A <em>directory_path</em> must be specified. The directory that is selected for the redo log archive file must exist when redo log archiving is activated, or an error is returned. The path can contain colons (‘:’), but semicolons (;) are not permitted.</p>
<p>The <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_redo_log_archive_dirs" target="_blank" rel="noopener"><code>innodb_redo_log_archive_dirs</code></a> variable must be configured before the redo log archiving can be activated. The default value is <code>NULL</code>, which does not permit activating redo log archiving.</p>
<p>Notes</p>
<p>The archive directories that you specify must satisfy the following requirements. (The requirements are enforced when redo log archiving is activated.):</p>
<ul>
<li><p>Directories must exist. Directories are not created by the redo log archive process. Otherwise, the following error is returned:</p>
<p>ERROR 3844 (HY000): Redo log archive directory ‘<em>directory_path1</em>‘ does not exist or is not a directory</p>
</li>
<li><p>Directories must not be world-accessible. This is to prevent the redo log data from being exposed to unauthorized users on the system. Otherwise, the following error is returned:</p>
<p>ERROR 3846 (HY000): Redo log archive directory ‘<em>directory_path1</em>‘ is accessible to all OS users</p>
</li>
<li><p>Directories cannot be those defined by <a href="https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_datadir" target="_blank" rel="noopener"><code>datadir</code></a>, <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_data_home_dir" target="_blank" rel="noopener"><code>innodb_data_home_dir</code></a>, <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_directories" target="_blank" rel="noopener"><code>innodb_directories</code></a>, <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_log_group_home_dir" target="_blank" rel="noopener"><code>innodb_log_group_home_dir</code></a>,<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_temp_tablespaces_dir" target="_blank" rel="noopener"><code>innodb_temp_tablespaces_dir</code></a>, <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_tmpdir" target="_blank" rel="noopener"><code>innodb_tmpdir</code></a> <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_undo_directory" target="_blank" rel="noopener"><code>innodb_undo_directory</code></a>, or <a href="https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_secure_file_priv" target="_blank" rel="noopener"><code>secure_file_priv</code></a>, nor can they be parent directories or subdirectories of those directories. Otherwise, an error similar to the following is returned:</p>
<p>ERROR 3845 (HY000): Redo log archive directory ‘<em>directory_path1</em>‘ is in, under, or over server directory ‘datadir’ - ‘<em>/path/to/data_directory</em>‘</p>
</li>
</ul>
<p>When a backup utility that supports redo log archiving initiates a backup, the backup utility activates redo log archiving by invoking the <code>innodb_redo_log_archive_start()</code> user-defined function.</p>
<p>If you are not using a backup utility that supports redo log archiving, redo log archiving can also be activated manually, as shown:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT innodb_redo_log_archive_start('label', 'subdir');</span><br><span class="line">+<span class="comment">------------------------------------------+</span></span><br><span class="line">| innodb_redo_log_archive_start('label') |</span><br><span class="line">+<span class="comment">------------------------------------------+</span></span><br><span class="line">| 0                                        |</span><br><span class="line">+<span class="comment">------------------------------------------+</span></span><br></pre></td></tr></table></figure>

<p>Or:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; DO innodb_redo_log_archive_start('label', 'subdir');</span><br><span class="line">Query OK, 0 rows affected (0.09 sec)</span><br></pre></td></tr></table></figure>

<p>Note</p>
<p>The MySQL session that activates redo log archiving (using <code>innodb_redo_log_archive_start()</code>) must remain open for the duration of the archiving. The same session must deactivate redo log archiving (using <code>innodb_redo_log_archive_stop()</code>). If the session is terminated before the redo log archiving is explicitly deactivated, the server deactivates redo log archiving implicitly and removes the redo log archive file.</p>
<p>where <em>label</em> is a label defined by <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_redo_log_archive_dirs" target="_blank" rel="noopener"><code>innodb_redo_log_archive_dirs</code></a>; <code>subdir</code> is an optional argument for specifying a subdirectory of the directory identified by <em>label</em> for saving the archive file; it must be a simple directory name (no slash (/), backslash (), or colon (:) is permitted). <code>subdir</code> can be empty, null, or it can be left out.</p>
<p>Only users with the <a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_innodb-redo-log-archive" target="_blank" rel="noopener"><code>INNODB_REDO_LOG_ARCHIVE</code></a> privilege can activate redo log archiving by invoking <code>innodb_redo_log_archive_start()</code>, or deactivate it using<code>innodb_redo_log_archive_stop()</code>. The MySQL user running the backup utility or the MySQL user activating and deactivating redo log archiving manually must have this privilege.</p>
<p>The redo log archive file path is <code>*directory_identified_by_label*/[*subdir*/]archive.*serverUUID*.000001.log</code>, where <code>*directory_identified_by_label*</code> is the archive directory identified by the <code>*label*</code> argument for <code>innodb_redo_log_archive_start()</code>. <code>*subdir*</code> is the optional argument used for <code>innodb_redo_log_archive_start()</code>.</p>
<p>For example, the full path and name for a redo log archive file appears similar to the following:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;directory_path&#x2F;subdirectory&#x2F;archive.e71a47dc-61f8-11e9-a3cb-080027154b4d.000001.log</span><br></pre></td></tr></table></figure>

<p>After the backup utility finishes copying <code>InnoDB</code> data files, it deactivates redo log archiving by calling the <code>innodb_redo_log_archive_stop()</code> user-defined function.</p>
<p>If you are not using a backup utility that supports redo log archiving, redo log archiving can also be deactivated manually, as shown:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT innodb_redo_log_archive_stop();</span><br><span class="line">+<span class="comment">--------------------------------+</span></span><br><span class="line">| innodb_redo_log_archive_stop() |</span><br><span class="line">+<span class="comment">--------------------------------+</span></span><br><span class="line">| 0                              |</span><br><span class="line">+<span class="comment">--------------------------------+</span></span><br></pre></td></tr></table></figure>

<p>Or:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; DO innodb_redo_log_archive_stop();</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br></pre></td></tr></table></figure>

<p>After the stop function completes successfully, the backup utility looks for the relevant section of redo log data from the archive file and copies it into the backup.</p>
<p>After the backup utility finishes copying the redo log data and no longer needs the redo log archive file, it deletes the archive file.</p>
<p>Removal of the archive file is the responsibility of the backup utility in normal situations. However, if the redo log archiving operation quits unexpectedly before<code>innodb_redo_log_archive_stop()</code> is called, the MySQL server removes the file.</p>
<h5 id="Performance-Considerations"><a href="#Performance-Considerations" class="headerlink" title="Performance Considerations"></a>Performance Considerations</h5><p>Activating redo log archiving typically has a minor performance cost due to the additional write activity.</p>
<p>On Unix and Unix-like operating systems, the performance impact is typically minor, assuming there is not a sustained high rate of updates. On Windows, the performance impact is typically a bit higher, assuming the same.</p>
<p>If there is a sustained high rate of updates and the redo log archive file is on the same storage media as the redo log files, the performance impact may be more significant due to compounded write activity.</p>
<p>If there is a sustained high rate of updates and the redo log archive file is on slower storage media than the redo log files, performance is impacted arbitrarily.</p>
<p>Writing to the redo log archive file does not impede normal transactional logging except in the case that the redo log archive file storage media operates at a much slower rate than the redo log file storage media, and there is a large backlog of persisted redo log blocks waiting to be written to the redo log archive file. In this case, the transactional logging rate is reduced to a level that can be managed by the slower storage media where the redo log archive file resides.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/09/read/implementionThreadInUserAndKernelSpace/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cas">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cas's website">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/09/read/implementionThreadInUserAndKernelSpace/" class="post-title-link" itemprop="url">read/implementionThreadInUserAndKernelSpace</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-09 17:17:39" itemprop="dateCreated datePublished" datetime="2020-01-09T17:17:39+08:00">2020-01-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-12-27 19:00:03" itemprop="dateModified" datetime="2019-12-27T19:00:03+08:00">2019-12-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>之前就看过关于在内核以及用户空间实现线程的文章, 到现在还对于其中的一些点一知半解, 比如: 为什么实现在用户空间的线程比实现在内核空间的快?. 今天碰巧看到了这篇文章, 原文出自 &lt;modern operating system, fourth edition&gt;</p>
<h2 id="threads-implementation-in-kernel-and-user-space"><a href="#threads-implementation-in-kernel-and-user-space" class="headerlink" title="threads implementation in kernel and user space"></a>threads implementation in kernel and user space</h2><h3 id="2-2-4-Implementing-Threads-in-User-Space"><a href="#2-2-4-Implementing-Threads-in-User-Space" class="headerlink" title="2.2.4 Implementing Threads in User Space"></a>2.2.4 Implementing Threads in User Space</h3><p>There are two main places to implement threads: user space and the kernel.<br>The choice is a bit controversial, and a hybrid implementation is also possible. We<br>will now describe these methods, along with their advantages and disadvantages.</p>
<p>有两种主要的地方用于实现线程: 用户空间以及内核空间. 如何在哪里实现具有一定争议性, 同时, 一种混合的实现也是可能的. 我们将会概述这些方法, 以及他们的优点和缺点.</p>
<p>The first method is to put the threads package entirely in user space. The kernel knows nothing about them. As far as the kernel is concerned, it is managing<br>ordinary, single-threaded processes. The first, and most obvious, advantage is that<br>a user-level threads package can be implemented on an operating system that does<br>not support threads. All operating systems used to fall into this category, and even<br>now some still do. With this approach, threads are implemented by a library.</p>
<p>第一种方法是将整个线程包放到用户空间. 内核对此毫无所知. 就内核而言, 它依旧像对待单线程对象一样.</p>
<p>首先, 最明显的优点是, 用户级别的线程可以实现在一个不支持多线程的操作系统上.所有的操作系统曾经都是这种类型, 直到现在还有部分保留, 在这种方式下, 线程通过一个库实现.</p>
<p>All of these implementations have the same general structure, illustrated in<br>Fig. 2-16(a). The threads run on top of a run-time system, which is a collection of<br>procedures that manage threads. We have seen four of these already: pthread create, pthread exit, pthread join, and pthread yield, but usually there are more.</p>
<p>所有的实现有同样通用的结构, 如图2-16(a). 线程运行于运行时系统上(一系列管理线程的程序). 我们已经见过四种这样的程序了: 线程创建, 退出, 加入, 放弃(这是本书前面部分的内容, 但为什么是 pthread 呢? 难道是基于 posix 标准的线程实现?)</p>
<p><img src="https://imgur.com/ljUry5a.png" alt=""></p>
<p>When threads are managed in user space, each process needs its own private<br>thread table to keep track of the threads in that process. This table is analogous to<br>the kernel’s process table, except that it keeps track only of the per-thread proper-<br>ties, such as each thread’s program counter, stack pointer, registers, state, and so<br>forth. The thread table is managed by the run-time system. When a thread is<br>moved to ready state or blocked state, the information needed to restart it is stored<br>in the thread table, exactly the same way as the kernel stores information about<br>processes in the process table.</p>
<p>当线程管理于用户空间时, 每个进程需要拥有独有的线程表, 以用于持续跟踪进程中的线程. 这个表类似与内核的进程表, 不过它只跟踪每个线程的属性. 比如每个线程的程序计数器, 栈指针, 寄存器, 状态, 以及… </p>
<p>线程表由运行时系统管理, 当线程转变为就绪/阻塞状态时, 用于重启的信息就存储在线程表中, 就和内核在进程表中存储关于进程的信息一样.</p>
<p>When a thread does something that may cause it to become blocked locally, for<br>example, waiting for another thread in its process to complete some work, it calls a<br>run-time system procedure. This procedure checks to see if the thread must be put<br>into blocked state. If so, it stores the thread’s registers (i.e., its own) in the thread<br>table, looks in the table for a ready thread to run, and reloads the machine registers<br>with the new thread’s saved values. As soon as the stack pointer and program<br>counter have been switched, the new thread comes to life again automatically.</p>
<p>如果线程做了某些操作导致它本地阻塞时, 比如: 等待进程中的其他线程完成某些工作. 它调用一个运行时作业调度. </p>
<p>这个程序检查线程是否必须置于阻塞态, 如果是, 它在线程表中存储线程的寄存器(它自己的). 在表中查找一个就绪态线程运行, 重新加载新线程的寄存器. 同时栈指针和程序计数器也会切换, 新线程再次自动运行.</p>
<p> If the machine happens to have an instruction to store all the registers and another<br>one to load them all, the entire thread switch can be done in just a handful of in-<br>structions. Doing thread switching like this is at least an order of magnitude—<br>maybe more—faster than trapping to the kernel and is a strong argument in favor<br>of user-level threads packages.</p>
<p>如果机器开始有一个指令可以存储所有的寄存器, 同时另一个指令加载他们, 那么整个线程的切换就只需要少量的指令.</p>
<p>要完成这样的线程切换比捕获内核至少快一个数量级, 或许更快. 这是一个对用户级线程拥护者强有力的论点.</p>
<p>However, there is one key difference with processes. When a thread is finished<br>running for the moment, for example, when it calls thread yield, the code of<br>thread yield can save the thread’s information in the thread table itself. Fur-<br>thermore, it can then call the thread scheduler to pick another thread to run. The<br>procedure that saves the thread’s state and the scheduler are just local procedures,<br>so invoking them is much more efficient than making a kernel call. Among other<br>issues, no trap is needed, no context switch is needed, the memory cache need not<br>be flushed, and so on. This makes thread scheduling very fast.</p>
<p>然而, 有一个关于进程的关键不同. 当线程暂停时, 比如: 调用 yield, 保存线程的信息到线程表中.</p>
<p>更进步一, 调用线程调度, 选择另一个线程执行. 程序保存线程状态, 因为调度只是本地程序, 所以调用其会比内核调用更加高效. 其他方面, 没有捕获, 没有环境切换, 内存缓冲也不需要刷新, 等等. 这使得线程调度非常快.</p>
<p>User-level threads also have other advantages. They allow each process to have<br>its own customized scheduling algorithm. For some applications, for example,<br>those with a garbage-collector thread, not having to worry about a thread being<br>stopped at an inconvenient moment is a plus. They also scale better, since kernel<br>threads invariably require some table space and stack space in the kernel, which<br>can be a problem if there are a very large number of threads.</p>
<p>用户级线程还有其他优点. 它使每个进程都可以有自己的特定调度算法. 对于一些应用, 比如垃圾回收线程, 不用担心线程在不适当时候停下来, 这是一个优点. 他们拥有更好的伸缩性, 因为内核线程总是需要一些表空间和栈空间, 当线程逐渐增加时, 会造成麻烦.</p>
<p>Despite their better performance, user-level threads packages have some major<br>problems. First among these is the problem of how blocking system calls are im-<br>plemented. Suppose that a thread reads from the keyboard before any keys hav e<br>been hit. Letting the thread actually make the system call is unacceptable, since<br>this will stop all the threads. One of the main goals of having threads in the first<br>place was to allow each one to use blocking calls, but to prevent one blocked<br>thread from affecting the others. With blocking system calls, it is hard to see how<br>this goal can be achieved readily.</p>
<p>即使它们拥有更好的性能, 用户级线程包也有一些固有的问题. </p>
<p>首先, 如何实现阻塞的系统调用. 假如线程等待来自键盘的输入, 让这个线程准确执行系统调用是不允许的, 因为这会阻塞所有线程, 线程的首要目的之一是允许每个线程使用阻塞调用, 但是保证一个阻塞线程不会影响其他线程. 可以看出这很难实现.</p>
<p>The system calls could all be changed to be nonblocking (e.g., a read on the<br>keyboard would just return 0 bytes if no characters were already buffered), but re-<br>quiring changes to the operating system is unattractive. Besides, one argument for<br>user-level threads was precisely that they could run with existing operating sys-<br>tems. In addition, changing the semantics of read will require changes to many<br>user programs.</p>
<p>系统调用必须都变为非阻塞的(比如, 读取键盘输入应该在没有任何字符被缓存时返回0), 但是这对于操作系统而已不太友好. 次外(我真不知道怎么翻译这句…). 另外, 改变读取的语义将会影响到大量用户程序.</p>
<p>Another alternative is available in the event that it is possible to tell in advance<br>if a call will block. In most versions of UNIX, a system call, select , exists, which<br>allows the caller to tell whether a prospective read will block. When this call is<br>present, the library procedure read can be replaced with a new one that first does a<br>select call and then does the read call only if it is safe (i.e., will not block). If the<br>read call will block, the call is not made. Instead, another thread is run. The next<br>time the run-time system gets control, it can check again to see if the read is now<br>safe. This approach requires rewriting parts of the system call library, and is inef-<br>ficient and inelegant, but there is little choice. The code placed around the system<br>call to do the checking is called a jacket or wrapper.</p>
<p>在这种情况下还有另一个方法: 提前告知一个调用将会被阻塞是可行的(??? 啥意思啊 = =).</p>
<p>在多个 UNIX 版本中, 选择性地存在系统调用运行调用者判断未来的读操作将会阻塞. 当这样的调用存在时, 库程序读取替换成一个首先做判断, 然后当确定是安全的时候读取(比如, 非阻塞).不会执行会阻塞的读操作, 另一个线程将会运行. </p>
<p>在下次运行时系统获得控制时, 会再次检查读操作是否是安全的. 这个方法需要重写部分系统调用库. 不那么高效和优雅. 不过这是一个选择, 放置在系统函数周围的代码去检查的这种方法被称为 jacket 或 wrapper.</p>
<p>Somewhat analogous to the problem of blocking system calls is the problem of<br>page faults. We will study these in Chap. 3. For the moment, suffice it to say that<br>computers can be set up in such a way that not all of the program is in main memo-<br>ry at once. If the program calls or jumps to an instruction that is not in memory, a<br>page fault occurs and the operating system will go and get the missing instruction<br>(and its neighbors) from disk. This is called a page fault. The process is blocked<br>while the necessary instruction is being located and read in. If a thread causes a<br>page fault, the kernel, unaware of even the existence of threads, naturally blocks<br>the entire process until the disk I/O is complete, even though other threads might<br>be runnable.01</p>
<p>(简单来说, 这段说的是页错误, 主存和磁盘间虚拟空间内容的交换.)</p>
<p>Another problem with user-level thread packages is that if a thread starts run-<br>ning, no other thread in that process will ever run unless the first thread voluntarily<br>gives up the CPU. Within a single process, there are no clock interrupts, making it<br>impossible to schedule processes round-robin fashion (taking turns). Unless a<br>thread enters the run-time system of its own free will, the scheduler will never get a<br>chance.</p>
<p>用户级线程将面临的另一个问题是: 当线程开始执行时, 除非自愿放弃, 不然其他线程无法执行. </p>
<p>单线程程序, 不会产生时钟终端, 使用 round-robin 调度器管理进程是不可能的. 除非线程自愿进入运行时系统. 否则调度器将不会生效.</p>
<p>One possible solution to the problem of threads running forever is to have the<br>run-time system request a clock signal (interrupt) once a second to give it control,<br>but this, too, is crude and messy to program. Periodic clock interrupts at a higher<br>frequency are not always possible, and even if they are, the total overhead may be<br>substantial. Furthermore, a thread might also need a clock interrupt, interfering<br>with the run-time system’s use of the clock.</p>
<p>一个可能的方法是: 让运行时系统每秒请求一个时钟信号来控制它(总而言之这是一个馊主意).</p>
<p>Another, and really the most devastating, argument against user-level threads is<br>that programmers generally want threads precisely in applications where the<br>threads block often, as, for example, in a multithreaded Web server. These threads<br>are constantly making system calls. Once a trap has occurred to the kernel to carry<br>out the system call, it is hardly any more work for the kernel to switch threads if<br>the old one has blocked, and having the kernel do this eliminates the need for con-<br>stantly making select system calls that check to see if read system calls are safe.<br>For applications that are essentially entirely CPU bound and rarely block, what is<br>the point of having threads at all? No one would seriously propose computing the<br>first n prime numbers or playing chess using threads because there is nothing to be<br>gained by doing it that way.</p>
<p>另一个反对用户级线程的论证(也是最具破坏性的)是, 程序员通常希望线程在线程经常阻塞的应用中使用, 比如, 在一个多线程 web 服务器中. 线程不间断地使用系统调用, 一旦内核执行系统调用, 如果旧线程已被阻塞, 那么切换线程就几乎没有其他需要做的了. …(后面我翻不下去了, 大概意思是, 这样的话, 程序就没有必要使用多线程了)</p>
<p>(总结归纳一下: 大概意思是, 用户级线程最大的优点是在于其切换起来很快, 但是我们通常希望在频繁发生线程阻塞的应用中使用线程, 而在这种情况下, 线程切换所需的操作就会变少(如果旧线程已经被阻塞了的话), 那么 用户级线程存在的意义就不大了)</p>
<h3 id="2-2-5-Implementing-Threads-in-the-Kernel"><a href="#2-2-5-Implementing-Threads-in-the-Kernel" class="headerlink" title="2.2.5 Implementing Threads in the Kernel"></a>2.2.5 Implementing Threads in the Kernel</h3><p>Now let us consider having the kernel know about and manage the threads. No<br>run-time system is needed in each, as shown in Fig. 2-16(b). Also, there is no<br>thread table in each process. Instead, the kernel has a thread table that keeps track<br>of all the threads in the system. When a thread wants to create a new thread or<br>destroy an existing thread, it makes a kernel call, which then does the creation or<br>destruction by updating the kernel thread table.</p>
<p>现在, 让我们考虑让内核知道如何管理线程. 如图 2-16(b) 所示, 在进程中没有运行时系统, 也没有线程表. 内核有张线程表, 用于跟踪系统中的所有线程. 当线程想要创建或删除一个线程时, 使用一个内核调用, 然后通过更新内核线程表来创建或删除.</p>
<p>The kernel’s thread table holds each thread’s registers, state, and other infor-<br>mation. The information is the same as with user-level threads, but now kept in the<br>kernel instead of in user space (inside the run-time system). This information is a<br>subset of the information that traditional kernels maintain about their single-<br>threaded processes, that is, the process state. In addition, the kernel also maintains<br>the traditional process table to keep track of processes.</p>
<p>内核的线程表保存每个线程的寄存器, 状态, 以及其他信息. 与用户级线程保存的信息一致, 只是保存在内核中. </p>
<p>这些信息是传统内核管理的单线程进程信息的子集. 内核也同样管理传统的进程表, 以用于跟踪进程.</p>
<p>All calls that might block a thread are implemented as system calls, at consid-<br>erably greater cost than a call to a run-time system procedure. When a thread<br>blocks, the kernel, at its option, can run either another thread from the same proc-<br>ess (if one is ready) or a thread from a different process. With user-level threads,<br>the run-time system keeps running threads from its own process until the kernel<br>takes the CPU away from it (or there are no ready threads left to run).</p>
<p>所有可能阻塞线程的调用都被实现为系统调用, 相对运行时系统的调用, 明显有很大的额外消耗. 当线程阻塞时, 内核可以选择同进程下的线程运行, 也可以运行另一个进程的线程. 但用户级线程只会运行本进程的线程, 直到内核不让其使用 CPU 资源.</p>
<p>Due to the relatively greater cost of creating and destroying threads in the ker-<br>nel, some systems take an environmentally correct approach and recycle their<br>threads. When a thread is destroyed, it is marked as not runnable, but its kernel<br>data structures are not otherwise affected. Later, when a new thread must be creat-<br>ed, an old thread is reactivated, saving some overhead. Thread recycling is also<br>possible for user-level threads, but since the thread-management overhead is much<br>smaller, there is less incentive to do this.</p>
<p>因为在内核中创建和销毁线程操作相对更费力, 一些系统使用与环境相关的方法, 重利用它们的线程. </p>
<p>当线程销毁时, 将其标记为不可运行, 但是其内核数据结构不受影响, 随后, 当新线程需要创建时, 重新利用这些资源.  用户级线程也可以使用这个方法, 不过因为线程管理的消耗较小, 并不是很有必要这么做</p>
<p>Kernel threads do not require any new, nonblocking system calls. In addition,<br>if one thread in a process causes a page fault, the kernel can easily check to see if<br>the process has any other runnable threads, and if so, run one of them while wait-<br>ing for the required page to be brought in from the disk. Their main disadvantage is<br>that the cost of a system call is substantial, so if thread operations (creation, termi-<br>nation, etc.) a common, much more overhead will be incurred.</p>
<p>内核线程不需要任何新的, 非阻塞系统调用. 另外, 如果线程导致了页错误, 内核可以轻松地检查进程是否有其他线程可运行, 如果有, 在等待所需的页加载入内存中时, 执行该线程. 它们潜在的问题是: 系统调用比较耗时, 所以如果线程操作比较常见, 则会有更多的负载.</p>
<p>While kernel threads solve some problems, they do not solve all problems. For<br>example, what happens when a multithreaded process forks? Does the new proc-<br>ess have as many threads as the old one did, or does it have just one? In many<br>cases, the best choice depends on what the process is planning to do next. If it is<br>going to call exec to start a new program, probably one thread is the correct choice,<br>but if it continues to execute, reproducing all the threads is probably best.</p>
<p>内核线程依旧有一些未能解决的问题, 比如, 当多线程进程执行 fork 的时候, 会发生什么? 新的进程是否会像旧进程一样拥有同样多的线程呢? 还是只拥有一个呢? 在大多数情况下, 取决于进程将要做什么, 如果它将会调用 exec 执行一个新的程序, 当然只有一个好, 但是如果是继续运行的话, 则保留所有的线程则是最好的.</p>
<p>(PS: 在 linux posix 线程下, 默认是同样多的线程)</p>
<p>Another issue is signals. Remember that signals are sent to processes, not to<br>threads, at least in the classical model. When a signal comes in, which thread<br>should handle it? Possibly threads could register their interest in certain signals, so<br>when a signal came in it would be given to the thread that said it wants it. But what<br>happens if two or more threads register for the same signal? These are only two of<br>the problems threads introduce, and there are more.</p>
<p>另一个问题是信号. 信号是发给进程的, 而并非线程(至少在经典模型下). 当信号到达时, 那个线程来处理它呢? 可能线程会注册自己感兴趣的信号, 所以, 当信号到达, 会交由那个注册线程处理. 但是如果多个线程注册了同样的信号呢? 这仅仅是线程引入的其中两个问题.</p>
<h3 id="2-2-6-Hybrid-Implementations"><a href="#2-2-6-Hybrid-Implementations" class="headerlink" title="2.2.6 Hybrid Implementations"></a>2.2.6 Hybrid Implementations</h3><p>Various ways have been investigated to try to combine the advantages of user-<br>level threads with kernel-level threads. One way is use kernel-level threads and<br>then multiplex user-level threads onto some or all of them, as shown in Fig. 2-17.<br>When this approach is used, the programmer can determine how many kernel<br>threads to use and how many user-level threads to multiplex on each one. This<br>model gives the ultimate in flexibility.</p>
<p>已经有多种方法被研究出来, 用于融合用户级线程和内核级线程. 其中一种方法是使用内核级别线程, 然后每个内核线程使用多个用户级别线程. 如 2-17. </p>
<p>程序能够知晓多少内核线程, 多少用户线程被使用. 这种模型给予了很大的灵活性.</p>
<p><img src="https://imgur.com/Bcc4Uzh.png" alt=""></p>
<p>With this approach, the kernel is aware of only the kernel-level threads and<br>schedules those. Some of those threads may have multiple user-level threads multi-<br>plexed on top of them. These user-level threads are created, destroyed, and sched-<br>uled just like user-level threads in a process that runs on an operating system with-<br>out multithreading capability. In this model, each kernel-level thread has some set<br>of user-level threads that take turns using it.</p>
<p>在这种方法下, 内核只至少内核线程, 并调度它们. 其中一些内核线程上可能存在多个用户级线程. 这些用户线程将会在进程中管控. </p>
<p>内核线程和用户线程各有其优势, 用户线程效率更高, 但是操作系统不知情的情况下, 会产生许多逻辑上是多线程, 但物理上依旧是单线程才会产生的错误. 比如 信号, 中断. 而内核线程虽然相对效率低, 并且占用内核空间, 但是操作系统知晓是多线程, 与操作系统间有更多协作的空间.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/09/read/fsync/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cas">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cas's website">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/09/read/fsync/" class="post-title-link" itemprop="url">read/fsync</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-09 17:17:39" itemprop="dateCreated datePublished" datetime="2020-01-09T17:17:39+08:00">2020-01-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-07-29 20:48:30" itemprop="dateModified" datetime="2019-07-29T20:48:30+08:00">2019-07-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>看 MySQL 官方文档, 有关 InnoDB 数据管理的时候, 看到有提到 fsync </p>
<p>仔细查了一下, 才发现自己好像对这东西, 乃至文件系统都一无所知…  </p>
<p>原地址 : <a href="http://blog.httrack.com/blog/2013/11/15/everything-you-always-wanted-to-know-about-fsync/" target="_blank" rel="noopener">http://blog.httrack.com/blog/2013/11/15/everything-you-always-wanted-to-know-about-fsync/</a></p>
<h1 id="Everything-You-Always-Wanted-to-Know-About-Fsync"><a href="#Everything-You-Always-Wanted-to-Know-About-Fsync" class="headerlink" title="Everything You Always Wanted to Know About Fsync()"></a>Everything You Always Wanted to Know About Fsync()</h1><p>NOV 15TH, 2013</p>
<p>And then the developer wondered:</p>
<blockquote>
<p>is my file properly sync’ed on disk ?</p>
</blockquote>
<p>You probably know <em>more or less</em> how databases (or things that look like one) store their data on disk in a <em>permanent</em> and <em>safe</em> way. Or at least, you know the basic principles. Or not ?</p>
<p>你可能或多或少知道数据库如何以持久并安全的方式将数据存储到磁盘</p>
<p>最少, 你知道基础的原则, 或者不知道?</p>
<h3 id="Being-on-AC-I-D"><a href="#Being-on-AC-I-D" class="headerlink" title="Being on AC(I)D"></a>Being on <strong>AC</strong>(I)<strong>D</strong></h3><p>There are a bunch of concepts that first must be understood: what is <strong>atomicity</strong>, <strong>consistency</strong>, and <strong>durability</strong> ? These concepts apply on databases (see <a href="http://en.wikipedia.org/wiki/ACID" target="_blank" rel="noopener">ACID</a>), but also on the underlying filesystem.</p>
<p>这里有一系列必须理解的原则: 什么是 原子性, 一致性, 持久性? </p>
<p>这些原则不仅用于数据库, 同时也用于底层文件系统</p>
<ul>
<li><p><strong>Atomicity</strong>: a write operation is fully executed at once, and is not <em>interleaved</em> with another one (if, for example, someone else is writing to the same location)</p>
<p>原子性 : 写操作一次彻底完成, 不会和另外一个写操作交错(其他写操作在同时更改同样的区域)</p>
<p>Atomicity is typically guaranteed in operations involving filename handling ; for example, for <a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/rename.html" target="_blank" rel="noopener">rename</a>, “<em>specification requires that the action of the function be atomic</em>” – that is, when renaming a file from the old name to the new one, at no circumstances should you ever see the two files at the same time.</p>
<p>涉及到文件名管理的操作通常是保存其原子性的, 比如, 重命名, 规则描述需要这个函数必须是原子的. </p>
<p>也就是说, 当重命名文件时, 不应该同时存在两个相同文件名的文件</p>
</li>
<li><p><strong>Consistency</strong>: integrity of data must be maintained when executing an operation, even in a crash event – for example, a power outage in the middle of a <code>rename()</code> operation shall not leave the filesystem in a “weird” state, with the filename being unreachable because its metadata has been corrupted. (ie. either the operation is lost, or the operation is committed.)</p>
<p>一致性 : 当执行操作时, 数据的一致性必须被维护, 即使是在崩溃事件中, 比如 : 断电不会使文件系统处于因其元数据损坏, 文件名不可被检索到的奇怪状态(即, 操作要么丢失, 要么被提交)</p>
<p>(PS. meta ? 什么是 meta ? 根据 wiki 的解释 : </p>
<p>​    <strong>Meta</strong> (from the <a href="https://en.wikipedia.org/wiki/Greek_language" target="_blank" rel="noopener">Greek</a> <em>meta-</em> μετά- meaning “after” or “beyond”) is a prefix used in <a href="https://en.wikipedia.org/wiki/English_language" target="_blank" rel="noopener">English</a> to indicate a concept that is an <a href="https://en.wikipedia.org/wiki/Abstraction" target="_blank" rel="noopener">abstraction</a> behind another concept, used to complete or add to the latter.</p>
<p>​    元是一个概念背后的抽象概念, 用来完整前者 </p>
<p>以及有 about 语义, 两者相同, 前者关联后者, metaprogramming(writing programs manipulate programs) )</p>
<p>Consistency is guaranteed on the filesystem level ; but you also need to have the same guarantee if you build a database on disk, for example by serializing/locking certain operations on a working area, and committing the transaction by changing some kind of generation number.</p>
<p>一致性在文件系统层面上确保, 但当在磁盘上构建数据库时, 也需要其确保一致性, 比如通过序列化/锁定某些在工作区域上的操作, 通过更改一些生成的数字提交事务</p>
</li>
<li><p><strong>Durability</strong>: the write operation is durable, that is, unplugging the power cord (or a kernel panic, a crash…) shall not lose any data (hitting the hard disk with a hammer is however not covered!)</p>
<p>​    写操作是耐久的, 也就是说, 拔掉电源线(或者内核错误, 崩溃)将不会丢失任何数据(用锤子砸硬盘当然不包含在其中!)( PS.挺喜欢有幽默感的作者 :) )</p>
<p>This is an important one – at a given point, you must ensure that the data is actually written on disk <em>physically</em>, preventing any loss of data in case of a sudden power outage, for example. This is absolutely critical when dealing with a client/server architecture: the client may have its connection or transaction aborted at any time without troubles (ie. the transaction will be retried later), but once the server acknowledges it, no event should ever cause it to be lost (think of responsibility in a commercial transaction, or a digital signature, for example). For this reason, having the data committed in the internal system or hard disk cache is NOT durable for obvious reasons (unless there is a guarantee that no such power outage could happen – if a battery is used on a RAID array, for example).</p>
<p>在某种观点来看, 这是很重要的一点. 你必须确保数据正确地物理性地写入了磁盘, 防止断电而引发的数据丢失</p>
<p>应用与CS模型时, 相当关键: 客户端会在任意时刻无困难断开连接/事务(换句话说, 事务会在之后重试). 但是一旦服务器确认后, 就应该没有任何事件导致它被丢失(考虑企业事务或数字签名中的责任)</p>
<p>因为这个理由, 在内部系统或硬盘缓存中提交数据是不是可一致的(除非保证没有类似断电的行为会发生 - 比如, RDID 磁盘阵列用了蓄电池)</p>
<p>On POSIX systems, durability is achieved through sync operations (<a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/fsync.html" target="_blank" rel="noopener"><code>fsync()</code></a>, <a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/fdatasync.html" target="_blank" rel="noopener"><code>fdatasync()</code></a>, <a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/aio_fsync.html" target="_blank" rel="noopener"><code>aio_fsync()</code></a>): “<em>The fsync() function is intended to force a physical write of data from the buffer cache, and to assure that after a system crash or other failure that all data up to the time of the fsync() call is recorded on the disk.</em>”. [Note: The difference between fsync() and fdatasync() is that the later does not necessarily update the meta-data associated with a file – such as the “last modified” date – but only the file data.]</p>
<p>在 POSIX 系统, 持久性通过 sync 操作(fsync, fdatasync, aio_fsync) 获得 (PS. fsync 和 fdatasync 的区别在于, 后者不冲刷 metadata) fsync 函数故意强制物理性的缓冲的数据写入, 保证在系统崩溃或其他错误之后, 所有 fsync 调用时的数据都被记录在磁盘中</p>
</li>
</ul>
<p>Now that these concepts are a bit clearer, let’s go back to our filesystem!</p>
<h3 id="Hey-What-is-a-File-By-The-Way"><a href="#Hey-What-is-a-File-By-The-Way" class="headerlink" title="Hey, What is a File, By The Way ?"></a>Hey, What is a File, By The Way ?</h3><p>If we want to simplify the concept, let’s consider the filesystem on POSIX platforms as a very simple <em>flat</em> storage manager, allowing to read/write data blobs and basic properties (such as the modified time) indexed by an <em>integer</em> number (hint: they sometimes call that the <em>inode number</em>).</p>
<p>如果想要简化这个概念, 让我们考虑在 POSIX 平台上, 文件系统作为一个非常简单的扁平存储管理器, 允许读/写二进制数据和其基础属性(比如更改时间) 被一个整型数字索引 (有时被称作 inode 数字)</p>
<p>For example, you may want to read the file #4242’s data. And later, write some data on file #1234.</p>
<p>To have a more convenient way to handle files (because “I need to send you the presentation number 155324” would not be really convenient in the real world), we use the <strong>filename/directory</strong> concepts. A file has a name, and it is <em>contained</em> within a <em>directory structure</em>. You may put files and directories in a directory, building a hierarchical structure. But everything rely on our previous basic data blobs to store both filename and the associated index.</p>
<p>为了更方便地操作文件(因为 “我需要发送你描述编号为155324” 在真实世界中很不方便) 我们使用 文件名/目录 概念. </p>
<p>文件有一个名字, 被包含一个目录结构中, 你可以将文件和目录放到另外一个目录下,  构建一个层次的结构</p>
<p>但是, 所有都依赖于之前的基础数据集合存储文件名和相关联的索引</p>
<p>As an example, reading the file <code>foo/bar.txt</code> (ie. the file <code>bar.txt</code> within the <code>foo</code> directory) will require to access the data blob associated with the directory <code>foo</code>. After parsing this opaque data blob, the system will fetch the entry for <code>bar.txt</code>, and open the associated data blob. (And yes, there is obviously a root entry, storing references to first-level entries, allowing to access any file top-down)</p>
<p>If I now want to create a new file named <code>foo/baz.txt</code>, it will require the system to access the data blob associated with the directory <code>foo</code>, add an entry named <code>baz.txt</code> with a new allocated index for the upcoming file, and write the updated directory blob back, and from this point, write to the newly allocated blob. The operation therefore involves <strong>two</strong> data structures: the <strong>directory entry</strong>, and the <strong>file</strong> itself.</p>
<h3 id="Keeping-My-File-name-Safe"><a href="#Keeping-My-File-name-Safe" class="headerlink" title="Keeping My File(name) Safe"></a>Keeping My File(name) Safe</h3><p>Let’s go back to our database problem: what is the impact of having <em>two</em> data structures for our files ?</p>
<p><strong>Atomicity</strong> and <strong>consistency</strong> of filenames are handled for us by the filesystem, so this is not really a bother.</p>
<p>What about <strong>durability</strong> ?</p>
<p>让我们回到数据库的问题(PS. 我觉得, 好像越说越多了 = =) : 如果我们的文件有两个数据结构的话, 会怎样? </p>
<p>文件名原子性和一致性由我们通过文件系统控制, 这不会造成什么麻烦, 但是持久性呢?</p>
<p>We know that <code>fsync()</code> provides guarantees related to data and meta-data sync’ing. But if you look closer to the specification, the only data involved are the one related to the file itself – not its directory entry. The “metadata” concept involves modified time, access time etc. – <strong>not</strong> the <em>directory entry</em> itself.</p>
<p>我们知道 fsync 提供相关文件和元数据的同步保证</p>
<p>但是深入了解规格, 唯一涉及的数据是和文件本身相关的数据, 不是它的目录入口</p>
<p>元数据概念包含更改时间, 访问时间等等, 但不包含目录入口</p>
<p>It would be cumbersome for a filesystem to provide this guarantee, by the way: on POSIX systems, you can have an arbitrary number of directory links to a filename (or to another directory entry). The most common case is <em>one</em>, of course. But you may delete a file being used (the file entry will be removed by the system when the file is closed) – the very reason why erasing a log file which is flooding a filesystem is a futile and deadly action – in such case, the number of links will be <em>zero</em>. And you may also create as many <a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/link.html" target="_blank" rel="noopener">hard-links</a> as you want for a given file/directory entry.</p>
<p>Therefore, in theory, you may create a file, write some data, synchronize it, close the file, and see your <a href="http://upload.wikimedia.org/wikipedia/en/e/e0/Gollum.PNG" target="_blank" rel="noopener">precious</a> file lost forever because of a power outage. Oh, the filesystem must guarantee consistency, of course, but not durability unless <em>explicitly</em> asked by the client – which means that a filesystem check <em>may</em> find your directory entry partially written, and decide to achieve consistency by taking the previous directory blob entry, <strong>wiping</strong> the unreferenced file entry (note: if you are “lucky” enough, the file will be expelled in <code>lost+found</code>)</p>
<p>The filesystem can, of course, decide to be gentle, and commit all filename operations when fsync’ing. It may also, such as for ext3, commit <a href="https://ext4.wiki.kernel.org/index.php/Ext3_Data%3DOrdered_vs_Data%3DWriteback_mode" target="_blank" rel="noopener"><strong>everything</strong></a> when fsync’ing a file – causing the <a href="http://lwn.net/Articles/328363/" target="_blank" rel="noopener">infamous</a> and <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=421482" target="_blank" rel="noopener">horrendous</a> lags in firefox or thunderbird.</p>
<p>But if you need to have <strong>guarantees</strong>, and not just <em>hope</em> the filesystem “<em>will be gentle<em>”, and do not want to “</em>trust the filesystem*” (yes, someone actually told me that: you *need</em> to “trust the filesystem” – I swear it), you have to actually make sure that your <strong>filename</strong> entry is properly sync’ed on disk following the POSIX specification.</p>
<p>Oh, and by the way: according to <a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/fsync.html" target="_blank" rel="noopener">POSIX</a>, <em>The fsync() function is intended to force a physical write of data from the buffer cache, and to assure that after a system crash or other failure that all data up to the time of the fsync() call is recorded on the disk</em>.</p>
<p><em>But</em> things are sometimes a bit obscure on the implementation side :</p>
<ul>
<li><p><a href="http://unixhelp.ed.ac.uk/CGI/man-cgi?fsync" target="_blank" rel="noopener"><strong>Linux/ext3</strong></a>: <em>If the underlying hard disk has write caching enabled, then the data may not really be on permanent storage when fsync() / fdatasync() return.</em> (do’h!)</p>
<p>如果底层磁盘允许写入缓存, 当 fsync/fdatasync 时数据可能不会真正的永久性存储</p>
</li>
<li><p><a href="http://linux.die.net/man/2/fsync" target="_blank" rel="noopener"><strong>Linux/ext4</strong></a>: <em>The fsync() implementations in older kernels and lesser used filesystems does not know how to flush disk caches.</em> (do’h!) – issue adressed quite <a href="http://lwn.net/Articles/270891/" target="_blank" rel="noopener">recently</a></p>
</li>
<li><p><a href="https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man2/fsync.2.html" target="_blank" rel="noopener"><strong>OSX</strong></a>: <em>For applications that require tighter guarantees about the integrity of their data, Mac OS X provides the F_FULLFSYNC fcntl. The F_FULLFSYNC fcntl asks the drive to flush all buffered data to permanent storage</em> (hey, fsync was supposed to do that, no ? guys ?) <em>(Edit: no, fsync is actually not required to do that – thanks for the clarification Florent!)</em></p>
</li>
</ul>
<p>But we may assume that on Linux with <a href="http://monolight.cc/2011/06/barriers-caches-filesystems/" target="_blank" rel="noopener">ext4</a> (and OSX with proper flags ?) the system is properly propagating <a href="http://docs.fedoraproject.org/en-US/Fedora/14/html/Storage_Administration_Guide/writebarr.html" target="_blank" rel="noopener">write barriers</a>.</p>
<p>On Windows, using <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/aa364439.aspx" target="_blank" rel="noopener"><code>FlushFileBuffers()</code></a> is probably the way to go.</p>
<p>(PS. 很惭愧, 有些我没有读懂… 不过有一件事情是明白的 : 我好像对文件系统真的一无所知… )</p>
<h3 id="Syncing-Filenames"><a href="#Syncing-Filenames" class="headerlink" title="Syncing Filenames"></a>Syncing Filenames</h3><p>I told you that a filesystem was actually a bunch of <em>flat</em> data blobs with associated metadata, and that a file had actually two parts: its directory entry (let’s assume there is only one directory entry for the sake of simplicity), and its actual data. We already know how to sync the later one ; do we have a way to do the same for the directory container itself ?</p>
<p>我已经告诉你, 文件系统实际上是一堆扁平的与元数据关联的数据块, 文件实际上有两部分 : 它的目录入口(为了简单起见, 假设只有一个目录入口), 以及它的实际数据, 我们已经知道如何同步后面的一部分, 我们有同样的刚发同步目录容器自身么?</p>
<p>On POSIX, you may actually open a directory as if you were opening a file (hint: a directory is <a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap03.html" target="_blank" rel="noopener"><em>a file that contains directory entries</em></a>). It means that <code>open()</code> <em>may</em> successfully open a directory entry. But on the other hand, you generally can not open a directory entry for <em>writing</em> (see POSIX <a href="http://pubs.opengroup.org/onlinepubs/009695299/functions/open.html" target="_blank" rel="noopener">remark</a> regarding <code>EISDIR</code>: <em>The named file is a directory and oflag includes O_WRONLY or O_RDWR</em>), and this is perfectly logical: by directly writing to the internal directory entry, you may be able to mess up with the directory structure, ruining the filesystem <strong>consistency</strong>.</p>
<p>在 POSIX 下, 你可能正常地像打开一个文件一样打开目录(目录是一个包含目录入口的文件)(PS. MD 我要疯了, 它说的 directory entries 到底是什么东西, 直译目录入口? 什么鬼东西啊, inode?那怎么不叫 inode/vnode ? 根据 google 出的解答 <a href="https://unix.stackexchange.com/questions/186992/what-is-directory-entry" target="_blank" rel="noopener">https://unix.stackexchange.com/questions/186992/what-is-directory-entry</a> 那是一个目录和文件名相关的结构体)  </p>
<p>But can we fsync() written data using a file descriptor opened <em>only</em> for reading ? The question is… yes, or at least “<em>yes it should*” – even POSIX group had *editorial</em> inconsistencies regarding <a href="http://austingroupbugs.net/view.php?id=501" target="_blank" rel="noopener">fdatasync</a> and <a href="http://austingroupbugs.net/view.php?id=671" target="_blank" rel="noopener">aio_fsync()</a>, leading to incorrect <a href="http://cygwin.com/frysk/bugzilla/show_bug.cgi?id=15361" target="_blank" rel="noopener">behavior</a> on various implementations. And the reason it should execute the operation is because requesting the completion of a write operation does not have to require actual write access – which have already been checked and enforced.</p>
<p>On Windows… err, there is no clear answer. You can not call <code>FlushFileBuffers()</code> on a directory handle as far as I can see.</p>
<p>Oh, a last funny note: how do you sync the <strong>content</strong> of a <em>symbolic link</em> (and its related meta-data), that is, the filename pointed by this link ? The answer is… you can’t. Nope. This is not possible with the current standard (hint: you can not <code>open()</code> a symbolic link). Which means that if you handle some kind of database generation update based on symbolic links (ie. changing a “last-version” symlink to the latest built generation file), you have zero guarantee over durability.</p>
<h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>Does it means that we need to call <code>fsync()</code> <em>twice</em>, one on the file data, and one on its parent directory ? When you need to achieve <em>durability</em>, the answer is obviously <strong>yes</strong>. (Remember that file file/filename will be sync’ed on disk anyway by the operating system, so you do not actually need to do that for every single file – only for those you want to have a durability guarantee at a given time)</p>
<p>However, the question is causing some headache on the POSIX standard, and as a follow-up to the <a href="http://comments.gmane.org/gmane.comp.standards.posix.austin.general/6952" target="_blank" rel="noopener">austin-group</a> (ie. POSIX mailing-list) discussion, an <a href="http://austingroupbugs.net/view.php?id=672" target="_blank" rel="noopener">editorial clarification request</a> is still pending and is waiting for feedback from various implementors. (you may also have a look at the <a href="http://unix.derkeiler.com/Newsgroups/comp.unix.programmer/2013-03/msg00016.html" target="_blank" rel="noopener">comp.unix.programmer</a> discussion)</p>
<p><strong>TL;DR</strong>: syncing a file is not as simple as it seems!</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/09/read/CreateInnoDBTables/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cas">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cas's website">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/09/read/CreateInnoDBTables/" class="post-title-link" itemprop="url">read/CreateInnoDBTables</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-09 17:17:38" itemprop="dateCreated datePublished" datetime="2020-01-09T17:17:38+08:00">2020-01-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-07-31 15:18:10" itemprop="dateModified" datetime="2019-07-31T15:18:10+08:00">2019-07-31</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li><h4 id="15-6-1-1-Creating-InnoDB-Tables"><a href="#15-6-1-1-Creating-InnoDB-Tables" class="headerlink" title="15.6.1.1 Creating InnoDB Tables"></a>15.6.1.1 Creating InnoDB Tables</h4></li>
</ul>
<p>  To create an <code>InnoDB</code> table, use the <a href="https://dev.mysql.com/doc/refman/8.0/en/create-table.html" target="_blank" rel="noopener"><code>CREATE TABLE</code></a> statement.</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1 (a <span class="built_in">INT</span>, b <span class="built_in">CHAR</span> (<span class="number">20</span>), PRIMARY <span class="keyword">KEY</span> (a)) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure>

<p>  You do not need to specify the <code>ENGINE=InnoDB</code> clause if <code>InnoDB</code> is defined as the default storage engine, which it is by default. To check the default storage engine, issue the following statement:</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT @@default_storage_engine;</span><br><span class="line">+<span class="comment">--------------------------+</span></span><br><span class="line">| @@default_storage_engine |</span><br><span class="line">+<span class="comment">--------------------------+</span></span><br><span class="line">| InnoDB                   |</span><br><span class="line">+<span class="comment">--------------------------+</span></span><br></pre></td></tr></table></figure>

<p>  You might still use <code>ENGINE=InnoDB</code> clause if you plan to use <a href="https://dev.mysql.com/doc/refman/8.0/en/mysqldump.html" target="_blank" rel="noopener"><strong>mysqldump</strong></a> or replication to replay the <a href="https://dev.mysql.com/doc/refman/8.0/en/create-table.html" target="_blank" rel="noopener"><code>CREATE TABLE</code></a> statement on a server where the default storage engine is not <code>InnoDB</code>.</p>
<p>  如果你计划使用 mysqldump/复制 将 CREATE TABLE 语句复现在另外一个默认存储引擎不是 InnoDB 的服务器上, 就坚持使用 ENGINE=InnoDB 子句 (不过我看 mysqldump 出的语句中会显式指定存储引擎类型)</p>
<p>  An <code>InnoDB</code> table and its indexes can be created in the <a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_system_tablespace" target="_blank" rel="noopener">system tablespace</a>, in a <a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_file_per_table" target="_blank" rel="noopener">file-per-table</a> tablespace, or in a <a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_general_tablespace" target="_blank" rel="noopener">general tablespace</a>. When <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_file_per_table" target="_blank" rel="noopener"><code>innodb_file_per_table</code></a> is enabled, which is the default, an <code>InnoDB</code> table is implicitly created in an individual file-per-table tablespace. Conversely, when <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_file_per_table" target="_blank" rel="noopener"><code>innodb_file_per_table</code></a> is disabled, an <code>InnoDB</code> table is implicitly created in the <code>InnoDB</code> system tablespace. To create a table in a general tablespace, use <a href="https://dev.mysql.com/doc/refman/8.0/en/create-table.html" target="_blank" rel="noopener"><code>CREATE TABLE ... TABLESPACE</code></a> syntax. For more information, see <a href="https://dev.mysql.com/doc/refman/8.0/en/general-tablespaces.html" target="_blank" rel="noopener">Section 15.6.3.3, “General Tablespaces”</a>.</p>
<p>  InnoDB 表及它的索引可以创建在 system tablespace, file-per-table tablespace  或 general tablespace. 当 innodb_file_per_table 启用, InnoDB 表默认创建在单独的 file-per-rable 表空间中, 相反, 则创建在 system tablespace 中. </p>
<p>  使用 CREATE TABLE … TABLESPACE 语法可以创建在 general tablespace 中</p>
<p>  When you create a table in a file-per-table tablespace, MySQL creates an <a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_ibd_file" target="_blank" rel="noopener">.ibd</a> tablespace file in a database directory under the MySQL data directory, by default. A table created in the <code>InnoDB</code> system tablespace is created in an existing <a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_ibd_file" target="_blank" rel="noopener">ibdata file</a>, which resides in the MySQL data directory. A table created in a general tablespace is created in an existing general tablespace <a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_ibd_file" target="_blank" rel="noopener">.ibd file</a>. General tablespace files can be created inside or outside of the MySQL data directory. For more information, see <a href="https://dev.mysql.com/doc/refman/8.0/en/general-tablespaces.html" target="_blank" rel="noopener">Section 15.6.3.3, “General Tablespaces”</a>.</p>
<p>  当你创建一个在 file-per-table 表空间中的表时, MySQL 在主目录下的单个数据库目录中创建 .idb 文件  </p>
<p>  在 InnoDB system 表空间中则创建在一个在 MySQL 主目录下已存在的 ibdata 文件中(PS. 那么 ibdata 文件是什么时候创建的? 如何增长?) </p>
<p>  Internally, <code>InnoDB</code> adds an entry for each table to the data dictionary. The entry includes the database name. For example, if table <code>t1</code> is created in the <code>test</code> database, the data dictionary entry for the database name is <code>&#39;test/t1&#39;</code>. This means you can create a table of the same name (<code>t1</code>) in a different database, and the table names do not collide inside <code>InnoDB</code>.</p>
<h5 id="InnoDB-Tables-and-Row-Formats"><a href="#InnoDB-Tables-and-Row-Formats" class="headerlink" title="InnoDB Tables and Row Formats"></a>InnoDB Tables and Row Formats</h5><p>  The default row format for <code>InnoDB</code> tables is defined by the <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_default_row_format" target="_blank" rel="noopener"><code>innodb_default_row_format</code></a> configuration option, which has a default value of <code>DYNAMIC</code>. <code>Dynamic</code> and<code>Compressed</code> row format allow you to take advantage of <code>InnoDB</code> features such as table compression and efficient off-page storage of long column values. To use these row formats, <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_file_per_table" target="_blank" rel="noopener"><code>innodb_file_per_table</code></a> must be enabled (the default).</p>
<p>  InnoDB 表的行格式化由 innodb_default_row_format 定义, 默认是 DYNAMIC </p>
<p>  Dynamic 和 Compressed 行格式化提供了 InnoDB 高级特性, 比如 压缩表, 高效的长列值页外存储</p>
<p>  使用这些行格式化, 必须启用 innodb_file_per_table</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> innodb_file_per_table=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t3 (a <span class="built_in">INT</span>, b <span class="built_in">CHAR</span> (<span class="number">20</span>), PRIMARY <span class="keyword">KEY</span> (a)) ROW_FORMAT=DYNAMIC;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t4 (a <span class="built_in">INT</span>, b <span class="built_in">CHAR</span> (<span class="number">20</span>), PRIMARY <span class="keyword">KEY</span> (a)) ROW_FORMAT=COMPRESSED;</span><br></pre></td></tr></table></figure>

<p>  Alternatively, you can use <a href="https://dev.mysql.com/doc/refman/8.0/en/create-table.html" target="_blank" rel="noopener"><code>CREATE TABLE ... TABLESPACE</code></a> syntax to create an <code>InnoDB</code> table in a general tablespace. General tablespaces support all row formats. For more information, see <a href="https://dev.mysql.com/doc/refman/8.0/en/general-tablespaces.html" target="_blank" rel="noopener">Section 15.6.3.3, “General Tablespaces”</a>.</p>
<p>  另外, 你可以使用 CREATE TABLE … TABLESAPCE 语法在 general tablespace 创建 InnoDB 表. general tablespace 支持所有的行格式化</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1 (c1 <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span>) <span class="keyword">TABLESPACE</span> ts1 ROW_FORMAT=DYNAMIC;</span><br></pre></td></tr></table></figure>

<p>  <a href="https://dev.mysql.com/doc/refman/8.0/en/create-table.html" target="_blank" rel="noopener"><code>CREATE TABLE ... TABLESPACE</code></a> syntax can also be used to create <code>InnoDB</code> tables with a <code>Dynamic</code> row format in the system tablespace, alongside tables with a <code>Compact</code> or<code>Redundant</code> row format.</p>
<p>  CREATE TABLE … TABLESPACE 语法也可以被用作在 system tablespace 中创建 Dynamic 格式化的表, 以及 Compacr 或 Redundant 格式化</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1 (c1 <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span>) <span class="keyword">TABLESPACE</span> = innodb_system ROW_FORMAT=DYNAMIC;</span><br></pre></td></tr></table></figure>

<p>  For more information about <code>InnoDB</code> row formats, see <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-row-format.html" target="_blank" rel="noopener">Section 15.10, “InnoDB Row Formats”</a>. For how to determine the row format of an <code>InnoDB</code> table and the physical characteristics of <code>InnoDB</code> row formats, see <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-row-format.html" target="_blank" rel="noopener">Section 15.10, “InnoDB Row Formats”</a>.</p>
<h5 id="InnoDB-Tables-and-Primary-Keys"><a href="#InnoDB-Tables-and-Primary-Keys" class="headerlink" title="InnoDB Tables and Primary Keys"></a>InnoDB Tables and Primary Keys</h5><p>  Always define a <a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_primary_key" target="_blank" rel="noopener">primary key</a> for an <code>InnoDB</code> table, specifying the column or columns that:</p>
<ul>
<li><p>Are referenced by the most important queries.</p>
</li>
<li><p>Are never left blank.</p>
</li>
<li><p>Never have duplicate values.</p>
</li>
<li><p>Rarely if ever change value once inserted.</p>
<p>通常会为 InnoDB 表定义一个主键, 说明列具有: 被最重要的查询引用, 永远不为空, 永远不重复, 一旦插入, 则很少改动</p>
<p>For example, in a table containing information about people, you would not create a primary key on <code>(firstname, lastname)</code> because more than one person can have the same name, some people have blank last names, and sometimes people change their names. With so many constraints, often there is not an obvious set of columns to use as a primary key, so you create a new column with a numeric ID to serve as all or part of the primary key. You can declare an <a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_auto_increment" target="_blank" rel="noopener">auto-increment</a> column so that ascending values are filled in automatically as rows are inserted:</p>
<p>比如, 在一个包含民众信息的表中, 不能创建以 (firstname, lastname) 组合的值为主键, 因为名字很可能重复, 一些人没有 lastname, 一些人会改变他们的名字. </p>
<p>涉及到这么多的限制, 进程没有一个明显列的集合能作为主键. 所以可以创建一个新的数字列用作整个或部分主键, 声明为 auto-increament  可以使行在插入时自增</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The value of ID can act like a pointer between related items in different tables.</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t5 (<span class="keyword">id</span> <span class="built_in">INT</span> AUTO_INCREMENT, b <span class="built_in">CHAR</span> (<span class="number">20</span>), PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment"># The primary key can consist of more than one column. Any autoinc column must come first.</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t6 (<span class="keyword">id</span> <span class="built_in">INT</span> AUTO_INCREMENT, a <span class="built_in">INT</span>, b <span class="built_in">CHAR</span> (<span class="number">20</span>), PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>,a));</span><br></pre></td></tr></table></figure>

<p>Although the table works correctly without defining a primary key, the primary key is involved with many aspects of performance and is a crucial design aspect for any large or frequently used table. It is recommended that you always specify a primary key in the <a href="https://dev.mysql.com/doc/refman/8.0/en/create-table.html" target="_blank" rel="noopener"><code>CREATE TABLE</code></a> statement. If you create the table, load data, and then run <a href="https://dev.mysql.com/doc/refman/8.0/en/alter-table.html" target="_blank" rel="noopener"><code>ALTER TABLE</code></a> to add a primary key later, that operation is much slower than defining the primary key when creating the table.</p>
<p>尽管没有定义主键 表也可以正常运行, 但是主键包含了许多性能方面和重要的为大容量或频繁使用表做的设计, 建议你总是在表中指定一个主键. </p>
<p>在创建和加载表之后使用 ALTER TABLE 语句增加主键, 速度会远慢于一开始创建时指定主键</p>
</li>
</ul>
<h5 id="Viewing-InnoDB-Table-Properties"><a href="#Viewing-InnoDB-Table-Properties" class="headerlink" title="Viewing InnoDB Table Properties"></a>Viewing InnoDB Table Properties</h5><p>  To view the properties of an <code>InnoDB</code> table, issue a <a href="https://dev.mysql.com/doc/refman/8.0/en/show-table-status.html" target="_blank" rel="noopener"><code>SHOW TABLE STATUS</code></a> statement:</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW TABLE STATUS FROM test LIKE 't%' \G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           Name: t1</span><br><span class="line">         Engine: InnoDB</span><br><span class="line">        Version: 10</span><br><span class="line">     Row_format: Compact</span><br><span class="line">           Rows: 0</span><br><span class="line"> Avg_row_length: 0</span><br><span class="line">    Data_length: 16384</span><br><span class="line">Max_data_length: 0</span><br><span class="line">   Index_length: 0</span><br><span class="line">      Data_free: 0</span><br><span class="line"> Auto_increment: NULL</span><br><span class="line">    Create_time: 2015-03-16 15:13:31</span><br><span class="line">    Update_time: NULL</span><br><span class="line">     Check_time: NULL</span><br><span class="line">      Collation: utf8mb4_0900_ai_ci</span><br><span class="line">       <span class="keyword">Checksum</span>: <span class="literal">NULL</span></span><br><span class="line"> Create_options:</span><br><span class="line">        <span class="keyword">Comment</span>:</span><br></pre></td></tr></table></figure>

<p>  For information about <a href="https://dev.mysql.com/doc/refman/8.0/en/show-table-status.html" target="_blank" rel="noopener"><code>SHOW TABLE STATUS</code></a> output, see <a href="https://dev.mysql.com/doc/refman/8.0/en/show-table-status.html" target="_blank" rel="noopener">Section 13.7.6.36, “SHOW TABLE STATUS Syntax”</a>.</p>
<p>  <code>InnoDB</code> table properties may also be queried using the <code>InnoDB</code> Information Schema system tables:</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM INFORMATION_SCHEMA.INNODB_TABLES WHERE NAME='test/t1' \G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">     TABLE_ID: 45</span><br><span class="line">         NAME: test/t1</span><br><span class="line">         FLAG: 1</span><br><span class="line">       N_COLS: 5</span><br><span class="line">        SPACE: 35</span><br><span class="line">   ROW_FORMAT: Compact</span><br><span class="line">ZIP_PAGE_SIZE: 0</span><br><span class="line">   SPACE_TYPE: Single</span><br></pre></td></tr></table></figure>

<p>  For more information, see <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-information-schema-system-tables.html" target="_blank" rel="noopener">Section 15.14.3, “InnoDB INFORMATION_SCHEMA Schema Object Tables”</a>.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/09/read/Choosing_the_best_indexes_for_MySQL_query_optimization/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cas">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cas's website">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/09/read/Choosing_the_best_indexes_for_MySQL_query_optimization/" class="post-title-link" itemprop="url">read/Choosing_the_best_indexes_for_MySQL_query_optimization</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-09 17:17:38" itemprop="dateCreated datePublished" datetime="2020-01-09T17:17:38+08:00">2020-01-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-07-25 13:39:14" itemprop="dateModified" datetime="2019-07-25T13:39:14+08:00">2019-07-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="原文-https-www-eversql-com-choosing-the-best-indexes-for-mysql-query-optimization"><a href="#原文-https-www-eversql-com-choosing-the-best-indexes-for-mysql-query-optimization" class="headerlink" title="原文 : https://www.eversql.com/choosing-the-best-indexes-for-mysql-query-optimization/"></a>原文 : <a href="https://www.eversql.com/choosing-the-best-indexes-for-mysql-query-optimization/" target="_blank" rel="noopener">https://www.eversql.com/choosing-the-best-indexes-for-mysql-query-optimization/</a></h2><h2 id="Which-indexes-should-I-create-for-an-SQL-query"><a href="#Which-indexes-should-I-create-for-an-SQL-query" class="headerlink" title="Which indexes should I create for an SQL query?"></a>Which indexes should I create for an SQL query?</h2><h2 id="我应该为SQL查询创建哪些索引"><a href="#我应该为SQL查询创建哪些索引" class="headerlink" title="我应该为SQL查询创建哪些索引?"></a>我应该为SQL查询创建哪些索引?</h2><p>As a general rule of thumb, MySQL can only use one index for each table in the query. Therefore, there is no point in creating more than one index for each query. Preferably, same indexes should match as many of the queries as possible, as it will reduce the load on the database when inserting or updating data (which requires updating the indexes as well).</p>
<p>按照一般的经验法则, MySQL查询中的每个表只能使用一个索引</p>
<p>(High Performance MySQL 中澄清了, 有可能会组合, 但最好不要依赖于它)</p>
<p>所以, 为每个查询创建多个索引是没有意义的, 更恰当的情况是, 同样的索引匹配尽可能多的查询</p>
<p>因为这将会在插入或更改数据时, 减少数据库的负载(该操作同样也需要更新索引)</p>
<p>When creating an index, the most important parts are the equality conditions in the WHERE and JOIN conditions. In most cases, conditions such as name = ‘John’ will allow the database to filter most of the rows from the table and go through a small amount of rows to return the required results. Therefore, we should start indexing by adding these columns to the index.</p>
<p>当创建索引时, 最重要的是在 WHERE 和 JOIN 中的等式条件 </p>
<p>在大多数情况下, 像 name = ‘John’ 这样的条件会使数据区从表中筛选行, 通过少量的行返回需要的数据</p>
<p>我们应该通过增加这些列到索引中来开始索引</p>
<p>Then, you should look into the range conditions, but you should only add one of them – the most selective one, as MySQL can’t handle more of them. In some cases when there are no range conditions, it makes sense to add the GROUP BY / ORDER BY columns, assuming the ordering is done in only one direction (ASC / DESC).</p>
<p>然后, 你应该关注范围条件, 但是你只能增加其中一个, 可选性最大的一个, 因为MySQL不能处理更多</p>
<p>(PS. 关于 selectivity, High Performance MySQL 5.3 节中 Choosing a Good Column Order 中有介绍)</p>
<p>(简单来理解的话, 就是最具可选性, 最能分辨的列)</p>
<p>在某些情况下没有范围条件, 增加 GROUP BY/ORDER BY 列, 假设顺序由其中一个方向确定(ASC/DESC)</p>
<p>In some cases, it also makes sense to create a separate index that contains the ORDER BY clause’s columns, as MySQL sometimes chooses to use it. Please note though that for this to happen, the index should contain all columns from the ORDER BY clause and they should all be specified with the same order (ASC / DESC). This doesn’t guarantee that the database’s optimizer will pick this index rather than the other compound indexes, but it’s worth a try.</p>
<p>有时候, 也可以创建一个单独的索引包含 ORDER BY 子句的列, 因为 MySQL 有时会选择使用它</p>
<p>请记住, 为了实现这一点, 索引应该包含 ORDER BY 子句中所有的列, 并且被指定为相同的顺序(ASC/DESC) </p>
<p>这不保证数据库的优化是否会选择这个, 而不是其他组合索引, 但是值得一试</p>
<p>Also, in some cases, it makes sense to also add the columns from the SELECT clause to the index, to have a complete covering index. This only relevant if the index isn’t already ‘too large’. What’s too large? Well, no official rule of thumb here, but let’s say… 5-7 columns? Creating a covering index allows the database to not only filter using the index, but to also fetch the information required by the SELECT clause directly from the index, which saves precious I/O operations.</p>
<p>同样的, 有时增加 SELECT 中的列, 以拥有一个完整的覆盖索引也是有必要的, 但只当索引不长时, 才有意义</p>
<p>那么, 多长才是长么? emm… 没有官方规定这个, 但是估计一下… 5-7列? </p>
<p>创建覆盖索引使数据库不仅能过滤, 同时也能直接从索引中获取 SELECT 子句需要的信息, 以节省宝贵的 I/O 操作</p>
<p>Let’s look at an example to clarify: (通过一个例子理解一下)</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    <span class="keyword">id</span>, first_name, last_name, age</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    employees</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    first_name = <span class="string">'John'</span></span><br><span class="line">        <span class="keyword">AND</span> last_name = <span class="string">'Brack'</span></span><br><span class="line">        <span class="keyword">AND</span> age &gt; <span class="number">25</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> age <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure>
<p>For this query, we’ll start with adding the columns <em>first_name</em> and <em>last_name</em>, which are compared with an equality operator. Then, we’ll add the <em>age</em> column which is compared with a range condition. No need to have the ORDER BY clause indexed here, as the <em>age</em> column is already in the index. Last but not least, we’ll add <em>id</em> from the SELECT clause to the index to have a covering index.</p>
<p>就这个例子, 我们应该一开始增加在 WHERE 子句中有相等比较操作的列 first_name 和 last_name</p>
<p>然后, 增加具有比较的 age 列. 在这里不需要有 ORDER BY 子句, 因为 age 列已经在索引中了 </p>
<p>最后, 但并不是最不重要的. 增加在 SELECT 子句中的 id 列, 以获得一个覆盖索引</p>
<p>So to index this query properly, you should add the index: (为了适当地索引这个查询, 你应该增加这个索引)</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">employees (first_name, last_name, age, id).</span><br><span class="line">mysql : <span class="keyword">CREATE</span> <span class="keyword">INDEX</span> [INDEX_NAME] <span class="keyword">ON</span> [TABLE_NAME] (first_name, last_name, age, <span class="keyword">id</span>)</span><br></pre></td></tr></table></figure>

<p>The above is a very simplified pseudo-algorithm that will allow you to build simple indexes for rather simple SQL queries.</p>
<p>上面是一个非常简单的(= = 这东西咋翻译来着… 虚拟方法? 总之就是一种方法)</p>
<p>让你为简单的 SQL 查询构建简单的索引</p>
<p>(实际情况可能会复杂一些, 参考 High Performance MySQL 第 5 章)</p>
<p>If you’re looking for a way to automate your index creation, while also adding the benefit of a proprietary indexing algorithm and query optimization recommendations, you can try out <a href="http://www.eversql.com/?utm_source=blog&utm_campaign=p502" target="_blank" rel="noopener">EverSQL Query Optimizer</a> which does all the heavy lifting for you.</p>
<p>(广告 = =)</p>
<h2 id="What-not-to-do-when-indexing-or-writing-SQL-queries"><a href="#What-not-to-do-when-indexing-or-writing-SQL-queries" class="headerlink" title="What not to do when indexing (or writing SQL queries)?"></a>What not to do when indexing (or writing SQL queries)?</h2><h2 id="使用索引时-不要做的事情"><a href="#使用索引时-不要做的事情" class="headerlink" title="使用索引时, 不要做的事情"></a>使用索引时, 不要做的事情</h2><p>We gathered some of the most common mistakes we see programmers and database administrators do when writing queries and indexing their tables.</p>
<p>我们收集了一些当程序/DBA写查询语句和索引他们的表时, 会犯的常见错误</p>
<h3 id="Indexing-each-and-every-column-in-the-table-separately"><a href="#Indexing-each-and-every-column-in-the-table-separately" class="headerlink" title="Indexing each and every column in the table separately"></a>Indexing each and every column in the table separately</h3><h3 id="索引每一个表中每一列"><a href="#索引每一个表中每一列" class="headerlink" title="索引每一个表中每一列"></a>索引每一个表中每一列</h3><p>In most cases, MySQL won’t be able to use more than one index for each table in the query.</p>
<p>Therefore, when creating a separate index for each column in the table, the database is bound to perform only one of the search operations using an index, and the rest of them will be significantly slower, as the database can’t use an index to execute them.</p>
<p>We recommend using compound indexes (explained later in this article) rather than single-column indexes.</p>
<p>通常, MySQL不能在查询语句中, 为同一张表使用超过一个索引</p>
<p>所以, 当为表中的每个列创建一个索引, MySQL被限制只使用其中一个索引, 而其他的会慢很多</p>
<p>所以数据库不能使用索引去执行它们</p>
<p>我们建议使用复合索引(将会在这篇文章之后介绍), 而不是使用单列索引</p>
<h2 id="The-OR-operator-in-filtering-conditions"><a href="#The-OR-operator-in-filtering-conditions" class="headerlink" title="The OR operator in filtering conditions"></a>The OR operator in filtering conditions</h2><h3 id="过滤中的-OR-操作"><a href="#过滤中的-OR-操作" class="headerlink" title="过滤中的 OR 操作"></a>过滤中的 OR 操作</h3><p>Consider this query: (考虑这个查询)</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    a, b</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    tbl</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    a = <span class="number">3</span> <span class="keyword">OR</span> b = <span class="number">8</span>;</span><br></pre></td></tr></table></figure>
<p>In many cases, MySQL won’t be able to use an index to apply an OR condition, and as a result, this query is not index-able.</p>
<p>Therefore, we recommend to avoid such OR conditions and consider splitting the query to two parts, combined with a UNION DISTINCT (or even better, UNION ALL, in case you know there won’t be any duplicate results)</p>
<p>通常, MySQL不能使用一个索引执行 OR 操作, 所以, 这个索引是 不可索引 的</p>
<p>所以, 我们建议避免这样的 OR 操作, 将其切分为两个部分, 由 UNION DISTINCT 组合</p>
<p>(或者更好地, UNION ALL, 你知道在这个例子中不会有重复的元素)</p>
<p>(PS. 是的, 在这样的情况下, MySQL不会使用索引 )</p>
<h2 id="The-order-of-columns-in-an-index-is-important"><a href="#The-order-of-columns-in-an-index-is-important" class="headerlink" title="The order of columns in an index is important"></a>The order of columns in an index is important</h2><h3 id="索引中列的顺序很重要"><a href="#索引中列的顺序很重要" class="headerlink" title="索引中列的顺序很重要"></a>索引中列的顺序很重要</h3><p>Let’s say I hand you my contacts phone book which is ordered by the contact’s first name and ask you to count how many people are there named “John” in the book. You’ll grab the book in both hands and say “no problem”. You will navigate to the page that holds all names starting with John, and start counting from there.</p>
<p>假设我把我的由联系人的姓作为顺序排序的通讯录给你, 问你在这个通讯录中, 有多少姓 “John” 的人</p>
<p>你会拿着这本书说”没问题”, 你会找到以 “John” 开始的书页, 然后开始计数</p>
<p>Now, let’s say I change the assignment and hand you a phone book that is ordered by the contact’s last name, but ask you to still count all contacts with the first name “John”. How would you approach that? Well, the database scratches his head in this situation as well.</p>
<p>如果我将书的顺序打乱, 以名排序, 问你同样的问题, 你如何回答这个问题? </p>
<p>数据库也会面临同样的麻烦</p>
<p>Now lets look at an SQL query to demonstrate the same behavior with the MySQL optimizer:</p>
<p>现在, 关注一个 SQL 语句来和 MySQL 优化器演示这个行为</p>
<p>Having the index contacts (first_name, last_name) is ideal here, because the index starts with our filtering condition and ends with another column in the SELECT clause.</p>
<p>如果有一个索引组合 (first_name, last_name) 在这里是很好的, 因为索引由 first_name 开始, 由 last_name 结束</p>
<p>(PS. 其实这个 High Performance MySQL 第 5 节有详细讨论) </p>
<p>(这里的优化的前提是, 该索引是 B-tree 类型, 如果是其他的, 比如 hash 类型, 那么可能就没有什么优化效果)</p>
<p>But, having the reverse index contacts (last_name, first_name) is rather useless, as the database can’t use the index for filtering, as the column we need is second in the index and not first.</p>
<p>如果有一个相反顺序的索引, 那么就是无用的</p>
<p>(因为如果是 B-tree 的话, 根本无法索引 = =)</p>
<p>The conclusion from this example is that the order of columns in an index is rather important.</p>
<p>最后点了一下题</p>
<h2 id="Adding-redundant-indexes"><a href="#Adding-redundant-indexes" class="headerlink" title="Adding redundant indexes"></a>Adding redundant indexes</h2><h2 id="增加冗余索引"><a href="#增加冗余索引" class="headerlink" title="增加冗余索引"></a>增加冗余索引</h2><p>Indexes are magnificent when trying to optimize your SQL queries and they can improve performance significantly.</p>
<p>索引在优化你的 SQL 语句和显著提升性能上很有帮助</p>
<p>But, they come with a downside as well. Each index you’re creating should be kept updated and in sync when changes occur in your databases. So for each INSERT / UPDATE / DELETE in your databases, all relevant indexes should be updated. This update can take sometime, especially with large tables / indexes.</p>
<p>但是, 它们也有一些缺点, 每个你创建的索引在你数据库变化时必须保持更新和同步</p>
<p>所以 每个 INSERT/UPDATE/DELETE 操作都会引起相关索引的更新, 这些操作所引起的索引可能会很耗时</p>
<p>Therefore, do not create indexes unless you know you’ll need them.</p>
<p>Also, we highly recommend to analyze your database once in a while, searching for any <a href="https://www.eversql.com/how-to-find-unused-indexes-in-a-mysql-database/" target="_blank" rel="noopener">redundant indexes that can be removed</a>.</p>
<p>所以, 除非你知道你需要它们, 否则不要创建无用的索引</p>
<p>同样地, 我们极力推荐每个一段时间, 分析一下数据库, 删除冗余的索引</p>
<h3 id="How-to-automate-index-creation-and-SQL-query-optimization"><a href="#How-to-automate-index-creation-and-SQL-query-optimization" class="headerlink" title="How to automate index creation and SQL query optimization?"></a>How to automate index creation and SQL query optimization?</h3><p>If you’re looking for a way to automate your index creation, while also adding the benefit of a proprietary indexing algorithm and query optimization recommendations, you can try out <a href="https://www.eversql.com/" target="_blank" rel="noopener">EverSQL Query Optimizer</a> which does all the heavy lifting for you.</p>
<p>(广告, 有兴趣可以去原页面试试)</p>
<h2 id="How-to-track-redundant-indexes-in-MySQL"><a href="#How-to-track-redundant-indexes-in-MySQL" class="headerlink" title="How to track redundant indexes in MySQL?"></a>How to track redundant indexes in MySQL?</h2><p>(这是在另一个页面的片段)</p>
<p>如何跟踪 MySQL 中冗余的索引</p>
<p>Starting MySQL 5.6, the database keeps track of index usage as part of its PERFORMANCE SCHEMA. This data can be queried using the <strong>schema_unused_indexes</strong> view, which displays indexes for which there are no events. Having no events indicates that these indexes might be redundant and unused for a while.</p>
<p>自 MySQL 5.6 开始, 数据库持续跟踪它 PERFORMANCE SCHEMA 中未使用的索引</p>
<p>这些数据可以用 schema_unused_indexes 来查询</p>
<p>显示哪些索引没有工作过, 这表示这些索引是冗余的, 在一段时间内没有使用过</p>
<p>But life isn’t that good, not yet at least. The potential obstacle here is that this information is re-counted every time MySQL is restarted. Therefore, in order to get reliable information, you should query these views a while after the MySQL instance was started. How long after the startup you’re asking? Well, that depends. My question back to you will be – how busy your database is? Do you know if all types of queries are usually executed in the database in a specific period of time? If so, that’s your window.</p>
<p>但是生活没有那么美好, 至少现在没有. 潜在的障碍是这些信息会在每次 MySQL 重启时重新统计</p>
<p>所以, 为了避免这种情况, 你应该在 MySQL 启动一段时间后去查询这些数据</p>
<p>这时间的长短取决与你数据库的忙碌程度</p>
<p>So let’s take a look at how it’s done: (让我们来看一看如何完成)</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> sys.schema_unused_indexes;</span><br><span class="line"></span><br><span class="line">object_schema	object_name	index_name</span><br><span class="line">mydb			age			agecountry_index</span><br><span class="line">mydb			country		agecountry_index</span><br></pre></td></tr></table></figure>
<p>(PS. 显然, 如果数据可靠, 那么 age 表中的 agecountry_index 和 country 表中的 agecountry_index 是可以删除的)</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/09/read/B-tree/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cas">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cas's website">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/09/read/B-tree/" class="post-title-link" itemprop="url">read/B-tree</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-09 17:17:38" itemprop="dateCreated datePublished" datetime="2020-01-09T17:17:38+08:00">2020-01-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-07-25 17:54:48" itemprop="dateModified" datetime="2019-07-25T17:54:48+08:00">2019-07-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="原文地址-https-en-wikipedia-org-wiki-B-tree"><a href="#原文地址-https-en-wikipedia-org-wiki-B-tree" class="headerlink" title="原文地址 : https://en.wikipedia.org/wiki/B-tree"></a>原文地址 : <a href="https://en.wikipedia.org/wiki/B-tree" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/B-tree</a></h2><h2 id="B-tree"><a href="#B-tree" class="headerlink" title="B-tree"></a>B-tree</h2><p>In <a href="https://en.wikipedia.org/wiki/Computer_science" target="_blank" rel="noopener">computer science</a>, a <strong>B-tree</strong> is a self-balancing <a href="https://en.wikipedia.org/wiki/Tree_data_structure" target="_blank" rel="noopener">tree data structure</a> that maintains sorted data and allows searches, sequential access, insertions, and deletions in <a href="https://en.wikipedia.org/wiki/Logarithmic_time" target="_blank" rel="noopener">logarithmic time</a>. The B-tree is a generalization of a <a href="https://en.wikipedia.org/wiki/Binary_search_tree" target="_blank" rel="noopener">binary search tree</a> in that a node can have more than two children.<a href="https://en.wikipedia.org/wiki/B-tree#cite_note-Comer-1" target="_blank" rel="noopener">[1]</a> Unlike other <a href="https://en.wikipedia.org/wiki/Self-balancing_binary_search_tree" target="_blank" rel="noopener">self-balancing binary search trees</a>, the B-tree is well suited for storage systems that read and write relatively large blocks of data, such as discs. It is commonly used in <a href="https://en.wikipedia.org/wiki/Database" target="_blank" rel="noopener">databases</a> and <a href="https://en.wikipedia.org/wiki/File_system" target="_blank" rel="noopener">file systems</a>.</p>
<p>What, if anything, the <em>B</em> stands for has never been established.</p>
<p>在计算机科学中, B-tree 是自平衡树数据结构, 管理排序后的数据, 能常量时间内搜索. 序列访问, 插入和删除操作</p>
<p>B-tree 是二分查找树的广泛实现, 即一个节点可以有超过两个子节点</p>
<p>不像其他自平衡二分查找树, B-tree 适用于存储系统, 用作读取和写入相当庞大的数据</p>
<p>比如 discs, 通常被数据库和操作系统使用</p>
<h3 id="Overview-概览"><a href="#Overview-概览" class="headerlink" title="Overview (概览)"></a>Overview (概览)</h3><p>In B-trees, internal (<a href="https://en.wikipedia.org/wiki/Leaf_node" target="_blank" rel="noopener">non-leaf</a>) nodes can have a variable number of child nodes within some pre-defined range. When data is inserted or removed from a node, its number of child nodes changes. In order to maintain the pre-defined range, internal nodes may be joined or split. Because a range of child nodes is permitted, B-trees do not need re-balancing as frequently as other self-balancing search trees, but may waste some space, since nodes are not entirely full. The lower and upper bounds on the number of child nodes are typically fixed for a particular implementation. For example, in a <a href="https://en.wikipedia.org/wiki/2-3_tree" target="_blank" rel="noopener">2-3 B-tree</a> (often simply referred to as a <strong>2-3 tree</strong>), each internal node may have only 2 or 3 child nodes.</p>
<p>Each internal node of a B-tree contains a number of <a href="https://en.wikipedia.org/wiki/Unique_key" target="_blank" rel="noopener">keys</a>. The keys act as separation values which divide its <a href="https://en.wikipedia.org/wiki/Subtree" target="_blank" rel="noopener">subtrees</a>. For example, if an internal node has 3 child nodes (or subtrees) then it must have 2 keys: <em>a</em>1 and <em>a</em>2. All values in the leftmost subtree will be less than <em>a</em>1, all values in the middle subtree will be between <em>a</em>1 and <em>a</em>2, and all values in the rightmost subtree will be greater than <em>a</em>2.</p>
<p>在 B-tree 中, 内部(非叶子)节点可以在预定义范围内拥有可变数量的子节点</p>
<p>当从节点中插入或删除数据时, 子节点的数量改变. 为了管理预定义的范围, 内部节点可以连接或分裂</p>
<p>因为子节点的范围是受限的, B-tree 不需要像其他自平衡二分查找数一样频繁地重平衡, 但是会浪费一些空间, 因为节点不是填充满的</p>
<p>子节点数量的上限和下限通常有具体的实现固定, 比如 2-3 B-tree(通常简称 2-3 tree) 每个内部节点只有 2 个 或 3个子节点</p>
<p>每个 B-tree 的内部节点含有一些 keys, keys 充当分离的值 分离子树</p>
<p>比如, 如果内部节点有 3 个子节点(或子树) 那么, 它必须有 2 个 keys : a1 和 a2</p>
<p>所有在最左边子树的值 &lt;a1, 所有在中间子树的值 &gt;a1 &lt;a2, 在最右子树中的所有值 &gt;a2</p>
<p>(PS. 这里没有考虑 = 的情况, 不过还行, 等于放在值的左边还是右边, 不会有太大影响)</p>
<p>Usually, the number of keys is chosen to vary between {\displaystyle d}<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/e85ff03cbe0c7341af6b982e47e9f90d235c66ab" alt="d"> and {\displaystyle 2d}<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/d8106478cb4da6af49992eeb3a3b8690d27797ad" alt="2d">, where {\displaystyle d}<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/e85ff03cbe0c7341af6b982e47e9f90d235c66ab" alt="d"> is the minimum number of keys, and {\displaystyle d+1}<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/056e0c06c828dbe71a0f9021b2828ff176a3d337" alt="d+1"> is the minimum <a href="https://en.wikipedia.org/wiki/Outdegree#Indegree_and_outdegree" target="_blank" rel="noopener">degree</a> or <a href="https://en.wikipedia.org/wiki/Branching_factor" target="_blank" rel="noopener">branching factor</a> of the tree. In practice, the keys take up the most space in a node. The factor of 2 will guarantee that nodes can be split or combined. If an internal node has {\displaystyle 2d}<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/d8106478cb4da6af49992eeb3a3b8690d27797ad" alt="2d"> keys, then adding a key to that node can be accomplished by splitting the hypothetical {\displaystyle 2d+1}<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/d68ab692c5c4a44b63f3bd320249b8cb8d035191" alt="2d+1"> key node into two {\displaystyle d}<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/e85ff03cbe0c7341af6b982e47e9f90d235c66ab" alt="d"> key nodes and moving the key that would have been in the middle to the parent node. Each split node has the required minimum number of keys. Similarly, if an internal node and its neighbor each have {\displaystyle d}<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/e85ff03cbe0c7341af6b982e47e9f90d235c66ab" alt="d"> keys, then a key may be deleted from the internal node by combining it with its neighbor. Deleting the key would make the internal node have {\displaystyle d-1}<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/0195b64ba44bcc80b4c98e9d34256b4043fe519e" alt="d-1"> keys; joining the neighbor would add {\displaystyle d}<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/e85ff03cbe0c7341af6b982e47e9f90d235c66ab" alt="d"> keys plus one more key brought down from the neighbor’s parent. The result is an entirely full node of {\displaystyle 2d}<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/d8106478cb4da6af49992eeb3a3b8690d27797ad" alt="2d"> keys.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/09/other/aQuestionAboutStaticKeyword/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cas">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cas's website">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/09/other/aQuestionAboutStaticKeyword/" class="post-title-link" itemprop="url">other/aQuestionAboutStaticKeyword</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-09 17:14:50" itemprop="dateCreated datePublished" datetime="2020-01-09T17:14:50+08:00">2020-01-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="一个关于-static-的问题"><a href="#一个关于-static-的问题" class="headerlink" title="一个关于 static 的问题"></a>一个关于 static 的问题</h3><p>2019年4月22日19:42:18  </p>
<p>日常的一天, 做做 leetcode, 但是突然发现了关于 leetcode 代码优化的问题 </p>
<p><img src="https://imgur.com/cH0JYBG.png" alt=""></p>
<p>题目大概是要你中序遍历树</p>
<p>(看到题目的时候愣了一下, 怀疑自己是不是眼花了, 直到看到了 Follow up…  emmm, 好吧, 迭代)</p>
<p>总之我先用递归试了一下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left)</span><br><span class="line">            inorderTraversal(root-&gt;left);</span><br><span class="line"></span><br><span class="line">        ret.push_back(root-&gt;val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right)</span><br><span class="line">            inorderTraversal(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://imgur.com/NMNndgq.png" alt=""></p>
<p>但是它总是给我报这个错</p>
<p>这是没有理由的! 我代码中不可能无中生有</p>
<p>我怀疑这是 leetcode 平台对于用户所做的一种优化  </p>
<p>而这种优化与我使用 static 关键字相冲突</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">cas</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">85</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">cas</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
