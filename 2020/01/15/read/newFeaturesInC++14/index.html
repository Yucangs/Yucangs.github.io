<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Muse',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="new features in c++14From : wiki New language features[edit]These are the features added to the core language of C++14. Function return type deduction[edit]C++11 allowed lambda functions to deduce the">
<meta property="og:type" content="article">
<meta property="og:title" content="read&#x2F;newFeaturesInC++14">
<meta property="og:url" content="http://yoursite.com/2020/01/15/read/newFeaturesInC++14/index.html">
<meta property="og:site_name" content="cas&#39;s website">
<meta property="og:description" content="new features in c++14From : wiki New language features[edit]These are the features added to the core language of C++14. Function return type deduction[edit]C++11 allowed lambda functions to deduce the">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-01-15T01:37:20.321Z">
<meta property="article:modified_time" content="2020-01-14T03:22:10.000Z">
<meta property="article:author" content="cas">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/2020/01/15/read/newFeaturesInC++14/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>read/newFeaturesInC++14 | cas's website</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">cas's website</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">casyup.me@outlook.com</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="Searching..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/15/read/newFeaturesInC++14/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cas">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cas's website">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          read/newFeaturesInC++14
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-15 09:37:20" itemprop="dateCreated datePublished" datetime="2020-01-15T09:37:20+08:00">2020-01-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-01-14 11:22:10" itemprop="dateModified" datetime="2020-01-14T11:22:10+08:00">2020-01-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="new-features-in-c-14"><a href="#new-features-in-c-14" class="headerlink" title="new features in c++14"></a>new features in c++14</h2><p>From : <a href="https://en.wikipedia.org/wiki/C%2B%2B14" target="_blank" rel="noopener">wiki</a></p>
<h2 id="New-language-features-edit"><a href="#New-language-features-edit" class="headerlink" title="New language features[edit]"></a>New language features[<a href="https://en.wikipedia.org/w/index.php?title=C%2B%2B14&action=edit&section=1" target="_blank" rel="noopener">edit</a>]</h2><p>These are the features added to the core language of C++14.</p>
<h3 id="Function-return-type-deduction-edit"><a href="#Function-return-type-deduction-edit" class="headerlink" title="Function return type deduction[edit]"></a>Function return type deduction[<a href="https://en.wikipedia.org/w/index.php?title=C%2B%2B14&action=edit&section=2" target="_blank" rel="noopener">edit</a>]</h3><p>C++11 allowed <a href="https://en.wikipedia.org/wiki/Lambda_function_(computer_programming)" target="_blank" rel="noopener">lambda functions</a> to deduce the return type based on the type of the expression given to the return statement. C++14 provides this ability to all functions. It also extends these facilities to lambda functions, allowing return type deduction for functions that are not of the form <code>return expression;</code>.<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-wong1-3" target="_blank" rel="noopener">[3]</a></p>
<p>c++允许 lambda 表达式根据返回值表达式推测返回值类型, c++14将其范围提升到了所有函数. </p>
<p>(后面这句我不明白它是什么意思)</p>
<p>In order to induce return type deduction, the function must be declared with <code>auto</code> as the return type, but without the trailing return type specifier in C++11:</p>
<p>为了引进返回值推测, 需要在声明时在返回值类型上带上 auto 关键字. 而不需要尾随返回值说明符.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto DeduceReturnType();   &#x2F;&#x2F; Return type to be determined.</span><br></pre></td></tr></table></figure>

<p>If multiple return expressions are used in the function’s implementation, then they must all deduce the same type.<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-deduce-4" target="_blank" rel="noopener">[4]</a></p>
<p>如果函数实现中存在多个返回值表达式, 它们必须被能被推测为一种类型. </p>
<p>Functions that deduce their return types can be forward declared, but they cannot be used until they have been defined. Their definitions must be available to the translation unit that uses them.</p>
<p>返回值类型推导可以前向声明. 但是直到被定义时才能使用. 定义必须能被翻译单元使用.</p>
<p><a href="https://en.wikipedia.org/wiki/Recursion" target="_blank" rel="noopener">Recursion</a> can be used with a function of this type, but the recursive call must happen after at least one return statement in the definition of the function:<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-deduce-4" target="_blank" rel="noopener">[4]</a></p>
<p>递归函数也可以使用返回值推导, 但是必须在至少一个返回语句之后使用.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">auto Correct(int i)</span><br><span class="line">&#123;</span><br><span class="line">  if (i &#x3D;&#x3D; 1)</span><br><span class="line">    return i;             &#x2F;&#x2F; return type deduced as int</span><br><span class="line"></span><br><span class="line">  return Correct(i-1)+i;  &#x2F;&#x2F; ok to call it now</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">auto Wrong(int i)</span><br><span class="line">&#123;</span><br><span class="line">  if (i !&#x3D; 1)</span><br><span class="line">    return Wrong(i-1)+i;  &#x2F;&#x2F; Too soon to call this. No prior return statement.</span><br><span class="line"></span><br><span class="line">  return i;               &#x2F;&#x2F; return type deduced as int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Alternate-type-deduction-on-declaration-5"><a href="#Alternate-type-deduction-on-declaration-5" class="headerlink" title="Alternate type deduction on declaration[5]"></a>Alternate type deduction on declaration<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-5" target="_blank" rel="noopener">[5]</a></h3><p>In C++11, two methods of type deduction were added. <code>auto</code> was a way to create a variable of the appropriate type, based on a given expression. <code>decltype</code> was a way to compute the type of a given expression. However, <code>decltype</code> and <code>auto</code> deduce types in different ways. In particular, <code>auto</code> always deduces a non-reference type, as though by using <code>std::decay</code>, while <code>auto&amp;&amp;</code> always deduces a reference type. However, <code>decltype</code> can be prodded into deducing a reference or non-reference type, based on the value category of the expression and the nature of the expression it is deducing:<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-wong1-3" target="_blank" rel="noopener">[3]</a></p>
<p>在 c++11, 引进了两种类型推导. <code>auto</code> 和 <code>decltype</code> <code>auto</code> 总是推导出非引用类型, <code>decltype</code> 则推导出完整的类型.  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int   i;</span><br><span class="line">int&amp;&amp; f();</span><br><span class="line">auto          x3a &#x3D; i;     &#x2F;&#x2F; decltype(x3a) is int</span><br><span class="line">decltype(i)   x3d &#x3D; i;     &#x2F;&#x2F; decltype(x3d) is int</span><br><span class="line">auto          x4a &#x3D; (i);   &#x2F;&#x2F; decltype(x4a) is int</span><br><span class="line">decltype((i)) x4d &#x3D; (i);   &#x2F;&#x2F; decltype(x4d) is int&amp;</span><br><span class="line">auto          x5a &#x3D; f();   &#x2F;&#x2F; decltype(x5a) is int</span><br><span class="line">decltype(f()) x5d &#x3D; f();   &#x2F;&#x2F; decltype(x5d) is int&amp;&amp;</span><br></pre></td></tr></table></figure>

<p>C++14 adds the <code>decltype(auto)</code> syntax. This allows <code>auto</code> declarations to use the <code>decltype</code> rules on the given expression.</p>
<p>c++ 增加了 <code>decltype(auto)</code> 语法, 这使 <code>auto</code> 声明可以在指定表达式上使用 <code>decltype</code> 规则.</p>
<p>The <code>decltype(auto)</code> syntax can also be used with <a href="https://en.wikipedia.org/wiki/C%2B%2B14#Function_return_type_deduction" target="_blank" rel="noopener">return type deduction</a>, by using <code>decltype(auto)</code> syntax instead of <code>auto</code> for the function’s return type deduction.<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-deduce-4" target="_blank" rel="noopener">[4]</a></p>
<p><code>decltype(auto)</code> 语法还可以在返回值类型推导上使用.</p>
<h3 id="Relaxed-constexpr-restrictions-edit"><a href="#Relaxed-constexpr-restrictions-edit" class="headerlink" title="Relaxed constexpr restrictions[edit]"></a>Relaxed constexpr restrictions[<a href="https://en.wikipedia.org/w/index.php?title=C%2B%2B14&action=edit&section=4" target="_blank" rel="noopener">edit</a>]</h3><p><a href="https://en.wikipedia.org/wiki/C%2B%2B11" target="_blank" rel="noopener">C++11</a> introduced the concept of a constexpr-declared function; a function which could be executed at compile time. Their return values could be consumed by operations that require constant expressions, such as an integer template argument. However, C++11 constexpr functions could only contain a single expression that is returned (as well as <code>static_assert</code>s and a small number of other declarations).</p>
<p>c++引进了常量声明函数(一个可以在编译期执行的函数). 他么的返回值可以被常量表达式使用. 然而, c++11 常量表达式函数只能包含单个返回的表达式</p>
<p>C++14 relaxes these restrictions. Constexpr-declared functions may now contain the following:<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-wong1-3" target="_blank" rel="noopener">[3]</a></p>
<p>c++14 取消了这些限制, 常量表达式函数可以包含以下: </p>
<ul>
<li><p>Any declarations except:</p>
<ul>
<li><p><code>static</code> or <code>thread_local</code> variables.</p>
<p><code>staic</code> 或 <code>thread_local</code> 变量.</p>
</li>
<li><p>Variable declarations without initializers.</p>
<p>没有初始化的变量声明(???)</p>
</li>
</ul>
</li>
<li><p>The conditional branching statements <code>if</code> and <code>switch</code>.</p>
<p>if 和 switch 条件语句</p>
</li>
<li><p>Any looping statement, including range-based <code>for</code>.</p>
<p>任何循环语句, 包括基于循环的 for</p>
</li>
<li><p>Expressions which change the value of an object if the lifetime of that object began within the constant expression function. This includes calls to any non-<code>const</code> <code>constexpr</code>-declared non-static member functions.</p>
<p>可更改开始于常量表达式函数的对象的值. 这包括任何对非常属性, 常量表达式定义, 非静态成员函数的调用.</p>
</li>
</ul>
<p><code>goto</code> statements are forbidden in C++14 relaxed constexpr-declared functions.</p>
<p>Also, C++11 stated that all non-static member functions that were declared <code>constexpr</code> were also implicitly declared <code>const</code>, with respect to <code>this</code>. That has since been removed; non-static member functions may be non-<code>const</code>.<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-6" target="_blank" rel="noopener">[6]</a> However, per the restrictions above, a non-<code>const</code> <code>constexpr</code> member function can only modify a class member if that object’s lifetime began within the constant expression evaluation.</p>
<p>C++11规定所有非静态, 被 <code>constexpr</code> 声明的成员函数是隐式声明为 <code>const</code> 的. 这同样也被移除了, 非静态成员函数可以是 <code>non-const</code> 的. 然而, 根据上面的限制, 一个 <code>non-const</code> <code>constexpr</code> 的成员函数只能更改对象生命周期随常量表达式求值开始的对象的成员(???) </p>
<p>(我在其他文档中并未看到具体的关于更改值的介绍, 我简单理解的话, constexpr 现已可以支持循环和分支语句, 并且可以包含 static 和 thread_local 变量)</p>
<h3 id="Variable-templates-edit"><a href="#Variable-templates-edit" class="headerlink" title="Variable templates[edit]"></a>Variable templates[<a href="https://en.wikipedia.org/w/index.php?title=C%2B%2B14&action=edit&section=5" target="_blank" rel="noopener">edit</a>]</h3><p>In prior versions of <a href="https://en.wikipedia.org/wiki/C%2B%2B" target="_blank" rel="noopener">C++</a>, only functions, classes or type aliases could be templated. C++14 now allows the creation of variables that are templated. An example given in the proposal is a variable <code>pi</code> that can be read to get the value of <a href="https://en.wikipedia.org/wiki/Pi" target="_blank" rel="noopener">pi</a> for various types (e.g., <code>3</code> when read as an integral type; the closest value possible with <code>float</code>, <code>double</code> or <code>long double</code> precision when read as <code>float</code>, <code>double</code> or <code>long double</code>, respectively; etc.).</p>
<p>在之前版本的 C++ 中, 类/类型别名可以模板化, C++14 允许创建变量模板. </p>
<p>The usual rules of templates apply to such declarations and definitions, including specialization.<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-isocpp-7" target="_blank" rel="noopener">[7]</a><a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-8" target="_blank" rel="noopener">[8]</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">constexpr T pi &#x3D; T(3.141592653589793238462643383);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Usual specialization rules apply:</span><br><span class="line">template&lt;&gt;</span><br><span class="line">constexpr const char* pi&lt;const char*&gt; &#x3D; &quot;pi&quot;;</span><br></pre></td></tr></table></figure>



<h3 id="Aggregate-member-initialization-edit"><a href="#Aggregate-member-initialization-edit" class="headerlink" title="Aggregate member initialization[edit]"></a>Aggregate member initialization[<a href="https://en.wikipedia.org/w/index.php?title=C%2B%2B14&action=edit&section=6" target="_blank" rel="noopener">edit</a>]</h3><p><a href="https://en.wikipedia.org/wiki/C%2B%2B11" target="_blank" rel="noopener">C++11</a> added member initializers, expressions to be applied to members at class scope if a constructor did not initialize the member itself. The definition of aggregates was changed to explicitly exclude any class with member initializers; therefore, they are not allowed to use aggregate initialization.</p>
<p>C++14 relaxes this restriction,<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-wong1-3" target="_blank" rel="noopener">[3]</a> allowing aggregate initialization on such types. If the braced init list does not provide a value for that argument, the member initializer takes care of it.<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-9" target="_blank" rel="noopener">[9]</a></p>
<p>(我不明白说的什么, 成员初始化不是 C++11 就有的么?)</p>
<h3 id="Binary-literals-edit"><a href="#Binary-literals-edit" class="headerlink" title="Binary literals[edit]"></a>Binary literals[<a href="https://en.wikipedia.org/w/index.php?title=C%2B%2B14&action=edit&section=7" target="_blank" rel="noopener">edit</a>]</h3><p>Numeric literals in C++14 can be specified in <a href="https://en.wikipedia.org/wiki/Binary_number" target="_blank" rel="noopener">binary form</a>.<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-wong1-3" target="_blank" rel="noopener">[3]</a> The syntax uses the prefixes <code>0b</code> or <code>0B</code>. The syntax is also used in other languages e.g. <a href="https://en.wikipedia.org/wiki/Java_(programming_language)" target="_blank" rel="noopener">Java</a>, <a href="https://en.wikipedia.org/wiki/C_Sharp_(programming_language)" target="_blank" rel="noopener">C#</a>, <a href="https://en.wikipedia.org/wiki/Swift_(programming_language)" target="_blank" rel="noopener">Swift</a>, <a href="https://en.wikipedia.org/wiki/Go_(programming_language)" target="_blank" rel="noopener">Go</a>, <a href="https://en.wikipedia.org/wiki/Scala_(programming_language)" target="_blank" rel="noopener">Scala</a>, <a href="https://en.wikipedia.org/wiki/Ruby_(programming_language)" target="_blank" rel="noopener">Ruby</a>, <a href="https://en.wikipedia.org/wiki/Python_(programming_language)" target="_blank" rel="noopener">Python</a>, <a href="https://en.wikipedia.org/wiki/OCaml" target="_blank" rel="noopener">OCaml</a>, and as an unofficial extension in some C compilers since at least 2007.<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-gccbinaryliteralbugreport-10" target="_blank" rel="noopener">[10]</a></p>
<h3 id="Digit-separators-edit"><a href="#Digit-separators-edit" class="headerlink" title="Digit separators[edit]"></a>Digit separators[<a href="https://en.wikipedia.org/w/index.php?title=C%2B%2B14&action=edit&section=8" target="_blank" rel="noopener">edit</a>]</h3><p>In C++14, the single-quote character may be used arbitrarily as a <a href="https://en.wikipedia.org/wiki/Integer_literal#Digit_separators" target="_blank" rel="noopener">digit separator</a> in numeric literals, both <a href="https://en.wikipedia.org/wiki/Integer_literal" target="_blank" rel="noopener">integer literals</a> and floating point literals.<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-11" target="_blank" rel="noopener">[11]</a> This can make it easier for human readers to parse large numbers through <a href="https://en.wikipedia.org/wiki/Subitizing" target="_blank" rel="noopener">subitizing</a>.</p>
<p>auto integer_literal = 1’000’000;<br> auto floating_point_literal = 0.000’015’3;<br> auto binary_literal = 0b0100’1100’0110;<br> auto silly_example = 1’0’0’000’00;</p>
<p>C++14中, 单引号专用于整数/浮点数表示, 使人看起来可以更加清晰(woo, 真是个人性化的功能)</p>
<h3 id="Generic-lambdas-edit"><a href="#Generic-lambdas-edit" class="headerlink" title="Generic lambdas[edit]"></a>Generic lambdas[<a href="https://en.wikipedia.org/w/index.php?title=C%2B%2B14&action=edit&section=9" target="_blank" rel="noopener">edit</a>]</h3><p>In C++11, <a href="https://en.wikipedia.org/wiki/Anonymous_function" target="_blank" rel="noopener">lambda function</a> parameters need to be declared with concrete types. C++14 relaxes this requirement, allowing lambda function parameters to be declared with the <code>auto</code> type specifier.<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-isocpp-7" target="_blank" rel="noopener">[7]</a></p>
<p>在 C++11 中, lambda 函数参数声明必须具有具体的类型, C++14 放松了这个要求, 允许 lambda 函数参数使用 auto 关键字声明, 如下: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto lambda &#x3D; [](auto x, auto y) &#123;return x + y;&#125;;</span><br></pre></td></tr></table></figure>

<p>Concerning <code>auto</code> type deduction, generic lambdas follow the rules of template argument deduction (which are similar, but not identical in all respects[*<a href="https://en.wikipedia.org/wiki/Wikipedia:Please_clarify" target="_blank" rel="noopener">clarification needed</a>*]). The code above is equivalent to this:<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-12" target="_blank" rel="noopener">[12]</a></p>
<p>关于 auto 类型推导, 泛型 lambdas 遵循模板参数推导原则. 上述代码等同于以下:</p>
<p>(其实也证实了, 与其说是匿名函数, 不如说是带 () 重载的匿名类)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct</span><br><span class="line">&#123;</span><br><span class="line">  template&lt;typename T, typename U&gt;</span><br><span class="line">    auto operator()(T x, U y) const &#123;return x + y;&#125;</span><br><span class="line">&#125; lambda&#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>Generic lambdas are essentially templated functor lambdas.</p>
<p>泛型 lambdas 是更高效的函数模板</p>
<h3 id="Lambda-capture-expressions-edit"><a href="#Lambda-capture-expressions-edit" class="headerlink" title="Lambda capture expressions[edit]"></a>Lambda capture expressions[<a href="https://en.wikipedia.org/w/index.php?title=C%2B%2B14&action=edit&section=10" target="_blank" rel="noopener">edit</a>]</h3><p>C++11 lambda functions capture variables declared in their outer scope by value-copy or by reference. This means that value members of a lambda cannot be move-only types.<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-13" target="_blank" rel="noopener">[13]</a> C++14 allows captured members to be initialized with arbitrary expressions. This allows both capture by value-move and declaring arbitrary members of the lambda, without having a correspondingly named variable in an outer scope.<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-isocpp-7" target="_blank" rel="noopener">[7]</a></p>
<p>C++11 在其所在作用域中按值/引用捕获变量, 这意味着 lambda 成员的值不能是 move-only 类型. C++14 循序被捕获变量以任意形式初始化. 这使所有捕获可以值/移动, 以及声明任意的 lambda 成员, 而不需要在外层作用域中有对应的已命名成员.</p>
<p>This is done via the use of an initializer expression:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto lambda &#x3D; [value &#x3D; 1] &#123;return value;&#125;;</span><br></pre></td></tr></table></figure>

<p>The lambda function <code>lambda</code> returns 1, which is what <code>value</code> was initialized with. The declared capture deduces the type from the initializer expression as if by <code>auto</code>.</p>
<p>声明捕获像 auto 一样推导初始化表达式.</p>
<p>This can be used to capture by move, via the use of the standard <code>std::move</code> function:</p>
<p>还可以用于捕获移动语义(赞啊 -v- )</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;int&gt; ptr(new int(10));</span><br><span class="line">auto lambda &#x3D; [value &#x3D; std::move(ptr)] &#123;return *value;&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="The-attribute-deprecated-edit"><a href="#The-attribute-deprecated-edit" class="headerlink" title="The attribute [[deprecated]][edit]"></a>The attribute <code>[[deprecated]]</code>[<a href="https://en.wikipedia.org/w/index.php?title=C%2B%2B14&action=edit&section=11" target="_blank" rel="noopener">edit</a>]</h3><p>The <code>deprecated</code> attribute allows marking an entity <a href="https://en.wikipedia.org/wiki/Deprecated" target="_blank" rel="noopener">deprecated</a>, which makes it still legal to use but puts users on notice that use is discouraged and may cause a warning message to be printed during compilation. An optional <a href="https://en.wikipedia.org/wiki/String_literal" target="_blank" rel="noopener">string literal</a> can appear as the argument of <code>deprecated</code>, to explain the rationale for deprecation and/or to suggest a replacement.</p>
<p>deprecated 属性可以标记一个整体为’废弃的’, 继续使用这个整体是合法的, 但是用户会在编译时收到一个警告. </p>
<p>deprecated 可以增加字符串文本, 用作警示语.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[[deprecated]] int f();</span><br><span class="line"></span><br><span class="line">[[deprecated(&quot;g() is thread-unsafe. Use h() instead&quot;)]]</span><br><span class="line">void g( int&amp; x );</span><br><span class="line"></span><br><span class="line">void h( int&amp; x );</span><br><span class="line"></span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">  int a &#x3D; f(); &#x2F;&#x2F; warning: &#39;f&#39; is deprecated</span><br><span class="line">  g(a); &#x2F;&#x2F; warning: &#39;g&#39; is deprecated: g() is thread-unsafe. Use h() instead</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(在 gcc (Debian 6.3.0-18+deb9u1) 6.3.0 20170516 版本下, 对于类的支持有所不足)</p>
<h2 id="New-standard-library-features-edit"><a href="#New-standard-library-features-edit" class="headerlink" title="New standard library features[edit]"></a>New standard library features[<a href="https://en.wikipedia.org/w/index.php?title=C%2B%2B14&action=edit&section=12" target="_blank" rel="noopener">edit</a>]</h2><h3 id="Shared-mutexes-and-locking-edit"><a href="#Shared-mutexes-and-locking-edit" class="headerlink" title="Shared mutexes and locking[edit]"></a>Shared mutexes and locking[<a href="https://en.wikipedia.org/w/index.php?title=C%2B%2B14&action=edit&section=13" target="_blank" rel="noopener">edit</a>]</h3><p>C++14 adds a shared timed mutex and a companion shared lock type.<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-wong3-14" target="_blank" rel="noopener">[14]</a><a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-15" target="_blank" rel="noopener">[15]</a></p>
<p>C++14 增加了共享互斥锁, 以及他的’伴侣’共享锁类型.</p>
<p>(这里有点不好说, mutex 本身是一把锁, 而 lock 也是锁的意思, 不过是加锁, lock(mutex), emm, 应该是这意思)</p>
<h3 id="Heterogeneous-lookup-in-associative-containers-edit"><a href="#Heterogeneous-lookup-in-associative-containers-edit" class="headerlink" title="Heterogeneous lookup in associative containers[edit]"></a>Heterogeneous lookup in associative containers[<a href="https://en.wikipedia.org/w/index.php?title=C%2B%2B14&action=edit&section=14" target="_blank" rel="noopener">edit</a>]</h3><p>The <a href="https://en.wikipedia.org/wiki/C%2B%2B_Standard_Library" target="_blank" rel="noopener">C++ Standard Library</a> defines four associative container classes. These classes allow the user to look up a value based on a value of that type. The map containers allow the user to specify a key and a value, where lookup is done by key and returns a value. However, the lookup is always done by the specific key type, whether it is the key as in maps or the value itself as in sets.</p>
<p>C++ 标准库定义了四种关联的容器类, 这些类型使用户可以检查基于该值类型的值. 然而, 检查总是需要指定类型来完成 (??? 卧槽 你想干嘛???)</p>
<p>C++14 allows the lookup to be done via an arbitrary type, so long as the comparison operator can compare that type with the actual key type.<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-wong2-16" target="_blank" rel="noopener">[16]</a> This would allow a map from <code>std::string</code> to some value to compare against a <code>const char*</code> or any other type for which an <code>operator&lt;</code>overload is available. It is also useful for indexing composite objects in a <code>std::set</code> by the value of a single member without forcing the user of <code>find</code> to create a dummy object (for example creating an entire <code>struct Person</code> to find a person by name).</p>
<p>C++14 允许检查可以经由任意类型完成, 只要对比操作可以和正确的键类型对比. 这使 map&lt;std::string&gt;可以和 const char* 类型的值或其他有有效 &lt; 重载的操作符的类型(为什么一定是 <code>&lt;</code> ?  <code>&gt;</code> 它不香么?) </p>
<p>当要检查一个集合中的复合类型时, 不需要创建一个复杂的复合类型也可以检索 (比如: 检索 struct person, 可以使用他的名字, 而并不需要创建一个 person 对象)</p>
<p>To preserve backwards compatibility, heterogeneous lookup is only allowed when the comparator given to the associative container allows it. The standard library classes <code>std::less&lt;&gt;</code> and <code>std::greater&lt;&gt;</code> are augmented to allow heterogeneous lookup.<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-17" target="_blank" rel="noopener">[17]</a></p>
<p>为了保持向后兼容性, heterogeneous 检查只在关联的容器允许对比器时才适用. 标准库 std::less&lt;&gt;, std::greater&lt;&gt; 被 heterogeneous 检查接纳 (诶, 我不知道这该怎么写…)</p>
<p>(这是我在网上找到的代码, 其中两个包含 thread::id 的重载缺一不可, 也就是说编译器都会用到)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ThreadCmp</span> &#123;</span></span><br><span class="line">  <span class="keyword">using</span> is_transparent = <span class="keyword">void</span>;</span><br><span class="line">  <span class="comment">// Regular overload.</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::thread&amp; a, <span class="keyword">const</span> <span class="built_in">std</span>::thread&amp; b)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.get_id() &lt; b.get_id();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Transparent overloads</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::thread&amp; a, <span class="built_in">std</span>::thread::id b)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.get_id() &lt; b;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="built_in">std</span>::thread::id a, <span class="keyword">const</span> <span class="built_in">std</span>::thread&amp; b)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &lt; b.get_id();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//bool operator()(std::thread::id a, std::thread::id b) const &#123;</span></span><br><span class="line">  <span class="comment">//  return a &lt; b;</span></span><br><span class="line">  <span class="comment">//&#125;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::thread, ThreadCmp&gt; threads;</span><br><span class="line">    <span class="comment">// Can't construct an instance of `std::thread` with the same id, just to do the lookup.</span></span><br><span class="line">    <span class="comment">// But we can look up by id instead.</span></span><br><span class="line">    <span class="built_in">std</span>::thread::id id = this_thread::get_id();;</span><br><span class="line">    <span class="keyword">auto</span> it = threads.<span class="built_in">find</span>(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h3 id="Standard-user-defined-literals-edit"><a href="#Standard-user-defined-literals-edit" class="headerlink" title="Standard user-defined literals[edit]"></a>Standard user-defined literals[<a href="https://en.wikipedia.org/w/index.php?title=C%2B%2B14&action=edit&section=15" target="_blank" rel="noopener">edit</a>]</h3><p>C++11 defined the syntax for user-defined literal suffixes, but the standard library did not use any of them. C++14 adds the following standard literals:<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-wong2-16" target="_blank" rel="noopener">[16]</a></p>
<p>C++14 增加了以下标准字面量</p>
<ul>
<li><p>“s”, for creating the various <code>std::basic_string</code> types.</p>
<p>“s”, 创建各种 <code>std::basic_string</code> 类型</p>
</li>
<li><p>“h”, “min”, “s”, “ms”, “us”, “ns”, for creating the corresponding <code>std::chrono::duration</code> time intervals.</p>
<p>“h”, “min”, “s”, “ms”, “us”, “ns”, 创建对应的 <code>std::chrono::duration</code> 时间间隔</p>
</li>
<li><p>“if”, “i”, “il”, for creating the corresponding <code>std::complex</code>, <code>std::complex</code> and <code>std::complex</code> imaginary numbers.</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto str &#x3D; &quot;hello world&quot;s; &#x2F;&#x2F; auto deduces string</span><br><span class="line">auto dur &#x3D; 60s;            &#x2F;&#x2F; auto deduces chrono::seconds</span><br><span class="line">auto z   &#x3D; 1i;             &#x2F;&#x2F; auto deduces complex&lt;double&gt;</span><br></pre></td></tr></table></figure>

<p>The two “s” literals do not interact, as the string one only operates on <a href="https://en.wikipedia.org/wiki/String_literal" target="_blank" rel="noopener">string literals</a>, and the one for seconds operates only on numbers.<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-18" target="_blank" rel="noopener">[18]</a></p>
<h3 id="Tuple-addressing-via-type-edit"><a href="#Tuple-addressing-via-type-edit" class="headerlink" title="Tuple addressing via type[edit]"></a>Tuple addressing via type[<a href="https://en.wikipedia.org/w/index.php?title=C%2B%2B14&action=edit&section=16" target="_blank" rel="noopener">edit</a>]</h3><p>The <code>std::tuple</code> type introduced in C++11 allows an aggregate of typed values to be indexed by a compile-time constant integer. C++14 extends this to allow fetching from a tuple by type instead of by index.<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-wong2-16" target="_blank" rel="noopener">[16]</a> If the tuple has more than one element of the type, a compile-time error results:<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-19" target="_blank" rel="noopener">[19]</a></p>
<p>C++14 扩展了 <code>std::tuple</code> , 可以通过类型来获取元素, 如果 tuple 有多个相同类型, 则会出错.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tuple&lt;string, string, int&gt; t(&quot;foo&quot;, &quot;bar&quot;, 7);</span><br><span class="line">int i &#x3D; get&lt;int&gt;(t);        &#x2F;&#x2F; i &#x3D;&#x3D; 7</span><br><span class="line">int j &#x3D; get&lt;2&gt;(t);          &#x2F;&#x2F; Same as before: j &#x3D;&#x3D; 7</span><br><span class="line">string s &#x3D; get&lt;string&gt;(t);  &#x2F;&#x2F; Compile-time error due to ambiguity</span><br></pre></td></tr></table></figure>



<h3 id="Smaller-library-features-edit"><a href="#Smaller-library-features-edit" class="headerlink" title="Smaller library features[edit]"></a>Smaller library features[<a href="https://en.wikipedia.org/w/index.php?title=C%2B%2B14&action=edit&section=17" target="_blank" rel="noopener">edit</a>]</h3><p><code>std::make_unique</code> can be used like <code>std::make_shared</code> for <code>std::unique_ptr</code> objects.<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-isocpp-7" target="_blank" rel="noopener">[7]</a></p>
<p><code>std::integral_constant</code> gained an <code>operator()</code> overload to return the constant value.<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-wong2-16" target="_blank" rel="noopener">[16]</a></p>
<p>The class template <code>std::integer_sequence</code> and related alias templates were added for representing compile-time integer sequences, such as the indices of elements in a parameter pack.<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-intseqs-20" target="_blank" rel="noopener">[20]</a></p>
<p>The global <code>std::begin</code>/<code>std::end</code> functions were augmented with <code>std::cbegin</code>/<code>std::cend</code> functions, which return constant iterators, and <code>std::rbegin</code>/<code>std::rend</code> and <code>std::crbegin</code>/<code>std::crend</code> which return reverse iterators.</p>
<p>The <code>std::exchange</code> function template assigns a new value to a variable and returns the old value.<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-exchange-21" target="_blank" rel="noopener">[21]</a></p>
<p>New overloads of <code>std::equal</code>, <code>std::mismatch</code>, and <code>std::is_permutation</code> take a pair of iterators for the second range, so that the caller does not need to separately check that the two ranges are of the same length.<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-robustseqs-22" target="_blank" rel="noopener">[22]</a></p>
<p>The <code>std::is_final</code> type trait detects if a class is marked <code>final</code>.</p>
<p>The <code>std::quoted</code> stream I/O manipulator allows inserting and extracting strings with embedded spaces, by placing delimiters (defaulting to double-quotes) on output and stripping them on input, and escaping any embedded delimiters.<a href="https://en.wikipedia.org/wiki/C%2B%2B14#cite_note-quoted-23" target="_blank" rel="noopener">[23]</a></p>
<h2 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h2><ol>
<li><p>类型推导, type deduce</p>
<p>以 <code>auto</code> 为主, 可以推导返回值而不需返回值后置语法. 同时 <code>decltype</code> 可以用于推导 auto 的原类型</p>
</li>
<li><p>常量表达式加强 <code>constexpr</code></p>
<p><code>constexpr</code> 中可以有静态变量, thread_local 变量, 可以有分支和循环语句</p>
</li>
<li><p>值模板 variable template</p>
<p>不仅类, 现在值也可以模板化</p>
</li>
<li><p>数字分隔符 digit separators</p>
<p>使数字更加易读</p>
</li>
<li><p>加强 lambda</p>
<p>lambda 的参数可以是 auto 推导的了, 同时 lambda 的捕获增加了移动语义, 还可以不是外部成员(也就是自建变量)</p>
</li>
<li><p>关键字 [[deprecated]]</p>
<p>用于警示用户</p>
</li>
<li><p>新的字面量, “s”, “h”, “min” … </p>
<p>新的字面量, 用于快捷创建变量, 而不需显式转换类型</p>
</li>
<li><p>新的 tuple 元素索引方式</p>
<p>可以用类型来检索了呢 :)</p>
</li>
</ol>
<p>以上是我从 C++14 中印象比较深刻的新特性</p>
<p>these are my impressive new features in c++14 </p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/01/10/other/memoryAndCache/" rel="prev" title="other/memoryAndCache">
      <i class="fa fa-chevron-left"></i> other/memoryAndCache
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/01/16/read/routingAlgorithms/" rel="next" title="read/routingAlgorithms">
      read/routingAlgorithms <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#new-features-in-c-14"><span class="nav-number">1.</span> <span class="nav-text">new features in c++14</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#New-language-features-edit"><span class="nav-number">2.</span> <span class="nav-text">New language features[edit]</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Function-return-type-deduction-edit"><span class="nav-number">2.1.</span> <span class="nav-text">Function return type deduction[edit]</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Alternate-type-deduction-on-declaration-5"><span class="nav-number">2.2.</span> <span class="nav-text">Alternate type deduction on declaration[5]</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Relaxed-constexpr-restrictions-edit"><span class="nav-number">2.3.</span> <span class="nav-text">Relaxed constexpr restrictions[edit]</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Variable-templates-edit"><span class="nav-number">2.4.</span> <span class="nav-text">Variable templates[edit]</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Aggregate-member-initialization-edit"><span class="nav-number">2.5.</span> <span class="nav-text">Aggregate member initialization[edit]</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Binary-literals-edit"><span class="nav-number">2.6.</span> <span class="nav-text">Binary literals[edit]</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Digit-separators-edit"><span class="nav-number">2.7.</span> <span class="nav-text">Digit separators[edit]</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Generic-lambdas-edit"><span class="nav-number">2.8.</span> <span class="nav-text">Generic lambdas[edit]</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Lambda-capture-expressions-edit"><span class="nav-number">2.9.</span> <span class="nav-text">Lambda capture expressions[edit]</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#The-attribute-deprecated-edit"><span class="nav-number">2.10.</span> <span class="nav-text">The attribute [[deprecated]][edit]</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#New-standard-library-features-edit"><span class="nav-number">3.</span> <span class="nav-text">New standard library features[edit]</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Shared-mutexes-and-locking-edit"><span class="nav-number">3.1.</span> <span class="nav-text">Shared mutexes and locking[edit]</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Heterogeneous-lookup-in-associative-containers-edit"><span class="nav-number">3.2.</span> <span class="nav-text">Heterogeneous lookup in associative containers[edit]</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Standard-user-defined-literals-edit"><span class="nav-number">3.3.</span> <span class="nav-text">Standard user-defined literals[edit]</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Tuple-addressing-via-type-edit"><span class="nav-number">3.4.</span> <span class="nav-text">Tuple addressing via type[edit]</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Smaller-library-features-edit"><span class="nav-number">3.5.</span> <span class="nav-text">Smaller library features[edit]</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#summary"><span class="nav-number">4.</span> <span class="nav-text">summary</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">cas</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">102</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">cas</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
