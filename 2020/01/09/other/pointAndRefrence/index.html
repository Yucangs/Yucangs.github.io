<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Muse',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="前言最近看了&lt;现代操作系统&gt;, 从内存管理那一章中获得了一些东西: 分页和分段   其中分页的概念让我对内存的管理有了更加清晰的认知 什么是分页?就是将内存分为一个个小的页面(以4k为例).  在将磁盘数据加载进内存时, 以页为单位, 而将内存中的数据换出到磁盘中时, 也以页为单位.  对此, 一个具体的虚拟地址可以分为两部分: 1页号 + 地址  其中, 页号会被替换, 而地址会被保">
<meta property="og:type" content="article">
<meta property="og:title" content="other&#x2F;pointAndRefrence">
<meta property="og:url" content="http://yoursite.com/2020/01/09/other/pointAndRefrence/index.html">
<meta property="og:site_name" content="cas&#39;s website">
<meta property="og:description" content="前言最近看了&lt;现代操作系统&gt;, 从内存管理那一章中获得了一些东西: 分页和分段   其中分页的概念让我对内存的管理有了更加清晰的认知 什么是分页?就是将内存分为一个个小的页面(以4k为例).  在将磁盘数据加载进内存时, 以页为单位, 而将内存中的数据换出到磁盘中时, 也以页为单位.  对此, 一个具体的虚拟地址可以分为两部分: 1页号 + 地址  其中, 页号会被替换, 而地址会被保">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-01-09T09:14:16.214Z">
<meta property="article:modified_time" content="2020-01-09T09:12:51.834Z">
<meta property="article:author" content="cas">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/2020/01/09/other/pointAndRefrence/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>other/pointAndRefrence | cas's website</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">cas's website</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">casyup.me@outlook.com</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/09/other/pointAndRefrence/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cas">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cas's website">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          other/pointAndRefrence
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-09 17:14:16 / Modified: 17:12:51" itemprop="dateCreated datePublished" datetime="2020-01-09T17:14:16+08:00">2020-01-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近看了&lt;现代操作系统&gt;, 从内存管理那一章中获得了一些东西: 分页和分段  </p>
<p>其中分页的概念让我对内存的管理有了更加清晰的认知</p>
<h3 id="什么是分页"><a href="#什么是分页" class="headerlink" title="什么是分页?"></a>什么是分页?</h3><p>就是将内存分为一个个小的页面(以4k为例). </p>
<p>在将磁盘数据加载进内存时, 以页为单位, 而将内存中的数据换出到磁盘中时, 也以页为单位. </p>
<p>对此, 一个具体的虚拟地址可以分为两部分:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">页号 + 地址</span><br></pre></td></tr></table></figure>

<p>其中, 页号会被替换, 而地址会被保留:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">真实的地址 + 地址</span><br></pre></td></tr></table></figure>

<p>真实的地址存放到进程虚拟地址映射表中  </p>
<p>emmm… 也就是说, <strong>虚拟地址中, 有部分的地址是真实的</strong></p>
<p>(如果我能知道那部分假的地址, 是否就有办法操作真实磁盘中的数据呢? 我突然有了不太好的想法 :) )</p>
<h3 id="指针中是否会保留原始变量的地址"><a href="#指针中是否会保留原始变量的地址" class="headerlink" title="指针中是否会保留原始变量的地址?"></a>指针中是否会保留原始变量的地址?</h3><p>指针中存放了数据, 而这样的数据能够找到指针所指向的变量  </p>
<p>那么, 这样的数据是什么呢? 最直接的, 那么应该是地址, 考虑以下程序:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="number">11</span>     <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="number">12</span>     <span class="keyword">int</span> *p = &amp;i;</span><br><span class="line"><span class="number">13</span>     <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, &amp;i);</span><br><span class="line"><span class="number">14</span>     <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, &amp;p);</span><br><span class="line"><span class="number">15</span>     <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *((<span class="keyword">int</span> *)&amp;p));</span><br><span class="line"><span class="number">16</span> </span><br><span class="line"><span class="number">17</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">18</span> &#125;</span><br></pre></td></tr></table></figure>

<p>15打印的是指针本身内存中所指向的东西, 将它与变量i的地址做以下对比, 会相同么?  以下是输出结果:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x7fff12ca4efc</span><br><span class="line">0x7fff12ca4ef0</span><br><span class="line">315248380</span><br></pre></td></tr></table></figure>

<p>i的地址是 0x7fff12ca4efc, 而p中保存的值(我将它解释为整数)是: 315248380  </p>
<p>整型数字不怎么直观, 将它转为hex试试?  =&gt; 0x12ca4efc </p>
<p>有没有觉得熟悉?  0x7fff12ca4efc —– 0x12ca4efc   </p>
<p>除前面的 0x7fff, 后面的数字是一样的, 所以我们可以说指针保存了变量的地址, 但是并不准确  </p>
<p>那么 0x7fff 就是那个页号么? 指针中只会存放真是地址? 好像不那么对…</p>
<p>emmm… 好像可以继续尝试, 因为当前环境是32位的, 这个地址数字明显超出了32位的表现范围</p>
<p>(我居然忽略了这一点 = =…)</p>
<p>或许我能获得更多的数据? 在代码中加入了下面一行:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">16</span>     <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ((<span class="keyword">int</span> *)&amp;p)[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>

<p>得到了数据: 32767 =&gt; 0x7fff  </p>
<p>所以指针中直接保存了变量的地址(我们之前并没有拿到完全的数据, 地址超过了int的大小)  </p>
<p><strong>指针就是地址</strong></p>
<p>emmm… 好像这个笔记不是那么有意义做了…</p>
<p>我是不是太慢了? 这些东西应该是初学者就可以去钻研的内容</p>
<p>(@btw: 为什么是[1] 而不是 [-1])</p>
<h3 id="是否有办法知道哪些数据是与页号有关的"><a href="#是否有办法知道哪些数据是与页号有关的" class="headerlink" title="是否有办法知道哪些数据是与页号有关的?"></a>是否有办法知道哪些数据是与页号有关的?</h3><p>emmm… 那些东西与内核有关, 我现在没有办法获得</p>
<h3 id="其他的耦合知识-volatile"><a href="#其他的耦合知识-volatile" class="headerlink" title="其他的耦合知识: volatile"></a>其他的耦合知识: volatile</h3><p>在书中我还读到了一个非常有趣的知识, 那就是进程表项有一个<strong>是否缓存标志位</strong></p>
<p>这个标志位的意思是, 如果该位是1, 表示该页不被缓存  </p>
<p>意思是什么呢? 如果要访问的数据是在该页中的, 那么访问时会去访问磁盘  </p>
<p>而写入的时候, 也会直接往磁盘中写入, 因为内存中不缓存该页的数据</p>
<p>仔细想想和什么东西有关? 嗯, c++的 volatile 关键字</p>
<p>我打赌, volatile的实现一定与这东西有关(至少实现类似) 不过我现在的能力暂时无法证实</p>
<p>同时还有一个疑问, volatile 修饰一个变量, 而一个页是4k的, 如何将这两个东西分开呢? </p>
<h3 id="为什么是-1-而不是-1"><a href="#为什么是-1-而不是-1" class="headerlink" title="为什么是[1] 而不是 [-1]"></a>为什么是[1] 而不是 [-1]</h3><p>上面的例子中, 我继续访问数据, 使用的是 [1] 而不是 [-1]</p>
<p>我一开始是用 [-1], 因为栈是往下增长的, 之后发现 [1] 是正确的, 为什么?</p>
<p>的确实际上应该是 [1], 不然局部数组的访问就要乱套了 </p>
<p>但是栈的确是向下增长的, 从 fc 和 f0 中可以看出来 </p>
<p>那么底层到底对我的代码做了什么? 或许可以从汇编中得到答案</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">12 main:</span><br><span class="line">13 .LFB1079:</span><br><span class="line">14     .cfi_startproc</span><br><span class="line">15     .cfi_personality 0x3,__gxx_personality_v0</span><br><span class="line">16     pushq   %rbp</span><br><span class="line">17     .cfi_def_cfa_offset 16</span><br><span class="line">18     .cfi_offset 6, -16</span><br><span class="line">19     movq    %rsp, %rbp		&#x2F;&#x2F; 保存了栈底指针</span><br><span class="line">20     .cfi_def_cfa_register 6</span><br><span class="line">21     subq    $16, %rsp		&#x2F;&#x2F; 开拓栈帧, 16个字节</span><br><span class="line">22     movl    $1, -4(%rbp)		&#x2F;&#x2F; 嗯, 我们的数字1被放入内存了</span><br><span class="line">23     leaq    -4(%rbp), %rax	&#x2F;&#x2F; 将变量1的地址放入rax</span><br><span class="line">24     movq    %rax, -16(%rbp)	&#x2F;&#x2F; 将rax的值放入了栈... 栈顶?(因为这里是-16)</span><br><span class="line">25     leaq    -4(%rbp), %rax	&#x2F;&#x2F; 又将变量1的地址放入rax</span><br><span class="line">26     movq    %rax, %rsi		</span><br><span class="line">27     movl    $.LC0, %edi		&#x2F;&#x2F; .LC0:.string &quot;%p\n&quot;</span><br><span class="line">28     movl    $0, %eax			</span><br><span class="line">29     call    printf			&#x2F;&#x2F; rax存了变量1的地址, 这里应该对应: printf(&quot;%p\n&quot;, &amp;i);</span><br><span class="line">30     leaq    -16(%rbp), %rax	&#x2F;&#x2F; 将栈顶的地址放入了rax</span><br><span class="line">31     movq    %rax, %rsi		</span><br><span class="line">32     movl    $.LC0, %edi</span><br><span class="line">33     movl    $0, %eax</span><br><span class="line">34     call    printf			&#x2F;&#x2F; 现在rax是栈顶, 所以对应这一句: printf(&quot;%p\n&quot;, &amp;p);</span><br><span class="line">35     leaq    -16(%rbp), %rax	&#x2F;&#x2F; 把p的地址放入rax</span><br><span class="line">36     movl    (%rax), %eax		&#x2F;&#x2F; 又移动到eax</span><br><span class="line">37     movl    %eax, %esi		&#x2F;&#x2F; 还移动 &#x3D; &#x3D;</span><br><span class="line">38     movl    $.LC1, %edi		&#x2F;&#x2F; .LC1:.string &quot;%d\n&quot;</span><br><span class="line">39     movl    $0, %eax</span><br><span class="line">40     call    printf			&#x2F;&#x2F; 对应: printf(&quot;%d\n&quot;, ((int *)&amp;p)[0]);</span><br><span class="line">41     leaq    -16(%rbp), %rax	</span><br><span class="line">42     addq    $4, %rax			&#x2F;&#x2F; *将rax+4, 也就是往栈顶移动的</span><br><span class="line">43     movl    (%rax), %eax</span><br><span class="line">44     movl    %eax, %esi</span><br><span class="line">45     movl    $.LC1, %edi</span><br><span class="line">46     movl    $0, %eax</span><br><span class="line">47     call    printf			&#x2F;&#x2F; 对应: printf(&quot;%d\n&quot;, ((int *)&amp;p)[1]);</span><br><span class="line">48     movl    $0, %eax</span><br><span class="line">49     leave</span><br><span class="line">50     .cfi_def_cfa 7, 8</span><br><span class="line">51     ret</span><br><span class="line">52     .cfi_endproc</span><br></pre></td></tr></table></figure>

<p>那么了解了, 虽然栈是往下移动的, 分配栈帧时也是往下移动的  </p>
<p>但是 [1] 这种位移时, 是往上移动的, 也就是往高地址移动的</p>
<p>因为变量本身的地址开始是在栈的低地址, 是往上移动的  </p>
<p>没有问题, 是正常的 :)</p>
<p>但是我又发现一个问题, 这里指针所占用的空间为8字节!</p>
<p>不过又想了一下, 这好像也正常的, 毕竟64位嘛…</p>
<h3 id="引用呢-引用又是什么样子的呢"><a href="#引用呢-引用又是什么样子的呢" class="headerlink" title="引用呢? 引用又是什么样子的呢?"></a>引用呢? 引用又是什么样子的呢?</h3><p>时隔几天, 突然想到了这个东西, 引用又是什么样子的呢? 它和指针实质的区别?</p>
<p>参考以下代码:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;i2 = i;</span><br><span class="line"><span class="keyword">int</span> *pi = &amp;i;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p\n"</span>, &amp;i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p\n"</span>, &amp;i2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p\n"</span>, &amp;pi);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *pi);</span><br></pre></td></tr></table></figure>

<p>emmm… 这很简单, 分别打印地址和值</p>
<p>我们来看看汇编:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line">.LFB1084:</span><br><span class="line">    .cfi_startproc</span><br><span class="line">    .cfi_personality 0x3,__gxx_personality_v0</span><br><span class="line">    pushq   %rbp</span><br><span class="line">    .cfi_def_cfa_offset 16</span><br><span class="line">    .cfi_offset 6, -16</span><br><span class="line">    movq    %rsp, %rbp</span><br><span class="line">    .cfi_def_cfa_register 6</span><br><span class="line">    subq    $32, %rsp			&#x2F;&#x2F; 32字节的栈帧</span><br><span class="line">    movl    $100, -12(%rbp)		&#x2F;&#x2F; i</span><br><span class="line">    leaq    -12(%rbp), %rax		&#x2F;&#x2F; i 的地址放入了rax</span><br><span class="line">    movq    %rax, -8(%rbp)		&#x2F;&#x2F; 直接将 rax 的值放入了 i2, 也就是说, 引用也保存了变量的地址</span><br><span class="line">    leaq    -12(%rbp), %rax		&#x2F;&#x2F; 这是一个完全可以优化掉的操作</span><br><span class="line">    movq    %rax, -24(%rbp)		&#x2F;&#x2F; pi </span><br><span class="line">    leaq    -12(%rbp), %rax		&#x2F;&#x2F; 你家 rax 都没变过, 你怎么还来 (눈_눈)</span><br><span class="line">    movq    %rax, %rsi</span><br><span class="line">    movl    $.LC0, %edi</span><br><span class="line">    movl    $0, %eax</span><br><span class="line">    call    printf				&#x2F;&#x2F; &amp;i</span><br><span class="line">    movq    -8(%rbp), %rax		&#x2F;&#x2F; 这里直接将栈中的值放进入了</span><br><span class="line">    movq    %rax, %rsi</span><br><span class="line">    movl    $.LC0, %edi</span><br><span class="line">    movl    $0, %eax</span><br><span class="line">    call    printf				&#x2F;&#x2F; &amp;i2</span><br><span class="line">    leaq    -24(%rbp), %rax		&#x2F;&#x2F; 注意, 这是 lea</span><br><span class="line">    movq    %rax, %rsi</span><br><span class="line">    movl    $.LC0, %edi</span><br><span class="line">    movl    $0, %eax</span><br><span class="line">    call    printf				&#x2F;&#x2F; &amp;pi</span><br><span class="line">    movl    -12(%rbp), %eax</span><br><span class="line">    movl    %eax, %esi</span><br><span class="line">    movl    $.LC1, %edi</span><br><span class="line">    movl    $0, %eax</span><br><span class="line">    call    printf				&#x2F;&#x2F; i</span><br><span class="line">    movq    -8(%rbp), %rax		&#x2F;&#x2F; 直接将地址放入 rax</span><br><span class="line">    movl    (%rax), %eax		&#x2F;&#x2F; 将这个地址中的值放入了(即 i 的地址) eax</span><br><span class="line">    movl    %eax, %esi</span><br><span class="line">    movl    $.LC1, %edi</span><br><span class="line">    movl    $0, %eax</span><br><span class="line">    call    printf				&#x2F;&#x2F; i2</span><br><span class="line">    movq    -24(%rbp), %rax</span><br><span class="line">    movl    (%rax), %eax</span><br><span class="line">    movl    %eax, %esi</span><br><span class="line">    movl    $.LC1, %edi</span><br><span class="line">    movl    $0, %eax</span><br><span class="line">    call    printf				&#x2F;&#x2F; pi</span><br><span class="line">    movl    $0, %eax</span><br><span class="line">    leave</span><br><span class="line">    .cfi_def_cfa 7, 8</span><br><span class="line">    ret</span><br><span class="line">    .cfi_endproc</span><br></pre></td></tr></table></figure>

<p>引用和指针并无关键性的区别, 引用也会占用内存(废话 (눈_눈), 不过我记得培训时有个沙雕老师说不占)</p>
<p>当使用引用的值时, 它是像指针一样使用</p>
<p>而当对引用取地址时, 它是直接拿存储的数据, 而并非用存储的数据去寻址</p>
<p>(这应当是编译器的规定, 它这么编译了引用)</p>
<p>唯一不同是, 引用占了8字节, 这很合理, 但是为什么指针是12字节</p>
<p>(这是一个我在之前忽视了的点, 我曾看过那4字节中是什么, 结果是 0 </p>
<p>(用指针的时候, 也用的是 movq, 这意味着只使用了 64 位, 即 8 字节, 为什么中空了 4 字节?)</p>
<p>或许我可以再试试赋值的时候, 引用和指针的不同之处</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i2 = <span class="number">100</span>;</span><br><span class="line">*pi = <span class="number">111</span>;</span><br></pre></td></tr></table></figure>

<p>汇编:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line">.LFB1078:</span><br><span class="line">    .cfi_startproc</span><br><span class="line">    .cfi_personality 0x3,__gxx_personality_v0</span><br><span class="line">    pushq   %rbp			&#x2F;&#x2F; 通过压栈的方式保存bp</span><br><span class="line">    .cfi_def_cfa_offset 16</span><br><span class="line">    .cfi_offset 6, -16</span><br><span class="line">    movq    %rsp, %rbp		&#x2F;&#x2F; 它没有显示说明栈帧有多大, 让我有点不习惯 ∑(￣□￣;)</span><br><span class="line">    .cfi_def_cfa_register 6</span><br><span class="line">    movl    $2147483647, -20(%rbp)</span><br><span class="line">    leaq    -20(%rbp), %rax</span><br><span class="line">    movq    %rax, -16(%rbp)</span><br><span class="line">    leaq    -20(%rbp), %rax</span><br><span class="line">    movq    %rax, -8(%rbp)</span><br><span class="line">    movq    -16(%rbp), %rax</span><br><span class="line">    movl    $100, (%rax)	&#x2F;&#x2F; 它是用寄存器寻址的方式来赋值的</span><br><span class="line">    movq    -8(%rbp), %rax</span><br><span class="line">    movl    $111, (%rax)</span><br><span class="line">    movl    $0, %eax</span><br><span class="line">    leave</span><br><span class="line">    .cfi_def_cfa 7, 8</span><br><span class="line">    ret</span><br><span class="line">    .cfi_endproc</span><br></pre></td></tr></table></figure>

<p>也就是说, 赋值是一样的, 嗯, 完全一样 </p>
<h3 id="指针和引用的安全性"><a href="#指针和引用的安全性" class="headerlink" title="指针和引用的安全性"></a>指针和引用的安全性</h3><p>还记得为什么引用比指针安全么? 因为对于引用是像值一样去使用它, 它仅仅是别名  </p>
<p>(其实不是别名, 如你所见, 有些时候访问引用其实还是访问的是引用所占的内存)  </p>
<p>它不会出现意外的 delete, 因为管理了它本身数据的访问, 也不会出现一些指针原有的错误(空指针,  野指针…)  </p>
<p>我更倾向于: <strong>引用是一个加了顶层const的非空, 不可用于delete的指针</strong></p>
<h3 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h3><p>引用和指针的本质都是地址</p>
<h3 id="题外话-尝试篡改引用指向的对象"><a href="#题外话-尝试篡改引用指向的对象" class="headerlink" title="题外话: 尝试篡改引用指向的对象"></a>题外话: 尝试篡改引用指向的对象</h3><p>等等, 引用的内存也是在栈中的, 虽然 c++ 不让我用光明正大的方式修改它</p>
<p>但是, 既然是在栈中的数据, 那么, 我应该是可以改的, 那么就来试一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int i &#x3D; 100;</span><br><span class="line">int i2 &#x3D; 200;</span><br><span class="line">int &amp;ref_i &#x3D; i;</span><br><span class="line"></span><br><span class="line">long long *desc &#x3D; (long long *)(&amp;i) + 1;&#x2F;&#x2F; 经过计算, i 的地址往上 8 个字节就是引用对象的内存</span><br><span class="line">char arr[64];	</span><br><span class="line">sprintf(arr, &quot;%ld&quot;, &amp;i2);	&#x2F;&#x2F; 将 &amp;i2 解释为ld类型数据, 放入数组中</span><br><span class="line">string s(arr);				&#x2F;&#x2F; 构建string对象, 主要是为了能使用 stoll (눈_눈)</span><br><span class="line"></span><br><span class="line">printf(&quot;%d\n&quot;, ref_i);		&#x2F;&#x2F; 100</span><br><span class="line">*desc &#x3D; stoll(s);			&#x2F;&#x2F; 现在, 它里面存储的数据是 i2 的地址了</span><br><span class="line">printf(&quot;%d\n&quot;, ref_i);		&#x2F;&#x2F; 200  成功了, 它指向了 i2  (￣ˇ￣)</span><br><span class="line">i2 &#x3D; 300;</span><br><span class="line">printf(&quot;%d\n&quot;, ref_i);		&#x2F;&#x2F; 300 再次验证, 没错, 我们更改了引用指向的对象</span><br></pre></td></tr></table></figure>

<p>汇编就不用看了, 因为这个程序就是根据自己脑补汇编中的样子来编写的</p>
<p>同理, 常量, 常量指针, 这些东西只要绕过编译器设的障碍就可以修改 (突然感受到了指针的魅力)</p>
<p>注: 经测试, 代码在 4.4 版本下的编译器可以, 而 4.8 版本的就不行</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/01/09/other/sed/" rel="prev" title="other/sed">
      <i class="fa fa-chevron-left"></i> other/sed
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/01/09/other/permission/" rel="next" title="other/permission">
      other/permission <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是分页"><span class="nav-number">2.</span> <span class="nav-text">什么是分页?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#指针中是否会保留原始变量的地址"><span class="nav-number">3.</span> <span class="nav-text">指针中是否会保留原始变量的地址?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#是否有办法知道哪些数据是与页号有关的"><span class="nav-number">4.</span> <span class="nav-text">是否有办法知道哪些数据是与页号有关的?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其他的耦合知识-volatile"><span class="nav-number">5.</span> <span class="nav-text">其他的耦合知识: volatile</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么是-1-而不是-1"><span class="nav-number">6.</span> <span class="nav-text">为什么是[1] 而不是 [-1]</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#引用呢-引用又是什么样子的呢"><span class="nav-number">7.</span> <span class="nav-text">引用呢? 引用又是什么样子的呢?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#指针和引用的安全性"><span class="nav-number">8.</span> <span class="nav-text">指针和引用的安全性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#summary"><span class="nav-number">9.</span> <span class="nav-text">summary</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题外话-尝试篡改引用指向的对象"><span class="nav-number">10.</span> <span class="nav-text">题外话: 尝试篡改引用指向的对象</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">cas</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">78</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">cas</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
